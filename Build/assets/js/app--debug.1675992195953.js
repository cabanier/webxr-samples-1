// --------------------------------------
// 
//    _  _ _/ .  _  _/ /_ _  _  _        
//   /_|/_ / /|//_  / / //_ /_// /_/     
//   https://activetheory.net    _/      
// 
// --------------------------------------
//   2/9/23 6:23p
// --------------------------------------

/**
 * Native polyfills and extensions for Hydra
 * @name Polyfill
 */

if (typeof(console) === 'undefined') {
    window.console = {};
    console.log = console.error = console.info = console.debug = console.warn = console.trace = function() {};
}

window.performance = (function() {
    if (window.performance && window.performance.now) return window.performance;
    else return Date;
})();

Date.now = Date.now || function() { return +new Date; };

if (!window.requestAnimationFrame) {
    window.requestAnimationFrame = (function() {
        return window.webkitRequestAnimationFrame ||
            window.mozRequestAnimationFrame ||
            window.oRequestAnimationFrame ||
            window.msRequestAnimationFrame ||
            (function() {
                const start = Date.now();
                return function(callback) {
                    window.setTimeout(() => callback(Date.now() - start), 1000 / 60);
                }
            })();
    })();
}

/**
 * Temporary alias for Core. Gets overwritten when Timer instantiated.
 * @see Timer
 * @private
 */
window.defer = window.requestAnimationFrame;

/**
 * Extends clearTimeout to clear hydra timers as well as native setTimeouts
 * @name window.clearTimeout
 * @memberof Polyfill
 *
 * @function
 * @param {Number} ref
 * @example
 * let timer = _this.delayedCall(myFunc, 1000);
 * clearTimeout(timer);
 */
window.clearTimeout = (function() {
    const _clearTimeout = window.clearTimeout;
    return function(ref) {

        // If Timer exists, try and see if is a hydra timer ref otherwise run native
        if (window.Timer) return Timer.__clearTimeout(ref) || _clearTimeout(ref);
        return _clearTimeout(ref);
    }
})();

/**
 * Fires callback when framerate idles, else fire at max time. Alias of window.requestIdleCallback
 * @name window.onIdle
 * @memberof Polyfill
 *
 * @function
 * @param {Function} callback
 * @param {Number} max - Milliseconds
 * @example
 * onIdle(myFunc, 1000);
 */
window.requestIdleCallback = (function() {
    const _requestIdleCallback = window.requestIdleCallback;
    return function(callback, max) {
        if (_requestIdleCallback) {
            return _requestIdleCallback(callback, max ? {timeout: max} : null);
        }
        return defer(() => {
            callback({didTimeout: false});
        }, 0);
    }
})();

window.onIdle = window.requestIdleCallback;

if (typeof Float32Array == 'undefined') Float32Array = Array;

/**
 * @name Math.sign
 * @memberof Polyfill
 *
 * @function
 * @param  {Number} x
 * @return {Number} Returns 1.0 if above 0.0, or -1.0 if below
 */
Math.sign = function(x) {
    x = +x; // convert to a number
    if (x === 0 || isNaN(x)) return Number(x);
    return x > 0 ? 1 : -1;
};

/**
 * Returns rounded number, with decimal places equal to precision
 * @name Math.round
 * @memberof Polyfill
 *
 * @function
 * @param {Number} Value to be rounded
 * @param {Integer} [precision = 0] Number of decimal places to return. 0 for integers.
 * @returns {Number} Rounded number
 * @example
 * // Returns 3.14
 * Math.round(3.14854839, 2);
 */
Math._round = Math.round;
Math.round = function(value, precision = 0) {
    let p = Math.pow(10, precision);
    return Math._round(value * p) / p;
};

/**
 * Returns random number between min and max values inclusive, with decimal places equal to precision
 * @name Math.random
 * @memberof Polyfill
 *
 * @function
 * @param {Number} [min=0] Min possible returned value
 * @param {Number} [max=1] Max possible returned value - inclusive.
 * @param {Integer} [precision = 0] Number of decimal places to return. 0 for integers.
 * @returns {Number} Between min and max inclusive
 * @example
 * // Returns int between 3 and 5 inclusive
 * Math.random(3, 5, 0);
 */
Math._random = Math.random;
Math.rand = Math.random = function(min, max, precision = 0) {
    if (typeof min === 'undefined') return Math._random();
    if (min === max) return min;

    min = min || 0;
    max = max || 1;

    if (precision == 0) return Math.floor(Math._random() * ((max+1) - min) + min);
    return Math.round((min + Math._random() * (max - min)), precision);
};

/**
 * Converts radians into degrees
 * @name Math.degrees
 * @memberof Polyfill
 *
 * @function
 * @param {Number} radians
 * @returns {Number}
 */

Math.degrees = function(radians) {
    return radians * (180 / Math.PI);
};

/**
 * Converts degrees into radians
 * @name Math.radians
 * @memberof Polyfill
 *
 * @function
 * @param {Number} degrees
 * @returns {Number}
 */
Math.radians = function(degrees) {
    return degrees * (Math.PI / 180);
};

/**
 * Clamps value between min and max
 * @name Math.clamp
 * @memberof Polyfill
 *
 * @function
 * @param {Number} value
 * @param {Number} [min = 0]
 * @param {Number} [max = 1]
 * @returns {Number}
 */
Math.clamp = function(value, min = 0, max = 1) {
    return Math.min(Math.max(value, Math.min(min, max)), Math.max(min, max));
};

/**
 * Maps value from an old range onto a new range
 * @name Math.map
 * @memberof Polyfill
 *
 * @function
 * @param {Number} value
 * @param {Number} [oldMin = -1]
 * @param {Number} [oldMax = 1]
 * @param {Number} [newMin = 0]
 * @param {Number} [newMax = 1]
 * @param {Boolean} [isClamp = false]
 * @returns {Number}
 * @example
 * // Convert sine curve's -1.0 > 1.0 value to 0.0 > 1.0 range
 * let x = Math.map(Math.sin(time));
 * @example
 * // Shift range
 * let y = 80;
 * let x = Math.map(y, 0, 200, -10, 10);
 * console.log(x); // logs -2
 * @example
 * // Reverse direction and shift range
 * let y = 0.9;
 * let x = Math.map(y, 0, 1, 200, 100);
 * console.log(x); // logs 110
 */
Math.map = Math.range = function(value, oldMin = -1, oldMax = 1, newMin = 0, newMax = 1, isClamp) {
    const newValue = (((value - oldMin) * (newMax - newMin)) / (oldMax - oldMin)) + newMin;
    if (isClamp) return Math.clamp(newValue, Math.min(newMin, newMax), Math.max(newMin, newMax));
    return newValue;
};

/**
 * Return blend between two values based on alpha paramater
 * @name Math.mix
 * @memberof Polyfill
 *
 * @function
 * @param {Number} a
 * @param {Number} b
 * @param {Number} alpha - Range of 0.0 to 1.0. Value of 0.0 returns a, value of 1.0 returns b
 * @returns {Number}
 * @example
 * console.log(Math.mix(0, 10, 0.4)); // logs 4
 */
Math.mix = function(a, b, alpha) {
    return a * (1.0 - alpha) + b * alpha;
};

/**
 * Returns 0.0 if value less than edge, 1.0 if greater.
 * @name Math.step
 * @memberof Polyfill
 *
 * @function
 * @param {Number} edge
 * @param {Number} value
 * @returns {Number}
 */
Math.step = function(edge, value) {
    return (value < edge) ? 0 : 1;
};

/**
 * Returns 0.0 if value less than min, 1.0 if greater than max. Otherwise the return value is interpolated between 0.0 and 1.0 using Hermite polynomials.
 * @name Math.smoothstep
 * @memberof Polyfill
 *
 * @function
 * @param {Number} min
 * @param {Number} max
 * @param {Number} value
 * @returns {Number}
 */
Math.smoothStep = function(min, max, value) {
    const x = Math.max(0, Math.min(1, (value - min) / (max - min)));
    return x * x * (3 - 2 * x);
};

/**
 * Returns fraction part of value
 * @name Math.fract
 * @memberof Polyfill
 *
 * @function
 * @param {Number} value
 * @returns {Number}
 */
Math.fract = function(value) {
    return value - Math.floor(value);
};

/**
 * Returns time-based interpolated value
 * @name Math.lerp
 * @memberof Polyfill
 *
 * @function
 * @param {Number} target
 * @param {Number} value
 * @param {Number} alpha
 * @returns {Number}
 */
Math.lerp = function (target, value, alpha, calcHz = true) {
    if (calcHz) {
        alpha = Math.framerateNormalizeLerpAlpha(alpha);
    } else {
        alpha = Math.clamp(alpha);
    }
    return value + ((target - value) * alpha);
};

{
    const mainThread = !!window.document;

    /**
     * Returns logarithmically normalized value of a lerp alpha based on exact time
     * since last frame, where the alpha is given based on the “standard” refresh
     * rate 60Hz. Accounts for dropped frames and faster or slower refresh rates.
     *
     * To see why the alpha does not vary linearly with respect to the refresh
     * rate, consider an example lerping from 0 to 1 with alpha 0.5.
     *
     * Lerping at 60Hz:
     *   frame 1.0: 0     * 0.5 + 1 * 0.5 = 0.5
     *   frame 2.0: 0.5   * 0.5 + 1 * 0.5 = 0.75
     *   frame 3.0: 0.75  * 0.5 + 1 * 0.5 = 0.875
     * ...
     *
     * When lerping at 120Hz, the lerp should proceed at the same rate as for
     * the 60Hz example, so the values at frames 1.0, 2.0 etc. should be
     * the same as above. But if we simply halve the alpha to 0.25, we get:
     *   frame 0.5: 0            * 0.75 + 1 * 0.25 = 0.25
     *   frame 1.0: 0.25         * 0.75 + 1 * 0.25 = 0.4375
     *   frame 1.5: 0.4375       * 0.75 + 1 * 0.25 = 0.578125
     *   frame 2.0: 0.578125     * 0.75 + 1 * 0.25 = 0.68359375
     *   frame 2.5: 0.68359375   * 0.75 + 1 * 0.25 = 0.7626953125
     *   frame 3.0: 0.7626953125 * 0.75 + 1 * 0.25 = 0.822021484375
     * - i.e. the lerp is progressing more slowly
     *
     * The correct alpha is ~0.293:
     *   frame 0.5: 0       * 0.707 + 1 * 0.293 = 0.293
     *   frame 1.0: 0.293   * 0.707 + 1 * 0.293 = ~0.5
     *   frame 1.5: 0.5     * 0.707 + 1 * 0.293 = 0.6465
     *   frame 2.0: 0.6465  * 0.707 + 1 * 0.293 = ~0.75
     *   frame 2.5: 0.75    * 0.707 + 1 * 0.293 = 0.82325
     *   frame 3.0: 0.82325 * 0.707 + 1 * 0.293 = ~0.875
     *
     * @param t
     * @returns {number}
     */
    Math.framerateNormalizeLerpAlpha = function(t) {
        t = Math.clamp(t);
        if (!mainThread) return t;
        return 1 - Math.exp(Math.log(1 - t) * Render.FRAME_HZ_MULTIPLIER);
    };
}

/**
 * Modulo limited to positive numbers
 * @name Math.mod
 * @memberof Polyfill
 *
 * @function
 * @param {Number} value
 * @param {Number} n
 * @returns {Number}
 */
Math.mod = function(value, n) {
    return ((value % n) + n) % n;
};

/**
 * Shuffles array
 * @name Array.prototype.shuffle
 * @memberof Polyfill
 *
 * @function
 * @returns {Array} shuffled
 */

Object.defineProperty(Array.prototype, 'shuffle', {
    writable: true,
    value: function() {
        let currentIndex = this.length, randomIndex;

        while (currentIndex != 0) {
            randomIndex = Math.floor(Math.random() * currentIndex);
            currentIndex--;

            [this[currentIndex], this[randomIndex]] = [this[randomIndex], this[currentIndex]];
        }

        return this;
    }
});

Array.storeRandom = function(arr) {
    arr.randomStore = [];
};

/**
 * Returns random element. If range passed in, will not return same element again until function has been called enough times to surpass the value.
 * @name Array.prototype.random
 * @memberof Polyfill
 *
 * @function
 * @param {Integer} [range]
 * @returns {ArrayElement}
 * @example
 * let a = [1, 2, 3, 4];
 * for (let i = 0; i < 6; i++) console.log(a.random(4)); // logs 3, 1, 2, 4, 3, 1
 */

 Object.defineProperty(Array.prototype, 'random', {
    writable: true,
    value: function(range) {
        let value = Math.random(0, this.length - 1);
        if (arguments.length && !this.randomStore) Array.storeRandom(this);
        if (!this.randomStore) return this[value];
        if (range > this.length - 1) range = this.length;
        if (range > 1) {
            while (!!~this.randomStore.indexOf(value)) if ((value += 1) > this.length - 1) value = 0;
            this.randomStore.push(value);
            if (this.randomStore.length >= range) this.randomStore.shift();
        }
        return this[value];
    }
 });

/**
 * Finds and removes element value from array
 * @name Array.prototype.remove
 * @memberof Polyfill
 *
 * @function
 * @param {ArrayElement} element - Element to remove
 * @returns {Array} Array containing removed element
 * @example
 * let a = ['cat', 'dog'];
 * a.remove('cat');
 * console.log(a); // logs ['dog']
 */

Object.defineProperty(Array.prototype, 'remove', {
    writable: true,
    value: function(element) {
        if (!this.indexOf) return;
        const index = this.indexOf(element);
        if (!!~index) return this.splice(index, 1);
    }
});

/**
 * Returns last element
 * @name Array.prototype.last
 * @memberof Polyfill
 *
 * @function
 * @returns {ArrayElement}
 */

Object.defineProperty(Array.prototype, 'last', {
    writable: true,
    value: function() {
        return this[this.length - 1]
    }
});

window.Promise = window.Promise || {};

if (!Array.prototype.flat) {
    Object.defineProperty(Array.prototype, 'flat', {
        configurable: true,
        value: function flat () {
            var depth = isNaN(arguments[0]) ? 1 : Number(arguments[0]);

            return depth ? Array.prototype.reduce.call(this, function (acc, cur) {
                if (Array.isArray(cur)) {
                    acc.push.apply(acc, flat.call(cur, depth - 1));
                } else {
                    acc.push(cur);
                }

                return acc;
            }, []) : Array.prototype.slice.call(this);
        },
        writable: true
    });
}

/**
 * Returns new Promise object
 * @name Promise.create
 * @memberof Polyfill
 *
 * @function
 * @returns {Promise}
 * @example
 * function waitOneSecond() {
 *     let p = Promise.create();
 *     _this.delayedCall(p.resolve, 1000);
 *     return p
 * }
 * waitOneSecond().then(() => console.log('happy days'));
 */
Promise.create = function() {
    const promise = new Promise((resolve, reject) => {
        this.temp_resolve = resolve;
        this.temp_reject = reject;
    });
    promise.resolve = this.temp_resolve;
    promise.reject = this.temp_reject;
    delete this.temp_resolve;
    delete this.temp_reject;
    return promise;
};

Promise.catchAll = function(array) {
    return Promise.all(array.map(promise =>
        promise.catch(error => {
            // Now that the rejection is handled, the original promise will
            // complete with result undefined, so Promise.all() will complete.
            // To allow the rejection to still be handled by a global
            // `unhandledrejection` handler (e.g. so that Dev.postErrorsToServer()
            // can log it), reject a new separate promise.
            // (Note: For this to work, the new promise must not be returned here).
            Promise.reject(error);
        })
    ));
};

Promise.timeout = function(promise, timeout) {
    if (Array.isArray(promise)) {
        promise = Promise.all(promise);
    }
    return Promise.race([promise, Timer.delayedCall(timeout)]);
};

(function() {
    // `IsRegExp` abstract operation
    // https://tc39.es/ecma262/#sec-isregexp
    function isRegExp(it) {
        var isObject = typeof it == 'object' ? it !== null : (typeof it == 'function');
        if (!isObject) return false;
        var match = it[typeof Symbol !== 'undefined' ? Symbol.match : 'match'];
        if (match !== undefined) return !!match;
        return Object.prototype.toString.call(it).slice(8, -1) === 'RegExp';
    }

    function notRegExp(it) {
        if (isRegExp(it)) throw new Error('First argument to String.prototype.includes must not be a regular expression');
        return it;
    }

    /**
     * Check if string contains phrase
     * @name String.prototype.includes
     * @memberof Polyfill
     *
     * @function
     * @param {String|String[]} str - Either a string or array of strings to check for
     * @returns {boolean}
     * @example
     * let userName = 'roger moore';
     * console.log(userName.includes(['steve', 'andrew', 'roger']); // logs true
     */
    Object.defineProperty(String.prototype, 'includes', {
        writable: true,
        value: function(str) {
            if (!Array.isArray(str)) return !!~this.indexOf(notRegExp(str));
            for (let i = str.length - 1; i >= 0; i--) {
                if (!!~this.indexOf(notRegExp(str[i]))) return true;
            }
            return false;
        }
    });

})();

Object.defineProperty(String.prototype, 'equals', {
    writable: true,
    value: function(str) {
        let compare = String(this);
        if (!Array.isArray(str)) return str === compare;
        for (let i = str.length - 1; i >= 0; i--) {
            if (str[i] === compare) return true;
        }
        return false;
    }
});

Object.defineProperty(String.prototype, 'strpos', {
    writable: true,
    value: function(str) {
        console.warn('strpos deprecated: use .includes()');
        return this.includes(str);
    }
});

/**
 * Returns clipped string. Doesn't alter original string.
 * @name String.prototype.clip
 * @memberof Polyfill
 *
 * @function
 * @param {Number} num - character length to clip to
 * @param {String} [end] - add string to end, such as elipsis '...'
 * @returns {string} - clipped string
 */
 Object.defineProperty(String.prototype, 'clip', {
    writable: true,
    value: function(num, end = '') {
        return this.length > num ? this.slice(0, Math.max( 0, num - end.length )).trim() + end : this.slice();
    }
 });

/**
 * Returns string with uppercase first letter. Doesn't alter original string.
 * @name String.prototype.capitalize
 * @memberof Polyfill
 *
 * @function
 * @returns {string}
 */
 Object.defineProperty(String.prototype, 'capitalize', {
    writable: true,
    value: function() {
        return this.charAt(0).toUpperCase() + this.slice(1);
    }
 });

/**
 * Replaces all occurrences within a string
 * @name String.prototype.replaceAll
 * @memberof Polyfill
 *
 * @function
 * @param {String} find - sub string to be replaced
 * @param {String} replace - sub string that replaces all occurrences
 * @returns {string}
 */
 Object.defineProperty(String.prototype, 'replaceAll', {
    writable: true,
    value: function(find, replace) {
        return this.split(find).join(replace);
    }
 });

Object.defineProperty(String.prototype, 'replaceAt', {
    writable: true,
    value: function(index, replacement) {
        return this.substr(0, index) + replacement + this.substr(index + replacement.length);
    }
});

/**
 * fetch API polyfill
 * @private
 */
if (!window.fetch || (!window.AURA && location.protocol.includes('file'))) window.fetch = function(url, options) {
    options = options || {};
    const promise = Promise.create();
    const request = new XMLHttpRequest();

    request.open(options.method || 'get', url);
    if (url.includes('.ktx')) request.responseType = 'arraybuffer';

    for (let i in options.headers) {
        request.setRequestHeader(i, options.headers[i]);
    }

    // request.withCredentials = options.credentials == 'include';

    request.onload = () => {
        promise.resolve(response());
    };

    request.onerror = promise.reject;

    request.send(options.body);

    function response() {
        let keys = [],
            all = [],
            headers = {},
            header;

        request.getAllResponseHeaders().replace(/^(.*?):\s*([\s\S]*?)$/gm, (m, key, value) => {
            keys.push(key = key.toLowerCase());
            all.push([key, value]);
            header = headers[key];
            headers[key] = header ? `${header},${value}` : value;
        });

        return {
            ok: (request.status/200|0) == 1,		// 200-399
            status: request.status,
            statusText: request.statusText,
            url: request.responseURL,
            clone: response,

            text: () => Promise.resolve(request.responseText),
            json: () => Promise.resolve(request.responseText).then(JSON.parse),
            xml: () => Promise.resolve(request.responseXML),
            blob: () => Promise.resolve(new Blob([request.response])),
            arrayBuffer: () => Promise.resolve(request.response),

            headers: {
                keys: () => keys,
                entries: () => all,
                get: n => headers[n.toLowerCase()],
                has: n => n.toLowerCase() in headers
            }
        };
    }
    return promise;
};

/**
 * Send http GET request. Wrapper around native fetch api. Automatically parses json.
 * @name window.get
 * @memberof Polyfill
 *
 * @function
 * @param {String} url
 * @param {Object} options
 * @returns {Promise}
 * @example
 * get('assets/geometry/curves.json).then(d => console.log(d));
 */
window.get = function(url, options = {credentials: 'same-origin'}) {
    let promise = Promise.create();
    options.method = 'GET';

    fetch(url, options).then(handleResponse).catch(promise.reject);

    function handleResponse(e) {
        if (!e.ok) return promise.reject(e);
        e.text().then(text => {
            if (text.charAt(0).includes(['[', '{'])) {

                // Try to parse json, else return text
                try {
                    promise.resolve(JSON.parse(text));
                } catch (err) {
                    promise.resolve(text);
                }
            } else {
                promise.resolve(text);
            }
        });
    }

    return promise;
};

/**
 * Send http POST request. Wrapper around native fetch api.
 * @name window.post
 * @memberof Polyfill
 *
 * @function
 * @param {String} url
 * @param {Object} body
 * @param {Object} [options]
 * @returns {Promise}
 */
window.post = function(url, body = {}, options = {}) {
    let promise = Promise.create();
    options.method = 'POST';
    if (body) options.body = typeof body === 'object' || Array.isArray(body) ? JSON.stringify(body) : body;
    if (!options.headers) options.headers = {'content-type': 'application/json'};

    fetch(url, options).then(handleResponse).catch(promise.reject);

    function handleResponse(e) {
        if (!e.ok) return promise.reject(e);
        e.text().then(text => {
            if (text.charAt(0).includes('[') || text.charAt(0).includes('{')) {

                // Try to parse json, else return text
                try {
                    promise.resolve(JSON.parse(text));
                } catch (err) {
                    promise.resolve(text);
                }
            } else {
                promise.resolve(text);
            }
        });
    }

    return promise;
};

/**
 * Send http PUT request. Wrapper around native fetch api.
 * @name window.put
 * @memberof Polyfill
 *
 * @function
 * @param {String} url
 * @param {Object} body
 * @param {Object} [options]
 * @returns {Promise}
 */
window.put = function(url, body, options = {}) {
    let promise = Promise.create();
    options.method = 'PUT';
    if (body) options.body = typeof body === 'object' || Array.isArray(body) ? JSON.stringify(body) : body;

    fetch(url, options).then(handleResponse).catch(promise.reject);

    function handleResponse(e) {
        if (!e.ok) return promise.reject(e);
        e.text().then(text => {
            if (text.charAt(0).includes(['[', '{'])) {

                // Try to parse json, else return text
                try {
                    promise.resolve(JSON.parse(text));
                } catch (err) {
                    promise.resolve(text);
                }
            } else {
                promise.resolve(text);
            }
        });
    }

    return promise;
};

/**
 * Class creation and stucture.
 * @name Core
 */

/**
 * Class constructor
 * @name Class
 * @memberof Core
 *
 * @function
 * @param {Function} _class - main class function
 * @param {String|Function} [_type] - class type ('static' or 'singleton') or static function
 * @param {Function} [_static] - static function if type is passed through, useful for 'singleton' type
 * @example
 *
 * // Instance
 * Class(function Name() {
 *     //...
 * });
 *
 * new Name(); // or
 * _this.initClass(Name);
 * @example
 * // Static
 * Class(function Name() {
 *     //...
 * }, 'static');
 *
 * console.log(Name);
 * @example
 * // Singleton
 * Class(function Name() {
 *     //...
 * }, 'singleton');
 *
 * Name.instance();
 * @example
 * // Instance with Static function
 * Class(function Name() {
 *     //...
 * }, function() {
 *     // Static
 *     Name.EVENT_NAME = 'event_name';
 * });
 * @example
 * // Singleton with Static function
 * Class(function Name() {
 *     //...
 * }, 'singleton', function() {
 *     // Static
 * });

 */
window.Class = function(_class, _type, _static) {
    const _this = this || window;

    // Function.name ie12+ only
    const _name = _class.name || _class.toString().match(/function ?([^\(]+)/)[1];

    // if (typeof Hydra !== 'undefined' && Hydra.LOCAL && _this[_name] && _this[_name].toString().indexOf('[native code]') < 0) {
    //     console.warn('Class ' + _name + ' already exists!');
    // }

    // Polymorphic if no type passed
    if (typeof _type === 'function') {
        _static = _type;
        _type = null;
    }

    _type = (_type || '').toLowerCase();

    // Instanced Class
    if (!_type) {
        _this[_name] = _class;

        // Initiate static function if passed through
        _static && _static();
    } else {

        // Static Class
        if (_type == 'static') {
            _this[_name] = new _class();

        // Singleton Class
        } else if (_type == 'singleton') {
            _this[_name] = _class;

            (function() {
                let _instance;

                _this[_name].instance = function() {
                    if (!_instance) _instance = new _class(...arguments);
                    return _instance;
                };
            })();

            // Initiate static function if passed through
            _static && _static();
        }
    }

    // Giving namespace classes reference to namespace
    if (this && this !== window) this[_name]._namespace = this.__namespace;
};

/**
 * Inherit class
 * @name Inherit
 * @memberof Core
 *
 * @function
 * @param {Object} child
 * @param {Function} parent
 * @param {Array} [params]
 * @example
 * Class(function Parent() {
 *     this.method = function() {
 *         console.log(`I'm a Parent`);
 *     };
 * });
 *
 * Class(function Child() {
 *     Inherit(this, Parent);
 *
 *     // Call parent method
 *     this.method();
 *     // Logs 'I'm a Parent'
 *
 *     // Overwrite method
 *     this.method = function() {
 *         console.log(`I'm a Child`);
 *
 *         // Call overwritten method with _ prefix
 *         this._method();
 *     };
 * });
 *
 * let child = new Child();
 *
 * // Need to defer to wait for method overwrite
 * defer(child.method);
 * // Logs 'I'm a Child', 'I'm a Parent'
 */
window.Inherit = function(child, parent) {
    const args = [].slice.call(arguments, 2);
    parent.apply(child, args);

    // Store methods for super calls
    const save = {};
    for (let method in child) {
        save[method] = child[method];
    }

    const addSuperMethods = () => {
        for (let method in save) {
            if (child[method] && child[method] !== save[method]) {
                if (method == 'destroy' && !child.__element) throw 'Do not override destroy directly, use onDestroy :: ' + child.constructor.toString();
                let name = method;
                do {
                    name = `_${name}`;
                } while (child[name]);
                child[name] = save[method];
            }
        }
    };
    if (child.__afterInitClass) {
        // When using Component.initClass(), use the hook to add super methods
        // synchronously, immediately after the constructor returns
        child.__afterInitClass.push(addSuperMethods);
    } else {
        // defer to wait for child to add its own methods
        defer(addSuperMethods);
    }
};

/**
 * Create class namespace for hydra
 * @name Namespace
 * @memberof Core
 *
 * @function
 * @param {Object|String} obj
 * @example
 * // Example using object
 * Class(function Baby() {
 *     Namespace(this);
 * }, 'static');
 *
 * Baby.Class(function Powder() {});
 *
 * new Baby.Powder();
 * @example
 * // Example using string
 * Class(function Baby() {
 *     Namespace('Talcum');
 * }, 'static');
 *
 * Talcum.Class(function Powder() {});
 *
 * new Talcum.Powder();
 */
window.Namespace = function(obj) {
    if (typeof obj === 'string') {
        if (!window[obj]) window[obj] = {Class, __namespace: obj};
    } else {
        obj.Class = Class;
        obj.__namespace = obj.constructor.name || obj.constructor.toString().match(/function ([^\(]+)/)[1];
    }
};

/**
 * Object to attach global properties
 * @name window.Global
 * @memberof Core
 *
 * @example
 * Global.PLAYGROUND = true;
 */
window.Global = {};

/**
 * Boolean for if Hydra is running on a thread
 * @name window.THREAD
 * @memberof Core
 */
window.THREAD = false;

/**
 * Hydra namespace. Fires ready callbacks and kicks off Main class once loaded.
 * @name Hydra
 */

Class(function Hydra() {
    const _this = this;
    const _readyPromise = Promise.create();
    var _base;

    var _callbacks = [];

    this.HASH = window.location.hash.slice(1);
    this.LOCAL = !window._BUILT_ && (location.hostname.indexOf('local') > -1 || location.hostname.split('.')[0] == '10' || location.hostname.split('.')[0] == '192' || /atdev.online$/.test(location.hostname)) && location.port == '';

    (function () {
        initLoad();
    })();

    function initLoad() {
        if (!document || !window) return setTimeout(initLoad, 1);
        if (window._NODE_) return setTimeout(loaded, 1);

        if (window._AURA_) {
            if (!window.Main) return setTimeout(initLoad, 1);
            else return setTimeout(loaded, 1);
        }

        window.addEventListener('load', loaded, false);
    }

    function loaded() {
        window.removeEventListener('load', loaded, false);

        _this.LOCAL = (!window._BUILT_ || location.pathname.toLowerCase().includes('platform')) && (location.hostname.indexOf('local') > -1 || location.hostname.split('.')[0] == '10' || location.hostname.split('.')[0] == '192' || /atdev.online$/.test(location.hostname)) && location.port == '';

        _callbacks.forEach(cb => cb());
        _callbacks = null;

        _readyPromise.resolve();

        // Initiate app
        if (window.Main) {
            _readyPromise.then(() => Hydra.Main = new window.Main());
        }
    }

    /**
     * Trigger page load callback
     * @memberof Hydra
     * @private
     */
    this.__triggerReady = function () {
        loaded();
    };

    /**
     * Attachment for ready event
     * @name Hydra.ready
     * @memberof Hydra
     *
     * @function
     * @param {Function} [callback] Function to trigger upon page load
     * @returns {Promise} - Returns promise if no callback passed in
     * @example
     * // either
     * Hydra.ready(init);
     * // or
     * Hydra.ready().then(init);
     * function init() {}
     */
    this.ready = function (callback) {
        if (!callback) return _readyPromise;
        if (_callbacks) _callbacks.push(callback);
        else callback();
    };

    this.absolutePath = function (path) {
        if (window.AURA) return path;
        let base = _base;
        if (base === undefined) {
            try {
                if (document.getElementsByTagName('base').length > 0) {
                    var a = document.createElement('a');
                    a.href = document.getElementsByTagName('base')[0].href;
                    base = a.pathname;
                    _base = base;
                }
            } catch (e) {
                _base = null;
            }
        }
        let pathname = base || location.pathname;
        if (pathname.includes('/index.html')) pathname = pathname.replace('/index.html', '');
        let port = Number(location.port) > 1000 ? `:${location.port}` : '';
        return path.includes('http') ? path : (location.protocol.length ? location.protocol + '//' : '') + (location.hostname + port + pathname + '/' + path).replace('//', '/');
    }

}, 'Static');

/**
 * Hydra tool-belt
 * @name Utils
 */

Class(function Utils() {

    var _queries = {};
    var _searchParams = new URLSearchParams(window.location.search);

    /**
     * Parse URL queries
     * @name this.query
     * @memberof Utils
     *
     * @function
     * @param {String} key
     * @returns {string}
     * @example
     * // url is myProject/HTML?dev=1
     * console.log(Utls.query('dev')); // logs '1'
     * @example
     * // url is myProject/HTML?dev=0
     * console.log(Utls.query('dev')); // logs false
     * // Also logs false for ?dev=false or ?dev=
     */
    this.query = this.queryParams = function(key, value) {
        if (value !== undefined) _queries[key] = value;

        if (_queries[key] !== undefined) return _queries[key];

        if (_searchParams) {
            value = _searchParams.get(key);
            if (value === '0') value = 0;
            else if (value === 'false' || value === null) value = false;
            else if (value === '') value = true;
        } else {
            let escapedKey = encodeURIComponent(key).replace(/[\.\+\*]/g, '\\$&');
            value = decodeURIComponent(window.location.search.replace(new RegExp(`^(?:.*?[&?]${escapedKey}(?:\=([^&]*)|[&$]))?.*$`, 'i'), '$1'));
            if (value == '0') {
                value = 0;
            } else if (value == 'false') {
                value = false;
            } else if (!value.length) {
                value = new RegExp(`[&?]${escapedKey}(?:[&=]|$)`, 'i').test(window.location.search);
            }
        }
        _queries[key] = value;
        return value;
    };

    /**
     * @name this.addQuery
     * @memberof Utils
     *
     * @function
     * @param query
     * @param value
   */
    this.addQuery = function ( query, value ) {
        if ( _queries[ query ] === value ) return _queries[ query ];
        let url = new URL(location.href);
        url.searchParams.set(query, value);
        _searchParams = url.searchParams;
        window.history.replaceState({}, document.title, url.toString());
        return _queries[ query ] = value;
    }

    /**
     * @name this.removeQuery
     * @memberof Utils
     *
     * @function
     * @param query
    */
    this.removeQuery = function ( query ) {
        let url = new URL(location.href);
        url.searchParams.delete(query);
        _searchParams = url.searchParams;
        window.history.replaceState({}, document.title, url.toString());
        return delete _queries[ query ];
    }

    this.addQueryToPath = function(path, hash) {
        return [
            [path, _searchParams.toString()].filter(Boolean).join('?'),
            hash
        ].filter(Boolean).join('#');
    }

    /**
     * @name this.addParam
     * @memberof Utils
     *
     * @function
     * @param url
     * @param param
     * @param value
   */
    this.addParam = function(url, param, value) {
        let index = url.indexOf('?');
        let prefix = url.substring(0, index + 1);
        let suffix = url.substring(index + 1);
        let searchParams = new URLSearchParams(suffix);
        searchParams.append(param, value);
        return prefix + searchParams.toString();
    };

    /**
     * @name this.removeParam
     * @memberof Utils
     *
     * @function
     * @param url, param
     */
    this.removeParam = function(url, param) {
        let index = url.indexOf('?');
        let prefix = url.substring(0, index + 1);
        let suffix = url.substring(index + 1);
        let searchParams = new URLSearchParams(suffix);
        searchParams.delete(param);
        return prefix + searchParams.toString();
    };

    // Object utils

    /**
     * Get class constructor name
     * @name this.getConstructorName
     * @memberof Utils
     *
     * @function
     * @param {Object} obj
     * @returns {String}
     */
     this.getConstructorName = function(obj) {
        if (!obj) return obj;

        if (!obj.___constructorName) {
            obj.___constructorName = (function() {
                if (typeof obj === 'function') return obj.toString().match(/function ([^\(]+)/)[1];
                return obj.constructor.name || obj.constructor.toString().match(/function ([^\(]+)/)[1];
            })();
        }

        return obj.___constructorName;
    };

    /**
     * Nullify object's properties
     * @name this.nullObject
     * @memberof Utils
     *
     * @function
     * @param {Object} object
     * @returns {null}
     */
    this.nullObject = function(object) {
        if (object && ( object.destroy || object.div)) {
            for (var key in object) {
                if (typeof object[key] !== 'undefined') object[key] = null;
            }
        }
        return null;
    };

    /**
     * Clone object
     * @name this.cloneObject
     * @memberof Utils
     *
     * @function
     * @param {Object} obj
     * @returns {Object}
     */
    this.cloneObject = function(obj) {
        return JSON.parse(JSON.stringify(obj));
    };

    /**
     * Return one of two parameters randomly
     * @name this.headsTails
     * @memberof Utils
     *
     * @function
     * @param {Number} n0
     * @param {Number} n1
     * @returns {Object}
     */
    this.headsTails = function(n0, n1) {
        return Math.random(0, 1) ? n1 : n0;
    };

    /**
     * Merge objects. Takes all arguments and merges them into one object.
     * @name this.mergeObject
     * @memberof Utils
     *
     * @function
     * @param {Object} Object - Any number of object paramaters
     * @returns {Object}
     */
    this.mergeObject = function() {
        var obj = {};
        for (var i = 0; i < arguments.length; i++) {
            var o = arguments[i];
            for (var key in o) {
                obj[key] = o[key];
            }
        }

        return obj;
    };

    // Mathematical utils

    /**
     * Returns unique timestamp
     * @name this.timestamp
     * @memberof Utils
     *
     * @function
     * @returns {string}
     */
    this.timestamp = this.uuid = function() {
        return Date.now() + 'xx-4xx-yxx-xxx'.replace(/[xy]/g, function(c) {
            let r = Math.random() * 16 | 0, v = c == 'x' ? r : (r & 0x3 | 0x8);
            return v.toString(16);
        });
    };

    /**
     * Returns random Hex color value
     * @name this.randomColor
     * @memberof Utils
     *
     * @function
     * @returns {string} - Hex color value
     */
    this.randomColor = function() {
        var color = '#' + Math.floor(Math.random() * 16777215).toString(16);
        if (color.length < 7) color = this.randomColor();
        return color;
    };

    /**
     * Turn number into comma-delimited string
     * @name this.numberWithCommas
     * @memberof Utils
     *
     * @function
     * @param {Number} num
     * @returns {String} - String of value with comma delimiters
     */
    this.numberWithCommas = function(num) {
        return num.toString().replace(/\B(?=(\d{3})+(?!\d))/g, ',');
    };

    /**
     * Pads number with 0s to match digits amount
     * @name this.padInt
     * @memberof Utils
     *
     * @function
     * @param {Number} num - Number value to convert to pad
     * @param {Integer} [digits] - Number of digits to match
     * @param {Boolean} [isLimit] limit to digit amount of 9s
     * @returns {string} - Padded value
     */
    this.padInt = function(num, digits, isLimit) {
        if (isLimit) num = Math.min(num, Math.pow(10, digits) - 1);
        let str = Math.floor(num).toString();
        return Math.pow(10, Math.max(0, digits - str.length)).toString().slice(1) + str;
    };

    /**
     * Copies string to clipboard on interaction
     * @name this.copyToClipboard
     * @memberof Utils
     *
     * @function
     * @param {string} string to copy to clipboard
     * @returns {Boolean} - Success
     */
    this.copyToClipboard = function(string) {
        try {
            var el = document.createElement( 'textarea' );
            var range = document.createRange();
            el.contentEditable = true;
            el.readOnly = true;
            el.value = string;
            document.body.appendChild( el );
            el.select();
            range.selectNodeContents( el );
            var s = window.getSelection();
            s.removeAllRanges();
            s.addRange(range);
            el.setSelectionRange(0, string.length);
            document.execCommand('copy');
            document.body.removeChild( el );
            return true;
        } catch ( e ) {
            return false;
        }
    };

    /**
     * Formats an array of strings into a single string list
     * @name this.stringList
     * @memberof Utils
     *
     * @function
     * @param {Array} Array of strings to join and format
     * @param {Integer} Max number of items to list before shortening - optional
     * @param {Object} Additional formatting options - optional
     * @returns {String} - Formatted string
     */
    this.stringList = function ( items = [], limit = 0, options = {} ) {
        if ( items.length === 0 ) return '';

        let output = '';
        let printed = 0;

        if ( typeof limit === 'object' ) {
            options = limit;
            limit = 0;
        }

        options.oxford = options.oxford === true ? true : false;
        options.more = options.more === false ? false : options.more ? options.more : 'more';
        options.and = options.and ? options.and : '&';
        options.comma = options.comma ? options.comma : ',';

        if ( !isNaN(options.limit)) limit = options.limit;
        if ( limit === 0 ) limit = items.length;

        do {
            let item = items.shift();
            output = `${output}${item}${options.comma} `;
            printed++;
        } while ( items.length > 1 && printed + 1 < limit );

        output = output.trim();
        output = output.slice(0,output.length-1);

        if ( items.length === 1 ) {
            output = `${output}${options.oxford && printed > 1 ? options.comma : ''} ${options.and} ${items.shift()}`;
        } else if ( items.length > 1 && options.more ) {
            let more = `${items.length} ${options.more}`;
            output = `${output}${options.oxford && printed > 1 ? options.comma : ''} ${options.and} ${more}`;
        }

        return output;
    }

    /**
     * @name this.debounce
     * @memberof Utils
     *
     * @function
     * @param callback
     * @param time
    */
    this.debounce = function (callback, time = 100) {
        clearTimeout(callback.__interval);
        callback.__interval = Timer.create(callback, time);
    }

}, 'Static');

/**
 * Single global requestAnimationFrame render loop to which all other classes attach their callbacks to be triggered every frame
 * @name Render
 */

Class(function Render() {
    const _this = this;

    const _render = [];
    const _native = [];
    const _drawFrame = [];
    const _multipliers = [];

    // If loops are added or removed from within a loop, the loop counter might
    // need to be adjusted to avoid missed callbacks. So put the loop counters
    // in the top-level scope.
    let _renderIndex = null;
    let _nativeIndex = null;

    var _last = performance.now();
    var _skipLimit = 200;
    var _localTSL = 0;
    var _elapsed = 0;
    var _capLast = 0;
    var _sampleRefreshRate = [];
    var _firstSample = false;
    var _saveRefreshRate = 60;
    var rAF = requestAnimationFrame;
    var _refreshScale = 1;
    var _canCap = 0;
    var _screenHash = getScreenHash();

   /**
    * @name timeScaleUniform
    * @memberof Render
    * @property
    */
    this.timeScaleUniform = {value: 1, type: 'f', ignoreUIL: true};
   /**
    * @name REFRESH_TABLE
    * @memberof Render
    * @property
    */
    this.REFRESH_TABLE = [30, 60, 72, 90, 100, 120, 144, 240];
   /**
    * @name REFRESH_RATE
    * @memberof Render
    * @property
    */
    this.REFRESH_RATE = 60;
   /**
    * @name HZ_MULTIPLIER
    * @memberof Render
    * @property
    */
    this.HZ_MULTIPLIER = 1;

   /**
    * @name capFPS
    * @memberof Render
    * @property
    */
    this.capFPS = null;

    //*** Constructor
    (function() {
        if (THREAD) return;
        rAF(render);
        setInterval(_ => _sampleRefreshRate = [], 3000);
        setInterval(checkMoveScreen, 5000);
    })();

    function render(tsl) {
        if (_native.length) {
            let multiplier = (60/_saveRefreshRate);
            for (_nativeIndex = _native.length-1; _nativeIndex > -1; _nativeIndex--) {
                _native[_nativeIndex](multiplier);
            }
            _nativeIndex = null;
        }

        if (_this.capFPS > 0 && ++_canCap > 31) {
            let delta = tsl - _capLast;
            _capLast = tsl;
            _elapsed += delta;
            if (_elapsed < 1000 / _this.capFPS) return rAF(render);
            _this.REFRESH_RATE = _this.capFPS;
            _this.HZ_MULTIPLIER = (60/_this.REFRESH_RATE) * _refreshScale;
            _elapsed = 0;
        }

        _this.timeScaleUniform.value = 1;
        if (_multipliers.length) {
            for (let i = 0; i < _multipliers.length; i++) {
                let obj = _multipliers[i];
                _this.timeScaleUniform.value *= obj.value;
            }
        }

        _this.DT = tsl - _last;
        _last = tsl;

        let delta = _this.DT * _this.timeScaleUniform.value;
        delta = Math.min(_skipLimit, delta);

        if (_sampleRefreshRate && !_this.capFPS) {
            let fps = 1000 / _this.DT;
            _sampleRefreshRate.push(fps);
            if (_sampleRefreshRate.length > 30) {
                _sampleRefreshRate.sort((a, b) => a - b);
                let rate = _sampleRefreshRate[Math.round(_sampleRefreshRate.length / 2)];
                rate = _this.REFRESH_TABLE.reduce((prev, curr) => (Math.abs(curr - rate) < Math.abs(prev - rate) ? curr : prev));
                _this.REFRESH_RATE = _saveRefreshRate = _firstSample ? Math.max(_this.REFRESH_RATE, rate) : rate;
                _this.HZ_MULTIPLIER = (60/_this.REFRESH_RATE) * _refreshScale;
                _sampleRefreshRate = null;
                _firstSample = true;
            }
        }

        _this.TIME = tsl;
        _this.DELTA = delta;

        if (_this.startFrame) _this.startFrame(tsl, delta);

        _localTSL += delta;

        for (_renderIndex = _render.length - 1; _renderIndex >= 0; _renderIndex--) {
            var callback = _render[_renderIndex];
            if (!callback) {
                _render.splice(_renderIndex, 1);
                continue;
            }
            if (callback.fps) {
                if (tsl - callback.last < 1000 / callback.fps) continue;
                callback(++callback.frame);
                callback.last = tsl;
                continue;
            }
            callback(tsl, delta);
        }
        _renderIndex = null;

        for (let i = _drawFrame.length-1; i > -1; i--) {
            _drawFrame[i](tsl, delta);
        }

        if (_this.drawFrame) _this.drawFrame(tsl, delta); //Deprecated
        if (_this.endFrame) _this.endFrame(tsl, delta); //Deprecated

        if (!THREAD && !_this.isPaused) rAF(render);
    }

    function getScreenHash() {
        if (!window.screen) return 'none';

        return `${window.screen.width}x${window.screen.height}.${window.screen.pixelDepth}`;
    }

    function checkMoveScreen() {
        var newScreen = getScreenHash();
        if (_screenHash === newScreen) return;
        // Changed screen. recalculate refresh rate

        _screenHash = newScreen;
        _sampleRefreshRate = null;
        _firstSample = false;
    }

    /**
     * @name Render.now
     * @memberof Render
     *
     * @function
    */
    this.now = function() {
        return _localTSL;
    }

    /**
     * @name Render.setRefreshScale
     * @memberof Render
     *
     * @function
     * @param scale
    */
    this.setRefreshScale = function(scale) {
        _refreshScale = scale;
        _sampleRefreshRate = [];
    }

    /**
     * Add callback to render queue
     * @name Render.start
     * @memberof Render
     *
     * @function
     * @param {Function} callback - Function to call
     * @param {Integer} [fps] - Optional frames per second callback rate limit
     * @example
     * // Warp time using multiplier
     * Render.start(loop);
     * let _timewarp = 0;
     * function loop(t, delta) {
     *     console.log(_timewarp += delta * 0.001);
     * }
     * @example
     * // Limits callback rate to 5
     * Render.start(tick, 5);
     *
     * // Frame count is passed to callback instead of time information
     * function tick(frame) {
     *     console.log(frame);
     * }
     */
    this.start = function(callback, fps, native) {
        if (fps) {
            callback.fps = fps;
            callback.last = -Infinity;
            callback.frame = -1;
        }

        // unshift as render queue works back-to-front
        if (native) {
            if (!~_native.indexOf(callback)) {
                _native.unshift(callback);
                if (_nativeIndex !== null) _nativeIndex += 1;
            }
        } else {
            if (!~_render.indexOf(callback)) {
                _render.unshift(callback);
                if (_renderIndex !== null) _renderIndex += 1;
            }
        }
    };

    /**
     * Remove callback from render queue
     * @name Render.stop
     * @memberof Render
     *
     * @function
     * @param {Function} callback
     */
    this.stop = function(callback) {
        let i = _render.indexOf(callback);
        if (i >= 0) {
            _render.splice(i, 1);
            if (_renderIndex !== null && i <= _renderIndex) {
                _renderIndex -= 1;
            }
        }
        i = _native.indexOf(callback);
        if (i >= 0) {
            _native.splice(i, 1);
            if (_nativeIndex !== null && i <= _nativeIndex) {
                _nativeIndex -= 1;
            }
        }
    };

    /**
     * Force render - for use in threads
     * @name Render.tick
     * @memberof Render
     *
     * @function
     */
    this.tick = function() {
        if (!THREAD) return;
        this.TIME = performance.now();
        render(this.TIME);
    };

    /**
     * Force render - for Vega frame by frame recording
     * @name Render.tick
     * @memberof Render
     *
     * @function
     */
     this.forceRender = function(time) {
        this.TIME = time;
        render(this.TIME);
    };

    /**
     * Distributed worker constuctor
     * @name Render.Worker
     * @memberof Render

     * @constructor
     * @param {Function} _callback
     * @param {Number} [_budget = 4]
     * @example
     * const worker = _this.initClass(Render.Worker, compute, 1);
     * function compute() {console.log(Math.sqrt(Math.map(Math.sin(performance.now()))))};
     * _this.delayedCall(worker.stop, 1000)
     *
     */
    this.Worker = function(_callback, _budget = 4) {
        Inherit(this, Component);
        let _scope = this;
        let _elapsed = 0;
        this.startRender(loop);
        function loop() {
            if (_scope.dead) return;
            while (_elapsed < _budget) {
                if (_scope.dead || _scope.paused) return;
                const start = performance.now();
                _callback && _callback();
                _elapsed += performance.now() - start;
            }
            _elapsed = 0;
        }

    /**
     * @name Render.stop
     * @memberof Render
     *
     * @function
    */
        this.stop = function() {
            this.dead = true;
            this.stopRender(loop);
            //defer(_ => _scope.destroy());
        }

    /**
     * @name Render.pause
     * @memberof Render
     *
     * @function
    */
        this.pause = function() {
            this.paused = true;
            this.stopRender(loop);
        }

    /**
     * @name Render.resume
     * @memberof Render
     *
     * @function
    */
        this.resume = function() {
            this.paused = false;
            this.startRender(loop);
        }

    /**
     * @name Render.setCallback
     * @memberof Render
     *
     * @function
     * @param cb
    */
        this.setCallback = function(cb) {
            _callback = cb;
        }
    };

    /**
     * Pause global render loop
     * @name Render.pause
     * @memberof Render
     *
     * @function
     */
    this.pause = function() {
        _this.isPaused = true;
    };

    /**
     * Resume global render loop
     * @name Render.resume
     * @memberof Render
     *
     * @function
     */
    this.resume = function() {
        if (!_this.isPaused) return;
        _this.isPaused = false;
        rAF(render);
    };

    /**
     * Use an alternative requestAnimationFrame function (for VR)
     * @name Render.useRAF
     * @param {Function} _callback
     * @memberof Render
     *
     * @function
     */
    this.useRAF = function(raf) {
        _firstSample = null;
        _last = performance.now();
        rAF = raf;
        rAF(render);
    }

    /**
     * @name Render.onDrawFrame
     * @memberof Render
     *
     * @function
     * @param cb
    */
    this.onDrawFrame = function(cb) {
        _drawFrame.push(cb);
    }

    /**
     * @name Render.setTimeScale
     * @memberof Render
     *
     * @function
     * @param v
    */
    this.setTimeScale = function(v) {
        _this.timeScaleUniform.value = v;
    }

    /**
     * @name Render.getTimeScale
     * @memberof Render
     *
     * @function
    */
    this.getTimeScale = function() {
        return _this.timeScaleUniform.value;
    }

    /**
     * @name Render.createTimeMultiplier
     * @memberof Render
     *
     * @function
    */
    /**
     * @name Render.createTimeMultiplier
     * @memberof Render
     *
     * @function
    */
    this.createTimeMultiplier = function() {
        let obj = {value: 1};
        _multipliers.push(obj);
        return obj;
    }

    /**
     * @name Render.destroyTimeMultiplier
     * @memberof Render
     *
     * @function
     * @param obj
    */
    this.destroyTimeMultiplier = function(obj) {
        _multipliers.remove(obj);
    }

    /**
     * @name Render.tweenTimeScale
     * @memberof Render
     *
     * @function
     * @param value
     * @param time
     * @param ease
     * @param delay
    */
    this.tweenTimeScale = function(value, time, ease, delay) {
        return tween(_this.timeScaleUniform, {value}, time, ease, delay, null, null, true);
    }

    Object.defineProperty(_this, 'FRAME_HZ_MULTIPLIER', {
        get() {
            return (60 / (1000 / _this.DELTA)) * _refreshScale;
        },
        enumerable: true
    });
}, 'Static');

/**
 * Timer class that uses hydra Render loop, which has much less overhead than native setTimeout
 * @name Timer
 */

Class(function Timer() {
    const _this = this;
    const _callbacks = [];
    const _discard = [];
    const _deferA = [];
    const _deferB = [];
    var _defer = _deferA;

    (function() {
        Render.start(loop);
    })();


    function loop(t, delta) {
        for (let i = _discard.length - 1; i >= 0; i--) {
            let obj = _discard[i];
            obj.callback = null;
            _callbacks.remove(obj);
        }
        if (_discard.length) _discard.length = 0;

        for (let i = _callbacks.length - 1; i >= 0; i--) {
            let obj = _callbacks[i];
            if (!obj) {
                _callbacks.remove(obj);
                continue;
            }

            if (obj.scaledTime) {
                obj.current += delta;
            } else {
                obj.current += Render.DT;
            }

            if (obj.current >= obj.time) {
                obj.callback && obj.callback();
                _discard.push(obj);
            }
        }

        for (let i = _defer.length-1; i > -1; i--) {
            _defer[i]();
        }
        _defer.length = 0;
        _defer = _defer == _deferA ? _deferB : _deferA;
    }

    function find(ref) {
        for (let i = _callbacks.length - 1; i > -1; i--) if (_callbacks[i].ref == ref) return _callbacks[i];
    }

    //*** Event handlers

    //*** Public methods

    /**
     *
     * @private
     *
     * @param ref
     * @returns {boolean}
     */
    this.__clearTimeout = function(ref) {
        const obj = find(ref);
        if (!obj) return false;
        obj.callback = null;
        _callbacks.remove(obj);
        return true;
    };

    /**
     * Create timer
     * @name Timer.create
     * @memberof Timer
     *
     * @function
     * @param {Function} callback
     * @param {Number} time
     * @returns {Number} Returns timer reference for use with window.clearTimeout
     */
    this.create = function(callback, time, scaledTime) {
        if (window._NODE_) return setTimeout(callback, time);
        const obj = {
            time: Math.max(1, time || 1),
            current: 0,
            ref: Utils.timestamp(),
            callback,
            scaledTime
        };
        _callbacks.unshift(obj);
        return obj.ref;
    };

    /**
     * @name Timer.delayedCall
     * @memberof Timer
     *
     * @function
     * @param time
    */
    this.delayedCall = function(time) {
        let promise = Promise.create();
        _this.create(promise.resolve, time);
        return promise;
    }

    /**
     * Defer callback until next frame
     * @name window.defer
     * @memberof Timer
     *
     * @function
     * @param {Function} callback
     */
    window.defer = this.defer = function(callback) {
        let promise;
        if (!callback) {
            promise = Promise.create();
            callback = promise.resolve;
        }

        let array = _defer == _deferA ? _deferB : _deferA;
        array.unshift(callback);
        return promise;
    };

}, 'static');
/**
 * Events class
 * @name Events
 */

Class(function Events() {
    const _this = this;
    this.events = {};

    const _e = {};
    const _linked = [];
    let _emitter;

    /**
     * Add event listener
     * @name this.events.sub
     * @memberof Events
     *
     * @function
     * @param {Object} [obj] - Optional local object to listen upon, prevents event from going global
     * @param {String} evt - Event string
     * @param {Function} callback - Callback function
     * @returns {Function} callback - Returns callback to be immediately triggered
     * @example
     * // Global event listener
     * _this.events.sub(Events.RESIZE, resize);
     * function resize(e) {};
     * @example
     * // Local event listener
     * _this.events.sub(_someClass, Events.COMPLETE, loaded);
     * function loaded(e) {};
     * @example
     * // Custom event
     * MyClass.READY = 'my_class_ready';
     * _this.events.sub(MyClass.READY, ready);
     * function ready(e) {};
     */
    this.events.sub = function(obj, evt, callback) {
        if (typeof obj !== 'object') {
            callback = evt;
            evt = obj;
            obj = null;
        }

        if (!obj) {
            Events.emitter._addEvent(evt, !!callback.resolve ? callback.resolve : callback, this);
            return callback;
        }

        let emitter = obj.events.emitter();
        emitter._addEvent(evt, !!callback.resolve ? callback.resolve : callback, this);
        emitter._saveLink(this);
        _linked.push(emitter);

        return callback;
    };

    this.events.wait = async function(obj, evt) {
        const promise = Promise.create();
        const args = [obj, evt, (e) => {
            _this.events.unsub(...args);
            promise.resolve(e);
        }];
        if (typeof obj !== 'object') {
            args.splice(1, 1);
        }
        _this.events.sub(...args);
        return promise;
    };

    /**
     * Remove event listener
     * @name this.events.unsub
     * @memberof Events
     *
     * @function
     * @param {Object} [obj] - Optional local object
     * @param {String} evt - Event string
     * @param {Function} callback - Callback function
     * @example
     * // Global event listener
     * _this.events.unsub(Events.RESIZE, resize);
     * @example
     * // Local event listener
     * _this.events.unsub(_someClass, Events.COMPLETE, loaded);
     */
    this.events.unsub = function(obj, evt, callback) {
        if (typeof obj !== 'object') {
            callback = evt;
            evt = obj;
            obj = null;
        }

        if (!obj) return Events.emitter._removeEvent(evt, !!callback.resolve ? callback.resolve : callback);
        obj.events.emitter()._removeEvent(evt, !!callback.resolve ? callback.resolve : callback);
    };

    /**
     * Fire event
     * @name this.events.fire
     * @memberof Events
     *
     * @function
     * @param {String} evt - Event string
     * @param {Object} [obj] - Optional passed data
     * @param {Boolean} [isLocalOnly] - If true, prevents event from going global if no-one is listening locally
     * @example
     * // Passing data with event
     * const data = {};
     * _this.events.fire(Events.COMPLETE, {data});
     * _this.events.sub(Events.COMPLETE, e => console.log(e.data);
     * @example
     * // Custom event
     * MyClass.READY = 'my_class_ready';
     * _this.events.fire(MyClass.READY);
     */
    this.events.fire = function(evt, obj, isLocalOnly) {
        obj = obj || _e;
        obj.target = this;
        Events.emitter._check(evt);
        if (_emitter && _emitter._fireEvent(evt, obj)) return;
        if (isLocalOnly) return;
        Events.emitter._fireEvent(evt, obj);
    };

    /**
     * Bubble up local event - subscribes locally and re-emits immediately
     * @name this.events.bubble
     * @memberof Events
     *
     * @function
     * @param {Object} obj - Local object
     * @param {String} evt - Event string
     * @example
     * _this.events.bubble(_someClass, Events.COMPLETE);
     */
    this.events.bubble = function(obj, evt) {
        _this.events.sub(obj, evt, e => _this.events.fire(evt, e));
    };

    /**
     * Destroys all events and notifies listeners to remove reference
     * @private
     * @name this.events.destroy
     * @memberof Events
     *
     * @function
     * @returns {null}
     */
    this.events.destroy = function() {
        Events.emitter._destroyEvents(this);
        if (_linked) _linked.forEach(emitter => emitter._destroyEvents(this));
        if (_emitter && _emitter.links) _emitter.links.forEach(obj => obj.events && obj.events._unlink(_emitter));
        return null;
    };

    /**
     * Gets and creates local emitter if necessary
     * @private
     * @name this.events.emitter
     * @memberof Events
     *
     * @function
     * @returns {Emitter}
     */
    this.events.emitter = function() {
        if (!_emitter) _emitter = Events.emitter.createLocalEmitter();
        return _emitter;
    };

    /**
     * Unlink reference of local emitter upon its destruction
     * @private
     * @name this.events._unlink
     * @memberof Events
     *
     * @function
     * @param {Emitter} emitter
     */
    this.events._unlink = function(emitter) {
        _linked.remove(emitter);
    };
}, () => {

    /**
     * Global emitter
     * @private
     * @name Events.emitter
     * @memberof Events
     */
    Events.emitter = new Emitter();
    Events.broadcast = Events.emitter._fireEvent;

    Events.VISIBILITY = 'hydra_visibility';
    Events.HASH_UPDATE = 'hydra_hash_update';
    Events.COMPLETE = 'hydra_complete';
    Events.PROGRESS = 'hydra_progress';
    Events.CONNECTIVITY = 'hydra_connectivity';
    Events.UPDATE = 'hydra_update';
    Events.LOADED = 'hydra_loaded';
    Events.END = 'hydra_end';
    Events.FAIL = 'hydra_fail';
    Events.SELECT = 'hydra_select';
    Events.ERROR = 'hydra_error';
    Events.READY = 'hydra_ready';
    Events.RESIZE = 'hydra_resize';
    Events.CLICK = 'hydra_click';
    Events.HOVER = 'hydra_hover';
    Events.MESSAGE = 'hydra_message';
    Events.ORIENTATION = 'orientation';
    Events.BACKGROUND = 'background';
    Events.BACK = 'hydra_back';
    Events.PREVIOUS = 'hydra_previous';
    Events.NEXT = 'hydra_next';
    Events.RELOAD = 'hydra_reload';
    Events.UNLOAD = 'hydra_unload';
    Events.FULLSCREEN = 'hydra_fullscreen';

    const _e = {};

    function Emitter() {
        const prototype = Emitter.prototype;
        this.events = [];

        if (typeof prototype._check !== 'undefined') return;
        prototype._check = function(evt) {
            if (typeof evt == 'undefined') throw 'Undefined event';
        };

        prototype._addEvent = function(evt, callback, object) {
            this._check(evt);
            this.events.push({evt, object, callback});
        };

        prototype._removeEvent = function(eventString, callback) {
            this._check(eventString);

            for (let i = this.events.length - 1; i >= 0; i--) {
                if (this.events[i].evt === eventString && this.events[i].callback === callback) {
                    this._markForDeletion(i);
                }
            }
        };

        prototype._sweepEvents = function() {
            for (let i = 0; i < this.events.length; i++) {
                if (this.events[i].markedForDeletion) {
                    delete this.events[i].markedForDeletion;
                    this.events.splice(i, 1);
                    --i;
                }
            }
        }

        prototype._markForDeletion = function(i) {
            this.events[i].markedForDeletion = true;
            if (this._sweepScheduled) return;
            this._sweepScheduled = true;
            defer(() => {
                this._sweepScheduled = false;
                this._sweepEvents();
            });
        }

        prototype._fireEvent = function(eventString, obj) {
            if (this._check) this._check(eventString);
            obj = obj || _e;
            let called = false;
            for (let i = 0; i < this.events.length; i++) {
                let evt = this.events[i];
                if (evt.evt == eventString && !evt.markedForDeletion) {
                    evt.callback(obj);
                    called = true;
                }
            }
            return called;
        };

        prototype._destroyEvents = function(object) {
            for (var i = this.events.length - 1; i >= 0; i--) {
                if (this.events[i].object === object) {
                    this._markForDeletion(i);
                }
            }
        };

        prototype._saveLink = function(obj) {
            if (!this.links) this.links = [];
            if (!~this.links.indexOf(obj)) this.links.push(obj);
        };

        prototype.createLocalEmitter = function() {
            return new Emitter();
        };
    }

    // Global Events
    Hydra.ready(() => {

        /**
         * Visibility event handler
         * @private
         */
        (function() {
            let _lastTime = performance.now();
            let _last;

            Timer.create(addVisibilityHandler, 250);

            function addVisibilityHandler() {
                let hidden, eventName;
                [
                    ['msHidden', 'msvisibilitychange'],
                    ['webkitHidden', 'webkitvisibilitychange'],
                    ['hidden', 'visibilitychange']
                ].forEach(d => {
                    if (typeof document[d[0]] !== 'undefined') {
                        hidden = d[0];
                        eventName = d[1];
                    }
                });

                if (!eventName) {
                    const root = Device.browser == 'ie' ? document : window;
                    root.onfocus = onfocus;
                    root.onblur = onblur;
                    return;
                }

                document.addEventListener(eventName, () => {
                    const time = performance.now();
                    if (time - _lastTime > 10) {
                        if (document[hidden] === false) onfocus();
                        else onblur();
                    }
                    _lastTime = time;
                });
            }

            function onfocus() {
                Render.blurTime = -1;
                if (_last != 'focus') Events.emitter._fireEvent(Events.VISIBILITY, {type: 'focus'});
                _last = 'focus';
            }

            function onblur() {
                Render.blurTime = Date.now();
                if (_last != 'blur') Events.emitter._fireEvent(Events.VISIBILITY, {type: 'blur'});
                _last = 'blur';
            }

            window.addEventListener('online', _ => Events.emitter._fireEvent(Events.CONNECTIVITY, {online: true}));
            window.addEventListener('offline', _ => Events.emitter._fireEvent(Events.CONNECTIVITY, {online: false}));

            window.onbeforeunload = _ => {
                Events.emitter._fireEvent(Events.UNLOAD);
                return null;
            };
        })();

        window.Stage = window.Stage || {};
        let box;
        if (Device.system.browser == 'social' && Device.system.os == 'ios') {
            box = document.createElement('div');
            box.style.position = 'fixed';
            box.style.top = box.style.left = box.style.right = box.style.bottom = '0px';
            box.style.zIndex = '-1';
            box.style.opacity = '0';
            box.style.pointerEvents = 'none';
            document.body.appendChild(box);
        }
        updateStage();

        let iosResize = Device.system.os === 'ios';
        let html = iosResize ? document.querySelector('html') : false;
        let delay = iosResize ? 500 : 16;
        let timer;

        function handleResize() {
            clearTimeout(timer);
            timer = setTimeout(_ => {
                updateStage();
                if ( html && Math.min( window.screen.width, window.screen.height ) !== Stage.height && !Mobile.isAllowNativeScroll ) {
                    html.scrollTop = -1;
                }
                Events.emitter._fireEvent(Events.RESIZE);
            }, delay);
        }

        window.addEventListener('resize', handleResize);

        window.onorientationchange = window.onresize;

        if (Device.system.browser == 'social' && (Stage.height >= screen.height || Stage.width >= screen.width)) {
            setTimeout(updateStage, 1000);
        }

        // Call initially
        defer(window.onresize);

        function updateStage() {
            if (box) {
                let bbox = box.getBoundingClientRect();
                Stage.width = bbox.width || window.innerWidth || document.body.clientWidth || document.documentElement.offsetWidth;
                Stage.height = bbox.height || window.innerHeight || document.body.clientHeight || document.documentElement.offsetHeight;

                document.body.parentElement.scrollTop = document.body.scrollTop = 0;
                document.documentElement.style.width = document.body.style.width = `${Stage.width}px`;
                document.documentElement.style.height = document.body.style.height = `${Stage.height}px`;
                Events.emitter._fireEvent(Events.RESIZE);
            } else {
                Stage.width = window.innerWidth || document.body.clientWidth || document.documentElement.offsetWidth;
                Stage.height = window.innerHeight || document.body.clientHeight || document.documentElement.offsetHeight;
            }
        }
    });
});
/**
 * Read-only class with device-specific information and exactly what's supported.
 * Information split into: system, mobile, media, graphics, style, tween.
 * @name Device
 */

Class(function Device() {
    var _this = this;

    /**
     * Stores user agent as string
     * @name Device.agent
     * @memberof Device
     */
    this.agent = navigator.userAgent.toLowerCase();

    /**
     * Checks user agent against match query
     * @name Device.detect
     * @memberof Device
     *
     * @function
     * @param {String|String[]} match - Either string or array of strings to test against
     * @returns {Boolean}
     */
    this.detect = function(match) {
        return this.agent.includes(match)
    };

    /**
     * Boolean
     * @name Device.touchCapable
     * @memberof Device
     */
    this.touchCapable = !!navigator.maxTouchPoints;

    /**
     * Alias of window.devicePixelRatio
     * @name Device.pixelRatio
     * @memberof Device
     */
    this.pixelRatio = window.devicePixelRatio;

    //==================================================================================//
    //===// System //===================================================================//

    this.system = {};

    /**
     * Boolean. True if devicePixelRatio greater that 1.0
     * @name Device.system.retina
     * @memberof Device
     */
    this.system.retina = window.devicePixelRatio > 1;

    /**
     * Boolean
     * @name Device.system.webworker
     * @memberof Device
     */
    this.system.webworker = typeof window.Worker !== 'undefined';


    /**
     * Boolean
     * @name Device.system.geolocation
     * @memberof Device
     */
    if (!window._NODE_) this.system.geolocation = typeof navigator.geolocation !== 'undefined';

    /**
     * Boolean
     * @name Device.system.pushstate
     * @memberof Device
     */
    if (!window._NODE_) this.system.pushstate = typeof window.history.pushState !== 'undefined';

    /**
     * Boolean
     * @name Device.system.webcam
     * @memberof Device
     */
    this.system.webcam = !!(navigator.getUserMedia || navigator.webkitGetUserMedia || navigator.mozGetUserMedia || navigator.mediaDevices);

    /**
     * String of user's navigator language
     * @name Device.system.language
     * @memberof Device
     */
    this.system.language = window.navigator.userLanguage || window.navigator.language;

    /**
     * Boolean
     * @name Device.system.webaudio
     * @memberof Device
     */
    this.system.webaudio = typeof window.AudioContext !== 'undefined';

    /**
     * Boolean
     * @name Device.system.xr
     * @memberof Device
     */
    this.system.xr = {};
    this.system.detectXR = async function() {
        if (window.AURA) {
            _this.system.xr.vr = true;
            _this.system.xr.ar = true;
            return;
        }

        if (!navigator.xr) {
            _this.system.xr.vr = false;
            _this.system.xr.ar = false;
            return;
        }

        try {
            [_this.system.xr.vr, _this.system.xr.ar] = await Promise.all([
                navigator.xr.isSessionSupported('immersive-vr'),
                navigator.xr.isSessionSupported('immersive-ar')
            ]);
        } catch(e) { }

        if (_this.system.os == 'android') {
            if (!_this.detect('oculus')) {
                _this.system.xr.vr = false;
            }
        }
    };

    /**
     * Boolean
     * @name Device.system.localStorage
     * @memberof Device
     */
    try {
        this.system.localStorage = typeof window.localStorage !== 'undefined';
    } catch (e) {
        this.system.localStorage = false;
    }

    /**
     * Boolean
     * @name Device.system.fullscreen
     * @memberof Device
     */
    this.system.fullscreen = document.fullscreenEnabled || document.webkitFullscreenEnabled || document.mozFullScreenEnabled || document.msFullscreenEnabled;

    function detectIpad() {
        let aspect = Math.max(screen.width, screen.height) / Math.min(screen.width, screen.height);
        // iPads getting bigger and bigger, 2022 iPad Pro is 1389x970. But the aspect
        // ratio has stayed consistent: iPads are all 4:3, Macbooks are 16:10.
        // Need to account for external displays too, but they're likely to be
        // closer to 16:10 than 4:3
        return _this.detect('mac') && _this.touchCapable && Math.abs(aspect - 4/3) < Math.abs(aspect - 16/10);
    }

    /**
     * String of operating system. Returns 'ios', 'android', 'blackberry', 'mac', 'windows', 'linux' or 'unknown'.
     * @name Device.system.os
     * @memberof Device
     */
    this.system.os = (function() {
        if (_this.detect(['ipad', 'iphone', 'ios']) || detectIpad()) return 'ios';
        if (_this.detect(['android', 'kindle'])) return 'android';
        if (_this.detect(['blackberry'])) return 'blackberry';
        if (_this.detect(['mac os'])) return 'mac';
        if (_this.detect(['windows', 'iemobile'])) return 'windows';
        if (_this.detect(['linux'])) return 'linux';
        return 'unknown';
    })();

    /**
     * Mobile os version. Currently only applicable to mobile OS.
     * @name Device.system.version
     * @memberof Device
     */
    this.system.version = (function() {
        try {
            if (_this.system.os == 'ios') {
                if (_this.agent.includes('intel mac')) {
                    let num = _this.agent.split('version/')[1].split(' ')[0];
                    let split = num.split('.');
                    return Number(split[0] + '.' + split[1]);
                } else {
                    var num = _this.agent.split('os ')[1].split('_');
                    var main = num[0];
                    var sub = num[1].split(' ')[0];
                    return Number(main + '.' + sub);
                }
            }
            if (_this.system.os == 'android') {
                var version = _this.agent.split('android ')[1].split(';')[0];
                if (version.length > 3) version = version.slice(0, -2);
                if (version.charAt(version.length-1) == '.') version = version.slice(0, -1);
                return Number(version);
            }
            if (_this.system.os == 'windows') {
                if (_this.agent.includes('rv:11')) return 11;
                return Number(_this.agent.split('windows phone ')[1].split(';')[0]);
            }
        } catch(e) {}
        return -1;
    })();

    /**
     * String of browser. Returns, 'social, 'chrome', 'safari', 'firefox', 'ie', 'browser' (android), or 'unknown'.
     * @name Device.system.browser
     * @memberof Device
     */
    this.system.browser = (function() {
        if (_this.system.os == 'ios') {
            if (_this.detect(['twitter', 'fbios', 'instagram'])) return 'social';
            if (_this.detect(['crios'])) return 'chrome';
            if (_this.detect(['fxios'])) return 'firefox';
            if (_this.detect(['safari'])) return 'safari';
            return 'unknown';
        }
        if (_this.system.os == 'android') {
            if (_this.detect(['twitter', 'fb', 'facebook', 'instagram'])) return 'social';
            if (_this.detect(['chrome'])) return 'chrome';
            if (_this.detect(['firefox'])) return 'firefox';
            return 'browser';
        }
        if (_this.detect(['msie'])) return 'ie';
        if (_this.detect(['trident']) && _this.detect(['rv:'])) return 'ie';
        if (_this.detect(['windows']) && _this.detect(['edge'])) return 'ie';
        if (_this.detect(['chrome'])) return 'chrome';
        if (_this.detect(['safari'])) return 'safari';
        if (_this.detect(['firefox'])) return 'firefox';

        // TODO: test windows phone and see what it returns
        //if (_this.os == 'Windows') return 'ie';
        return 'unknown';
    })();

    /**
     * Number value of browser version
     * @name Device.browser.browserVersion
     * @memberof Device
     */
    this.system.browserVersion = (function() {
        try {
            if (_this.system.browser == 'chrome') {
                if (_this.detect('crios')) return Number(_this.agent.split('crios/')[1].split('.')[0]);
                return Number(_this.agent.split('chrome/')[1].split('.')[0]);
            }
            if (_this.system.browser == 'firefox') return Number(_this.agent.split('firefox/')[1].split('.')[0]);
            if (_this.system.browser == 'safari') return Number(_this.agent.split('version/')[1].split('.')[0].split('.')[0]);
            if (_this.system.browser == 'ie') {
                if (_this.detect(['msie'])) return Number(_this.agent.split('msie ')[1].split('.')[0]);
                if (_this.detect(['rv:'])) return Number(_this.agent.split('rv:')[1].split('.')[0]);
                return Number(_this.agent.split('edge/')[1].split('.')[0]);
            }
        } catch(e) {
            return -1;
        }
    })();

    //==================================================================================//
    //===// Mobile //===================================================================//

    /**
     * Object that only exists if device is mobile or tablet
     * @name Device.mobile
     * @memberof Device
     */
    this.mobile = !window._NODE_ && (!!(('ontouchstart' in window) || ('onpointerdown' in window)) && _this.system.os.includes(['ios', 'android', 'magicleap'])) ? {} : false;
    if (_this.detect('oculusbrowser')) this.mobile = true;
    if (_this.detect('quest')) this.mobile = true;
    if (this.mobile && this.detect(['windows']) && !this.detect(['touch'])) this.mobile = false;
    if (this.mobile) {

        /**
         * Boolean
         * @name Device.mobile.tablet
         * @memberof Device
         */
        this.mobile.tablet = Math.max(window.screen ? screen.width : window.innerWidth, window.screen ? screen.height : window.innerHeight) > 1000;

        /**
         * Boolean
         * @name Device.mobile.phone
         * @memberof Device
         */
        this.mobile.phone = !this.mobile.tablet;

        /**
         * Boolean
         * @name Device.mobile.pwa
         * @memberof Device
         */
        this.mobile.pwa = (function() {
            if (window.matchMedia && window.matchMedia('(display-mode: standalone)').matches) return true;
            if (window.navigator.standalone) return true;
            return false;
        })();

        /**
         * Boolean. Only available after Hydra is ready
         * @name Device.mobile.native
         * @memberof Device
         */
        Hydra.ready(() => {
            _this.mobile.native = (function() {
                if (Mobile.NativeCore && Mobile.NativeCore.active) return true;
                if (window._AURA_) return true;
                return false;
            })();
        });
    }

    //=================================================================================//
    //===// Media //===================================================================//

    this.media = {};

    /**
     * String for preferred audio format ('ogg' or 'mp3'), else false if unsupported
     * @name Device.media.audio
     * @memberof Device
     */
    this.media.audio = (function() {
        if (!!document.createElement('audio').canPlayType) {
            return _this.detect(['firefox', 'opera']) ? 'ogg' : 'mp3';
        } else {
            return false;
        }
    })();

    /**
     * String for preferred video format ('webm', 'mp4' or 'ogv'), else false if unsupported
     * @name Device.media.video
     * @memberof Device
     */
    this.media.video = (function() {
        var vid = document.createElement('video');
        if (!!vid.canPlayType) {
            if (vid.canPlayType('video/webm;')) return 'webm';
            return 'mp4';
        } else {
            return false;
        }
    })();

    /**
     * Boolean
     * @name Device.media.webrtc
     * @memberof Device
     */
    this.media.webrtc = !!(window.webkitRTCPeerConnection || window.mozRTCPeerConnection || window.msRTCPeerConnection || window.oRTCPeerConnection || window.RTCPeerConnection);

    //====================================================================================//
    //===// Graphics //===================================================================//

    this.graphics = {};

    /**
     * Object with WebGL-related information. False if WebGL unsupported.
     * @name Device.graphics.webgl
     * @memberof Device
     * @example
     * Device.graphics.webgl.renderer
     * Device.graphics.webgl.version
     * Device.graphics.webgl.glsl
     * Device.graphics.webgl.extensions
     * Device.graphics.webgl.gpu
     * Device.graphics.webgl.extensions
     */
    this.graphics.webgl = (function() {

        let DISABLED = false;

        Object.defineProperty(_this.graphics, 'webgl', {
           get: () => {
               if (DISABLED) return false;

               if (_this.graphics._webglContext) return _this.graphics._webglContext;

               try {
                   const names = ['webgl2', 'webgl', 'experimental-webgl'];
                   const canvas = document.createElement('canvas');
                   let gl;
                   for (let i = 0; i < names.length; i++) {
                       if (names[i] === 'webgl2' && Utils.query('compat')) continue;
                       gl = canvas.getContext(names[i]);
                       if (gl) break;
                   }

                   let output = { gpu: 'unknown' };
                   output.renderer = gl.getParameter(gl.RENDERER).toLowerCase();
                   output.version = gl.getParameter(gl.VERSION).toLowerCase();
                   output.glsl = gl.getParameter(gl.SHADING_LANGUAGE_VERSION).toLowerCase();
                   output.extensions = gl.getSupportedExtensions();
                   output.webgl2 = output.version.includes(['webgl 2', 'webgl2']);
                   output.canvas = canvas;
                   output.context = gl;

                   if (_this.system.browser === 'firefox' && _this.system.browserVersion >= 92) {
                       // WEBGL_debug_renderer_info deprecated in Firefox since 92, with
                       // “sanitized” gpu moved to the RENDERER parameter. See
                       // https://bugzil.la/1722782 and https://bugzil.la/1722113
                       output.gpu = output.renderer;
                   } else {
                       let info = gl.getExtension('WEBGL_debug_renderer_info');
                       if (info) {
                           let gpu = info.UNMASKED_RENDERER_WEBGL;
                           output.gpu = gl.getParameter(gpu).toLowerCase();
                       }
                   }

                   output.detect = function(matches) {
                       if (output.gpu && output.gpu.toLowerCase().includes(matches)) return true;
                       if (output.version && output.version.toLowerCase().includes(matches)) return true;

                       for (let i = 0; i < output.extensions.length; i++) {
                           if (output.extensions[i].toLowerCase().includes(matches)) return true;
                       }
                       return false;
                   };

                   if (!output.webgl2 && !output.detect('instance') && !window.AURA) DISABLED = true;

                   _this.graphics._webglContext = output;
                   return output;
               } catch(e) {
                   return false;
               }
           },

            set: v => {
               if (v === false) DISABLED = true;
            }
        });
    })();

    this.graphics.metal = (function() {
        if (!window.Metal) return false;
        let output = {};
        output.gpu = Metal.device.getName().toLowerCase();
        output.detect = function(matches) {
            return output.gpu.includes(matches);
        };
        return output;
    })();

    /**
     * Abstraction of Device.graphics.webgl to handle different rendering backends
     *
     * @name Device.graphics.gpu
     * @memberof Device
     */
    this.graphics.gpu = (function() {
        if (!_this.graphics.webgl && !_this.graphics.metal) return false;
        let output = {};
        ['metal', 'webgl'].forEach(name => {
            if (!!_this.graphics[name] && !output.identifier) {
                output.detect = _this.graphics[name].detect;
                output.identifier = _this.graphics[name].gpu;
            }
        });
        return output;
    })();

    /**
     * Boolean
     * @name Device.graphics.canvas
     * @memberof Device
     */
    this.graphics.canvas = (function() {
        var canvas = document.createElement('canvas');
        return canvas.getContext ? true : false;
    })();

    //==================================================================================//
    //===// Styles //===================================================================//

    const checkForStyle = (function() {
        let _tagDiv;
        return function (prop) {
            _tagDiv = _tagDiv || document.createElement('div');
            const vendors = ['Khtml', 'ms', 'O', 'Moz', 'Webkit']
            if (prop in _tagDiv.style) return true;
            prop = prop.replace(/^[a-z]/, val => {return val.toUpperCase()});
            for (let i = vendors.length - 1; i >= 0; i--) if (vendors[i] + prop in _tagDiv.style) return true;
            return false;
        }
    })();

    this.styles = {};

    /**
     * Boolean
     * @name Device.styles.filter
     * @memberof Device
     */
    this.styles.filter = checkForStyle('filter');

    /**
     * Boolean
     * @name Device.styles.blendMode
     * @memberof Device
     */
    this.styles.blendMode = checkForStyle('mix-blend-mode');

    //=================================================================================//
    //===// Tween //===================================================================//

    this.tween = {};

    /**
     * Boolean
     * @name Device.tween.transition
     * @memberof Device
     */
    this.tween.transition = checkForStyle('transition');

    /**
     * Boolean
     * @name Device.tween.css2d
     * @memberof Device
     */
    this.tween.css2d = checkForStyle('transform');

    /**
     * Boolean
     * @name Device.tween.css3d
     * @memberof Device
     */
    this.tween.css3d = checkForStyle('perspective');

    //==================================================================================//
    //===// Social //===================================================================//

    /**
     * Boolean
     * @name Device.social
     * @memberof Device
     */
    this.social = (function() {
        if (_this.agent.includes('instagram')) return 'instagram';
        if (_this.agent.includes('fban')) return 'facebook';
        if (_this.agent.includes('fbav')) return 'facebook';
        if (_this.agent.includes('fbios')) return 'facebook';
        if (_this.agent.includes('twitter')) return 'twitter';
        if (document.referrer && document.referrer.includes('//t.co/')) return 'twitter';
        return false;
    })();
}, 'Static');

/**
 * Class structure tool-belt that cleans up after itself upon class destruction.
 * @name Component
 */

Class(function Component() {
    Inherit(this, Events);
    const _this = this;
    const _setters = {};
    const _flags = {};
    const _timers = [];
    const _loops = [];
    var _onDestroy, _appStateBindings;

    this.classes = {};

    function defineSetter(_this, prop) {
        _setters[prop] = {};
        Object.defineProperty(_this, prop, {
            set: function(v) {
                if (_setters[prop] && _setters[prop].s) _setters[prop].s.call(_this, v);
                v = null;
            },

            get: function() {
                if (_setters[prop] && _setters[prop].g) return _setters[prop].g.apply(_this);
            }
        });
    }

    /**
     * @name this.findParent
     * @memberof Component
     *
     * @function
     * @param type
    */
    this.findParent = function(type) {
        let p = _this.parent;
        while (p) {
            if (!p._cachedName) p._cachedName = Utils.getConstructorName(p);
            if (p._cachedName == type) return p;
            p = p.parent;
        }
    }

    /**
     * Define setter for class property
     * @name this.set
     * @memberof Component
     *
     * @function
     * @param {String} prop
     * @param {Function} callback
     */
    this.set = function(prop, callback) {
        if (!_setters[prop]) defineSetter(this, prop);
        _setters[prop].s = callback;
    };

    /**
     * Define getter for class property
     * @name this.get
     * @memberof Component
     *
     * @function
     * @param {String} prop
     * @param {Function} callback
     */
    this.get = function(prop, callback) {
        if (!_setters[prop]) defineSetter(this, prop);
        _setters[prop].g = callback;
    };

    /**
     * Returns true if the current playground is set to this class
     * @name this.set
     * @memberof Component
     *
     * @function
     */
    this.isPlayground = function(name) {
        return Global.PLAYGROUND && Global.PLAYGROUND == (name || Utils.getConstructorName(_this));
    };


    /**
     * Helper to initialise class and keep reference for automatic cleanup upon class destruction
     * @name this.initClass
     * @memberof Component
     *
     * @function
     * @param {Function} clss - class to initialise
     * @param {*} arguments - All additional arguments passed to class constructor
     * @returns {Object} - Instanced child class
     * @example
     * Class(function BigButton(_color) {
     *     console.log(`${this.parent} made me ${_color}); //logs [parent object] made me red
     * });
     * const bigButton _this.initClass(BigButton, 'red');
     */
    this.initClass = function(clss) {
        if (!clss) {
            console.trace();
            throw `unable to locate class`;
        }

        const args = [].slice.call(arguments, 1);
        const child = Object.create(clss.prototype);
        child.parent = this;
        child.__afterInitClass = [];
        clss.apply(child, args);

        // Store reference if child is type Component
        if (child.destroy) {
            const id = Utils.timestamp();
            this.classes[id] = child;
            this.classes[id].__id = id;
        }

        // Automatically attach HydraObject elements
        if (child.element) {
            const last = arguments[arguments.length - 1];
            if (Array.isArray(last) && last.length == 1 && last[0] instanceof HydraObject) last[0].add(child.element);
            else if (this.element && this.element.add && last !== null) this.element.add(child.element);
        }

        // Automatically attach 3D groups
        if (child.group) {
            const last = arguments[arguments.length - 1];
            if (this.group && last !== null) this.group.add(child.group);
        }

        child.__afterInitClass.forEach(callback => {
            callback();
        });
        delete child.__afterInitClass;

        return child;
    };

    /**
     * Create timer callback with automatic cleanup upon class destruction
     * @name this.delayedCall
     * @memberof Component
     *
     * @function
     * @param {Function} callback
     * @param {Number} time
     * @param {*} [args] - any number of arguments can be passed to callback
     */
    this.delayedCall = function(callback, time, scaledTime) {
        const timer = Timer.create(() => {
            if (!_this || !_this.destroy) return;
            callback && callback();
        }, time, scaledTime);

        _timers.push(timer);

        // Limit in case dev using a very large amount of timers, so not to local reference
        if (_timers.length > 50) _timers.shift();

        return timer;
    };

    /**
     * Clear all timers linked to this class
     * @name this.clearTimers
     * @memberof Component
     *
     * @function
     */
    this.clearTimers = function() {
        for (let i = _timers.length - 1; i >= 0; i--) clearTimeout(_timers[i]);
        _timers.length = 0;
    };

    /**
     * Start render loop. Stored for automatic cleanup upon class destruction
     * @name this.startRender
     * @memberof Component
     *
     * @function
     * @param {Function} callback
     * @param {Number} [fps] Limit loop rate to number of frames per second. eg Value of 1 will trigger callback once per second
     */
    this.startRender = function(callback, fps, obj) {
        if (typeof fps !== 'number') {
            obj = fps;
            fps = undefined;
        }

        for (let i = 0; i < _loops.length; i++) {
            if (_loops[i].callback == callback) return;
        }

        let flagInvisible = _ => {
            if (!_this._invisible) {
                _this._invisible = true;
                _this.onInvisible && _this.onInvisible();
            }
        };

        let loop = (a, b, c, d) => {
            if (!_this.startRender) return false;

            let p = _this;
            while (p) {
                if (p.visible === false) return flagInvisible();
                if (p.group && p.group.visible === false) return flagInvisible();
                p = p.parent;
            }

            if (_this._invisible !== false) {
                _this._invisible = false;
                _this.onVisible && _this.onVisible();
            }

            callback(a, b, c, d);
            return true;
        };
        _loops.push({callback, loop});

        if (obj) {
            if (obj == RenderManager.NATIVE_FRAMERATE) Render.start(loop, null, true);
            else RenderManager.schedule(loop, obj);
        } else {
            Render.start(loop, fps);
        }
    };

    /**
     * Link up to the resize event
     * @name this.resize
     * @memberof Component
     *
     * @function
     * @param {Function} callback
     * @param {Boolean} callInitial
     */
    this.onResize = function(callback, callInitial = true) {
        if (callInitial) callback();

        this.events.sub(Events.RESIZE, callback);
    }

    /**
     * Stop and clear render loop linked to callback
     * @name this.stopRender
     * @memberof Component
     *
     * @function
     * @param {Function} callback
     */
    this.stopRender = function(callback, obj) {
        for (let i = 0; i < _loops.length; i++) {
            if (_loops[i].callback == callback) {

                let loop = _loops[i].loop;

                if (obj) {
                    RenderManager.unschedule(loop, obj);
                }

                Render.stop(loop);
                _loops.splice(i, 1);
            }
        }
    };

    /**
     * Clear all render loops linked to this class
     * @name this.clearRenders
     * @memberof Component
     *
     * @function
     */
    this.clearRenders = function() {
        for (let i = 0; i < _loops.length; i++) {
            Render.stop(_loops[i].loop);
        }

        _loops.length = 0;
    };

    /**
     * Get callback when object key exists. Uses internal render loop so automatically cleaned up.
     * @name this.wait
     * @memberof Component
     *
     * @function
     * @param {Object} object
     * @param {String} key
     * @param {Function} [callback] - Optional callback
     * @example
     * // Using promise syntax
     * this.wait(this, 'loaded').then(() => console.log('LOADED'));
     * @example
     * // Omitting object defaults to checking for a property on `this`
     * await this.wait('loaded'); console.log('LOADED');
     * @example
     * // Waiting for a property to flip from truthy to falsy
     * await this.wait('!busy'); console.log('ready');
     * @example
     * // Using callback
     * this.wait(this, 'loaded', () => console.log('LOADED'));
     * @example
     * // Using custom condition
     * await this.wait(() => _count > 3); console.log('done');
     * @example
     * // Wait for a number of milliseconds
     * await this.wait(500); console.log('timeout');
     */
    this.wait = function(object, key, callback) {
        const promise = Promise.create();
        let condition;

        if (typeof object === 'string') {
            callback = key;
            key = object;
            object = _this;
        }

        if (typeof object === 'number' && arguments.length === 1) {
            _this.delayedCall(promise.resolve, object);
            return promise;
        }

        if (typeof object === 'function' && arguments.length === 1) {
            condition = object;
            object = _this;
        }

        // To catch old format of first param being callback
        if (typeof object == 'function' && typeof callback === 'string') {
            let _object = object;
            object = key;
            key = callback;
            callback = _object;
        }

        callback = callback || promise.resolve;

        if (!condition) {
            if (key?.charAt?.(0) === '!') {
                key = key.slice(1);
                condition = () => !(object[key] || (typeof object.flag === 'function' && object.flag(key)));
            } else {
                condition = () => !!object[key] || !!(typeof object.flag === 'function' && object.flag(key));
            }
        }

        if (condition()) {
            callback();
        } else {
            Render.start(test);

            function test() {
                if (!object || !_this.flag || object.destroy === null) return Render.stop(test);
                if (condition()) {
                    callback();
                    Render.stop(test);
                }
            }
        }

        return promise;
    };

    /**
     * Bind to an AppState to get your binding automatically cleaned up on destroy
     * @name this.bindState
     * @memberof Component
     *
     * @function
     * @param {AppState} AppState
     * @param {String} [key] Key name
     * @param {Any} [rest] - Callback or otherwise second parameter to pass to AppState.bind
     */
    this.bindState = async function(appState, key, ...rest) {
        if (!!appState.then) appState = await appState;
        if (!_appStateBindings) _appStateBindings = [];
        // if(!(appState._bind || appState.bind)) console.log(appState)
        let fn = (appState._bind || appState.bind).bind(appState);
        let binding = fn(key, ...rest);
        _appStateBindings.push(binding);
        
        binding._bindOnDestroy(() => {
            _appStateBindings.remove(binding);
        });

        return binding;
    }

    /**
     * Set or get boolean
     * @name this.flag
     * @memberof Component
     *
     * @function
     * @param {String} name
     * @param {Boolean} [value] if no value passed in, current value returned
     * @param {Number} [time] - Optional delay before toggling the value to the opposite of its current value
     * @returns {*} Returns with current value if no value passed in
     */
    this.flag = function(name, value, time) {
        if (typeof value !== 'undefined') {
            _flags[name] = value;

            if (time) {
                clearTimeout(_flags[name+'_timer']);
                _flags[name+'_timer'] = this.delayedCall(() => {
                    _flags[name] = !_flags[name];
                }, time);
            }
        } else {
            return _flags[name];
        }
    };

    /**
     * Destroy class and all of its attachments: events, timers, render loops, children.
     * @name this.destroy
     * @memberof Component
     *
     * @function
     */
    this.destroy = function() {
        if (this.removeDispatch) this.removeDispatch();
        if (this.onDestroy) this.onDestroy();
        if (this.fxDestroy) this.fxDestroy();
        if (_onDestroy) _onDestroy.forEach(cb => cb());

        for (let id in this.classes) {
            var clss = this.classes[id];
            if (clss && clss.destroy) clss.destroy();
        }
        this.classes = null;

        this.clearRenders && this.clearRenders();
        this.clearTimers && this.clearTimers();
        if (this.element && window.GLUI && this.element instanceof GLUIObject) this.element.remove();

        if (this.events) this.events = this.events.destroy();
        if (this.parent && this.parent.__destroyChild) this.parent.__destroyChild(this.__id);

        if (_appStateBindings) {
            while (_appStateBindings.length > 0) {
                // destroying removes itself from the _appStateBindings array
                // so keep looking until there are none left,
                // since the indexes of _appStateBindings are changing
                _appStateBindings[_appStateBindings.length - 1].destroy?.();
            }
        }

        return Utils.nullObject(this);
    };

    this._bindOnDestroy = function(cb) {
        if (!_onDestroy) _onDestroy = [];
        _onDestroy.push(cb);
    }

    this.__destroyChild = function(name) {
        delete this.classes[name];
    };

    this.navigate = function(route) {
        let p = _this.parent;
        while (p) {
            if (p.navigate) p.navigate(route);
            p = p.parent;
        }
    }

});

/**
 * Class structure tool-belt that helps with loading and storing data.
 * @name Model
 */

Class(function Model() {
    Inherit(this, Component);
    Namespace(this);

    const _this = this;
    const _storage = {};
    const _requests = {};
    let _data = 0;
    let _triggered = 0;

    /**
     * @name this.push
     * @memberof Model
     *
     * @function
     * @param {String} name
     * @param {*} val
     */
    this.push = function(name, val) {
        _storage[name] = val;
    };

    /**
     * @name this.pull
     * @memberof Model
     *
     * @function
     * @param {String} name
     * @returns {*}
     */
    this.pull = function(name) {
        return _storage[name];
    };

    /**
     * @name this.promiseData
     * @memberof Model
     *
     * @function
     * @param {Number} [num = 1]
     */
    this.waitForData = this.promiseData = function(num = 1) {
        _data += num;
    };

    /**
     * @name this.resolveData
     * @memberof Model
     *
     * @function
     */
    this.fulfillData = this.resolveData = function() {
        _triggered++;
        if (_triggered == _data) {
            _this.dataReady = true;
        }
    };

    /**
     * @name this.ready
     * @memberof Model
     *
     * @function
     * @param {Function} [callback]
     * @returns {Promise}
     */
    this.ready = function(callback) {
        let promise = Promise.create();
        if (callback) promise.then(callback);
        _this.wait(_this, 'dataReady').then(promise.resolve);
        return promise;
    };

    /**
     * Calls init() on object member is exists, and then on self once completed.
     * @name this.initWithData
     * @memberof Model
     *
     * @function
     * @param {Object} data
     */
    this.initWithData = function(data) {
        _this.STATIC_DATA = data;

        for (var key in _this) {
            var model = _this[key];
            var init = false;

            for (var i in data) {
                if (i.toLowerCase().replace(/-/g, "") == key.toLowerCase()) {
                    init = true;
                    if (model.init) model.init(data[i]);
                }
            }

            if (!init && model.init) model.init();
        }

        _this.init && _this.init(data);
    };

    /**
     * Loads url with salt, then calls initWithData on object received
     * @name this.loadData
     * @memberof Model
     *
     * @function
     * @param {String} url
     * @param {Function} [callback]
     * @returns {Promise}
     */
    this.loadData = function(url, callback) {
        let promise = Promise.create();
        if (!callback) callback = promise.resolve;

        var _this = this;
        get(url + '?' + Utils.timestamp()).then( d => {
            defer(() => {
                _this.initWithData(d);
                callback(d);
            });
        });

        return promise;
    };

    /**
     * @name this.handleRequest
     * @memberof Model
     *
     * @function
     * @param {String} type
     * @param {Function} [callback]
     */
    this.handleRequest = function(type, callback) {
        _requests[type] = callback;
    }

    /**
     * @name this.makeRequest
     * @memberof Model
     *
     * @function
     * @param {String} type
     * @param {Object} data?
     * @param {Object} mockData?
     * @returns {Promise}
     */
    this.makeRequest = async function(type, data, mockData = {}) {
        if (!_requests[type]) {
            console.warn(`Missing data handler for ${type} with mockData`, mockData);
            return Array.isArray(mockData) ? new StateArray(mockData) : AppState.createLocal(mockData);
        }
        let result = await _requests[type](data, mockData);
        if (!(result instanceof StateArray) && !result.createLocal) throw `makeRequest ${type} must return either an AppState or StateArray`;
        return result;
    }


    this.request = async function(type, data, mockData) {
        if (typeof data === 'function') {
            mockData = data;
            data = null;
        }

        if (mockData) mockData = mockData();

        if (!_requests[type]) {
            // console.warn(`Missing data handler for ${type} with mockData`, mockData);
            return Array.isArray(mockData) ? new StateArray(mockData) : AppState.createLocal(mockData);
        }
        let result = await _requests[type](data, mockData);
        if (Array.isArray(result)) result = new StateArray(result);
        else if (typeof result === 'object') result = AppState.createLocal(result);
        
        if (!(result instanceof StateArray) && !result.createLocal) throw `makeRequest ${type} must return either an AppState or StateArray`;
        return result;
    }

});

Class(function Data() {
    Inherit(this, Model);
    const _this = this;
}, 'static');
/**
 * @name Modules
 */

Class(function Modules() {
    const _modules = {};
    const _constructors = {};

    //*** Constructor
    (function () {
        defer(exec);
    })();

    function exec() {
        for (let m in _modules) {
            for (let key in _modules[m]) {
                let module = _modules[m][key];
                if (module._ready) continue;
                module._ready = true;
                if (module.exec) module.exec();
            }
        }
    }

    function requireModule(root, path) {
        let module = _modules[root];
        if (!module) throw `Module ${root} not found`;
        module = module[path];

        if (!module._ready) {
            module._ready = true;
            if (module.exec) module.exec();
        }

        return module;
    }

    //*** Public methods

    /**
     * @name window.Module
     * @memberof Modules
     *
     * @function
     * @param {Constructor} module
     */
    this.Module = function(module) {
        let m = new module();

        let name = module.toString().slice(0, 100).match(/function ([^\(]+)/);

        if (name) {
            m._ready = true;
            name = name[1];
            _modules[name] = {index: m};
            _constructors[name] = module;
        } else {
            if (!_modules[m.module]) _modules[m.module] = {};
            _modules[m.module][m.path] = m;
        }
    };

    /**
     * @name window.require
     * @memberof Modules
     *
     * @function
     * @param {String} path
     * @returns {*}
     */
    this.require = function(path) {
        let root;
        if (!path.includes('/')) {
            root = path;
            path = 'index';
        } else {
            root = path.split('/')[0];
            path = path.replace(root+'/', '');
        }

        return requireModule(root, path).exports;
    };

    this.getConstructor = function(name) {
        return _constructors[name];
    }

    this.modulesReady = async function () {
        let modules = [...arguments].flat();
        await Promise.all( modules.map( name => Modules.moduleReady( name )));
    }

    this.moduleReady = function (name) {
        let promise = Promise.create();
        let check = function () {
            if ( !_modules[name]) return;
            Render.stop( check );
            promise.resolve();
        }
        Render.start( check );
        return promise;
    }

    window.Module = this.Module;

    if (!window._NODE_) {
        window.requireNative = window.require;
        window.require = this.require;
    }
}, 'Static');

Class(function StateWrapper(_array) {
    const _this = this;
    Inherit(this, Component);
    
    this.bind = this.listen = function(key, callback) {
        _array.forEach(async obj => {
            await obj.wait('__ready');
            _this.bindState(obj.state, key, data => {
                callback({target: obj, data});
            });
        });
    }
    
});
Class(function StateInitializer(Class, _ref, _params, _stateRef) {
    Inherit(this, Component);
    const _this = this;

    this.ref = _ref;
    
    //*** Constructor
    (function () {
        if (!_stateRef.init) throw `StateInitializer required init parameter`;
        if (_stateRef.init) _this.bindState(AppState, _stateRef.init, onInit);
        if (_stateRef.init3d) _this.bindState(AppState, _stateRef.init3d, onInit3D);
    })();

    function onInit(bool) {
        if (bool) {
            _this.parent[_ref] = _this.parent.initClass(Class, _params);
        } else {
            _this.parent[_ref] = _this.parent[_ref].destroy();
        }
    }

    async function onInit3D() {
        let ref = _this.parent[_ref];
        await _this.wait(_ => ref);
        let next = await Initializer3D.queue();
        await Initializer3D.uploadAllAsync(ref.layout || ref.scene || ref.group);
        next();
    }
    
    //*** Event handlers
    
    //*** Public methods
    this.force = function() {
        AppState.set(_stateRef.init, true);
    }
});
Class(function FragUIHelper(_obj, _root) {
    Inherit(this, Component);
    const _this = this;

    if (!_obj.addTo) _obj.addTo = "$element";
    if (_root) applyValues(_root, _this.parent.element);
    create(_obj);

    function isLowerCase(str) {
        return str == str.toLowerCase();
    }

    function findStateObject(text) {
        return text.match(/\$(.*)\./)[1];
    }

    function getPropByString(obj, propString) {
        if (!propString)
          return obj;
      
        var prop, props = propString.split('.');
      
        for (var i = 0, iLen = props.length - 1; i < iLen; i++) {
          prop = props[i];
      
          var candidate = obj[prop];
          if (candidate !== undefined) {
            obj = candidate;
          } else {
            break;
          }
        }
        return obj[props[i]];
    }

    function parseTextBindings(text) {
        let binds = [];
        while (text.match(/\$(.*)\./)) {
            let match = text.match(/\$(.*)\./);
            let split = text.split(match[0]);
            split[0] = split[0] + '@[';
            split[1] = split[1].split(' ');
            let name = split[1][0];
            split[1][0] += ']';
            split[1] = split[1].join(' ');
            text = split.join('');
            binds.push(name);
        }
        return [binds, text];
    }

    function parseTextGlobalBindings(text) {
        let binds = [];
        while (text.match(/\$(\w*)\/(\w*)/)) {
            let match = text.match(/\$(\w*)\/(\w*)/);
            let split = text.split(match[0]);
            split[0] = split[0] + '@[';
            split[1] = split[1].split(' ');
            let name = match[0].slice(1).trim();
            split[1][0] = name;
            split[1][0] += ']';
            split[1] = split[1].join(' ');
            text = split.join('');
            binds.push(name);
        }
        return [binds, text];
    }

    function doConstructor(obj) {
        switch (obj._type) {
            case 'UI':
                return _this.parent.element;
                break;

            case 'GLObject':
            case 'glObject':
            case 'glObj':
                if (obj.width && obj.height && obj.bg) {
                    let tempObj = $gl(Number(obj.width), Number(obj.height), obj.bg);

                    // calling GLObject.bg() in applyValues() removes the custom shader.
                    // didn't happen before because we weren't waiting for parent init before calling
                    delete obj.bg;

                    return tempObj;
                } else {
                    return $gl();
                }
                break;

            case 'GLText':
            case 'glText':
                if (obj._innerText.match?.(/\$(.*)\./)) {
                    let $text = $glText(obj._innerText, obj.font, Number(obj.fontSize), { color: obj.fontColor });
                    let state = findStateObject(obj._innerText);
                    let ref = state;
                    if (ref.includes('.')) {
                        let split = state.split('.');
                        ref = split[0];
                        split.shift();
                        state = split.join('.');
                    } 
                    _this.wait(_this.parent, ref).then(_ => {
                        let [binds, text] = parseTextBindings(obj._innerText);
                        $obj.text(text);
                        _this.parent.bindState(ref == state ? _this.parent[ref] : getPropByString(_this.parent[ref], state), binds, $obj);
                    });
                    return $text;
                } else if (obj._innerText.match?.(/\$(\w*)\/(\w*)/)) {
                    let [binds, text] = parseTextGlobalBindings(obj._innerText);
                    let $text = $glText(text, obj.font, Number(obj.fontSize), { color: obj.fontColor });
                    _this.parent.bindState(AppState, binds, $text);
                    return $text;
                } else {
                    return $glText(obj._innerText, obj.font, Number(obj.fontSize), { color: obj.fontColor });
                }
                break;

            default:
                let $obj = $(obj.className || obj.refName || 'h', obj._type != 'HydraObject' ? obj._type : 'div');
                if (obj.width && obj.height) $obj.size(obj.width, obj.height);
                if (obj.font) $obj.fontStyle(obj.font, Number(obj.fontSize), obj.fontColor);
                if (obj._innerText) {
                   if (obj._innerText.match?.(/\$(.*)\./)) {
                        let state = findStateObject(obj._innerText);
                        let ref = state;
                        if (ref.includes('.')) {
                            let split = state.split('.');
                            ref = split[0];
                            split.shift();
                            state = split.join('.');
                        } 
                        _this.wait(_this.parent, ref).then(_ => {
                            let [binds, text] = parseTextBindings(obj._innerText);
                            $obj.text(text);
                            _this.parent.bindState(ref == state ? _this.parent[ref] : getPropByString(_this.parent[ref], state), binds, $obj);
                        });
                    } else if (obj._innerText.match?.(/\$(\w*)\/(\w*)/)) {
                        let [binds, text] = parseTextGlobalBindings(obj._innerText);
                        $obj.text(text);
                        _this.parent.bindState(AppState, binds, $obj);
                    } else {
                        $obj.text(obj._innerText);
                    }
                }
                return $obj;
                break;
        }
    }

    function applyValues(obj, $obj) {
        const callObjKeyVal = (key) => {
            return new Promise(resolve => {
                const applyValue = (val) => {
                    if (typeof $obj[key] === 'function') {
                        $obj[key](val);
                    } else {
                        $obj[key] = val;
                    }
                };
                const callFn = async () => {
                    let val = isNaN(obj[key]) ? obj[key] : Number(obj[key]);
                    if (typeof val === 'string') {
                        if (val.match(/\$(.*)\./)) {
                            let stateStr = findStateObject(val);
                            let state = _this.parent[stateStr];
                            if (!state) {
                                await _this.wait(_this.parent, stateStr);
                                state = _this.parent[stateStr];
                            }
                            if (!!state.then) state = await state;
                            let [binds] = parseTextBindings(val);
                            return _this.parent.bindState(state, binds, (dataVal) => applyValue(dataVal));
                        } else if (val.match(/\$(\w*)\/(\w*)/)) {
                            let [binds] = parseTextGlobalBindings(val);
                            return _this.parent.bindState(AppState, binds, (dataVal) => applyValue(dataVal));
                        }

                        if (val.startsWith('$') && val != '$element') {
                            return applyValue(_this.parent[val.slice(1)]);
                        }
                    }
                    
                    applyValue(val);
                };
                if (_this.parent.__afterInitClass) {
                    return _this.parent.__afterInitClass.push(() => resolve(callFn()));
                }
                resolve(callFn());
            });
        };

        for (let key in obj) {
            if (key == 'shader') {
                let shader = _this.initClass(Shader, obj[key], {
                    tMap: { value: null }
                });
                if (window[shader.vsName]) window[shader.vsName]({}, shader);
                $obj.useShader(shader);
                // ShaderUIL.add(shader);
            }

            if (obj.width && obj.height && $obj.size) {
                $obj.size(!isNaN(obj.width) ? Number(obj.width) : obj.width,
                    !isNaN(obj.height) ? Number(obj.height) : obj.height);
            }

            if (key == 'css' || key == 'transform') {
                let data = {};
                obj[key].split(',').forEach(param => {
                    let [a, b] = param.split(':');
                    a = a.trim();
                    b = b.trim();
                    if (!isNaN(b)) b = Number(b);
                    data[a] = b;
                });
                $obj[key](data);
            } else if (key == 'onClick' || key == 'onHover') {
                _this.wait(_ => !!_this.parent[obj[key].slice(1)]).then(_ => {
                    const interactHandle = _this.parent[obj[key].slice(1)]
                    let hoverFn = key === 'onHover' ? interactHandle : null;
                    let clickFn = key === 'onClick' ? interactHandle : null;
                    $obj.interact(hoverFn, clickFn, obj["seoLink"], obj["seoText"]);
                })
            } else {
                if (typeof $obj[key] === 'function') {
                    if (key == 'size') {
                        let size = obj.size.split(',');
                        size.map(x => Number(x));
                        $obj.size(size[0], size[1]);
                        continue;
                    }
                    if (obj[key] === 1) obj[key] = undefined;
                    callObjKeyVal(key);
                } else {
                    callObjKeyVal(key);
                }
            }

        }
    }
    
    function convertToUsableRef(str) {
        if (str.startsWith('$')) str = str.slice(1);
        let ref = str;
        let state = str;
        if (str.includes('.')) {
            let split = str.split('.');
            state = split[0];
            split.shift();
            ref = split.join('.');
        }

        return [state, ref];
    }

    async function create(obj, parent) {
        if (!isLowerCase(obj._type) && obj._type != 'GLObject' && obj._type != 'HydraObject' && obj._type != 'GLText' && obj._type != 'UI') {
            let params = {};
            for (let key in obj) {
                if (key == '_type' || key == 'refName' || key == 'children' || key == 'display') continue;
                params[key] = obj[key];

                if (params[key].match?.(/\$(.*)\./)) {
                    await defer();
                    let [state, ref] = convertToUsableRef(params[key]);
                    params[key] = state == ref ?
                                    _this.parent[state] : 
                                    _this.parent[ref] ? 
                                    _this.parent[ref] : 
                                    getPropByString(_this.parent[state], ref);
                } else if (params[key].startsWith('$')) {
                    await defer();
                    params[key] = _this.parent[params[key].slice(1)];
                }
            }

            if (obj._type == 'ViewState') {
                params.__parent = parent;
            }
            _this.parent[obj.refName] = _this.parent.initClass(window[obj._type], AppState.createLocal(params), [parent]);
            return;
        }

        let $obj = doConstructor(obj);
        if (obj.addTo) {
            let addTo = obj.addTo.includes('.') ? eval(obj.addTo) : _this.parent.element;
            addTo.add($obj);
        } else {
            if (parent) parent.add($obj);
        }

        applyValues(obj, $obj);

        $obj.transform?.();

        if (obj.refName) {
            _this.parent[obj.refName] = $obj;
        }

        obj.children.forEach(o => create(o, $obj));
    }

});
/**
 * @name LinkedList
 *
 * @constructor
 */

Class(function LinkedList() {
    var prototype = LinkedList.prototype;

    /**
     * @name length
     * @memberof LinkedList
     */
    this.length = 0;
    this.first = null;
    this.last = null;
    this.current = null;
    this.prev = null;

    if (typeof prototype.push !== 'undefined') return;

    /**
     * @name push
     * @memberof LinkedList
     *
     * @function
     * @param {*} obj
     */
    prototype.push = function(obj) {
        if (!this.first) {
            this.first = obj;
            this.last = obj;
            obj.__prev = obj;
            obj.__next = obj;
        } else {
            obj.__next = this.first;
            obj.__prev = this.last;
            this.last.__next = obj;
            this.last = obj;
        }

        this.length++;
    };

    /**
     * @name remove
     * @memberof LinkedList
     *
     * @function
     * @param {*} obj
     */
    prototype.remove = function(obj) {
        if (!obj || !obj.__next) return;

        if (this.length <= 1) {
            this.empty();
        } else {
            if (obj == this.first) {
                this.first = obj.__next;
                this.last.__next = this.first;
                this.first.__prev = this.last;
            } else if (obj == this.last) {
                this.last = obj.__prev;
                this.last.__next = this.first;
                this.first.__prev = this.last;
            } else {
                obj.__prev.__next = obj.__next;
                obj.__next.__prev = obj.__prev;
            }

            this.length--;
        }

        obj.__prev = null;
        obj.__next = null;
    };

    /**
     * @name empty
     * @memberof LinkedList
     *
     * @function
     */
    prototype.empty = function() {
        this.first = null;
        this.last = null;
        this.current = null;
        this.prev = null;
        this.length = 0;
    };

    /**
     * @name start
     * @memberof LinkedList
     *
     * @function
     * @return {*}
     */
    prototype.start = function() {
        this.current = this.first;
        this.prev = this.current;
        return this.current;
    };

    /**
     * @name next
     * @memberof LinkedList
     *
     * @function
     * @return {*}
     */
    prototype.next = function() {
        if (!this.current) return;
        this.current = this.current.__next;
        if (this.length == 1 || this.prev.__next == this.first) return;
        this.prev = this.current;
        return this.current;
    };

    /**
     * @name destroy
     * @memberof LinkedList
     *
     * @function
     * @returns {Null}
     */
    prototype.destroy = function() {
        Utils.nullObject(this);
        return null;
    };

});
/**
 * @name ObjectPool
 *
 * @constructor
 * @param {Constructor} [_type]
 * @param {Number} [_number = 10] - Only applied if _type argument exists
 */

Class(function ObjectPool(_type, _number = 10) {
    var _pool = [];

    /**
     * Pool array
     * @name array
     * @memberof ObjectPool
     */
    this.array = _pool;

    //*** Constructor
    (function() {
        if (_type) for (var i = 0; i < _number; i++) _pool.push(new _type());
    })();

    //*** Public Methods

    /**
     * Retrieve next object from pool
     * @name get
     * @memberof ObjectPool
     *
     * @function
     * @returns {ArrayElement|null}
     */
    this.get = function() {
        return _pool.shift() || (_type ? new _type() : null);
    };

    /**
     * Empties pool array
     * @name empty
     * @memberof ObjectPool
     *
     * @function
     */
    this.empty = function() {
        _pool.length = 0;
    };

    /**
     * Place object into pool
     * @name put
     * @memberof ObjectPool
     *
     * @function
     * @param {Object} obj
     */
    this.put = function(obj) {
        if (obj && !_pool.includes(obj)) _pool.push(obj);
    };

    /**
     * Insert array elements into pool
     * @name insert
     * @memberof ObjectPool
     *
     * @function
     * @param {Array} array
     */
    this.insert = function(array) {
        if (typeof array.push === 'undefined') array = [array];
        for (var i = 0; i < array.length; i++) this.put(array[i]);
    };

    /**
     * Retrieve pool length
     * @name length
     * @memberof ObjectPool
     *
     * @function
     * @returns {Number}
     */
    this.length = function() {
        return _pool.length;
    };

    /**
     * Randomize pool
     * @memberof ObjectPool
     *
     * @function
     */
    this.randomize = function() {
        let array = _pool;
        for (let i = array.length - 1; i > 0; i--) {
            const j = Math.floor(Math.random() * (i + 1));
            [array[i], array[j]] = [array[j], array[i]];
        }
    }

    /**
     * Calls destroy method on all members if exists, then removes reference.
     * @name destroy
     * @memberof ObjectPool
     *
     * @function
     * @returns {null}
     */
    this.destroy = function() {
        for (let i = _pool.length - 1; i >= 0; i--) if (_pool[i].destroy) _pool[i].destroy();
        return _pool = null;
    };
});

/**
 * @name Gate
 *
 * @constructor
 */


Class(function Gate() {
    var _this = this;

    var _list = [];
    var _map = {};

    //*** Event handlers

    //*** Public methods
    /**
     * @name this.create
     * @memberof Gate
     *
     * @function
     * @param name
    */
    this.create = function(name) {
        let promise = Promise.create();
        if (name) _map[name] = promise;
        else _list.push(promise);
    }

    /**
     * @name this.open
     * @memberof Gate
     *
     * @function
     * @param name
    */
    this.open = function(name) {
        if (name) {
            if (!_map[name]) _map[name] = Promise.create();
            _map[name].resolve();
        }

        let promise = _list.shift();
        if (promise) promise.resolve();
    }

    /**
     * @name this.wait
     * @memberof Gate
     *
     * @function
     * @param name
    */
    this.wait = function(name) {
        if (!_list.length && !name) return Promise.resolve();

        if (name) {
            if (!_map[name]) _map[name] = Promise.create();
            return _map[name];
        }

        return _list[_list.length-1] || Promise.resolve();
    }
}, 'static');
/**
 * @name Assets
 */

Class(function Assets() {
    const _this = this;
    const _fetchCors = {mode: 'cors'};

    this.__loaded = [];

    /**
     * Flip bitmap images when decoding.
     * @name Assets.FLIPY
     * @memberof Assets
     * @example
     * Assets.FLIPY = false // do not flip when decoding
     */
    this.FLIPY = true;

    /**
     * Path for Content Distribution Network (eg. Amazon bucket)
     * @name Assets.CDN
     * @memberof Assets
     * @example
     * Assets.CDN = '//amazonbucket.com/project/';
     */
    this.CDN = '';

    /**
     * Cross Origin string to apply to images
     * @name Assets.CORS
     * @memberof Assets
     * @example
     * Assets.CORS = '';
     */
    this.CORS = 'anonymous';

    /**
     * Storage for all images loaded for easy access
     * @name Assets.IMAGES
     * @memberof Assets
     */
    this.IMAGES = {};

    /**
     * Storage for all videos loaded for easy access
     * @name Assets.VIDEOS
     * @memberof Assets
     */
    this.VIDEOS = {};

    /**
     * Storage for all audios loaded for easy access
     * @name Assets.AUDIOS
     * @memberof Assets
     */
    this.AUDIOS = {};

    /**
     * Storage for all sdf font files loaded for easy access
     * @name Assets.SDF
     * @memberof Assets
     */
    this.SDF = {};

    /**
     * Storage for all JSON files loaded for easy access. Always clones object when retrieved.
     * @name Assets.JSON
     * @memberof Assets
     */
    this.JSON = {
        push: function(prop, value) {
            this[prop] = value;
            Object.defineProperty(this, prop, {
                get: () => {return JSON.parse(JSON.stringify(value))},
            });
        }
    };

    Object.defineProperty(this.JSON, 'push', {
        enumerable: false,
        writable: true
    });

    /**
     * Storage for all SVG files loaded for easy access
     * @name Assets.SVG
     * @memberof Assets
     */
    this.SVG = {};

    /**
     * Returns pixel-ratio-appropriate version if exists
     * @private
     * @param path
     * @returns {String}
     */
    function parseResolution(path) {
        if (!window.ASSETS || !ASSETS.RES) return path;
        var res = ASSETS.RES[path];
        var ratio = Math.min(Device.pixelRatio, 3);
        if (!res) return path;
        if (!res['x' + ratio]) return path;
        var split = path.split('/');
        var file = split[split.length-1];
        split = file.split('.');
        return path.replace(file, split[0] + '-' + ratio + 'x.' + split[1]);
    }

    /**
     * Array extension for manipulating list of assets
     * @private
     * @param {Array} arr
     * @returns {AssetList}
     * @constructor
     */
    function AssetList(arr) {
        arr.__proto__ = AssetList.prototype;
        return arr;
    }
    AssetList.prototype = new Array;

    /**
     * Filter asset list to only include those matching the arguments
     * @param {String|String[]} items
     */
    AssetList.prototype.filter = function(items) {
        for (let i = this.length - 1; i >= 0; i--) if (!this[i].includes(items)) this.splice(i, 1);
        return this;
    };

    /**
     * Filter asset list to exclude those matching the arguments
     * @param {String|String[]} items
     */
    AssetList.prototype.exclude = function(items) {
        for (let i = this.length - 1; i >= 0; i--) if (this[i].includes(items)) this.splice(i, 1);
        return this;
    };

    AssetList.prototype.prepend = function(prefix) {
        for (let i = this.length - 1; i >= 0; i--) this[i] = prefix + this[i];
        return this;
    };

    AssetList.prototype.append = function(suffix) {
        for (let i = this.length - 1; i >= 0; i--) this[i] = this[i] + suffix;
        return this;
    };

    /**
     * Get compiled list of assets
     * @name Assets.list
     * @memberof Assets
     *
     * @function
     * @returns {AssetList}
     * @example
     * const assets = Assets.list();
     * assets.filter(['images', 'geometry']);
     * assets.exclude('mobile');
     * assets.append('?' + Utils.timestamp());
     * const loader = _this.initClass(AssetLoader, assets);
     */
    this.list = function() {
        if (!window.ASSETS) console.warn(`ASSETS list not available`);
        return new AssetList(window.ASSETS.slice(0) || []);
    };

    /**
     * Wrap path in CDN and get correct resolution file
     * @name Assets.getPath
     * @memberof Assets
     *
     * @function
     * @param {String} path
     * @returns {String}
     */

    this.BASE_PATH = '';

    this.getPath = function(path) {

        if (path.includes('~')) return _this.BASE_PATH + path.replace('~', '');

        // If static url, return untouched
        if (path.includes('//')) return path;

        // Check if should offer different DPR version
        path = parseResolution(path);

        // Check if the asset's path should be replaced with a different path.
        // Doesnt use a CDN.
        if (_this.replacementPaths) {
            for (let pathKey in _this.replacementPaths) {
                if(path.startsWith(pathKey)) {
                    path = path.replace(pathKey, _this.replacementPaths[pathKey]);
                    return path;
                }
            }
        }

        if (_this.dictionary) {
            for (let pathKey in _this.dictionary) {
                if (_this.dictionary[pathKey].includes(path.split('?')[0])) return pathKey + path;
            }
        }

        // Wrap in CDN
        if (this.CDN && !~path.indexOf(this.CDN)) path = this.CDN + path;

        return path;
    };

    /**
     * Replace an assets path before trying to load it.  Ie, if an asset has a url of /dam/content/assets/ and you want it to become /images/, call this function with ('/dam/content/assets/', '/images');
     * This function should only be used as a last resort.  In some cases, when integrating in a system like AEM, it's pretty unavoidable.
     * @param {string} path
     * @param {string} replacedPath
     */
    this.registerPathReplacement = function(path, replacedPath) {
        if (!_this.replacementPaths) _this.replacementPaths = {};
        _this.replacementPaths[path] = replacedPath;
    }

    this.registerPath = function(path, assets) {
        if (!_this.dictionary) _this.dictionary = {};
        _this.dictionary[path] = assets;
    };

    /**
     * Load image, adding CDN and CORS state and optionally storing in memory
     * @name Assets.loadImage
     * @memberof Assets
     *
     * @function
     * @param {String} path - path of asset
     * @param {Boolean} [isStore] - True if to store in memory under Assets.IMAGES
     * @returns {Image}
     * @example
     * Assets.loadImage('assets/images/cube.jpg', true);
     * console.log(Assets.IMAGES['assets/images/cube.jpg']);
     */
    this.loadImage = function(path, isStore) {
        var img = new Image();
        img.crossOrigin = this.CORS;
        img.src = _this.getPath(path);

        img.loadPromise = function() {
            let promise = Promise.create();
            img.onload = promise.resolve;
            return promise;
        };

        if (isStore) this.IMAGES[path] = img;

        return img;
    };

    /**
     * Load and decode an image off the main thread
     * @name Assets.decodeImage
     * @memberof Assets
     *
     * @function
     * @param {String} path - path of asset
     * @param {Boolean} [flipY=Assets.FLIPY] - overwrite global flipY option
     * @returns {Promise}
     * @example
     * Assets.decodeImage('assets/images/cube.jpg').then(imgBmp => {});
     */
    this.decodeImage = function(path, params, promise) {
        if ( !promise ) promise = Promise.create();
        let img = _this.loadImage(path);
        img.onload = () => promise.resolve(img);
        img.onerror = () => _this.decodeImage('assets/images/_scenelayout/uv.jpg', params, promise);
        return promise;
    };

    /**
     * Detects webp support, returns boolean
     * @name Assets.supportsWebP
     * @memberof Assets
     *
     * @function
     * @returns {Boolean}
     * @example
     * let supportsWebP = Assets.supportsWebP();
     * > true
     */
    const _supportsWebP = (function () {
        try {
            let canvas = document.createElement('canvas');
            return canvas.toDataURL('image/webp').indexOf('data:image/webp') == 0;
        } catch (e) {
            return false;
        }
    })();
    
    this.supportsWebP = function () {
        return !!_supportsWebP;
    }

    /**
     * Detects webp support, returns best image path
     * @name Assets.perfImage
     * @memberof Assets
     *
     * @function
     * @returns {String}
     * @example
     * let path = Assets.perfImage('assets/images/cube.jpg');
     * console.log(path);
     * > "assets/images/cube.webp"
     */
    this.perfImage = function(path) {
        let result = path;
        if ( _this.supportsWebP() && path.includes(['.jpg', '.png'])) result = `${path.substring(0, path.lastIndexOf('.'))}.webp`;
        return result;
    }

}, 'static');

/**
 * @name AssetLoader
 * @example
 * const assets = Assets.list()l
 * const loader = new AssetLoader(assets);
 * _this.events.sub(loader, Events.COMPLETE, complete);
 */

Class(function AssetLoader(_assets, _callback, ASSETS = Assets) {
    Inherit(this, Events);
    const _this = this;

    let _total = _assets.length;
    let _loaded = 0;
    let _lastFiredPercent = 0;

    (function() {
        if (!Array.isArray(_assets)) throw `AssetLoader requires array of assets to load`;
        _assets = _assets.slice(0).reverse();

        init();
    })();

    function init() {
        if (!_assets.length) return complete();
        for (let i = 0; i < AssetLoader.SPLIT; i++) {
            if (_assets.length) loadAsset();
        }
    }

    function loadAsset() {
        let path = _assets.splice(_assets.length - 1, 1)[0];

        const name = path.split('assets/').last().split('.')[0];
        const ext = path.split('.').last().split('?')[0].toLowerCase();

        let timeout = Timer.create(timedOut, AssetLoader.TIMEOUT, path);

        // Check if asset previously loaded
        if (!Assets.preventCache && !!~Assets.__loaded.indexOf(path)) return loaded();

        // If image, don't use fetch api
        if (ext.includes(['jpg', 'jpeg', 'png', 'gif'])) {
            let image = ASSETS.loadImage(path);
            if (image.complete) return loaded();
            image.onload = loaded;
            image.onerror = loaded;
            return;
        }

        // If video, do manual request and create blob
        if (ext.includes(['mp4', 'webm'])) {
            fetch(path).then(async response => {
                let blob = await response.blob();
                Assets.VIDEOS[name] = URL.createObjectURL(blob);
                loaded();
            }).catch(e => {
                console.warn(e);
                loaded();
            });
            return;
        }

        // If audio, do manual request and create blob
        if (ext.includes(['mp3'])) {
            fetch(path).then(async response => {
                let blob = await response.blob();
                Assets.AUDIOS[name] = URL.createObjectURL(blob);
                loaded();
            }).catch(e => {
                console.warn(e);
                loaded();
            });
            return;
        }

        get(Assets.getPath(path), Assets.HEADERS).then(data => {
            Assets.__loaded.push(path);
            if (ext == 'json') ASSETS.JSON.push(name, data);
            if (ext == 'svg') ASSETS.SVG[name] = data;
            if (ext == 'fnt') ASSETS.SDF[name.split('/')[1]] = data;
            if (ext == 'js') window.eval(data);
            if (ext.includes(['fs', 'vs', 'glsl']) && window.Shaders) Shaders.parse(data, path);
            loaded();
        }).catch(e => {
            console.warn(e);
            loaded();
        });

        function loaded() {
            if (timeout) clearTimeout(timeout);
            increment();
            if (_assets.length) loadAsset();
        }
    }

    function increment() {
        let percent = Math.max(_lastFiredPercent, Math.min(1, ++_loaded / _total));
        _this.events.fire(Events.PROGRESS, {percent});
        _lastFiredPercent = percent;

        // Defer to get out of promise error catching
        if (_loaded >= _total) defer(complete);
    }

    function complete() {
        if (_this.completed) return;
        _this.completed = true;

        // Defer again to allow any code waiting for loaded libs to run first
        defer(() => {
            _callback && _callback();
            _this.events.fire(Events.COMPLETE);
        });
    }

    function timedOut(path) {
        console.warn('Asset timed out', path);
    }

    this.loadModules = function() {
        if (!window._BUILT_) return;
        this.add(1);
        let module = window._ES5_ ? 'es5-modules' : 'modules';
        let src = 'assets/js/'+module+'.js?' + window._CACHE_;
        // Use <link rel="preload"> along with <script async> to make Chrome download
        // the script with High priority.
        // Ref: https://medium.com/dev-channel/javascript-loading-priorities-in-chrome-57c54cfa6672
        let s = document.createElement('link');
        s.href = src;
        s.rel = 'preload';
        s.as = 'script';
        document.head.appendChild(s);

        s = document.createElement('script');
        s.src = src;
        s.async = true;
        document.head.appendChild(s);
        return AssetLoader.waitForLib('_MODULES_').then(_ => _this.trigger(1));
    }

    /**
     * Increment total tasks for loader. Will need to manually trigger same amount for loader to complete.
     * @name add
     * @memberof AssetLoader
     *
     * @function
     * @param {Number} num
     * @example
     * const loader = new AssetLoader(assets);
     * loader.add(1);
     * _this.delayedCall(loader.trigger, 1000, 1);
     */
    this.add = function(num) {
        _total += num || 1;
    };

    /**
     * Increment number of loaded tasks.
     * @name trigger
     * @memberof AssetLoader
     *
     * @function
     * @param {Number} num
     */
    this.trigger = function(num) {
        for (let i = 0; i < (num || 1); i++) increment();
    };

}, () => {

    /**
     * Define number of batches to split up AssetLoader. Loader waits until each batch completes before starting next.
     * @name AssetLoader.SPLIT
     * @memberof AssetLoader
     */
    AssetLoader.SPLIT = 2;

    /**
     * Define length of asset timeout
     * @name AssetLoader.TIMEOUT
     * @memberof AssetLoader
     */
    AssetLoader.TIMEOUT = 5000;

    /**
     * Util to wrap AssetLoader in a promise and load all files.
     * @name AssetLoader.loadAllAssets
     * @memberof AssetLoader
     *
     * @function
     * @param {Function} callback
     * @returns {Promise}
     */
    AssetLoader.loadAllAssets = function(callback) {
        let promise = Promise.create();
        if (!callback) callback = promise.resolve;

        promise.loader = new AssetLoader(Assets.list(), () => {
            if (callback) callback();
            if (promise.loader && promise.loader.destroy) promise.loader = promise.loader.destroy();
        });

        return promise;
    };

    /**
     * Util to wrap AssetLoader in a promise and load a list of files.
     * @name AssetLoader.loadAssets
     * @memberof AssetLoader
     *
     * @function
     * @param {Array} list
     * @param {Function} callback
     * @returns {Promise}
     */
    AssetLoader.loadAssets = function(list, callback) {
        let promise = Promise.create();
        if (!callback) callback = promise.resolve;

        promise.loader = new AssetLoader(list, () => {
            if (callback) callback();
            if (promise.loader && promise.loader.destroy) promise.loader = promise.loader.destroy();
        });

        return promise;
    };

    /**
     * Wait for global variable to be available
     * @name AssetLoader.waitForLib
     * @memberof AssetLoader
     *
     * @function
     * @param {String} name
     * @param {Function} [callback]
     * @returns {Promise}
     */
    AssetLoader.waitForLib = function(name, callback) {
        let promise = Promise.create();
        if (!callback) callback = promise.resolve;

        Render.start(check);
        function check() {
            if (window[name]) {
                Render.stop(check);
                callback && callback();
            }
        }

        return promise;
    };

    AssetLoader.waitForModules = function() {
        return AssetLoader.waitForLib(window._BUILT_ ? '_MODULES_' : 'zUtils3D');
    }
});

!function(e,t){"object"==typeof exports&&"undefined"!=typeof module?t(exports):"function"==typeof define&&define.amd?define(["exports"],t):t((e=e||self).goober={})}(this,function(e){let t={data:""},n=e=>"undefined"!=typeof window?((e?e.querySelector("#_goober"):window._goober)||Object.assign((e||document.head).appendChild(document.createElement("style")),{innerHTML:" ",id:"_goober"})).firstChild:e||t,o=/(?:([A-Z0-9-%@]+) *:? *([^{;]+?);|([^;}{]*?) *{)|(})/gi,r=/\/\*[^]*?\*\/|\s\s+|\n/g,l=(e,t)=>{let n,o="",r="",a="";for(let s in e){let c=e[s];"object"==typeof c?(n=t?t.replace(/([^,])+/g,e=>s.replace(/([^,])+/g,t=>/&/.test(t)?t.replace(/&/g,e):e?e+" "+t:t)):s,r+="@"==s[0]?"f"==s[1]?l(c,s):s+"{"+l(c,"k"==s[1]?"":t)+"}":l(c,n)):"@"==s[0]&&"i"==s[1]?o=s+" "+c+";":(s=s.replace(/[A-Z]/g,"-$&").toLowerCase(),a+=l.p?l.p(s,c):s+":"+c+";")}return a[0]?(n=t?t+"{"+a+"}":a,o+n+r):o+r},a={},s=e=>{let t="";for(let n in e)t+=n+("object"==typeof e[n]?s(e[n]):e[n]);return t},c=(e,t,n,c,i)=>{let f="object"==typeof e?s(e):e,p=a[f]||(a[f]=(e=>{let t=0,n=11;for(;t<e.length;)n=101*n+e.charCodeAt(t++)>>>0;return"go"+n})(f));if(!a[p]){let t="object"==typeof e?e:(e=>{let t,n=[{}];for(;t=o.exec(e.replace(r,""));)t[4]&&n.shift(),t[3]?n.unshift(n[0][t[3]]=n[0][t[3]]||{}):t[4]||(n[0][t[1]]=t[2]);return n[0]})(e);a[p]=l(i?{["@keyframes "+p]:t}:t,n?"":"."+p)}return((e,t,n)=>{-1==t.data.indexOf(e)&&(t.data=n?e+t.data:t.data+e)})(a[p],t,c),p},i=(e,t,n)=>e.reduce((e,o,r)=>{let a=t[r];if(a&&a.call){let e=a(n),t=e&&e.props&&e.props.className||/^go/.test(e)&&e;a=t?"."+t:e&&"object"==typeof e?e.props?"":l(e,""):e}return e+o+(null==a?"":a)},"");function f(e){let t=this||{},o=e.call?e(t.p):e;return c(o.unshift?o.raw?i(o,[].slice.call(arguments,1),t.p):o.reduce((e,n)=>n?Object.assign(e,n.call?n(t.p):n):e,{}):o,n(t.target),t.g,t.o,t.k)}let p,d,u,g=f.bind({g:1}),b=f.bind({k:1});e.css=f,e.extractCss=e=>{let t=n(e),o=t.data;return t.data="",o},e.glob=g,e.keyframes=b,e.setup=function(e,t,n,o){l.p=t,p=e,d=n,u=o},e.styled=function(e,t){let n=this||{};return function(){let o=arguments;function r(l,a){let s=Object.assign({},l),c=s.className||r.className;n.p=Object.assign({theme:d&&d()},s),n.o=/ *go\d+/.test(c),s.className=f.apply(n,o)+(c?" "+c:""),t&&(s.ref=a);let i=s.as||e;return u&&i[0]&&u(s),p(i,s)}return t?t(r):r}}});
!function(i,n){"object"==typeof exports&&"undefined"!=typeof module?n(exports):"function"==typeof define&&define.amd?define(["exports"],n):n((i=i||self).gooberPrefixer={})}(this,function(i){var n=new Map([["align-self","-ms-grid-row-align"],["color-adjust","-webkit-print-color-adjust"],["column-gap","grid-column-gap"],["gap","grid-gap"],["grid-template-columns","-ms-grid-columns"],["grid-template-rows","-ms-grid-rows"],["justify-self","-ms-grid-column-align"],["margin-inline-end","-webkit-margin-end"],["margin-inline-start","-webkit-margin-start"],["overflow-wrap","word-wrap"],["padding-inline-end","-webkit-padding-end"],["padding-inline-start","-webkit-padding-start"],["row-gap","grid-row-gap"],["scroll-margin-bottom","scroll-snap-margin-bottom"],["scroll-margin-left","scroll-snap-margin-left"],["scroll-margin-right","scroll-snap-margin-right"],["scroll-margin-top","scroll-snap-margin-top"],["scroll-margin","scroll-snap-margin"],["text-combine-upright","-ms-text-combine-horizontal"]]);i.prefix=function(i,r){let t="";const e=n.get(i);e&&(t+=`${e}:${r};`);const o=function(i){var n=/^(?:(text-(?:decoration$|e|or|si)|back(?:ground-cl|d|f)|box-d|(?:mask(?:$|-[ispro]|-cl)))|(tab-|column(?!-s)|text-align-l)|(ap)|(u|hy))/i.exec(i);return n?n[1]?1:n[2]?2:n[3]?3:5:0}(i);1&o&&(t+=`-webkit-${i}:${r};`),2&o&&(t+=`-moz-${i}:${r};`),4&o&&(t+=`-ms-${i}:${r};`);const a=function(i,n){var r=/^(?:(pos)|(background-i)|((?:max-|min-)?(?:block-s|inl|he|widt))|(dis))/i.exec(i);return r?r[1]?/^sti/i.test(n)?1:0:r[2]?/^image-/i.test(n)?1:0:r[3]?"-"===n[3]?2:0:/^(inline-)?grid$/i.test(n)?4:0:0}(i,r);return 1&a?t+=`${i}:-webkit-${r};`:2&a?t+=`${i}:-moz-${r};`:4&a&&(t+=`${i}:-ms-${r};`),t+=`${i}:${r};`,t}});
!function(e,o){"object"==typeof exports&&"undefined"!=typeof module?o(exports,require("goober")):"function"==typeof define&&define.amd?define(["exports","goober"],o):o((e=e||self).gooberGlobal={},e.goober)}(this,function(e,o){let n=o.css.bind({g:1});e.createGlobalStyles=function(){const e=o.styled.call({g:1},"div").apply(null,arguments);return function(o){return e(o),null}},e.glob=n});

/**
 * @name Stage
 */

Hydra.ready(function() {
    //*** Set global shortcut to window, document, and body.

    /**
     * A HydraObject wrapper of the window object
     * @name window.__window
     * @memberof Stage
     */
    window.__window = $(window);

    /**
     * A HydraObject wrapper of the window object
     * @name window.__document
     * @memberof Stage
     */
    window.__document = $(document);

    /**
     * A HydraObject wrapper of the document.body element
     * @name window.__body
     * @memberof Stage
     */
    window.__body = $(document.getElementsByTagName('body')[0]);

    /**
     * A HydraObject wrapper of the main #Stage div element. Size of application to be retrieved from this object via Stage.width and Stage.height.
     * @name window.Stage
     * @memberof Stage
     */
    window.Stage = !!window.Stage && !!window.Stage.style ? $(window.Stage) : __body.create('#Stage');

    Stage.size('100%');
    Stage.__useFragment = true;
    Stage.width = window.innerWidth || document.body.clientWidth || document.documentElement.offsetWidth;
    Stage.height = window.innerHeight || document.body.clientHeight || document.documentElement.offsetHeight;
});
/**
 * @name HydraCSS
 */

Class(function HydraCSS() {
    var _this = this;
    var _tag, _obj, _style, _needsUpdate;

    //*** Constructor
    Hydra.ready(function() {
        _obj = {};
        _style = '';
        _tag = document.createElement('style');
        _tag.type = 'text/css';
        document.getElementsByTagName('head')[0].appendChild(_tag);
    });

    function objToCSS(key) {
        var match = key.match(/[A-Z]/);
        var camelIndex = match ? match.index : null;
        if (camelIndex) {
            var start = key.slice(0, camelIndex);
            var end = key.slice(camelIndex);
            key = start+'-'+end.toLowerCase();
        }
        return key;
    }

    function cssToObj(key) {
        var match = key.match(/\-/);
        var camelIndex = match ? match.index : null;
        if (camelIndex) {
            var start = key.slice(0, camelIndex);
            var end = key.slice(camelIndex).slice(1);
            var letter = end.charAt(0);
            end = end.slice(1);
            end = letter.toUpperCase() + end;
            key = start + end;
        }
        return key;
    }

    function render() {
        var s = '';
        for ( let selector in _obj ) {
            let obj = _obj[selector];
            s += `${selector} {`;
            for (var key in obj) {
                var prop = objToCSS(key);
                var val = obj[key];
                if (typeof val !== 'string' && key != 'opacity') val += 'px';
                s += prop+':'+val+'!important;';
            }
            s += '}';
        }

        _this._write(s);
    }

    function setHTML() {
        _tag.innerHTML = _style;
        _needsUpdate = false;
    }

    this._read = function() {
        return _style;
    };

    this._write = function(css) {
        _style = css;
        if (!_needsUpdate) {
            _needsUpdate = true;
            defer(setHTML);
        }
    };

    /**
     * @name HydraCSS.style
     * @memberof HydraCSS
     *
     * @function
     * @param {String} selector
     * @param {Object} obj
     */
    this.style = function(selector, obj = {}) {
        if ( !_obj[selector]) _obj[selector] = {};
        Object.assign( _obj[selector], obj );
        render();
    };

    /**
     * @name HydraCSS.get
     * @memberof HydraCSS
     *
     * @function
     * @param {String} selector
     * @param {String} prop
     * @returns {*}
     */
    this.get = function(selector, prop) {
        if ( !_obj[selector]) return prop ? null : {};
        let obj = Object.assign({}, _obj[selector]);
        return prop ? obj[prop] : obj;
    };

    /**
     * @name HydraCSS.textSize
     * @memberof HydraCSS
     *
     * @function
     * @param {HydraObject} $obj
     * @returns {Object} Object with width and height properties
     */
    this.textSize = function($obj) {
        var $clone = $obj.clone();
        $clone.css({position: 'relative', cssFloat: 'left', styleFloat: 'left', marginTop: -99999, width: '', height: ''});
        __body.addChild($clone);

        var width = $clone.div.offsetWidth;
        var height = $clone.div.offsetHeight;

        $clone.remove();
        return {width: width, height: height};
    };

    /**
     * @name HydraCSS.prefix
     * @memberof HydraCSS
     *
     * @function
     * @param {String} style
     * @returns {String}
     */
    this.prefix = function(style) {
        return _this.styles.vendor == '' ? style.charAt(0).toLowerCase() + style.slice(1) : _this.styles.vendor + style;
    };

    this._toCSS = objToCSS;

}, 'Static');

/**
 * @name HydraObject
 *
 * @constructor
 */

Class(function HydraObject(_selector, _type, _exists, _useFragment) {

	this._children = new LinkedList();
	this._onDestroy;
	this.__useFragment = _useFragment;
	this._initSelector(_selector, _type, _exists);

}, () => {
	var prototype = HydraObject.prototype;
	const svgElements = ['svg', 'path', 'rect', 'circle', 'filter', 'clippath', 'clipPath', 'ellipse', 'image', 'mask', 'polygon', 'g', 'animate', 'line', 'linearGradient', 'marker', 'mpath', 'polyline', 'set', 'stop', 'text'];

	// Constructor function
	prototype._initSelector = function(_selector, _type, _exists) {
		if (_selector && typeof _selector !== 'string') {
			this.div = _selector;
		} else {
			var first = _selector ? _selector.charAt(0) : null;
			var name = _selector ? _selector.slice(1) : null;

			if (first != '.' && first != '#') {
				name = _selector;
				first = '.';
			}

			if (!_exists) {
				this._type = _type || 'div';
				if (svgElements.includes(this._type)) {
					this.div = document.createElementNS('http://www.w3.org/2000/svg', this._type);
					if(this._type === 'svg') {
						this.div.setAttributeNS("http://www.w3.org/2000/xmlns/", "xmlns:xlink", "http://www.w3.org/1999/xlink");
					}
				} else {
					this.div = document.createElement(this._type);
					if (first) {
						if (first == '#') this.div.id = name;
						else this.div.className = name;
					}
				}
			} else {
				if (first != '#') throw 'Hydra Selectors Require #ID';
				this.div = document.getElementById(name);
			}
		}

		this.div.hydraObject = this;
	};

	/**
	 * @name this.add
	 * @memberof HydraObject
	 *
	 * @function
     * @params {HydraObject} child
     * @returns {Self}
     */
	prototype.add = function(child, before = null) {
		var div = this.div;

        var _this = this;
		var doInsertChild = function(childDiv) {
			if (before) {
				if (before.element && before.element instanceof HydraObject) {
					before = before.element.div;
				} else if (before.div) {
					before = before.div;
				} else if (!before.nodeName) {
					before = null;
				}
			}
			if (before && before.parentNode !== _this.div) {
				before = null;
			}
			_this.div.insertBefore(childDiv, before);

		};
		var insertChild = function(childDiv) {
			if (_this.__useFragment) {
				if (!_this._fragment) {
					_this._fragment = document.createDocumentFragment();

					defer(function () {
						if (!_this._fragment || !_this.div) {
							delete _this._fragment;
							return;
						}
						if (Array.prototype.every.call(_this._fragment.childNodes, childDiv => !childDiv._fragmentBefore)) {
							// All children were simply appended, so append the fragment
							_this.div.appendChild(_this._fragment);
						} else {
							while (_this._fragment.childNodes.length) {
								childDiv = _this._fragment.childNodes[0];
								before = childDiv._fragmentBefore;
								delete childDiv._fragmentBefore;
								doInsertChild(childDiv);
							}
						}
						delete _this._fragment;
						_this.onMountedHook?.();
					})
				}
				_this._fragment.appendChild(childDiv);
				childDiv._fragmentBefore = before;
			} else {
				doInsertChild(childDiv);
			}
		};

        if (child.element && child.element instanceof HydraObject) {
			insertChild(child.element.div);
            this._children.push(child.element);
            child.element._parent = this;
            child.element.div.parentNode = this.div;
        } else if (child.div) {
			insertChild(child.div);
			this._children.push(child);
			child._parent = this;
			child.div.parentNode = this.div;
		} else if (child.nodeName) {
			insertChild(child);
			child.parentNode = this.div;
		}

		return this;
	};

    /**
     * @name this.clone
	 * @memberof HydraObject
	 *
	 * @function
     * @returns {HydraObject}
     */
	prototype.clone = function() {
		return $(this.div.cloneNode(true));
	};

    /**
     * @name this.create
	 * @memberof HydraObject
	 *
	 * @function
     * @param {String} name
     * @param {String} [type='div']
     * @returns {HydraObject}
     */
	prototype.create = function(name, type) {
		var $obj = $(name, type);
		this.add($obj);
		return $obj;
	};

    /**
     * @name this.empty
	 * @memberof HydraObject
	 *
	 * @function
     * @returns {Self}
     */
	prototype.empty = function() {
		var child = this._children.start();
		while (child) {
			var next = this._children.next();
			if (child && child.remove) child.remove();
			child = next;
		}

		this.div.innerHTML = '';
		return this;
	};

    /**
     * @name this.parent
	 * @memberof HydraObject
	 *
	 * @function
     * @returns {HydraObject}
     */
	prototype.parent = function() {
		return this._parent;
	};

    /**
     * @name this.children
	 * @memberof HydraObject
	 *
	 * @function
     * @returns {DocumentNode[]}
     */
	prototype.children = function(isHydraChildren = false) {
		let children = this.div.children ? this.div.children : this.div.childNodes;

		if (isHydraChildren) {
			children = [];

			var child = this._children.start();

			while (child) {
				if (child) {
					children.push(child);
					child = this._children.next();
				}
			}
		}

		return children;
	};

    /**
     * @name this.removeChild
	 * @memberof HydraObject
	 *
	 * @function
     * @param {HydraObject} object
     * @param {Boolean} [keep]
     * @returns {HydraObject}
     */
	prototype.removeChild = function(object, keep) {
		try {object.div.parentNode.removeChild(object.div)} catch(e) {};
		if (!keep) this._children.remove(object);
	};

    /**
	 * Removes self from parent
	 * @memberof HydraObject
	 *
	 * @function
     * @name this.remove
     */
	prototype.remove = function(param) {
		if (param) console.warn('HydraObject.remove removes ITSELF from its parent. use removeChild instead');

		if (this._onDestroy) this._onDestroy.forEach(cb => cb());
		this.removed = true;

		var parent = this._parent;
		if (!!(parent && !parent.removed && parent.removeChild)) parent.removeChild(this, true);

		var child = this._children.start();
		while (child) {
			var next = this._children.next(); // won't be able to do this after calling child.remove() - child.__next will be null
			if (child && child.remove) child.remove();
			child = next;
		}
		this._children.destroy();

		this.div.hydraObject = null;
		Utils.nullObject(this);
	};

	prototype.destroy = function() {
		this.remove();
	}

	prototype._bindOnDestroy = function(cb) {
		if (!this._onDestroy) this._onDestroy = [];
		this._onDestroy.push(cb);
	}

	/**
     * @name window.$
	 * @memberof HydraObject
	 *
	 * @function
     * @param {String} selector - dom element class name
     * @param {String} [type='div']
     * @param {Boolean} [exists] - will search document tree if true, else creates new dom element
     * @returns {HydraObject}
     */
	window.$ = function(selector, type, exists) {
		return new HydraObject(selector, type, exists);
	};

    /**
     * @name window.$.fn
	 * @memberof HydraObject
	 *
     * @param {String} name
     * @param {String} [type='div']
     * @returns {HydraObject}
     */
	$.fn = HydraObject.prototype;
});

/**
 * @name Extensions
 */

/*
* TODO: write documentation comments
* */

(function() {

    /**
     * @name $.fn.text
     * @memberof Extensions
     *
     * @function
     * @param {String} text
     * @returns {Self}
     */
    $.fn.text = function(text) {
        if (typeof text !== 'undefined') {
            if (this.__cacheText != text) this.div.textContent = text;
            this.__cacheText = text;
            return this;
        } else {
            return this.div.textContent;
        }
    };

    /**
     * @name $.fn.html
     * @memberof Extensions
     *
     * @function
     * @param {String} text
     * @param {Boolean} [force]
     * @returns {Self}
     */
    $.fn.html = function(text, force) {
        if (text && !text.includes('<') && !force) return this.text(text);

        if (typeof text !== 'undefined') {
            this.div.innerHTML = text;
            return this;
        } else {
            return this.div.innerHTML;
        }
    };

    /**
     * @name $.fn.hide
     * @memberof Extensions
     *
     * @function
     * @returns {Self}
     */
    $.fn.hide = function() {
        this.div.style.display = 'none';
        return this;
    };

    /**
     * @name $.fn.show
     * @memberof Extensions
     *
     * @function
     * @returns {Self}
     */
    $.fn.show = function() {
        this.div.style.display = '';
        return this;
    };

    /**
     * @name $.fn.visible
     * @memberof Extensions
     *
     * @function
     * @returns {Self}
     */
    $.fn.visible = function() {
        this.div.style.visibility = 'visible';
        return this;
    };

    /**
     * @name $.fn.invisible
     * @memberof Extensions
     *
     * @function
     * @returns {Self}
     */
    $.fn.invisible = function() {
        this.div.style.visibility = 'hidden';
        return this;
    };

    /**
     * @name $.fn.setZ
     * @memberof Extensions
     *
     * @function
     * @param {Integer} z
     * @returns {Self}
     */
    $.fn.setZ = function(z) {
        this.div.style.zIndex = z;
        return this;
    };

    /**
     * @name $.fn.clearAlpha
     * @memberof Extensions
     *
     * @function
     * @returns {Self}
     */
    $.fn.clearAlpha = function() {
        this.div.style.opacity = '';
        return this;
    };

    /**
     * @name $.fn.size
     * @memberof Extensions
     *
     * @function
     * @param {Number|String} w
     * @param {Number|String} h
     * @param {Boolean} [noScale] - Set true to prevent bacground size being set
     * @returns {Self}
     */
    $.fn.size = function(w, h, noScale) {
        if (typeof w === 'string') {
            if (typeof h === 'undefined') h = '100%';
            else if (typeof h !== 'string') h = h+'px';
            this.div.style.width = w;
            this.div.style.height = h;
        } else {
            this.div.style.width = w+'px';
            this.div.style.height = h+'px';
            if (!noScale) this.div.style.backgroundSize = w+'px '+h+'px';
        }

        this.width = w;
        this.height = h;

        return this;
    };

    /**
     * @name $.fn.mouseEnabled
     * @memberof Extensions
     *
     * @function
     * @param {Boolean} bool
     * @returns {Self}
     */
    $.fn.mouseEnabled = function(bool) {
        this.div.style.pointerEvents = bool ? 'auto' : 'none';
        return this;
    };

    /**
     * @name $.fn.fontStyle
     * @memberof Extensions
     *
     * @function
     * @param {String} [family]
     * @param {String} [size]
     * @param {String} [color]
     * @param {String} [style]
     * @returns {Self}
     */
    $.fn.fontStyle = function(family, size, color, style) {
        var font = {};
        if (family) font.fontFamily = family;
        if (size) font.fontSize = size;
        if (color) font.color = color;
        if (style) font.fontStyle = style;
        this.css(font);
        return this;
    };

    /**
     * @name $.fn.font
     * @memberof Extensions
     *
     * @function
     * @param {String} [font]
     * @returns {Self}
     */
    $.fn.font = function(font) {
        this.css('font', font);
        return this;
    }

    /**
     * @name $.fn.bg
     * @memberof Extensions
     *
     * @function
     * @param {String} src
     * @param {Number|String} x
     * @param {Number|String} y
     * @param {Boolean} repeat
     * @returns {Self}
     */
    $.fn.bg = function(src, x, y, repeat) {
        if (!src) return this;

        if (src.includes('.')) src = Assets.getPath(src);

        if (!src.includes('.')) this.div.style.backgroundColor = src;
        else this.div.style.backgroundImage = 'url('+src+')';

        if (typeof x !== 'undefined') {
            x = typeof x == 'number' ? x+'px' : x;
            y = typeof y == 'number' ? y+'px' : y;
            this.div.style.backgroundPosition = x+' '+y;
        }

        if (repeat) {
            this.div.style.backgroundSize = '';
            this.div.style.backgroundRepeat = repeat;
        }

        if (x == 'cover' || x == 'contain') {
            this.div.style.backgroundSize = x;
            this.div.style.backgroundPosition = typeof y != 'undefined' ? y +' ' +repeat : 'center';
        }

        return this;
    };

    /**
     * @name $.fn.center
     * @memberof Extensions
     *
     * @function
     * @param {Boolean} [x]
     * @param {Boolean} [y]
     * @param {Boolean} [noPos]
     * @returns {Self}
     */
    $.fn.center = function(x, y, noPos) {
        var css = {};
        if (typeof x === 'undefined') {
            css.left = '50%';
            css.top = '50%';
            css.marginLeft = -this.width/2;
            css.marginTop = -this.height/2;
        } else {
            if (x) {
                css.left = '50%';
                css.marginLeft = -this.width/2;
            }
            if (y) {
                css.top = '50%';
                css.marginTop = -this.height/2;
            }
        }

        if (noPos) {
            delete css.left;
            delete css.top;
        }

        this.css(css);
        return this;
    };

    /**
     * @name $.fn.max
     * @memberof Extensions
     *
     * @function
     * @param {Number} [width]
     * @param {Number} [height]
     * @returns {Self}
     */
    $.fn.max = function(width, height) {
        let w, h;
        if (typeof width !== 'undefined') {
            w = typeof width == 'number' ? width+'px' : width;
            this.div.style.maxWidth = w;
        }

        if (typeof height !== 'undefined') {
            h = typeof height == 'number' ? height+'px' : height;
            this.div.style.maxHeight = h;
        } else {
            h = w;
            this.div.style.maxHeight = h;
        }

        return this;
    }

    /**
     * @name $.fn.min
     * @memberof Extensions
     *
     * @function
     * @param {Number} [width]
     * @param {Number} [height]
     * @returns {Self}
     */
    $.fn.min = function(width, height) {
        let w, h;
        if (typeof width !== 'undefined') {
            w = typeof width == 'number' ? width+'px' : width;
            this.div.style.minWidth = w;
        }

        if (typeof height !== 'undefined') {
            h = typeof height == 'number' ? height+'px' : height;
            this.div.style.minHeight = h;
        } else {
            h = w;
            this.div.style.minHeight = h;
        }

        return this;
    }

    /**
     * @name $.fn.flex
     * @memberof Extensions
     *
     * @function
     * @param {Boolean} [inline]
     * @returns {Self}
     */
      $.fn.flex = function(inline) {
        // if parent is not flex, set a default flex on it
        // if (!this.parent) return;
        // let parentEl = this.parent();
        // parentEl.div.style['display'] = 'flex';
        this.div.style.display = inline ? 'inline-flex' : 'flex';
        this.div.style.justifyContent = 'center';
        this.div.style.alignItems = 'center';

        this.div.classList.add('relative-children');

        return this;
    };

    /**
     * @name $.fn.order
     * @memberof Extensions
     *
     * @function
     * @param {Object} [options]
     * @returns {Self}
     */
    $.fn.order = function(opts={}) {
        let s = this.div.style;

        if (opts.flexWrap === 'none') opts.flexWrap = 'nowrap';

        if (opts.direction) s.flexDirection = opts.direction;
        if (opts.wrap) s.flexWrap = opts.wrap;
        if (opts.order) s.order = opts.order;

        return this;
    }

    /**
     * @name $.fn.align
     * @memberof Extensions
     *
     * @function
     * @param {Object} [options]
     * @returns {Self}
     */
    $.fn.align = function(opts={}) {
        let s = this.div.style;

        function flex(str, contentMode = false) {
            if (str === 'start') return 'flex-start';
            if (str === 'end') return 'flex-end';
            if (str === 'between') return contentMode ? 'space-between' : 'flex-between';
            if (str === 'around') return contentMode ? 'space-around' : 'flex-around';
            if (str === 'none') return 'nowrap';
            return str;
        }

        if (opts.justify) s.justifyContent = flex(opts.justify);
        if (opts.items) s.alignItems = flex(opts.items);
        if (opts.self) s.alignSelf = flex(opts.self);
        if (opts.content) s.alignContent = flex(opts.content, true);

        return this;
    }

    /**
     * @name $.fn.flexibility
     * @memberof Extensions
     *
     * @function
     * @param {Object} [options]
     * @returns {Self}
     */
    $.fn.flexibility = function(opts={}) {
        let s = this.div.style;

        if (opts.grow !== 'undefined') s.flexGrow = opts.grow;
        if (opts.shrink !== 'undefined') s.flexGrow = opts.shrink;

        if (typeof opts.basis !== 'undefined') {
            s.flexBasis = typeof opts.basis == 'number' ? opts.basis+'px' : opts.basis;
        }

        return this;
    }

    /**
     * @name $.fn.mask
     * @memberof Extensions
     *
     * @function
     * @param {String} arg
     * @returns {Self}
     */
    $.fn.mask = function(arg) {
        let maskPrefix = HydraCSS.styles.vendor === 'Moz' ? 'mask' : HydraCSS.prefix('Mask');
        this.div.style[maskPrefix] = (arg.includes('.') ? 'url('+arg+')' : arg) + ' no-repeat';
        this.div.style[maskPrefix+'Size'] = 'contain';
        return this;
    };

    /**
     * @name $.fn.blendMode
     * @memberof Extensions
     *
     * @function
     * @param {String} mode
     * @param {Boolean} [bg]
     * @returns {Self}
     */
    $.fn.blendMode = function(mode, bg) {
        if (bg) {
            this.div.style['background-blend-mode'] = mode;
        } else {
            this.div.style['mix-blend-mode'] = mode;
        }

        return this;
    };

    /**
     * @name $.fn.css
     * @memberof Extensions
     *
     * @function
     * @param {Object|String} obj
     * @param {*} [value]
     * @returns {Self}
     */
    $.fn.css = function(obj, value) {
        if (typeof value == 'boolean') {
            value = null;
        }

        if (typeof obj !== 'object') {
            if (!value) {
                var style = this.div.style[obj];
                if (typeof style !== 'number') {
                    if (!style) return false;
                    if (style.includes('px')) style = Number(style.slice(0, -2));
                    if (obj == 'opacity') style = !isNaN(Number(this.div.style.opacity)) ? Number(this.div.style.opacity) : 1;
                }
                if (!style) style = 0;
                return style;
            } else {
                this.div.style[obj] = value;
                return this;
            }
        }

        TweenManager._clearCSSTween(this);

        for (var type in obj) {
            var val = obj[type];
            if (!(typeof val === 'string' || typeof val === 'number')) continue;
            if (typeof val !== 'string' && type != 'opacity' && type != 'zIndex' && type != 'lineHeight') val += 'px';
            if (type == 'position' && val == 'sticky' && Device.system.browser == 'safari') val = '-webkit-sticky';
            this.div.style[type] = val;
        }

        return this;
    };

    /**
     * @name $.fn.transform
     * @memberof Extensions
     *
     * @function
     * @param {Object} props
     * @returns {Self}
     */
    $.fn.transform = function(props) {
        if (Hydra.LOCAL && props && !this.__warningShown && !props._mathTween) {
            // Under 20ms we assume it's a loop
            if (this.__lastTransform && (performance.now() - this.__lastTransform) < 20) {
                this.__warningCount = ++this.__warningCount || 1;
                props.__warningCount2 = ++props.__warningCount2 || 1;

                // If more then 10 warnings, show in console.
                if (this.__warningCount > 10 && props.__warningCount2 !== this.__warningCount) {
                    console.warn('Are you using .transform() in a loop? Avoid creating a new object {} every frame. Ex. assign .x = 1; and .transform();');
                    console.log(this);
                    this.__warningShown = true;
                }
            }

            this.__lastTransform = performance.now();
        }

        TweenManager._clearCSSTween(this);

        if (Device.tween.css2d) {
            if (!props) {
                props = this;
            } else {
                for (var key in props) {
                    if (typeof props[key] === 'number' || typeof props[key] === 'string') this[key] = props[key];
                }
            }

            var transformString =TweenManager._parseTransform(props);

            if (this.__transformCache != transformString) {
                this.div.style[HydraCSS.styles.vendorTransform] = transformString;
                this.__transformCache = transformString;
            }
        }

        return this;
    };

    /**
     * @name $.fn.willChange
     * @memberof Extensions
     *
     * @function
     * @param {Boolean} [props]
     */
    $.fn.willChange = function(props) {
        if (typeof props === 'boolean') {
            if (props === true) this._willChangeLock = true;
            else this._willChangeLock = false;
        } else {
            if (this._willChangeLock) return;
        }

        var string = typeof props === 'string';
        if ((!this._willChange || string) && typeof props !== 'null') {
            this._willChange = true;
            this.div.style['will-change'] = string ? props : HydraCSS.transformProperty+', opacity';
        } else {
            this._willChange = false;
            this.div.style['will-change'] = '';
        }
    };

    /**
     * @name $.fn.backfaceVisibility
     * @memberof Extensions
     *
     * @function
     * @param {Boolean} visible
     */
    $.fn.backfaceVisibility = function(visible) {
        if (visible) this.div.style[HydraCSS.prefix('BackfaceVisibility')] = 'visible';
        else this.div.style[HydraCSS.prefix('BackfaceVisibility')] = 'hidden';
    };

    /**
     * @name $.fn.enable3D
     * @memberof Extensions
     *
     * @function
     * @param {Number} perspective
     * @param {Number|String} x
     * @param {Number|String} y
     * @returns {Self}
     */
    $.fn.enable3D = function(perspective, x, y) {
        if (!Device.tween.css3d) return this;
        this.div.style[HydraCSS.prefix('TransformStyle')] = 'preserve-3d';
        if (perspective) this.div.style[HydraCSS.prefix('Perspective')] = perspective + 'px';
        if (typeof x !== 'undefined') {
            x = typeof x === 'number' ? x + 'px' : x;
            y = typeof y === 'number' ? y + 'px' : y;
            this.div.style[HydraCSS.prefix('PerspectiveOrigin')] = x+' '+y;
        }
        return this;
    };

    /**
     * @name $.fn.disable3D
     * @memberof Extensions
     *
     * @function
     * @returns {Self}
     */
    $.fn.disable3D = function() {
        this.div.style[HydraCSS.prefix('TransformStyle')] = '';
        this.div.style[HydraCSS.prefix('Perspective')] = '';
        return this;
    };

    /**
     * @name $.fn.transformPoint
     * @memberof Extensions
     *
     * @function
     * @param {Number|String} x
     * @param {Number|String} y
     * @param {Number|String} z
     * @returns {Self}
     */
    $.fn.transformPoint = function(x, y, z) {
        var origin = '';
        if (typeof x !== 'undefined') origin += (typeof x === 'number' ? x+'px ' : x+' ');
        if (typeof y !== 'undefined') origin += (typeof y === 'number' ? y+'px ' : y+' ');
        if (typeof z !== 'undefined') origin += (typeof z === 'number' ? z+'px' : z);
        this.div.style[HydraCSS.prefix('TransformOrigin')] = origin;
        return this;
    };

    /**
     * @name $.fn.tween
     * @memberof Extensions
     *
     * @function
     * @param {Object} props
     * @param {Number} time
     * @param {String} ease
     * @param {Number} [delay]
     * @param {Function} [callback]
     * @param {Boolean} [manual]
     * @returns {*}
     */
    $.fn.tween = function(props, time, ease, delay, callback, manual) {
        if (typeof delay === 'boolean') {
            manual = delay;
            delay = 0;
            callback = null;
        } else if (typeof delay === 'function') {
            callback = delay;
            delay = 0;
        }
        if (typeof callback === 'boolean') {
            manual = callback;
            callback = null;
        }
        if (!delay) delay = 0;

        var usePromise = null;
        if (callback && callback instanceof Promise) {
            usePromise = callback;
            callback = callback.resolve;
        }

        var tween = TweenManager._detectTween(this, props, time, ease, delay, callback, manual);
        return usePromise || tween;
    };

    /**
     * @name $.fn.clearTransform
     * @memberof Extensions
     *
     * @function
     * @returns {Self}
     */
    $.fn.clearTransform = function() {
        if (typeof this.x === 'number') this.x = 0;
        if (typeof this.y === 'number') this.y = 0;
        if (typeof this.z === 'number') this.z = 0;
        if (typeof this.scale === 'number') this.scale = 1;
        if (typeof this.scaleX === 'number')this.scaleX = 1;
        if (typeof this.scaleY === 'number') this.scaleY = 1;
        if (typeof this.rotation === 'number') this.rotation = 0;
        if (typeof this.rotationX === 'number') this.rotationX = 0;
        if (typeof this.rotationY === 'number') this.rotationY = 0;
        if (typeof this.rotationZ === 'number') this.rotationZ = 0;
        if (typeof this.skewX === 'number') this.skewX = 0;
        if (typeof this.skewY === 'number') this.skewY = 0;
        this.div.style[HydraCSS.styles.vendorTransform] = '';
        this.__transformCache = '';
        return this;
    };

    /**
     * @name $.fn.clearTween
     * @memberof Extensions
     *
     * @function
     * @returns {Self}
     */
    $.fn.clearTween = function() {
        if (this._cssTween) this._cssTween.stop();
        if (this._mathTween) this._mathTween.stop();
        return this;
    };

    $.fn.stopTween = function() {
        console.warn('.stopTween deprecated. use .clearTween instead');
        return this.clearTween();
    };

    /**
     * @name $.fn.keypress
     * @memberof Extensions
     *
     * @function
     * @param {Function} callback
     */
    $.fn.keypress = function(callback) {
        this.div.onkeypress = function(e) {
            e = e || window.event;
            e.code = e.keyCode ? e.keyCode : e.charCode;
            if (callback) callback(e);
        };
    };

    /**
     * @name $.fn.keydown
     * @memberof Extensions
     *
     * @function
     * @param {Function} callback
     */
    $.fn.keydown = function(callback) {
        this.div.onkeydown = function(e) {
            e = e || window.event;
            e.code = e.keyCode;
            if (callback) callback(e);
        };
    };

    /**
     * @name $.fn.keyup
     * @memberof Extensions
     *
     * @function
     * @param {Function} callback
     */
    $.fn.keyup = function(callback) {
        this.div.onkeyup = function(e) {
            e = e || window.event;
            e.code = e.keyCode;
            if (callback) callback(e);
        }
    };

    /**
     * @name $.fn.attr
     * @memberof Extensions
     *
     * @function
     * @param {String} attr
     * @param {String|Boolean} value
     * @returns {Self}
     */
    $.fn.attr = function(attr, value) {
        if (typeof attr !== 'string') return this;
        if (value === undefined) return this.div.getAttribute(attr);

        if (value === false || value === null) this.div.removeAttribute(attr);
        else this.div.setAttribute(attr, value);

        return this;
    };

    /**
     * @name $.fn.val
     * @memberof Extensions
     *
     * @function
     * @param {String} [value] - sets if value exists, else returns value
     * @returns {Number|Self}
     */
    $.fn.val = function(value) {
        if (typeof value === 'undefined') {
            return this.div.value;
        } else {
            this.div.value = value;
        }

        return this;
    };

    /**
     * @name $.fn.change
     * @memberof Extensions
     *
     * @function
     * @param {Function} callback
     */
    $.fn.change = $.fn.onChange = function(callback) {
        var _this = this;
        this.div.onchange = function() {
            callback({object: _this, value: _this.div.value || ''});
        };
    };

    /**
     * @name $.fn.svgSymbol
     * @memberof Extensions
     *
     * @function
     * @param {String} id
     * @param {String} width
     * @param {String} height
     */
    $.fn.svgSymbol = function(id, width, height) {
        var config = SVG.getSymbolConfig(id);
        var svgHTML = '<svg viewBox="0 0 '+config.width+' '+config.height+'" width="'+width+'" height="'+height+'">'+
            '<use xlink:href="#'+config.id+'" x="0" y="0" />'+
            '</svg>';
        this.html(svgHTML, true);
    };

    /**
     * @name $.fn.svg
     * @memberof Extensions
     *
     * @function
     * @param {String} url
     */
    $.fn.svg = async function(url) {
        let promise = Promise.create();
        fetch(url).then(async res => {
            let svgHTML = await res.text();
            this.html(svgHTML, true);
            promise.resolve();
        });

        return promise;
    };

    /**
     * @name $.fn.overflowScroll
     * @memberof Extensions
     *
     * @function
     * @param {Object} [dir] object with x and y boolean properties
     */
    $.fn.overflowScroll = function(dir) {
        var x = !!dir.x;
        var y = !!dir.y;

        var overflow = {};
        if ((!x && !y) || (x && y)) overflow.overflow = 'auto';
        if (!x && y) {
            overflow.overflowY = 'auto';
            overflow.overflowX = 'hidden';
        }
        if (x && !y) {
            overflow.overflowX = 'auto';
            overflow.overflowY = 'hidden';
        }

        if (Device.mobile) {
            overflow['-webkit-overflow-scrolling'] = 'touch';
            Mobile._addOverflowScroll(this);
        }

        return this.css(overflow);
    };

    /**
     * @name $.fn.removeOverflowScroll
     * @memberof Extensions
     *
     * @function
     */
    $.fn.removeOverflowScroll = function() {
        this.css({overflow: 'hidden', overflowX: '', overflowY: '', '-webkit-overflow-scrolling': ''});
        if (Device.mobile) Mobile._removeOverflowScroll(this);
        return this;
    };

    /**
     * @name $.fn.accessible
     * @memberof Extensions
     *
     * @function
     * @param {String} [type]
     * @param {Number} [tabIndex]
     * @returns {Self}
     */
    $.fn.accessible = function(type = 'label', tabIndex = -1) {
        if (tabIndex > -1) this.attr('tabindex', tabIndex);
        switch (type) {
            case 'label':
                this.attr('aria-label', this.div.textContent);
                break;

            case 'hidden':
                this.attr('aria-hidden', true);
                break;
        }
        return this;
    };

    /**
     * @name $.fn.tabIndex
     * @memberof Extensions
     *
     * @function
     * @param {Number} [tabIndex]
     * @returns {Self}
     */
    $.fn.tabIndex = function(tabIndex) {
        this.attr('tabindex', tabIndex);
        return this;
    };

    /**
     * @name $.fn.createObserver
     * @memberof Extensions
     *
     * @function
     * @param {Callback} [options]
     * @returns {Self}
     */
    $.fn.createObserver = function(callback, {isViewport = false, ...options} = {}) {
        const handle = array => {
            array.forEach(entry => {
                entry.object = entry.target.hydraObject;
            });
            callback(array);
        };
        if (isViewport) options.root = this.div;
        const observer = this._observer = new IntersectionObserver(handle, options);
        this._bindOnDestroy(() => {
            observer.disconnect();
        });
        return this;
    }

    /**
     * @name $.fn.observe
     * @memberof Extensions
     *
     * @function
     * @param {HydraObject}
     * @returns {Self}
     */
    $.fn.observe = function(obj = this) {
        this._observer?.observe(obj.div);
        return this;
    }

    /**
     * @name $.fn.unobserve
     * @memberof Extensions
     *
     * @function
     * @param {HydraObject}
     * @returns {Self}
     */
    $.fn.unobserve = function(obj = this) {
        this._observer?.unobserve(obj.div);
        return this;
    }

    /**
     * @name $.fn.cursor
     * @memberof Extensions
     *
     * @function
     * @param {String} [type]
     * @param {Object} [lock]
     * @returns {Self}
     */
    $.fn.cursor = function(cursor, lock) {
        if (Device.mobile) return;

        if (lock) {
            if (!this.cursorLock) this.cursorLock = new Map();

            if (cursor == 'auto') {
                this.cursorLock.delete(lock);
            } else {
                this.cursorLock.set(lock, cursor);
            }
        }

        if (this.cursorLock && cursor == 'auto') {
            this.cursorLock.forEach(v => {
                cursor = v; //todo maybe add priority if necessary
            });
        }

        this.css('cursor', cursor);
        return this;
    };

    /**
     * @name $.fn.classList
     * @memberof Extensions
     *
     * @function
     * @returns {classList}
     */
    $.fn.classList = function() {
        return this.div.classList;
    }

    /**
     * @name $.fn.goob
     * @memberof Extensions
     *
     * @function
     * @returns {Self}
     */
    $.fn.goob = function(styles) {
        let _styles;
        if (typeof styles === 'string') _styles = goober.css`${styles}`;
        else _styles = goober.css(styles);
        this.goobClass = _styles;
        this.div.classList.add(_styles);
        return this;
    }

    $.fn.href = function(str) {
        this.attr('href', str);
        return this;
    }

    $.fn.target = function(str) {
        this.attr('target', str);
        return this;
    }

    $.fn.ariaLabel = function(str) {
        this.attr('aria-label', str);
        return this;
    }

    $.fn.alt = function(str) {
        this.attr('alt', str);
        return this;
    }

    $.fn.src = function(str) {
        this.attr('src', str);
        return this;
    }

    $.fn.display = function(bool) {
        if (bool) $this.show();
        else $this.hide();
    }
})();

/**
 * @name Input
 */

/*
* TODO: rewrite using bind instead of addEventListener directly
* */

(function() {
    var windowsPointer = !!window.MSGesture;

    var translateEvent = function(evt) {
        if (windowsPointer) {
            switch (evt) {
                case 'touchstart': return 'pointerdown'; break;
                case 'touchmove': return 'MSGestureChange'; break;
                case 'touchend': return 'pointerup'; break;
            }
        }
        return evt;
    };

    var convertTouchEvent = function(e) {
        var touchEvent = {};
        touchEvent.x = 0;
        touchEvent.y = 0;

        if (e.windowsPointer) return e;

        if (!e) return touchEvent;
        if (e.touches || e.changedTouches) {
            if (e.touches.length) {
                touchEvent.x = e.touches[0].clientX;
                touchEvent.y = e.touches[0].clientY;
            } else {
                touchEvent.x = e.changedTouches[0].clientX;
                touchEvent.y = e.changedTouches[0].clientY;
            }
        } else {
            touchEvent.x = e.clientX;
            touchEvent.y = e.clientY;
        }

        // If mobile forced into other orientation - transform touch coordinates to match
        if (Mobile.ScreenLock && Mobile.ScreenLock.isActive && Mobile.orientationSet && Mobile.orientation !== Mobile.orientationSet) {
            if (window.orientation == 90 || window.orientation === 0) {
                var x = touchEvent.y;
                touchEvent.y = touchEvent.x;
                touchEvent.x = Stage.width - x;
            }

            if (window.orientation == -90 || window.orientation === 180) {
                var y = touchEvent.x;
                touchEvent.x = touchEvent.y;
                touchEvent.y = Stage.height - y;
            }
        }

        return touchEvent;
    };

    /**
     * @name this.click
     * @memberof Input
     *
     * @function
     * @param {Function} callback
     * @returns {Self}
     */
    $.fn.click = function(callback) {
        var _this = this;
        function click(e) {
            if (!_this.div) return false;
            if (Mouse._preventClicks) return false;

            e.object = _this.div.className == 'hit' ? _this.parent() : _this;
            e.action = 'click';

            if (callback) callback(e);

            if (Mouse.autoPreventClicks) Mouse.preventClicks();
        }

        if (Device.mobile) {
            this.div.addEventListener(translateEvent('touchend'), click, { passive: true });
        } else {
            this.div.addEventListener(translateEvent('click'), click, true);
            this.div.style.cursor = 'pointer';
        }

        return this;
    };

    /**
     * @name this.hover
     * @memberof Input
     *
     * @function
     * @param {Function} callback
     * @returns {Self}
     */
    $.fn.hover = function(callback) {
        var _this = this;
        var _over = false;
        var _time;

        function hover(e) {
            if (!_this.div) return false;
            var time = performance.now();
            var original = e.toElement || e.relatedTarget;

            if (_time && (time - _time) < 5) {
                _time = time;
                return false;
            }

            _time = time;

            e.object = _this.div.className == 'hit' ? _this.parent() : _this;

            switch (e.type) {
                case 'mouseout': e.action = 'out'; break;
                case 'mouseleave': e.action = 'out'; break;
                default: e.action = 'over'; break;
            }

            if (_over) {
                if (Mouse._preventClicks) return false;
                if (e.action == 'over') return false;
                if (e.action == 'out') {
                    if (isAChild(_this.div, original)) return false;
                }
                _over = false;
            } else {
                if (e.action == 'out') return false;
                _over = true;
            }

            if (callback) callback(e);
        }

        function isAChild(div, object) {
            var len = div.children.length-1;
            for (var i = len; i > -1; i--) {
                if (object == div.children[i]) return true;
            }

            for (i = len; i > -1; i--) {
                if (isAChild(div.children[i], object)) return true;
            }
        }

        this.div.addEventListener(translateEvent('mouseover'), hover, true);
        this.div.addEventListener(translateEvent('mouseout'), hover, true);

        return this;
    };

    /**
     * @name this.press
     * @memberof Input
     *
     * @function
     * @param {Function} callback
     * @returns {Self}
     */
    $.fn.press = function(callback) {
        var _this = this;

        function press(e) {
            if (!_this.div) return false;
            e.object = _this.div.className == 'hit' ? _this.parent() : _this;

            switch (e.type) {
                case 'mousedown': e.action = 'down'; break;
                default: e.action = 'up'; break;
            }

            if (callback) callback(e);
        }

        this.div.addEventListener(translateEvent('mousedown'), press, true);
        this.div.addEventListener(translateEvent('mouseup'), press, true);

        return this;
    };

    /**
     * @name this.bind
     * @memberof Input
     *
     * @function
     * @param {String} evt
     * @param {Function} callback
     * @returns {Self}
     */
    $.fn.bind = function(evt, callback) {
        this._events = this._events || {};

        if (windowsPointer && this == __window) {
            return Stage.bind(evt, callback);
        }

        if (evt == 'touchstart') {
            if (!Device.mobile) {
                if (Device.touchCapable) this.bind('mousedown', callback);
                else evt = 'mousedown';
            }
        } else if (evt == 'touchmove') {
            if (!Device.mobile) {
                if (Device.touchCapable) this.bind('mousemove', callback);
                else evt = 'mousemove';
            }

            if (windowsPointer && !this.div.msGesture) {
                this.div.msGesture = new MSGesture();
                this.div.msGesture.target = this.div;
            }
        } else if (evt == 'touchend') {
            if (!Device.mobile) {
                if (Device.touchCapable) this.bind('mouseup', callback);
                else evt = 'mouseup';
            }
        }

        this._events['bind_'+evt] = this._events['bind_'+evt] || [];
        var _events = this._events['bind_'+evt];
        var e = {};
        var target = this.div;
        e.callback = callback;
        e.target = this.div;
        _events.push(e);

        function touchEvent(e) {
            if (windowsPointer && target.msGesture && evt == 'touchstart') {
                target.msGesture.addPointer(e.pointerId);
            }

            if (!Device.mobile && evt == 'touchstart') e.preventDefault();

            var touch = convertTouchEvent(e);
            if (windowsPointer) {
                var windowsEvt = e;
                e = {};
                e.preventDefault = () => windowsEvt.preventDefault();
                e.stopPropagation = () => windowsEvt.stopPropagation();
                e.x = Number(windowsEvt.clientX);
                e.y = Number(windowsEvt.clientY);
                e.target = windowsEvt.target;
                e.currentTarget = windowsEvt.currentTarget;
                e.path = [];
                var node = e.target;
                while (node) {
                    e.path.push(node);
                    node = node.parentElement || null;
                }
                e.windowsPointer = true;
            } else {
                e.x = touch.x;
                e.y = touch.y;
            }

            for (var i = 0; i < _events.length; i++) {
                var ev = _events[i];
                if (ev.target == e.currentTarget) {
                    ev.callback(e);
                }
            }
        }

        if (!this._events['fn_'+evt]) {
            this._events['fn_'+evt] = touchEvent;
            this.div.addEventListener(translateEvent(evt), touchEvent, { capture: true, passive: false });
        }
        return this;
    };

    /**
     * @name this.unbind
     * @memberof Input
     *
     * @function
     * @param {String} evt
     * @param {Function} callback
     * @returns {*}
     */
    $.fn.unbind = function(evt, callback) {
        this._events = this._events || {};

        if (windowsPointer && this == __window) {
            return Stage.unbind(evt, callback);
        }

        if (evt == 'touchstart') {
            if (!Device.mobile) {
                if (Device.touchCapable) this.unbind('mousedown', callback);
                else evt = 'mousedown';
            }
        } else if (evt == 'touchmove') {
            if (!Device.mobile) {
                if (Device.touchCapable) this.unbind('mousemove', callback);
                else evt = 'mousemove';
            }
        } else if (evt == 'touchend') {
            if (!Device.mobile) {
                if (Device.touchCapable) this.unbind('mouseup', callback);
                else evt = 'mouseup';
            }
        }

        var _events = this._events['bind_'+evt];
        if (!_events) return this;

        for (var i = 0; i < _events.length; i++) {
            var ev = _events[i];
            if (ev.callback == callback) _events.splice(i, 1);
        }

        if (this._events['fn_'+evt] && !_events.length) {
            this.div.removeEventListener(translateEvent(evt), this._events['fn_'+evt], Device.mobile ? {passive: true} : true);
            this._events['fn_'+evt] = null;
        }

        return this;
    };

    /**
     * @name this.interact
     * @memberof Input
     *
     * All parameters may be omitted and instead specified inside an options
     * object passed as the last parameter.
     *
     * Some additional options may only be passed in the options object:
     *   - `role`: pass 'button' to use the button interaction convention of
     *     firing the clickCallback on spacebar as well as the enter key.
     *
     * @function
     * @param {Function} overCallback
     * @param {Function} clickCallback
     * @param {String} seoLink path for SEO link href, turns hit into anchor tag
     * @param {String} seoText text for achor tag if seoLink is provided
     * @param {String | Number} zIndex specify zIndex or default to 99999 (pass 'auto' for browser default 0)
     * @param {Object} options optional object containing further parameters
     */
    $.fn.interact = function(overCallback, clickCallback, seoLink, seoText, zIndex, options) {
        if (!this.hit) {
            if (typeof arguments[arguments.length - 1] === 'object') {
                options = arguments[arguments.length - 1];
                [overCallback, clickCallback, seoLink, seoText, zIndex] = Array.prototype.slice.call(arguments, 0, -1);
                if (options.overCallback) overCallback = options.overCallback;
                if (options.clickCallback) clickCallback = options.clickCallback;
                if (options.seoLink) seoLink = options.seoLink;
                if (options.seoText) seoText = options.seoText;
                if (options.zIndex) zIndex = options.zIndex;
            }
            if (!options) options = {};
            this.hit = $('.hit', seoLink ? 'a' : undefined);
            this.hit.css({width: '100%', height: '100%', zIndex: zIndex || 99999, top: 0, left: 0, position: 'absolute'});
            this.add(this.hit);
            var _this = this;

            if (seoLink) {
                this.hit.attr('href', seoLink === '#' ? seoLink : Hydra.absolutePath(seoLink));
                this.hit.text(seoText || this.div.textContent);
                this.hit.css({fontSize: 0});
                this.hit.accessible();
                if (typeof overCallback === 'function') {
                    this.hit.div.onfocus = _ => overCallback({action: 'over', object: this});
                    this.hit.div.onblur = _ => overCallback({action: 'out', object: this});
                }
                this.hit.div.onclick = e => {
                    e.preventDefault();
                    e.object = _this;
                    e.action = 'click';
                    clicked(e);
                };
            }
            if (options.role) {
                this.hit.attr('role', options.role);
                if (options.role === 'button') {
                    this.hit.div.onkeydown = e => {
                        switch (e.key) {
                            case ' ':
                            case 'Spacebar':
                                e.preventDefault();
                                e.stopPropagation();
                                e.object = _this;
                                e.action = 'click';
                                clicked(e);
                                break;
                        }
                    }
                }
            }
        }

        let time = Render.TIME;
        function clicked(e) {
            if (clickCallback && Render.TIME - time > 250) clickCallback(e);
            time = Render.TIME;
        }

        if (!Device.mobile) this.hit.hover(overCallback).click(clicked);
        else this.hit.touchClick(overCallback, clicked);
    };

    $.fn.clearInteract = function() {
        if (this.hit) this.hit = this.hit.destroy();
    };

    $.fn.disableInteract = function() {
        if (this.hit) this.hit.css({ pointerEvents: 'none' });
    };

    $.fn.enableInteract = function() {
        if (this.hit) this.hit.css({ pointerEvents: 'auto' });
    };

    /**
     * @name this.touchSwipe
     * @memberof Input
     *
     * @function
     * @param {Function} callback
     * @param {Number} [distance = 75]
     * @returns {Self}
     */
    $.fn.touchSwipe = function(callback, distance) {
        if (!window.addEventListener) return this;

        var _this = this;
        var _distance = distance || 75;
        var _startX, _startY;
        var _moving = false;
        var _move = {};

        if (Device.mobile) {
            this.div.addEventListener(translateEvent('touchstart'), touchStart, {passive: true});
            this.div.addEventListener(translateEvent('touchend'), touchEnd, {passive: true});
            this.div.addEventListener(translateEvent('touchcancel'), touchEnd, {passive: true});
        }

        function touchStart(e) {
            var touch = convertTouchEvent(e);
            if (!_this.div) return false;
            if (e.touches.length == 1) {
                _startX = touch.x;
                _startY = touch.y;
                _moving = true;
                _this.div.addEventListener(translateEvent('touchmove'), touchMove, {passive: true});
            }
        }

        function touchMove(e) {
            if (!_this.div) return false;
            if (_moving) {
                var touch = convertTouchEvent(e);
                var dx = _startX - touch.x;
                var dy = _startY - touch.y;

                _move.direction = null;
                _move.moving = null;
                _move.x = null;
                _move.y = null;
                _move.evt = e;

                if (Math.abs(dx) >= _distance) {
                    touchEnd();
                    if (dx > 0) {
                        _move.direction = 'left';
                    } else {
                        _move.direction = 'right';
                    }
                } else if (Math.abs(dy) >= _distance) {
                    touchEnd();
                    if (dy > 0) {
                        _move.direction = 'up';
                    } else {
                        _move.direction = 'down';
                    }
                } else {
                    _move.moving = true;
                    _move.x = dx;
                    _move.y = dy;
                }

                if (callback) callback(_move, e);
            }
        }

        function touchEnd(e) {
            if (!_this.div) return false;
            _startX = _startY = _moving = false;
            _this.div.removeEventListener(translateEvent('touchmove'), touchMove);
        }

        return this;
    };

    /**
     * @name this.touchClick
     * @memberof Input
     *
     * @function
     * @param {Function} hover
     * @param {Function} click
     * @returns {Self}
     */
    $.fn.touchClick = function(hover, click) {
        if (!window.addEventListener) return this;
        var _this = this;
        var _time, _move;
        var _start = {};
        var _touch = {};

        if (Device.mobile) {
            this.div.addEventListener(translateEvent('touchstart'), touchStart, {passive: true});
            this.div.addEventListener(translateEvent('touchend'), touchEnd, {passive: true});
        }

        function findDistance(p1, p2) {
            var dx = p2.x - p1.x;
            var dy = p2.y - p1.y;
            return Math.sqrt(dx * dx + dy * dy);
        }

        function setTouch(e) {
            var touch = convertTouchEvent(e);
            e.touchX = touch.x;
            e.touchY = touch.y;

            _start.x = e.touchX;
            _start.y = e.touchY;
        }

        function touchStart(e) {
            if (!_this.div) return false;
            _time = performance.now();
            e.action = 'over';
            e.object = _this.div.className == 'hit' ? _this.parent() : _this;
            setTouch(e);
            if (hover && !_move) hover(e);
        }

        function touchEnd(e) {
            if (!_this.div) return false;
            var time = performance.now();
            var clicked = false;

            _touch = convertTouchEvent(e);
            _move = findDistance(_start, _touch) > 25;

            e.object = _this.div.className == 'hit' ? _this.parent() : _this;
            setTouch(e);

            if (_time && time - _time < 750) {
                if (Mouse._preventClicks) return false;
                if (click && !_move) {
                    clicked = true;
                    e.action = 'click';
                    if (click && !_move) click(e);

                    if (Mouse.autoPreventClicks) Mouse.preventClicks();
                }
            }

            if (hover) {
                e.action = 'out';
                if (!Mouse._preventFire) hover(e);
            }

            _move = false;
        }

        return this;
    };
})();

/**
 * @name Element
 */

Class(function Element(type = 'div') {
	Inherit(this, Component);
	var name = Utils.getConstructorName(this);

	this.__element = true;

    /**
     * Hydra object
     * @name this.element
     * @memberof Element
     */
	this.element = $('.'+name, type);
	this.element.__useFragment = true;

    /**
     * @name Element.destroy
     * @memberof Element
     *
     * @function
    */
    this.destroy = function() {
        if (this.element && this.element.remove) this.element = this.element.remove();
        this._destroy && this._destroy();
    };

    /**
     * @name Element.querySelector
     * @memberof Element
     *
     * @function
     * @param selector
    */
    this.querySelector = async function(selector) {
        await defer();

        if (!Array.isArray(selector)) {
            return $(this.element.div.querySelector(selector));
        } else {
            let values = [];
            selector.forEach(s => {
                values.push($(this.element.div.querySelector(s)));
            });
            return values;
        }
    }

    /**
     * @name Element.querySelectorAll
     * @memberof Element
     *
     * @function
     * @param selector
    */
    this.querySelectorAll = async function(selector) {
        await defer();

        let list = this.element.div.querySelectorAll(selector);
        let values = [];
        for (let i = 0; i < list.length; i++) values.push($(list[i]));
        return values;
    }

});
(()=>{var fs=Object.create;var yt=Object.defineProperty,ds=Object.defineProperties,cs=Object.getOwnPropertyDescriptor,ms=Object.getOwnPropertyDescriptors,hs=Object.getOwnPropertyNames,$o=Object.getOwnPropertySymbols,gs=Object.getPrototypeOf,Bo=Object.prototype.hasOwnProperty,ys=Object.prototype.propertyIsEnumerable;var Nr=(e,t,r)=>t in e?yt(e,t,{enumerable:!0,configurable:!0,writable:!0,value:r}):e[t]=r,b=(e,t)=>{for(var r in t||(t={}))Bo.call(t,r)&&Nr(e,r,t[r]);if($o)for(var r of $o(t))ys.call(t,r)&&Nr(e,r,t[r]);return e},R=(e,t)=>ds(e,ms(t)),Fo=e=>yt(e,"__esModule",{value:!0});var kt=(e,t)=>()=>(t||e((t={exports:{}}).exports,t),t.exports),Lr=(e,t)=>{Fo(e);for(var r in t)yt(e,r,{get:t[r],enumerable:!0})},bs=(e,t,r)=>{if(t&&typeof t=="object"||typeof t=="function")for(let o of hs(t))!Bo.call(e,o)&&o!=="default"&&yt(e,o,{get:()=>t[o],enumerable:!(r=cs(t,o))||r.enumerable});return e},Et=e=>bs(Fo(yt(e!=null?fs(gs(e)):{},"default",e&&e.__esModule&&"default"in e?{get:()=>e.default,enumerable:!0}:{value:e,enumerable:!0})),e);var d=(e,t,r)=>(Nr(e,typeof t!="symbol"?t+"":t,r),r);var Wn=kt((Jy,qn)=>{var Eu;qn.exports=Eu=function(){function e(t,r,o,n){this.set(t,r,o,n)}return e.prototype.set=function(t,r,o,n){this._cx=3*t,this._bx=3*(o-t)-this._cx,this._ax=1-this._cx-this._bx,this._cy=3*r,this._by=3*(n-r)-this._cy,this._ay=1-this._cy-this._by},e.epsilon=1e-6,e.prototype._sampleCurveX=function(t){return((this._ax*t+this._bx)*t+this._cx)*t},e.prototype._sampleCurveY=function(t){return((this._ay*t+this._by)*t+this._cy)*t},e.prototype._sampleCurveDerivativeX=function(t){return(3*this._ax*t+2*this._bx)*t+this._cx},e.prototype._solveCurveX=function(t,r){var o,n,i,a,s,u;for(i=void 0,a=void 0,s=void 0,u=void 0,o=void 0,n=void 0,s=t,n=0;n<8;){if(u=this._sampleCurveX(s)-t,Math.abs(u)<r)return s;if(o=this._sampleCurveDerivativeX(s),Math.abs(o)<r)break;s=s-u/o,n++}if(i=0,a=1,s=t,s<i)return i;if(s>a)return a;for(;i<a;){if(u=this._sampleCurveX(s),Math.abs(u-t)<r)return s;t>u?i=s:a=s,s=(a-i)*.5+i}return s},e.prototype.solve=function(t,r){return this._sampleCurveY(this._solveCurveX(t,r))},e.prototype.solveSimple=function(t){return this._sampleCurveY(this._solveCurveX(t,1e-6))},e}()});var Na=kt((fS,Va)=>{var cr,co;cr=[];co=[];function xc(e,t,r){var o,n,i,a,s,u,p,l;if(e===t)return 0;if(o=e.length,n=t.length,o===0)return n;if(n===0)return o;for(r&&(e=e.toLowerCase(),t=t.toLowerCase()),p=0;p<o;)co[p]=e.charCodeAt(p),cr[p]=++p;for(l=0;l<n;)for(i=t.charCodeAt(l),a=s=l++,p=-1;++p<o;)u=i===co[p]?s:s+1,s=cr[p],cr[p]=a=s>a?u>a?a+1:u:u>s?s+1:u;return a}Va.exports=xc});var $a=kt((dS,Ma)=>{var La=Na();function Sc(){var e,t,r,o,n,i=0,a=arguments[0],s=arguments[1],u=s.length,p=arguments[2];p&&(o=p.threshold,n=p.ignoreCase),o===void 0&&(o=0);for(var l=0;l<u;++l)n?t=La(a,s[l],!0):t=La(a,s[l]),t>a.length?e=1-t/s[l].length:e=1-t/a.length,e>i&&(i=e,r=s[l]);return i>=o?r:null}Ma.exports=Sc});var Po=kt((mT,Ha)=>{"use strict";Ha.exports=function e(t,r){if(t===r)return!0;if(t&&r&&typeof t=="object"&&typeof r=="object"){if(t.constructor!==r.constructor)return!1;var o,n,i;if(Array.isArray(t)){if(o=t.length,o!=r.length)return!1;for(n=o;n--!=0;)if(!e(t[n],r[n]))return!1;return!0}if(t.constructor===RegExp)return t.source===r.source&&t.flags===r.flags;if(t.valueOf!==Object.prototype.valueOf)return t.valueOf()===r.valueOf();if(t.toString!==Object.prototype.toString)return t.toString()===r.toString();if(i=Object.keys(t),o=i.length,o!==Object.keys(r).length)return!1;for(n=o;n--!=0;)if(!Object.prototype.hasOwnProperty.call(r,i[n]))return!1;for(n=o;n--!=0;){var a=i[n];if(!e(t[a],r[a]))return!1}return!0}return t!==t&&r!==r}});var Mo={};Lr(Mo,{Ticker:()=>se,getCoreTicker:()=>qe,getProject:()=>ps,notify:()=>ne,onChange:()=>us,setCoreTicker:()=>jo,types:()=>Sr,val:()=>ls});var Lo={};Lr(Lo,{Ticker:()=>se,getCoreTicker:()=>qe,getProject:()=>ps,notify:()=>ne,onChange:()=>us,setCoreTicker:()=>jo,types:()=>Sr,val:()=>ls});var Ps=Array.isArray,L=Ps;var js=typeof window=="object"&&window&&window.Object===Object&&window,Dt=js;var _s=typeof self=="object"&&self&&self.Object===Object&&self,xs=Dt||_s||Function("return this")(),N=xs;var Ss=N.Symbol,Q=Ss;var Uo=Object.prototype,Ts=Uo.hasOwnProperty,vs=Uo.toString,bt=Q?Q.toStringTag:void 0;function Is(e){var t=Ts.call(e,bt),r=e[bt];try{e[bt]=void 0;var o=!0}catch(i){}var n=vs.call(e);return o&&(t?e[bt]=r:delete e[bt]),n}var zo=Is;var As=Object.prototype,ws=As.toString;function Os(e){return ws.call(e)}var qo=Os;var Cs="[object Null]",ks="[object Undefined]",Wo=Q?Q.toStringTag:void 0;function Es(e){return e==null?e===void 0?ks:Cs:Wo&&Wo in Object(e)?zo(e):qo(e)}var H=Es;function Ds(e){return e!=null&&typeof e=="object"}var J=Ds;var Rs="[object Symbol]";function Vs(e){return typeof e=="symbol"||J(e)&&H(e)==Rs}var ye=Vs;var Ns=/\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/,Ls=/^\w*$/;function Ms(e,t){if(L(e))return!1;var r=typeof e;return r=="number"||r=="symbol"||r=="boolean"||e==null||ye(e)?!0:Ls.test(e)||!Ns.test(e)||t!=null&&e in Object(t)}var He=Ms;function $s(e){var t=typeof e;return e!=null&&(t=="object"||t=="function")}var U=$s;var Bs="[object AsyncFunction]",Fs="[object Function]",Us="[object GeneratorFunction]",zs="[object Proxy]";function qs(e){if(!U(e))return!1;var t=H(e);return t==Fs||t==Us||t==Bs||t==zs}var Rt=qs;var Ws=N["__core-js_shared__"],Vt=Ws;var Go=function(){var e=/[^.]+$/.exec(Vt&&Vt.keys&&Vt.keys.IE_PROTO||"");return e?"Symbol(src)_1."+e:""}();function Gs(e){return!!Go&&Go in e}var Ko=Gs;var Ks=Function.prototype,Hs=Ks.toString;function Js(e){if(e!=null){try{return Hs.call(e)}catch(t){}try{return e+""}catch(t){}}return""}var le=Js;var Ys=/[\\^$.*+?()[\]{}|]/g,Xs=/^\[object .+?Constructor\]$/,Zs=Function.prototype,Qs=Object.prototype,ep=Zs.toString,tp=Qs.hasOwnProperty,rp=RegExp("^"+ep.call(tp).replace(Ys,"\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g,"$1.*?")+"$");function op(e){if(!U(e)||Ko(e))return!1;var t=Rt(e)?rp:Xs;return t.test(le(e))}var Ho=op;function np(e,t){return e==null?void 0:e[t]}var Jo=np;function ip(e,t){var r=Jo(e,t);return Ho(r)?r:void 0}var z=ip;var ap=z(Object,"create"),fe=ap;function sp(){this.__data__=fe?fe(null):{},this.size=0}var Yo=sp;function pp(e){var t=this.has(e)&&delete this.__data__[e];return this.size-=t?1:0,t}var Xo=pp;var up="__lodash_hash_undefined__",lp=Object.prototype,fp=lp.hasOwnProperty;function dp(e){var t=this.__data__;if(fe){var r=t[e];return r===up?void 0:r}return fp.call(t,e)?t[e]:void 0}var Zo=dp;var cp=Object.prototype,mp=cp.hasOwnProperty;function hp(e){var t=this.__data__;return fe?t[e]!==void 0:mp.call(t,e)}var Qo=hp;var gp="__lodash_hash_undefined__";function yp(e,t){var r=this.__data__;return this.size+=this.has(e)?0:1,r[e]=fe&&t===void 0?gp:t,this}var en=yp;function Je(e){var t=-1,r=e==null?0:e.length;for(this.clear();++t<r;){var o=e[t];this.set(o[0],o[1])}}Je.prototype.clear=Yo;Je.prototype.delete=Xo;Je.prototype.get=Zo;Je.prototype.has=Qo;Je.prototype.set=en;var Mr=Je;function bp(){this.__data__=[],this.size=0}var tn=bp;function Pp(e,t){return e===t||e!==e&&t!==t}var Ye=Pp;function jp(e,t){for(var r=e.length;r--;)if(Ye(e[r][0],t))return r;return-1}var be=jp;var _p=Array.prototype,xp=_p.splice;function Sp(e){var t=this.__data__,r=be(t,e);if(r<0)return!1;var o=t.length-1;return r==o?t.pop():xp.call(t,r,1),--this.size,!0}var rn=Sp;function Tp(e){var t=this.__data__,r=be(t,e);return r<0?void 0:t[r][1]}var on=Tp;function vp(e){return be(this.__data__,e)>-1}var nn=vp;function Ip(e,t){var r=this.__data__,o=be(r,e);return o<0?(++this.size,r.push([e,t])):r[o][1]=t,this}var an=Ip;function Xe(e){var t=-1,r=e==null?0:e.length;for(this.clear();++t<r;){var o=e[t];this.set(o[0],o[1])}}Xe.prototype.clear=tn;Xe.prototype.delete=rn;Xe.prototype.get=on;Xe.prototype.has=nn;Xe.prototype.set=an;var Pe=Xe;var Ap=z(N,"Map"),je=Ap;function wp(){this.size=0,this.__data__={hash:new Mr,map:new(je||Pe),string:new Mr}}var sn=wp;function Op(e){var t=typeof e;return t=="string"||t=="number"||t=="symbol"||t=="boolean"?e!=="__proto__":e===null}var pn=Op;function Cp(e,t){var r=e.__data__;return pn(t)?r[typeof t=="string"?"string":"hash"]:r.map}var _e=Cp;function kp(e){var t=_e(this,e).delete(e);return this.size-=t?1:0,t}var un=kp;function Ep(e){return _e(this,e).get(e)}var ln=Ep;function Dp(e){return _e(this,e).has(e)}var fn=Dp;function Rp(e,t){var r=_e(this,e),o=r.size;return r.set(e,t),this.size+=r.size==o?0:1,this}var dn=Rp;function Ze(e){var t=-1,r=e==null?0:e.length;for(this.clear();++t<r;){var o=e[t];this.set(o[0],o[1])}}Ze.prototype.clear=sn;Ze.prototype.delete=un;Ze.prototype.get=ln;Ze.prototype.has=fn;Ze.prototype.set=dn;var Ee=Ze;var Vp="Expected a function";function $r(e,t){if(typeof e!="function"||t!=null&&typeof t!="function")throw new TypeError(Vp);var r=function(){var o=arguments,n=t?t.apply(this,o):o[0],i=r.cache;if(i.has(n))return i.get(n);var a=e.apply(this,o);return r.cache=i.set(n,a)||i,a};return r.cache=new($r.Cache||Ee),r}$r.Cache=Ee;var cn=$r;var Np=500;function Lp(e){var t=cn(e,function(o){return r.size===Np&&r.clear(),o}),r=t.cache;return t}var mn=Lp;var Mp=/[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g,$p=/\\(\\)?/g,Bp=mn(function(e){var t=[];return e.charCodeAt(0)===46&&t.push(""),e.replace(Mp,function(r,o,n,i){t.push(n?i.replace($p,"$1"):o||r)}),t}),hn=Bp;function Fp(e,t){for(var r=-1,o=e==null?0:e.length,n=Array(o);++r<o;)n[r]=t(e[r],r,e);return n}var gn=Fp;var Up=1/0,yn=Q?Q.prototype:void 0,bn=yn?yn.toString:void 0;function Pn(e){if(typeof e=="string")return e;if(L(e))return gn(e,Pn)+"";if(ye(e))return bn?bn.call(e):"";var t=e+"";return t=="0"&&1/e==-Up?"-0":t}var Nt=Pn;function zp(e){return e==null?"":Nt(e)}var Lt=zp;function qp(e,t){return L(e)?e:He(e,t)?[e]:hn(Lt(e))}var Qe=qp;var Wp=1/0;function Gp(e){if(typeof e=="string"||ye(e))return e;var t=e+"";return t=="0"&&1/e==-Wp?"-0":t}var ae=Gp;function Kp(e,t){t=Qe(t,e);for(var r=0,o=t.length;e!=null&&r<o;)e=e[ae(t[r++])];return r&&r==o?e:void 0}var Mt=Kp;function Hp(e,t,r){var o=e==null?void 0:Mt(e,t);return o===void 0?r:o}var et=Hp;function Jp(e,t){return function(r){return e(t(r))}}var $t=Jp;var Yp=$t(Object.getPrototypeOf,Object),jn=Yp;var Xp="[object Object]",Zp=Function.prototype,Qp=Object.prototype,_n=Zp.toString,eu=Qp.hasOwnProperty,tu=_n.call(Object);function ru(e){if(!J(e)||H(e)!=Xp)return!1;var t=jn(e);if(t===null)return!0;var r=eu.call(t,"constructor")&&t.constructor;return typeof r=="function"&&r instanceof r&&_n.call(r)==tu}var Pt=ru;function ou(e){var t=e==null?0:e.length;return t?e[t-1]:void 0}var xn=ou;function xe(e){return e&&e.isPrism&&e.isPrism===!0}var Br=new WeakMap,Sn=new WeakMap,Tn=Symbol("pointerMeta"),nu={get(e,t){if(t===Tn)return Br.get(e);let r=Sn.get(e);r||(r=new Map,Sn.set(e,r));let o=r.get(t);if(o!==void 0)return o;let n=Br.get(e),i=vn({root:n.root,path:[...n.path,t]});return r.set(t,i),i}},Bt=e=>e[Tn],De=e=>{let{root:t,path:r}=Bt(e);return{root:t,path:r}};function vn(e){var o;let t={root:e.root,path:(o=e.path)!=null?o:[]},r={};return Br.set(r,t),new Proxy(r,nu)}var de=vn,Se=e=>e&&!!Bt(e);function Fr(e,t,r){return t.length===0?r(e):Ft(e,t,r)}var Ft=(e,t,r)=>{if(t.length===0)return r(e);if(Array.isArray(e)){let[o,...n]=t;o=parseInt(String(o),10),isNaN(o)&&(o=0);let i=e[o],a=Ft(i,n,r);if(i===a)return e;let s=[...e];return s.splice(o,1,a),s}else if(typeof e=="object"&&e!==null){let[o,...n]=t,i=e[o],a=Ft(i,n,r);return i===a?e:R(b({},e),{[o]:a})}else{let[o,...n]=t;return{[o]:Ft(void 0,n,r)}}};var tt=class{constructor(){this._head=void 0}peek(){return this._head&&this._head.data}pop(){let t=this._head;if(!!t)return this._head=t.next,t.data}push(t){let r={next:this._head,data:t};this._head=r}};function In(){let e=()=>{},t=new tt,r=e;return{type:"Dataverse_discoveryMechanism",startIgnoringDependencies:()=>{t.push(r)},stopIgnoringDependencies:()=>{t.peek()!==r||t.pop()},reportResolutionStart:p=>{let l=t.peek();l&&l(p),t.push(r)},reportResolutionEnd:p=>{t.pop()},pushCollector:p=>{t.push(p)},popCollector:p=>{if(t.peek()!==p)throw new Error("Popped collector is not on top of the stack");t.pop()}}}function iu(){let e="__dataverse_discoveryMechanism_sharedStack",t=typeof window!="undefined"||typeof window!="undefined"?window:{};if(t){let r=t[e];if(r&&typeof r=="object"&&r.type==="Dataverse_discoveryMechanism")return r;{let o=In();return t[e]=o,o}}else return In()}var{startIgnoringDependencies:rt,stopIgnoringDependencies:ot,reportResolutionEnd:An,reportResolutionStart:wn,pushCollector:On,popCollector:Cn}=iu();var kn=()=>{},En=class{constructor(t,r){this._fn=t;this._prismInstance=r;this._didMarkDependentsAsStale=!1;this._isFresh=!1;this._cacheOfDendencyValues=new Map;this._dependents=new Set;this._dependencies=new Set;this._possiblyStaleDeps=new Set;this._scope=new Ut(this);this._lastValue=void 0;this._forciblySetToStale=!1;this._reactToDependencyGoingStale=t=>{this._possiblyStaleDeps.add(t),this._markAsStale()};for(let o of this._dependencies)o._addDependent(this._reactToDependencyGoingStale);rt(),this.getValue(),ot()}get hasDependents(){return this._dependents.size>0}removeDependent(t){this._dependents.delete(t)}addDependent(t){this._dependents.add(t)}destroy(){for(let t of this._dependencies)t._removeDependent(this._reactToDependencyGoingStale);Rn(this._scope)}getValue(){if(!this._isFresh){let t=this._recalculate();this._lastValue=t,this._isFresh=!0,this._didMarkDependentsAsStale=!1,this._forciblySetToStale=!1}return this._lastValue}_recalculate(){let t;if(!this._forciblySetToStale&&this._possiblyStaleDeps.size>0){let n=!1;rt();for(let i of this._possiblyStaleDeps)if(this._cacheOfDendencyValues.get(i)!==i.getValue()){n=!0;break}if(ot(),this._possiblyStaleDeps.clear(),!n)return this._lastValue}let r=new Set;this._cacheOfDendencyValues.clear();let o=n=>{r.add(n),this._addDependency(n)};On(o),q.push(this._scope);try{t=this._fn()}catch(n){console.error(n)}finally{q.pop()!==this._scope&&console.warn("The Prism hook stack has slipped. This is a bug.")}Cn(o);for(let n of this._dependencies)r.has(n)||this._removeDependency(n);this._dependencies=r,rt();for(let n of r)this._cacheOfDendencyValues.set(n,n.getValue());return ot(),t}forceStale(){this._forciblySetToStale=!0,this._markAsStale()}_markAsStale(){if(!this._didMarkDependentsAsStale){this._didMarkDependentsAsStale=!0,this._isFresh=!1;for(let t of this._dependents)t(this._prismInstance)}}_addDependency(t){this._dependencies.has(t)||(this._dependencies.add(t),t._addDependent(this._reactToDependencyGoingStale))}_removeDependency(t){!this._dependencies.has(t)||(this._dependencies.delete(t),t._removeDependent(this._reactToDependencyGoingStale))}},au={},Dn=class{constructor(t){this._fn=t;this.isPrism=!0;this._state={hot:!1,handle:void 0}}get isHot(){return this._state.hot}onChange(t,r,o=!1){let n=()=>{t.onThisOrNextTick(a)},i=au,a=()=>{let u=this.getValue();u!==i&&(i=u,r(u))};return this._addDependent(n),o&&(i=this.getValue(),r(i)),()=>{this._removeDependent(n)}}onStale(t){let r=()=>{this._removeDependent(o)},o=()=>t();return this._addDependent(o),r}keepHot(){return this.onStale(()=>{})}_addDependent(t){this._state.hot||this._goHot(),this._state.handle.addDependent(t)}_goHot(){let t=new En(this._fn,this);this._state={hot:!0,handle:t}}_removeDependent(t){let r=this._state;if(!r.hot)return;let o=r.handle;o.removeDependent(t),o.hasDependents||(this._state={hot:!1,handle:void 0},o.destroy())}getValue(){wn(this);let t=this._state,r;return t.hot?r=t.handle.getValue():r=hu(this._fn),An(this),r}},Ut=class{constructor(t){this._hotHandle=t;this._refs=new Map;this.isPrismScope=!0;this.subs={};this.effects=new Map;this.memos=new Map}ref(t,r){let o=this._refs.get(t);if(o!==void 0)return o;{let n={current:r};return this._refs.set(t,n),n}}effect(t,r,o){let n=this.effects.get(t);n===void 0&&(n={cleanup:kn,deps:void 0},this.effects.set(t,n)),Vn(n.deps,o)&&(n.cleanup(),rt(),n.cleanup=zt(r,kn).value,ot(),n.deps=o)}memo(t,r,o){let n=this.memos.get(t);return n===void 0&&(n={cachedValue:null,deps:void 0},this.memos.set(t,n)),Vn(n.deps,o)&&(rt(),n.cachedValue=zt(r,void 0).value,ot(),n.deps=o),n.cachedValue}state(t,r){let{value:o,setValue:n}=this.memo("state/"+t,()=>{let i={current:r};return{value:i,setValue:s=>{i.current=s,this._hotHandle.forceStale()}}},[]);return[o.current,n]}sub(t){return this.subs[t]||(this.subs[t]=new Ut(this._hotHandle)),this.subs[t]}cleanupEffects(){for(let t of this.effects.values())zt(t.cleanup,void 0);this.effects.clear()}source(t,r){let o="$$source/blah";return this.effect(o,()=>t(()=>{this._hotHandle.forceStale()}),[t]),r()}};function Rn(e){for(let t of Object.values(e.subs))Rn(t);e.cleanupEffects()}function zt(e,t){try{return{value:e(),ok:!0}}catch(r){return setTimeout(function(){throw r}),{value:t,ok:!1}}}var q=new tt;function su(e,t){let r=q.peek();if(!r)throw new Error("prism.ref() is called outside of a prism() call.");return r.ref(e,t)}function pu(e,t,r){let o=q.peek();if(!o)throw new Error("prism.effect() is called outside of a prism() call.");return o.effect(e,t,r)}function Vn(e,t){if(e===void 0||t===void 0)return!0;let r=e.length;if(r!==t.length)return!0;for(let o=0;o<r;o++)if(e[o]!==t[o])return!0;return!1}function Nn(e,t,r){let o=q.peek();if(!o)throw new Error("prism.memo() is called outside of a prism() call.");return o.memo(e,t,r)}function uu(e,t){let r=q.peek();if(!r)throw new Error("prism.state() is called outside of a prism() call.");return r.state(e,t)}function lu(){if(!q.peek())throw new Error("The parent function is called outside of a prism() call.")}function fu(e,t){let r=q.peek();if(!r)throw new Error("prism.scope() is called outside of a prism() call.");let o=r.sub(e);q.push(o);let n=zt(t,void 0).value;return q.pop(),n}function du(e,t,r){return Nn(e,()=>oe(t),r).getValue()}function cu(){return!!q.peek()}function mu(e,t){let r=q.peek();if(!r)throw new Error("prism.source() is called outside of a prism() call.");return r.source(e,t)}var oe=e=>new Dn(e),qt=class{effect(t,r,o){console.warn("prism.effect() does not run in cold prisms")}memo(t,r,o){return r()}state(t,r){return[r,()=>{}]}ref(t,r){return{current:r}}sub(t){return new qt}source(t,r){return r()}};function hu(e){let t=new qt;q.push(t);let r;try{r=e()}catch(o){console.error(o)}finally{q.pop()!==t&&console.warn("The Prism hook stack has slipped. This is a bug.")}return r}oe.ref=su;oe.effect=pu;oe.memo=Nn;oe.ensurePrism=lu;oe.state=uu;oe.scope=fu;oe.sub=du;oe.inPrism=cu;oe.source=mu;var g=oe;var Te;(function(o){o[o.Dict=0]="Dict",o[o.Array=1]="Array",o[o.Other=2]="Other"})(Te||(Te={}));var Ur=e=>Array.isArray(e)?1:Pt(e)?0:2,Ln=(e,t,r=Ur(e))=>r===0&&typeof t=="string"||r===1&&gu(t)?e[t]:void 0,gu=e=>{let t=typeof e=="number"?e:parseInt(e,10);return!isNaN(t)&&t>=0&&t<1/0&&(t|0)===t},Wt=class{constructor(t,r){this._parent=t;this._path=r;this.children=new Map;this.identityChangeListeners=new Set}addIdentityChangeListener(t){this.identityChangeListeners.add(t)}removeIdentityChangeListener(t){this.identityChangeListeners.delete(t),this._checkForGC()}removeChild(t){this.children.delete(t),this._checkForGC()}getChild(t){return this.children.get(t)}getOrCreateChild(t){let r=this.children.get(t);return r||(r=r=new Wt(this,this._path.concat([t])),this.children.set(t,r)),r}_checkForGC(){this.identityChangeListeners.size>0||this.children.size>0||this._parent&&this._parent.removeChild(xn(this._path))}},I=class{constructor(t){this.$$isIdentityPrismProvider=!0;this.prism=this.getIdentityPrism([]);this._onPathValueChange=(t,r)=>{let o=this._getOrCreateScopeForPath(t);return o.identityChangeListeners.add(r),()=>{o.identityChangeListeners.delete(r)}};this._currentState=t,this._rootScope=new Wt(void 0,[]),this.pointer=de({root:this,path:[]})}set(t){let r=this._currentState;this._currentState=t,this._checkUpdates(this._rootScope,r,t)}getState(){return this._currentState}get(){return this.getState()}setState(t){this.set(t)}getIn(t){return t.length===0?this.getState():et(this.getState(),t)}reduce(t){this.set(t(this.get()))}reduceByPointer(t,r){let o=t(this.pointer),n=De(o).path,i=Fr(this.get(),n,r);this.set(i)}setByPointer(t,r){this.reduceByPointer(t,()=>r)}_checkUpdates(t,r,o){if(r===o)return;for(let a of t.identityChangeListeners)a(o);if(t.children.size===0)return;let n=Ur(r),i=Ur(o);if(!(n===2&&n===i))for(let[a,s]of t.children){let u=Ln(r,a,n),p=Ln(o,a,i);this._checkUpdates(s,u,p)}}_getOrCreateScopeForPath(t){let r=this._rootScope;for(let o of t)r=r.getOrCreateChild(o);return r}getIdentityPrism(t){let r=n=>this._onPathValueChange(t,n),o=()=>this.getIn(t);return g(()=>g.source(r,o))}},Mn=new WeakMap,Re=e=>{let t=Bt(e),r=Mn.get(t);if(!r){let o=t.root;if(!yu(o))throw new Error("Cannot run pointerToPrism() on a pointer whose root is not an IdentityPrismProvider");let{path:n}=t;r=o.getIdentityPrism(n),Mn.set(t,r)}return r};function yu(e){return typeof e=="object"&&e!==null&&e.$$isIdentityPrismProvider===!0}var P=e=>Se(e)?Re(e).getValue():xe(e)?e.getValue():e;function bu(){let e=new se;if(typeof window!="undefined"){let t=r=>{e.tick(r),window.requestAnimationFrame(t)};window.requestAnimationFrame(t)}else e.tick(0),setTimeout(()=>e.tick(1),0);return e}var zr,se=class{constructor(){this._ticking=!1;this.__ticks=0;this._scheduledForThisOrNextTick=new Set,this._scheduledForNextTick=new Set,this._timeAtCurrentTick=0}static get raf(){return zr||(zr=bu()),zr}onThisOrNextTick(t){this._scheduledForThisOrNextTick.add(t)}onNextTick(t){this._scheduledForNextTick.add(t)}offThisOrNextTick(t){this._scheduledForThisOrNextTick.delete(t)}offNextTick(t){this._scheduledForNextTick.delete(t)}get time(){return this._ticking?this._timeAtCurrentTick:performance.now()}tick(t=performance.now()){this.__ticks++,this._ticking=!0,this._timeAtCurrentTick=t;for(let r of this._scheduledForNextTick)this._scheduledForThisOrNextTick.add(r);this._scheduledForNextTick.clear(),this._tick(0),this._ticking=!1}_tick(t){let r=this.time;if(t>10&&console.warn("_tick() recursing for 10 times"),t>100)throw new Error("Maximum recursion limit for _tick()");let o=this._scheduledForThisOrNextTick;this._scheduledForThisOrNextTick=new Set;for(let n of o)n(r);if(this._scheduledForThisOrNextTick.size>0)return this._tick(t+1)}};var Ve=class{constructor(t){this.$$isIdentityPrismProvider=!0;this._currentPointerBox=new I(t),this.pointer=de({root:this,path:[]})}setPointer(t){this._currentPointerBox.set(t)}getIdentityPrism(t){return g(()=>{let r=this._currentPointerBox.prism.getValue(),o=t.reduce((n,i)=>n[i],r);return P(o)})}};var $n=class{constructor(){d(this,"atom",new I({projects:{}}))}add(t,r){this.atom.setByPointer(o=>o.projects[t],r)}get(t){return this.atom.get().projects[t]}has(t){return!!this.get(t)}remove(t){this.atom.setByPointer(r=>r.projects[t],void 0)}},Pu=new $n,Ne=Pu;var Bn=new WeakMap;function _(e){return Bn.get(e)}function ve(e,t){Bn.set(e,t)}var Gt=[];function qr(e,t){return t.length===0?e:et(e,t)}var Ie=class{constructor(){d(this,"_values",{})}get(t,r){if(this.has(t))return this._values[t];{let o=r();return this._values[t]=o,o}}has(t){return this._values.hasOwnProperty(t)}};var ju=function(){try{var e=z(Object,"defineProperty");return e({},"",{}),e}catch(t){}}(),Wr=ju;function _u(e,t,r){t=="__proto__"&&Wr?Wr(e,t,{configurable:!0,enumerable:!0,value:r,writable:!0}):e[t]=r}var Kt=_u;var xu=Object.prototype,Su=xu.hasOwnProperty;function Tu(e,t,r){var o=e[t];(!(Su.call(e,t)&&Ye(o,r))||r===void 0&&!(t in e))&&Kt(e,t,r)}var Fn=Tu;var vu=9007199254740991,Iu=/^(?:0|[1-9]\d*)$/;function Au(e,t){var r=typeof e;return t=t==null?vu:t,!!t&&(r=="number"||r!="symbol"&&Iu.test(e))&&e>-1&&e%1==0&&e<t}var nt=Au;function wu(e,t,r,o){if(!U(e))return e;t=Qe(t,e);for(var n=-1,i=t.length,a=i-1,s=e;s!=null&&++n<i;){var u=ae(t[n]),p=r;if(u==="__proto__"||u==="constructor"||u==="prototype")return e;if(n!=a){var l=s[u];p=o?o(l,u,s):void 0,p===void 0&&(p=U(l)?l:nt(t[n+1])?[]:{})}Fn(s,u,p),s=s[u]}return e}var Un=wu;function Ou(e,t,r){return e==null?e:Un(e,t,r)}var zn=Ou;var Gr=new WeakMap;function Kr(e){return Hr(e)}function Hr(e){if(Gr.has(e))return Gr.get(e);let t=e.type==="compound"?ku(e):e.type==="enum"?Cu(e):e.default;return Gr.set(e,t),t}function Cu(e){let t={$case:e.defaultCase};for(let[r,o]of Object.entries(e.cases))t[r]=Hr(o);return t}function ku(e){let t={};for(let[r,o]of Object.entries(e.props))t[r]=Hr(o);return t}var Gn=Et(Wn());function Jr(e,t,r){return g(()=>{let o=P(t);return g.memo("driver",()=>o?o.type==="BasicKeyframedTrack"?Du(e,o,r):(e.logger.error("Track type not yet supported."),g(()=>{})):g(()=>{}),[o]).getValue()})}function Du(e,t,r){return g(()=>{let o=g.ref("state",{started:!1}),n=o.current,i=r.getValue();return(!n.started||i<n.validFrom||n.validTo<=i)&&(o.current=n=Ru(e,r,t)),n.der.getValue()})}var Kn=g(()=>{});function Ru(e,t,r){let o=t.getValue();if(r.keyframes.length===0)return{started:!0,validFrom:-1/0,validTo:1/0,der:Kn};let n=0;for(;;){let i=r.keyframes[n];if(!i)return Le.error;let a=n===r.keyframes.length-1;if(o<i.position)return n===0?Le.beforeFirstKeyframe(i):Le.error;if(i.position===o)return a?Le.lastKeyframe(i):Le.between(i,r.keyframes[n+1],t);if(n===r.keyframes.length-1)return Le.lastKeyframe(i);{let s=n+1;if(r.keyframes[s].position<=o){n=s;continue}else return Le.between(i,r.keyframes[n+1],t)}}}var Le={beforeFirstKeyframe(e){return{started:!0,validFrom:-1/0,validTo:e.position,der:g(()=>({left:e.value,progression:0}))}},lastKeyframe(e){return{started:!0,validFrom:e.position,validTo:1/0,der:g(()=>({left:e.value,progression:0}))}},between(e,t,r){if(!e.connectedRight)return{started:!0,validFrom:e.position,validTo:t.position,der:g(()=>({left:e.value,progression:0}))};let o=i=>(i-e.position)/(t.position-e.position);if(!e.type||e.type==="bezier"){let i=new Gn.default(e.handles[2],e.handles[3],t.handles[0],t.handles[1]),a=g(()=>{let s=o(r.getValue()),u=i.solveSimple(s);return{left:e.value,right:t.value,progression:u}});return{started:!0,validFrom:e.position,validTo:t.position,der:a}}let n=g(()=>{let i=o(r.getValue()),a=Math.floor(i);return{left:e.value,right:t.value,progression:a}});return{started:!0,validFrom:e.position,validTo:t.position,der:n}},error:{started:!0,validFrom:-1/0,validTo:1/0,der:Kn}};function it(e,t,r){let n=r.get(e);if(n&&n.override===t)return n.merged;let i=b({},e);for(let a of Object.keys(t)){let s=t[a],u=e[a];i[a]=typeof s=="object"&&typeof u=="object"?it(u,s,r):s===void 0?u:s}return r.set(e,{override:t,merged:i}),i}function Me(e,t){let r=e;for(let o of t)r=r[o];return r}var Hn=(e,t)=>{let r=g.memo(e,()=>new I(t),[]);return r.setState(t),r};var Vu=/\s/;function Nu(e){for(var t=e.length;t--&&Vu.test(e.charAt(t)););return t}var Jn=Nu;var Lu=/^\s+/;function Mu(e){return e&&e.slice(0,Jn(e)+1).replace(Lu,"")}var Yn=Mu;var Xn=0/0,$u=/^[-+]0x[0-9a-f]+$/i,Bu=/^0b[01]+$/i,Fu=/^0o[0-7]+$/i,Uu=parseInt;function zu(e){if(typeof e=="number")return e;if(ye(e))return Xn;if(U(e)){var t=typeof e.valueOf=="function"?e.valueOf():e;e=U(t)?t+"":t}if(typeof e!="string")return e===0?e:+e;e=Yn(e);var r=Bu.test(e);return r||Fu.test(e)?Uu(e.slice(2),r?2:8):$u.test(e)?Xn:+e}var ce=zu;var Zn=1/0,qu=17976931348623157e292;function Wu(e){if(!e)return e===0?e:0;if(e=ce(e),e===Zn||e===-Zn){var t=e<0?-1:1;return t*qu}return e===e?e:0}var Qn=Wu;function Gu(e){var t=Qn(e),r=t%1;return t===t?r?t-r:t:0}var Ht=Gu;function Ku(e){return e}var ei=Ku;var Hu=z(N,"WeakMap"),Jt=Hu;var Ju=9007199254740991;function Yu(e){return typeof e=="number"&&e>-1&&e%1==0&&e<=Ju}var at=Yu;function Xu(e){return e!=null&&at(e.length)&&!Rt(e)}var ti=Xu;var Zu=Object.prototype;function Qu(e){var t=e&&e.constructor,r=typeof t=="function"&&t.prototype||Zu;return e===r}var ri=Qu;function el(e,t){for(var r=-1,o=Array(e);++r<e;)o[r]=t(r);return o}var oi=el;var tl="[object Arguments]";function rl(e){return J(e)&&H(e)==tl}var Yr=rl;var ni=Object.prototype,ol=ni.hasOwnProperty,nl=ni.propertyIsEnumerable,il=Yr(function(){return arguments}())?Yr:function(e){return J(e)&&ol.call(e,"callee")&&!nl.call(e,"callee")},Yt=il;function al(){return!1}var ii=al;var ai=typeof exports=="object"&&exports&&!exports.nodeType&&exports,si=ai&&typeof module=="object"&&module&&!module.nodeType&&module,sl=si&&si.exports===ai,pi=sl?N.Buffer:void 0,pl=pi?pi.isBuffer:void 0,ul=pl||ii,jt=ul;var ll="[object Arguments]",fl="[object Array]",dl="[object Boolean]",cl="[object Date]",ml="[object Error]",hl="[object Function]",gl="[object Map]",yl="[object Number]",bl="[object Object]",Pl="[object RegExp]",jl="[object Set]",_l="[object String]",xl="[object WeakMap]",Sl="[object ArrayBuffer]",Tl="[object DataView]",vl="[object Float32Array]",Il="[object Float64Array]",Al="[object Int8Array]",wl="[object Int16Array]",Ol="[object Int32Array]",Cl="[object Uint8Array]",kl="[object Uint8ClampedArray]",El="[object Uint16Array]",Dl="[object Uint32Array]",E={};E[vl]=E[Il]=E[Al]=E[wl]=E[Ol]=E[Cl]=E[kl]=E[El]=E[Dl]=!0;E[ll]=E[fl]=E[Sl]=E[dl]=E[Tl]=E[cl]=E[ml]=E[hl]=E[gl]=E[yl]=E[bl]=E[Pl]=E[jl]=E[_l]=E[xl]=!1;function Rl(e){return J(e)&&at(e.length)&&!!E[H(e)]}var ui=Rl;function Vl(e){return function(t){return e(t)}}var li=Vl;var fi=typeof exports=="object"&&exports&&!exports.nodeType&&exports,_t=fi&&typeof module=="object"&&module&&!module.nodeType&&module,Nl=_t&&_t.exports===fi,Xr=Nl&&Dt.process,Ll=function(){try{var e=_t&&_t.require&&_t.require("util").types;return e||Xr&&Xr.binding&&Xr.binding("util")}catch(t){}}(),Zr=Ll;var di=Zr&&Zr.isTypedArray,Ml=di?li(di):ui,Xt=Ml;var $l=Object.prototype,Bl=$l.hasOwnProperty;function Fl(e,t){var r=L(e),o=!r&&Yt(e),n=!r&&!o&&jt(e),i=!r&&!o&&!n&&Xt(e),a=r||o||n||i,s=a?oi(e.length,String):[],u=s.length;for(var p in e)(t||Bl.call(e,p))&&!(a&&(p=="length"||n&&(p=="offset"||p=="parent")||i&&(p=="buffer"||p=="byteLength"||p=="byteOffset")||nt(p,u)))&&s.push(p);return s}var ci=Fl;var Ul=$t(Object.keys,Object),mi=Ul;var zl=Object.prototype,ql=zl.hasOwnProperty;function Wl(e){if(!ri(e))return mi(e);var t=[];for(var r in Object(e))ql.call(e,r)&&r!="constructor"&&t.push(r);return t}var hi=Wl;function Gl(e){return ti(e)?ci(e):hi(e)}var st=Gl;function Kl(e,t){for(var r=-1,o=t.length,n=e.length;++r<o;)e[n+r]=t[r];return e}var gi=Kl;function Hl(e,t,r){var o=-1,n=e.length;t<0&&(t=-t>n?0:n+t),r=r>n?n:r,r<0&&(r+=n),n=t>r?0:r-t>>>0,t>>>=0;for(var i=Array(n);++o<n;)i[o]=e[o+t];return i}var yi=Hl;function Jl(e,t,r){var o=e.length;return r=r===void 0?o:r,!t&&r>=o?e:yi(e,t,r)}var bi=Jl;var Yl="\\ud800-\\udfff",Xl="\\u0300-\\u036f",Zl="\\ufe20-\\ufe2f",Ql="\\u20d0-\\u20ff",ef=Xl+Zl+Ql,tf="\\ufe0e\\ufe0f",rf="\\u200d",of=RegExp("["+rf+Yl+ef+tf+"]");function nf(e){return of.test(e)}var pt=nf;function af(e){return e.split("")}var Pi=af;var ji="\\ud800-\\udfff",sf="\\u0300-\\u036f",pf="\\ufe20-\\ufe2f",uf="\\u20d0-\\u20ff",lf=sf+pf+uf,ff="\\ufe0e\\ufe0f",df="["+ji+"]",Qr="["+lf+"]",eo="\\ud83c[\\udffb-\\udfff]",cf="(?:"+Qr+"|"+eo+")",_i="[^"+ji+"]",xi="(?:\\ud83c[\\udde6-\\uddff]){2}",Si="[\\ud800-\\udbff][\\udc00-\\udfff]",mf="\\u200d",Ti=cf+"?",vi="["+ff+"]?",hf="(?:"+mf+"(?:"+[_i,xi,Si].join("|")+")"+vi+Ti+")*",gf=vi+Ti+hf,yf="(?:"+[_i+Qr+"?",Qr,xi,Si,df].join("|")+")",bf=RegExp(eo+"(?="+eo+")|"+yf+gf,"g");function Pf(e){return e.match(bf)||[]}var Ii=Pf;function jf(e){return pt(e)?Ii(e):Pi(e)}var Ai=jf;function _f(e,t,r){return e===e&&(r!==void 0&&(e=e<=r?e:r),t!==void 0&&(e=e>=t?e:t)),e}var wi=_f;function xf(e,t,r){return r===void 0&&(r=t,t=void 0),r!==void 0&&(r=ce(r),r=r===r?r:0),t!==void 0&&(t=ce(t),t=t===t?t:0),wi(ce(e),t,r)}var xt=xf;function Sf(){this.__data__=new Pe,this.size=0}var Oi=Sf;function Tf(e){var t=this.__data__,r=t.delete(e);return this.size=t.size,r}var Ci=Tf;function vf(e){return this.__data__.get(e)}var ki=vf;function If(e){return this.__data__.has(e)}var Ei=If;var Af=200;function wf(e,t){var r=this.__data__;if(r instanceof Pe){var o=r.__data__;if(!je||o.length<Af-1)return o.push([e,t]),this.size=++r.size,this;r=this.__data__=new Ee(o)}return r.set(e,t),this.size=r.size,this}var Di=wf;function ut(e){var t=this.__data__=new Pe(e);this.size=t.size}ut.prototype.clear=Oi;ut.prototype.delete=Ci;ut.prototype.get=ki;ut.prototype.has=Ei;ut.prototype.set=Di;var lt=ut;function Of(e,t){for(var r=-1,o=e==null?0:e.length,n=0,i=[];++r<o;){var a=e[r];t(a,r,e)&&(i[n++]=a)}return i}var Ri=Of;function Cf(){return[]}var Vi=Cf;var kf=Object.prototype,Ef=kf.propertyIsEnumerable,Ni=Object.getOwnPropertySymbols,Df=Ni?function(e){return e==null?[]:(e=Object(e),Ri(Ni(e),function(t){return Ef.call(e,t)}))}:Vi,Li=Df;function Rf(e,t,r){var o=t(e);return L(e)?o:gi(o,r(e))}var Mi=Rf;function Vf(e){return Mi(e,st,Li)}var to=Vf;var Nf=z(N,"DataView"),Zt=Nf;var Lf=z(N,"Promise"),Qt=Lf;var Mf=z(N,"Set"),er=Mf;var $i="[object Map]",$f="[object Object]",Bi="[object Promise]",Fi="[object Set]",Ui="[object WeakMap]",zi="[object DataView]",Bf=le(Zt),Ff=le(je),Uf=le(Qt),zf=le(er),qf=le(Jt),$e=H;(Zt&&$e(new Zt(new ArrayBuffer(1)))!=zi||je&&$e(new je)!=$i||Qt&&$e(Qt.resolve())!=Bi||er&&$e(new er)!=Fi||Jt&&$e(new Jt)!=Ui)&&($e=function(e){var t=H(e),r=t==$f?e.constructor:void 0,o=r?le(r):"";if(o)switch(o){case Bf:return zi;case Ff:return $i;case Uf:return Bi;case zf:return Fi;case qf:return Ui}return t});var ro=$e;var Wf=N.Uint8Array,oo=Wf;var Gf="__lodash_hash_undefined__";function Kf(e){return this.__data__.set(e,Gf),this}var qi=Kf;function Hf(e){return this.__data__.has(e)}var Wi=Hf;function tr(e){var t=-1,r=e==null?0:e.length;for(this.__data__=new Ee;++t<r;)this.add(e[t])}tr.prototype.add=tr.prototype.push=qi;tr.prototype.has=Wi;var Gi=tr;function Jf(e,t){for(var r=-1,o=e==null?0:e.length;++r<o;)if(t(e[r],r,e))return!0;return!1}var Ki=Jf;function Yf(e,t){return e.has(t)}var Hi=Yf;var Xf=1,Zf=2;function Qf(e,t,r,o,n,i){var a=r&Xf,s=e.length,u=t.length;if(s!=u&&!(a&&u>s))return!1;var p=i.get(e),l=i.get(t);if(p&&l)return p==t&&l==e;var c=-1,h=!0,f=r&Zf?new Gi:void 0;for(i.set(e,t),i.set(t,e);++c<s;){var y=e[c],x=t[c];if(o)var S=a?o(x,y,c,t,e,i):o(y,x,c,e,t,i);if(S!==void 0){if(S)continue;h=!1;break}if(f){if(!Ki(t,function(j,T){if(!Hi(f,T)&&(y===j||n(y,j,r,o,i)))return f.push(T)})){h=!1;break}}else if(!(y===x||n(y,x,r,o,i))){h=!1;break}}return i.delete(e),i.delete(t),h}var rr=Qf;function ed(e){var t=-1,r=Array(e.size);return e.forEach(function(o,n){r[++t]=[n,o]}),r}var Ji=ed;function td(e){var t=-1,r=Array(e.size);return e.forEach(function(o){r[++t]=o}),r}var Yi=td;var rd=1,od=2,nd="[object Boolean]",id="[object Date]",ad="[object Error]",sd="[object Map]",pd="[object Number]",ud="[object RegExp]",ld="[object Set]",fd="[object String]",dd="[object Symbol]",cd="[object ArrayBuffer]",md="[object DataView]",Xi=Q?Q.prototype:void 0,no=Xi?Xi.valueOf:void 0;function hd(e,t,r,o,n,i,a){switch(r){case md:if(e.byteLength!=t.byteLength||e.byteOffset!=t.byteOffset)return!1;e=e.buffer,t=t.buffer;case cd:return!(e.byteLength!=t.byteLength||!i(new oo(e),new oo(t)));case nd:case id:case pd:return Ye(+e,+t);case ad:return e.name==t.name&&e.message==t.message;case ud:case fd:return e==t+"";case sd:var s=Ji;case ld:var u=o&rd;if(s||(s=Yi),e.size!=t.size&&!u)return!1;var p=a.get(e);if(p)return p==t;o|=od,a.set(e,t);var l=rr(s(e),s(t),o,n,i,a);return a.delete(e),l;case dd:if(no)return no.call(e)==no.call(t)}return!1}var Zi=hd;var gd=1,yd=Object.prototype,bd=yd.hasOwnProperty;function Pd(e,t,r,o,n,i){var a=r&gd,s=to(e),u=s.length,p=to(t),l=p.length;if(u!=l&&!a)return!1;for(var c=u;c--;){var h=s[c];if(!(a?h in t:bd.call(t,h)))return!1}var f=i.get(e),y=i.get(t);if(f&&y)return f==t&&y==e;var x=!0;i.set(e,t),i.set(t,e);for(var S=a;++c<u;){h=s[c];var j=e[h],T=t[h];if(o)var w=a?o(T,j,h,t,e,i):o(j,T,h,e,t,i);if(!(w===void 0?j===T||n(j,T,r,o,i):w)){x=!1;break}S||(S=h=="constructor")}if(x&&!S){var $=e.constructor,B=t.constructor;$!=B&&"constructor"in e&&"constructor"in t&&!(typeof $=="function"&&$ instanceof $&&typeof B=="function"&&B instanceof B)&&(x=!1)}return i.delete(e),i.delete(t),x}var Qi=Pd;var jd=1,ea="[object Arguments]",ta="[object Array]",or="[object Object]",_d=Object.prototype,ra=_d.hasOwnProperty;function xd(e,t,r,o,n,i){var a=L(e),s=L(t),u=a?ta:ro(e),p=s?ta:ro(t);u=u==ea?or:u,p=p==ea?or:p;var l=u==or,c=p==or,h=u==p;if(h&&jt(e)){if(!jt(t))return!1;a=!0,l=!1}if(h&&!l)return i||(i=new lt),a||Xt(e)?rr(e,t,r,o,n,i):Zi(e,t,u,r,o,n,i);if(!(r&jd)){var f=l&&ra.call(e,"__wrapped__"),y=c&&ra.call(t,"__wrapped__");if(f||y){var x=f?e.value():e,S=y?t.value():t;return i||(i=new lt),n(x,S,r,o,i)}}return h?(i||(i=new lt),Qi(e,t,r,o,n,i)):!1}var oa=xd;function na(e,t,r,o,n){return e===t?!0:e==null||t==null||!J(e)&&!J(t)?e!==e&&t!==t:oa(e,t,r,o,na,n)}var nr=na;var Sd=1,Td=2;function vd(e,t,r,o){var n=r.length,i=n,a=!o;if(e==null)return!i;for(e=Object(e);n--;){var s=r[n];if(a&&s[2]?s[1]!==e[s[0]]:!(s[0]in e))return!1}for(;++n<i;){s=r[n];var u=s[0],p=e[u],l=s[1];if(a&&s[2]){if(p===void 0&&!(u in e))return!1}else{var c=new lt;if(o)var h=o(p,l,u,e,t,c);if(!(h===void 0?nr(l,p,Sd|Td,o,c):h))return!1}}return!0}var ia=vd;function Id(e){return e===e&&!U(e)}var ir=Id;function Ad(e){for(var t=st(e),r=t.length;r--;){var o=t[r],n=e[o];t[r]=[o,n,ir(n)]}return t}var aa=Ad;function wd(e,t){return function(r){return r==null?!1:r[e]===t&&(t!==void 0||e in Object(r))}}var ar=wd;function Od(e){var t=aa(e);return t.length==1&&t[0][2]?ar(t[0][0],t[0][1]):function(r){return r===e||ia(r,e,t)}}var sa=Od;function Cd(e,t){return e!=null&&t in Object(e)}var pa=Cd;function kd(e,t,r){t=Qe(t,e);for(var o=-1,n=t.length,i=!1;++o<n;){var a=ae(t[o]);if(!(i=e!=null&&r(e,a)))break;e=e[a]}return i||++o!=n?i:(n=e==null?0:e.length,!!n&&at(n)&&nt(a,n)&&(L(e)||Yt(e)))}var ua=kd;function Ed(e,t){return e!=null&&ua(e,t,pa)}var la=Ed;var Dd=1,Rd=2;function Vd(e,t){return He(e)&&ir(t)?ar(ae(e),t):function(r){var o=et(r,e);return o===void 0&&o===t?la(r,e):nr(t,o,Dd|Rd)}}var fa=Vd;function Nd(e){return function(t){return t==null?void 0:t[e]}}var sr=Nd;function Ld(e){return function(t){return Mt(t,e)}}var da=Ld;function Md(e){return He(e)?sr(ae(e)):da(e)}var ca=Md;function $d(e){return typeof e=="function"?e:e==null?ei:typeof e=="object"?L(e)?fa(e[0],e[1]):sa(e):ca(e)}var ma=$d;function Bd(e){return function(t,r,o){for(var n=-1,i=Object(t),a=o(t),s=a.length;s--;){var u=a[e?s:++n];if(r(i[u],u,i)===!1)break}return t}}var ha=Bd;var Fd=ha(),ga=Fd;function Ud(e,t){return e&&ga(e,t,st)}var ya=Ud;var zd=function(){return N.Date.now()},pr=zd;var qd="Expected a function",Wd=Math.max,Gd=Math.min;function Kd(e,t,r){var o,n,i,a,s,u,p=0,l=!1,c=!1,h=!0;if(typeof e!="function")throw new TypeError(qd);t=ce(t)||0,U(r)&&(l=!!r.leading,c="maxWait"in r,i=c?Wd(ce(r.maxWait)||0,t):i,h="trailing"in r?!!r.trailing:h);function f(A){var F=o,G=n;return o=n=void 0,p=A,a=e.apply(G,F),a}function y(A){return p=A,s=setTimeout(j,t),l?f(A):a}function x(A){var F=A-u,G=A-p,ie=t-F;return c?Gd(ie,i-G):ie}function S(A){var F=A-u,G=A-p;return u===void 0||F>=t||F<0||c&&G>=i}function j(){var A=pr();if(S(A))return T(A);s=setTimeout(j,x(A))}function T(A){return s=void 0,h&&o?f(A):(o=n=void 0,a)}function w(){s!==void 0&&clearTimeout(s),p=0,o=u=n=s=void 0}function $(){return s===void 0?a:T(pr())}function B(){var A=pr(),F=S(A);if(o=arguments,n=this,u=A,F){if(s===void 0)return y(u);if(c)return clearTimeout(s),s=setTimeout(j,t),f(u)}return s===void 0&&(s=setTimeout(j,t)),a}return B.cancel=w,B.flush=$,B}var io=Kd;function Hd(e){return typeof e=="number"&&e==Ht(e)}var ao=Hd;function Jd(e,t){var r={};return t=ma(t,3),ya(e,function(o,n,i){Kt(r,n,t(o,n,i))}),r}var so=Jd;var Yd=9007199254740991,Xd=Math.floor;function Zd(e,t){var r="";if(!e||t<1||t>Yd)return r;do t%2&&(r+=e),t=Xd(t/2),t&&(e+=e);while(t);return r}var po=Zd;var Qd=sr("length"),ba=Qd;var Pa="\\ud800-\\udfff",ec="\\u0300-\\u036f",tc="\\ufe20-\\ufe2f",rc="\\u20d0-\\u20ff",oc=ec+tc+rc,nc="\\ufe0e\\ufe0f",ic="["+Pa+"]",uo="["+oc+"]",lo="\\ud83c[\\udffb-\\udfff]",ac="(?:"+uo+"|"+lo+")",ja="[^"+Pa+"]",_a="(?:\\ud83c[\\udde6-\\uddff]){2}",xa="[\\ud800-\\udbff][\\udc00-\\udfff]",sc="\\u200d",Sa=ac+"?",Ta="["+nc+"]?",pc="(?:"+sc+"(?:"+[ja,_a,xa].join("|")+")"+Ta+Sa+")*",uc=Ta+Sa+pc,lc="(?:"+[ja+uo+"?",uo,_a,xa,ic].join("|")+")",va=RegExp(lo+"(?="+lo+")|"+lc+uc,"g");function fc(e){for(var t=va.lastIndex=0;va.test(e);)++t;return t}var Ia=fc;function dc(e){return pt(e)?Ia(e):ba(e)}var ur=dc;var cc=Math.ceil;function mc(e,t){t=t===void 0?" ":Nt(t);var r=t.length;if(r<2)return r?po(t,e):t;var o=po(t,cc(e/ur(t)));return pt(t)?bi(Ai(o),0,e).join(""):o.slice(0,e)}var Aa=mc;function hc(e,t,r){e=Lt(e),t=Ht(t);var o=t?ur(e):0;return t&&o<t?Aa(t-o,r)+e:e}var Be=hc;var wa=5*1e3,lr=class{constructor(t){d(this,"_cache",new Ie);d(this,"_keepHotUntapDebounce");ve(this,t)}get type(){return"Theatre_SheetObject_PublicAPI"}get props(){return _(this).propsP}get sheet(){return _(this).sheet.publicApi}get project(){return _(this).sheet.project.publicApi}get address(){return b({},_(this).address)}_valuesPrism(){return this._cache.get("_valuesPrism",()=>{let t=_(this);return g(()=>P(t.getValues().getValue()))})}onValuesChange(t){let r=_(this).sheet.ticker;return this._valuesPrism().onChange(r,t,!0)}get value(){let t=this._valuesPrism();if(wa!=null){if(!t.isHot){this._keepHotUntapDebounce!=null&&this._keepHotUntapDebounce.flush();let r=t.keepHot();this._keepHotUntapDebounce=io(()=>{r(),this._keepHotUntapDebounce=void 0},wa)}this._keepHotUntapDebounce&&this._keepHotUntapDebounce()}return t.getValue()}set initialValue(t){_(this).setInitialValue(t)}};function St(e){return e.type==="compound"||e.type==="enum"}function Tt(e,t){if(!e)return;let[r,...o]=t;if(r===void 0)return e;if(!St(e))return;let n=e.type==="enum"?e.cases[r]:e.props[r];return Tt(n,o)}function Oa(e){return!St(e)}var Lx=new WeakMap;var fr=class{constructor(t,r,o){this.sheet=t;this.template=r;this.nativeObject=o;d(this,"$$isIdentityPrismProvider",!0);d(this,"address");d(this,"publicApi");d(this,"_initialValue",new I({}));d(this,"_cache",new Ie);d(this,"_logger");d(this,"_internalUtilCtx");this._logger=t._logger.named("SheetObject",r.address.objectKey),this._logger._trace("creating object"),this._internalUtilCtx={logger:this._logger.utilFor.internal()},this.address=R(b({},r.address),{sheetInstanceId:t.address.sheetInstanceId}),this.publicApi=new lr(this)}get type(){return"Theatre_SheetObject"}getValues(){return this._cache.get("getValues()",()=>g(()=>{let t=P(this.template.getDefaultValues()),r=P(this._initialValue.pointer),o=g.memo("withInitialCache",()=>new WeakMap,[]),n=it(t,r,o),i=P(this.template.getStaticValues()),a=g.memo("withStatics",()=>new WeakMap,[]),u=it(n,i,a),p;{let c=g.memo("seq",()=>this.getSequencedValues(),[]),h=g.memo("withSeqsCache",()=>new WeakMap,[]);p=P(P(c)),u=it(u,p,h)}return Hn("finalAtom",u).pointer}))}getValueByPointer(t){let r=P(this.getValues()),{path:o}=De(t);return P(Me(r,o))}getIdentityPrism(t){return g(()=>{let r=P(this.getValues());return P(Me(r,t))})}getSequencedValues(){return g(()=>{let t=g.memo("tracksToProcess",()=>this.template.getArrayOfValidSequenceTracks(),[]),r=P(t),o=new I({}),n=P(this.template.configPointer);return g.effect("processTracks",()=>{let i=[];for(let{trackId:a,pathToProp:s}of r){let u=this._trackIdToPrism(a),p=Tt(n,s),l=p.deserializeAndSanitize,c=p.interpolate,h=()=>{let y=u.getValue();if(!y)return o.setByPointer(w=>Me(w,s),void 0);let x=l(y.left),S=x===void 0?p.default:x;if(y.right===void 0)return o.setByPointer(w=>Me(w,s),S);let j=l(y.right),T=j===void 0?p.default:j;return o.setByPointer(w=>Me(w,s),c(S,T,y.progression))},f=u.onStale(h);h(),i.push(f)}return()=>{for(let a of i)a()}},[n,...r]),o.pointer})}_trackIdToPrism(t){let r=this.template.project.pointers.historic.sheetsById[this.address.sheetId].sequence.tracksByObject[this.address.objectKey].trackData[t],o=this.sheet.getSequence().positionPrism;return Jr(this._internalUtilCtx,r,o)}get propsP(){return this._cache.get("propsP",()=>de({root:this,path:[]}))}validateValue(t,r){}setInitialValue(t){this.validateValue(this.propsP,t),this._initialValue.setState(t)}};function C(e){return function(r,o){return e(r,o())}}var M;(function(o){o[o.GENERAL=1]="GENERAL",o[o.TODO=2]="TODO",o[o.TROUBLESHOOTING=4]="TROUBLESHOOTING"})(M||(M={}));var D;(function(o){o[o.INTERNAL=8]="INTERNAL",o[o.DEV=16]="DEV",o[o.PUBLIC=32]="PUBLIC"})(D||(D={}));var v;(function(n){n[n.TRACE=64]="TRACE",n[n.DEBUG=128]="DEBUG",n[n.WARN=256]="WARN",n[n.ERROR=512]="ERROR"})(v||(v={}));var m;(function(f){f[f.ERROR_PUBLIC=545]="ERROR_PUBLIC",f[f.ERROR_DEV=529]="ERROR_DEV",f[f._HMM=524]="_HMM",f[f._TODO=522]="_TODO",f[f._ERROR=521]="_ERROR",f[f.WARN_PUBLIC=289]="WARN_PUBLIC",f[f.WARN_DEV=273]="WARN_DEV",f[f._KAPOW=268]="_KAPOW",f[f._WARN=265]="_WARN",f[f.DEBUG_DEV=145]="DEBUG_DEV",f[f._DEBUG=137]="_DEBUG",f[f.TRACE_DEV=81]="TRACE_DEV",f[f._TRACE=73]="_TRACE"})(m||(m={}));var Y={_hmm:X(524),_todo:X(522),_error:X(521),errorDev:X(529),errorPublic:X(545),_kapow:X(268),_warn:X(265),warnDev:X(273),warnPublic:X(289),_debug:X(137),debugDev:X(145),_trace:X(73),traceDev:X(81)};function X(e){return Object.freeze({audience:Fe(e,8)?"internal":Fe(e,16)?"dev":"public",category:Fe(e,4)?"troubleshooting":Fe(e,2)?"todo":"general",level:Fe(e,512)?512:Fe(e,256)?256:Fe(e,128)?128:64})}function Fe(e,t){return(e&t)===t}function k(e,t){return((t&32)==32?!0:(t&16)==16?e.dev:(t&8)==8?e.internal:!1)&&e.min<=t}var me={loggingConsoleStyle:!0,loggerConsoleStyle:!0,includes:Object.freeze({internal:!1,dev:!1,min:256}),filtered:function(){},include:function(){return{}},create:null,creatExt:null,named(e,t,r){return this.create({names:[...e.names,{name:t,key:r}]})},style:{bold:void 0,italic:void 0,cssMemo:new Map([["",""]]),collapseOnRE:/[a-z- ]+/g,color:void 0,collapsed(e){if(e.length<5)return e;let t=e.replace(this.collapseOnRE,"");return this.cssMemo.has(t)||this.cssMemo.set(t,this.css(e)),t},css(e){var o,n,i,a;let t=this.cssMemo.get(e);if(t)return t;let r=`color:${(n=(o=this.color)==null?void 0:o.call(this,e))!=null?n:`hsl(${(e.charCodeAt(0)+e.charCodeAt(e.length-1))%360}, 100%, 60%)`}`;return((i=this.bold)==null?void 0:i.test(e))&&(r+=";font-weight:600"),((a=this.italic)==null?void 0:a.test(e))&&(r+=";font-style:italic"),this.cssMemo.set(e,r),r}}};function vt(e=console,t={}){let r=R(b({},me),{includes:b({},me.includes)}),o={styled:bc.bind(r,e),noStyle:jc.bind(r,e)},n=yc.bind(r);function i(){return r.loggingConsoleStyle&&r.loggerConsoleStyle?o.styled:o.noStyle}return r.create=i(),{configureLogger(a){var s;a==="console"?(r.loggerConsoleStyle=me.loggerConsoleStyle,r.create=i()):a.type==="console"?(r.loggerConsoleStyle=(s=a.style)!=null?s:me.loggerConsoleStyle,r.create=i()):a.type==="keyed"?(r.creatExt=u=>a.keyed(u.names),r.create=n):a.type==="named"&&(r.creatExt=gc.bind(null,a.named),r.create=n)},configureLogging(a){var s,u,p,l,c;r.includes.dev=(s=a.dev)!=null?s:me.includes.dev,r.includes.internal=(u=a.internal)!=null?u:me.includes.internal,r.includes.min=(p=a.min)!=null?p:me.includes.min,r.include=(l=a.include)!=null?l:me.include,r.loggingConsoleStyle=(c=a.consoleStyle)!=null?c:me.loggingConsoleStyle,r.create=i()},getLogger(){return r.create({names:[]})}}}function gc(e,t){let r=[];for(let{name:o,key:n}of t.names)r.push(n==null?o:`${o} (${n})`);return e(r)}function yc(e){let t=b(b({},this.includes),this.include(e)),r=this.filtered,o=this.named.bind(this,e),n=this.creatExt(e),i=k(t,524),a=k(t,522),s=k(t,521),u=k(t,529),p=k(t,545),l=k(t,265),c=k(t,268),h=k(t,273),f=k(t,289),y=k(t,137),x=k(t,145),S=k(t,73),j=k(t,81),T=i?n.error.bind(n,Y._hmm):r.bind(e,524),w=a?n.error.bind(n,Y._todo):r.bind(e,522),$=s?n.error.bind(n,Y._error):r.bind(e,521),B=u?n.error.bind(n,Y.errorDev):r.bind(e,529),A=p?n.error.bind(n,Y.errorPublic):r.bind(e,545),F=c?n.warn.bind(n,Y._kapow):r.bind(e,268),G=l?n.warn.bind(n,Y._warn):r.bind(e,265),ie=h?n.warn.bind(n,Y.warnDev):r.bind(e,273),Ae=f?n.warn.bind(n,Y.warnPublic):r.bind(e,273),we=y?n.debug.bind(n,Y._debug):r.bind(e,137),Oe=x?n.debug.bind(n,Y.debugDev):r.bind(e,145),Ce=S?n.trace.bind(n,Y._trace):r.bind(e,73),ke=j?n.trace.bind(n,Y.traceDev):r.bind(e,81),V={_hmm:T,_todo:w,_error:$,errorDev:B,errorPublic:A,_kapow:F,_warn:G,warnDev:ie,warnPublic:Ae,_debug:we,debugDev:Oe,_trace:Ce,traceDev:ke,lazy:{_hmm:i?C(T):T,_todo:a?C(w):w,_error:s?C($):$,errorDev:u?C(B):B,errorPublic:p?C(A):A,_kapow:c?C(F):F,_warn:l?C(G):G,warnDev:h?C(ie):ie,warnPublic:f?C(Ae):Ae,_debug:y?C(we):we,debugDev:x?C(Oe):Oe,_trace:S?C(Ce):Ce,traceDev:j?C(ke):ke},named:o,utilFor:{internal(){return{debug:V._debug,error:V._error,warn:V._warn,trace:V._trace,named(K,O){return V.named(K,O).utilFor.internal()}}},dev(){return{debug:V.debugDev,error:V.errorDev,warn:V.warnDev,trace:V.traceDev,named(K,O){return V.named(K,O).utilFor.dev()}}},public(){return{error:V.errorPublic,warn:V.warnPublic,debug(K,O){V._warn(`(public "debug" filtered out) ${K}`,O)},trace(K,O){V._warn(`(public "trace" filtered out) ${K}`,O)},named(K,O){return V.named(K,O).utilFor.public()}}}}};return V}function bc(e,t){let r=b(b({},this.includes),this.include(t)),o=[],n="";for(let u=0;u<t.names.length;u++){let{name:p,key:l}=t.names[u];if(n+=` %c${p}`,o.push(this.style.css(p)),l!=null){let c=`%c#${l}`;n+=c,o.push(this.style.css(c))}}let i=this.filtered,a=this.named.bind(this,t),s=[n,...o];return Ca(i,t,r,e,s,Pc(s),a)}function Pc(e){let t=e.slice(0);for(let r=1;r<t.length;r++)t[r]+=";background-color:#e0005a;padding:2px;color:white";return t}function jc(e,t){let r=b(b({},this.includes),this.include(t)),o="";for(let s=0;s<t.names.length;s++){let{name:u,key:p}=t.names[s];o+=` ${u}`,p!=null&&(o+=`#${p}`)}let n=this.filtered,i=this.named.bind(this,t),a=[o];return Ca(n,t,r,e,a,a,i)}function Ca(e,t,r,o,n,i,a){let s=k(r,524),u=k(r,522),p=k(r,521),l=k(r,529),c=k(r,545),h=k(r,265),f=k(r,268),y=k(r,273),x=k(r,289),S=k(r,137),j=k(r,145),T=k(r,73),w=k(r,81),$=s?o.error.bind(o,...n):e.bind(t,524),B=u?o.error.bind(o,...n):e.bind(t,522),A=p?o.error.bind(o,...n):e.bind(t,521),F=l?o.error.bind(o,...n):e.bind(t,529),G=c?o.error.bind(o,...n):e.bind(t,545),ie=f?o.warn.bind(o,...i):e.bind(t,268),Ae=h?o.warn.bind(o,...n):e.bind(t,265),we=y?o.warn.bind(o,...n):e.bind(t,273),Oe=x?o.warn.bind(o,...n):e.bind(t,273),Ce=S?o.info.bind(o,...n):e.bind(t,137),ke=j?o.info.bind(o,...n):e.bind(t,145),V=T?o.debug.bind(o,...n):e.bind(t,73),K=w?o.debug.bind(o,...n):e.bind(t,81),O={_hmm:$,_todo:B,_error:A,errorDev:F,errorPublic:G,_kapow:ie,_warn:Ae,warnDev:we,warnPublic:Oe,_debug:Ce,debugDev:ke,_trace:V,traceDev:K,lazy:{_hmm:s?C($):$,_todo:u?C(B):B,_error:p?C(A):A,errorDev:l?C(F):F,errorPublic:c?C(G):G,_kapow:f?C(ie):ie,_warn:h?C(Ae):Ae,warnDev:y?C(we):we,warnPublic:x?C(Oe):Oe,_debug:S?C(Ce):Ce,debugDev:j?C(ke):ke,_trace:T?C(V):V,traceDev:w?C(K):K},named:a,utilFor:{internal(){return{debug:O._debug,error:O._error,warn:O._warn,trace:O._trace,named(pe,ue){return O.named(pe,ue).utilFor.internal()}}},dev(){return{debug:O.debugDev,error:O.errorDev,warn:O.warnDev,trace:O.traceDev,named(pe,ue){return O.named(pe,ue).utilFor.dev()}}},public(){return{error:O.errorPublic,warn:O.warnPublic,debug(pe,ue){O._warn(`(public "debug" filtered out) ${pe}`,ue)},trace(pe,ue){O._warn(`(public "trace" filtered out) ${pe}`,ue)},named(pe,ue){return O.named(pe,ue).utilFor.public()}}}}};return O}var ka=vt(console,{_debug:function(){},_error:function(){}});ka.configureLogging({dev:!0,min:v.TRACE});var ft=ka.getLogger().named("Theatre.js (default logger)").utilFor.dev();var Ea=new WeakMap;function fo(e){let t=Ea.get(e);if(t)return t;let r=new Map;return Ea.set(e,r),Da([],e,r),r}function Da(e,t,r){for(let[o,n]of Object.entries(t.props))if(!St(n)){let i=[...e,o];r.set(JSON.stringify(i),r.size),Ra(i,n,r)}for(let[o,n]of Object.entries(t.props))if(St(n)){let i=[...e,o];r.set(JSON.stringify(i),r.size),Ra(i,n,r)}}function Ra(e,t,r){if(t.type==="compound")Da(e,t,r);else{if(t.type==="enum")throw new Error("Enums aren't supported yet");r.set(JSON.stringify(e),r.size)}}var dr=class{constructor(t,r,o,n,i){this.sheetTemplate=t;d(this,"address");d(this,"type","Theatre_SheetObjectTemplate");d(this,"_config");d(this,"_actions");d(this,"_cache",new Ie);d(this,"project");this.address=R(b({},t.address),{objectKey:r}),this._config=new I(n),this._actions=new I(i),this.project=t.project}get staticConfig(){return this._config.getState()}get configPointer(){return this._config.pointer}get staticActions(){return this._actions.getState()}get actionsPointer(){return this._actions.pointer}createInstance(t,r,o){return this._config.setState(o),new fr(t,this,r)}reconfigure(t){this._config.setState(t)}registerAction(t,r){this._actions.setByPointer(o=>o[t],r)}getDefaultValues(){return this._cache.get("getDefaultValues()",()=>g(()=>{let t=P(this.configPointer);return Kr(t)}))}getStaticValues(){return this._cache.get("getStaticValues",()=>g(()=>{var i;let t=this.sheetTemplate.project.pointers.historic.sheetsById[this.address.sheetId],r=(i=P(t.staticOverrides.byObject[this.address.objectKey]))!=null?i:{};return P(this.configPointer).deserializeAndSanitize(r)||{}}))}getArrayOfValidSequenceTracks(){return this._cache.get("getArrayOfValidSequenceTracks",()=>g(()=>{let t=this.project.pointers.historic.sheetsById[this.address.sheetId],r=P(t.sequence.tracksByObject[this.address.objectKey].trackIdByPropPath);if(!r)return Gt;let o=[];if(!r)return Gt;let n=P(this.configPointer),i=Object.entries(r);for(let[s,u]of i){let p=_c(s);if(!p)continue;let l=Tt(n,p);!(l&&Oa(l))||o.push({pathToProp:p,trackId:u})}let a=fo(n);return o.sort((s,u)=>{let p=s.pathToProp,l=u.pathToProp,c=a.get(JSON.stringify(p)),h=a.get(JSON.stringify(l));return c>h?1:-1}),o.length===0?Gt:o}))}getMapOfValidSequenceTracks_forStudio(){return this._cache.get("getMapOfValidSequenceTracks_forStudio",()=>g(()=>{let t=P(this.getArrayOfValidSequenceTracks()),r={};for(let{pathToProp:o,trackId:n}of t)zn(r,o,n);return r}))}getDefaultsAtPointer(t){let{path:r}=De(t),o=this.getDefaultValues().getValue();return qr(o,r)}};function _c(e){try{return JSON.parse(e)}catch(t){ft.warn(`property ${JSON.stringify(e)} cannot be parsed. Skipping.`);return}}var Tc=Et($a());var Ba=class extends Error{},ee=class extends Ba{};function te(){let e,t,r=new Promise((n,i)=>{e=a=>{n(a),o.status="resolved"},t=a=>{i(a),o.status="rejected"}}),o={resolve:e,reject:t,promise:r,status:"pending"};return o}var vc=()=>{},dt=vc;var mr=class{constructor(t){this._ticker=t;d(this,"_stopPlayCallback",dt);d(this,"_state",new I({position:0,playing:!1}));d(this,"statePointer");this.statePointer=this._state.pointer}destroy(){}pause(){this._stopPlayCallback(),this.playing=!1,this._stopPlayCallback=dt}gotoPosition(t){this._updatePositionInState(t)}_updatePositionInState(t){this._state.setByPointer(r=>r.position,t)}getCurrentPosition(){return this._state.get().position}get playing(){return this._state.get().playing}set playing(t){this._state.setByPointer(r=>r.playing,t)}play(t,r,o,n){this.playing&&this.pause(),this.playing=!0;let i=this._ticker,a=r[1]-r[0];{let f=this.getCurrentPosition();f<r[0]||f>r[1]?n==="normal"||n==="alternate"?this._updatePositionInState(r[0]):(n==="reverse"||n==="alternateReverse")&&this._updatePositionInState(r[1]):n==="normal"||n==="alternate"?f===r[1]&&this._updatePositionInState(r[0]):f===r[0]&&this._updatePositionInState(r[1])}let s=te(),u=i.time,p=a*t,l=this.getCurrentPosition()-r[0];(n==="reverse"||n==="alternateReverse")&&(l=r[1]-this.getCurrentPosition());let c=f=>{let x=Math.max(f-u,0)/1e3,S=Math.min(x*o+l,p);if(S!==p){let j=Math.floor(S/a),T=S/a%1*a;if(n!=="normal")if(n==="reverse")T=a-T;else{let w=j%2==0;n==="alternate"?w||(T=a-T):w&&(T=a-T)}this._updatePositionInState(T+r[0]),h()}else{if(n==="normal")this._updatePositionInState(r[1]);else if(n==="reverse")this._updatePositionInState(r[0]);else{let j=(t-1)%2==0;n==="alternate"?j?this._updatePositionInState(r[1]):this._updatePositionInState(r[0]):j?this._updatePositionInState(r[0]):this._updatePositionInState(r[1])}this.playing=!1,s.resolve(!0)}};this._stopPlayCallback=()=>{i.offThisOrNextTick(c),i.offNextTick(c),this.playing&&s.resolve(!1)};let h=()=>i.onNextTick(c);return i.onThisOrNextTick(c),s.promise}playDynamicRange(t){this.playing&&this.pause(),this.playing=!0;let r=this._ticker,o=te(),n=t.keepHot();o.promise.then(n,n);let i=r.time,a=u=>{let p=Math.max(u-i,0);i=u;let l=p/1e3,c=this.getCurrentPosition(),h=t.getValue();if(c<h[0]||c>h[1])this.gotoPosition(h[0]);else{let f=c+l;f>h[1]&&(f=h[0]+(f-h[1])),this.gotoPosition(f)}s()};this._stopPlayCallback=()=>{r.offThisOrNextTick(a),r.offNextTick(a),o.resolve(!1)};let s=()=>r.onNextTick(a);return r.onThisOrNextTick(a),o.promise}};var Fa="__TheatreJS_StudioBundle",hr="__TheatreJS_CoreBundle",Ua="__TheatreJS_Notifications";var gr=e=>(...t)=>{var r;switch(e){case"success":{ft.debug(t.slice(0,2).join(`
`));break}case"info":{ft.debug(t.slice(0,2).join(`
`));break}case"warning":{ft.warn(t.slice(0,2).join(`
`));break}case"error":}return typeof window!="undefined"?(r=window[Ua])==null?void 0:r.notify[e](...t):void 0},ne={warning:gr("warning"),success:gr("success"),info:gr("info"),error:gr("error")};typeof window!="undefined"&&(window.addEventListener("error",e=>{ne.error("An error occurred",`<pre>${e.message}</pre>

See **console** for details.`)}),window.addEventListener("unhandledrejection",e=>{ne.error("An error occurred",`<pre>${e.reason}</pre>

See **console** for details.`)}));var yr=class{constructor(t,r,o,n){this._ticker=t;this._decodedBuffer=r;this._audioContext=o;this._nodeDestination=n;d(this,"_mainGain");d(this,"_state",new I({position:0,playing:!1}));d(this,"statePointer");d(this,"_stopPlayCallback",dt);this.statePointer=this._state.pointer,this._mainGain=this._audioContext.createGain(),this._mainGain.connect(this._nodeDestination)}playDynamicRange(t){let r=te();this._playing&&this.pause(),this._playing=!0;let o,n=()=>{o==null||o(),o=this._loopInRange(t.getValue()).stop},i=t.onStale(n);return n(),this._stopPlayCallback=()=>{o==null||o(),i(),r.resolve(!1)},r.promise}_loopInRange(t){let r=1,o=this._ticker,n=this.getCurrentPosition(),i=t[1]-t[0];n<t[0]||n>t[1]?this._updatePositionInState(t[0]):n===t[1]&&this._updatePositionInState(t[0]),n=this.getCurrentPosition();let a=this._audioContext.createBufferSource();a.buffer=this._decodedBuffer,a.connect(this._mainGain),a.playbackRate.value=r,a.loop=!0,a.loopStart=t[0],a.loopEnd=t[1];let s=o.time,u=n-t[0];a.start(0,n);let p=h=>{let S=(Math.max(h-s,0)/1e3*r+u)/i%1*i;this._updatePositionInState(S+t[0]),l()},l=()=>o.onNextTick(p);return o.onThisOrNextTick(p),{stop:()=>{a.stop(),a.disconnect(),o.offThisOrNextTick(p),o.offNextTick(p)}}}get _playing(){return this._state.get().playing}set _playing(t){this._state.setByPointer(r=>r.playing,t)}destroy(){}pause(){this._stopPlayCallback(),this._playing=!1,this._stopPlayCallback=dt}gotoPosition(t){this._updatePositionInState(t)}_updatePositionInState(t){this._state.reduce(r=>R(b({},r),{position:t}))}getCurrentPosition(){return this._state.get().position}play(t,r,o,n){this._playing&&this.pause(),this._playing=!0;let i=this._ticker,a=this.getCurrentPosition(),s=r[1]-r[0];if(n!=="normal")throw new ee(`Audio-controlled sequences can only be played in the "normal" direction. '${n}' given.`);a<r[0]||a>r[1]?this._updatePositionInState(r[0]):a===r[1]&&this._updatePositionInState(r[0]),a=this.getCurrentPosition();let u=te(),p=this._audioContext.createBufferSource();p.buffer=this._decodedBuffer,p.connect(this._mainGain),p.playbackRate.value=o,t>1e3&&(ne.warning("Can't play sequences with audio more than 1000 times",`The sequence will still play, but only 1000 times. The \`iterationCount: ${t}\` provided to \`sequence.play()\`
is too high for a sequence with audio.

To fix this, either set \`iterationCount\` to a lower value, or remove the audio from the sequence.`,[{url:"https://www.theatrejs.com/docs/latest/manual/audio",title:"Using Audio"},{url:"https://www.theatrejs.com/docs/latest/api/core#sequence.attachaudio",title:"Audio API"}]),t=1e3),t>1&&(p.loop=!0,p.loopStart=r[0],p.loopEnd=r[1]);let l=i.time,c=a-r[0],h=s*t;p.start(0,a,h-c);let f=S=>{let T=Math.max(S-l,0)/1e3,w=Math.min(T*o+c,h);if(w!==h){let $=w/s%1*s;this._updatePositionInState($+r[0]),x()}else this._updatePositionInState(r[1]),this._playing=!1,y(),u.resolve(!0)},y=()=>{p.stop(),p.disconnect()};this._stopPlayCallback=()=>{y(),i.offThisOrNextTick(f),i.offNextTick(f),this._playing&&u.resolve(!1)};let x=()=>i.onNextTick(f);return i.onThisOrNextTick(f),u.promise}};var br=class{get type(){return"Theatre_Sequence_PublicAPI"}constructor(t){ve(this,t)}play(t){let r=_(this);if(r._project.isReady())return r.play(t);{let o=te();return o.resolve(!0),o.promise}}pause(){_(this).pause()}get position(){return _(this).position}set position(t){_(this).position=t}async attachAudio(t){let{audioContext:r,destinationNode:o,decodedBuffer:n,gainNode:i}=await Ic(t),a=new yr(_(this)._sheet.ticker,n,r,i);return _(this).replacePlaybackController(a),{audioContext:r,destinationNode:o,decodedBuffer:n,gainNode:i}}get pointer(){return _(this).pointer}};async function Ic(e){function t(){if(e.audioContext)return Promise.resolve(e.audioContext);let p=new AudioContext;return p.state==="running"||typeof window=="undefined"?Promise.resolve(p):new Promise(l=>{let c=()=>{p.resume()},h=["mousedown","keydown","touchstart"],f={capture:!0,passive:!1};h.forEach(y=>{window.addEventListener(y,c,f)}),p.addEventListener("statechange",()=>{p.state==="running"&&(h.forEach(y=>{window.removeEventListener(y,c,f)}),l(p))})})}async function r(){if(e.source instanceof AudioBuffer)return e.source;let p=te();if(typeof e.source!="string")throw new Error("Error validating arguments to sequence.attachAudio(). args.source must either be a string or an instance of AudioBuffer.");let l;try{l=await fetch(e.source)}catch(y){throw console.error(y),new Error(`Could not fetch '${e.source}'. Network error logged above.`)}let c;try{c=await l.arrayBuffer()}catch(y){throw console.error(y),new Error(`Could not read '${e.source}' as an arrayBuffer.`)}(await o).decodeAudioData(c,p.resolve,p.reject);let f;try{f=await p.promise}catch(y){throw console.error(y),new Error(`Could not decode ${e.source} as an audio file.`)}return f}let o=t(),n=r(),[i,a]=await Promise.all([o,n]),s=e.destinationNode||i.destination,u=i.createGain();return u.connect(s),{audioContext:i,decodedBuffer:a,gainNode:u,destinationNode:s}}var Pr=class{constructor(t,r,o,n,i){this._project=t;this._sheet=r;this._lengthD=o;this._subUnitsPerUnitD=n;d(this,"address");d(this,"publicApi");d(this,"_playbackControllerBox");d(this,"_prismOfStatePointer");d(this,"_positionD");d(this,"_positionFormatterD");d(this,"_playableRangeD");d(this,"pointer",de({root:this,path:[]}));d(this,"$$isIdentityPrismProvider",!0);d(this,"_logger");d(this,"closestGridPosition",t=>{let r=this.subUnitsPerUnit,o=1/r;return parseFloat((Math.round(t/o)*o).toFixed(3))});this._logger=t._logger.named("Sheet",r.address.sheetId).named("Instance",r.address.sheetInstanceId),this.address=R(b({},this._sheet.address),{sequenceName:"default"}),this.publicApi=new br(this),this._playbackControllerBox=new I(i!=null?i:new mr(r.ticker)),this._prismOfStatePointer=g(()=>this._playbackControllerBox.prism.getValue().statePointer),this._positionD=g(()=>{let a=this._prismOfStatePointer.getValue();return P(a.position)}),this._positionFormatterD=g(()=>{let a=P(this._subUnitsPerUnitD);return new za(a)})}getIdentityPrism(t){if(t.length===0)return g(()=>({length:P(this.pointer.length),playing:P(this.pointer.playing),position:P(this.pointer.position)}));if(t.length>1)return g(()=>{});let[r]=t;return r==="length"?this._lengthD:r==="position"?this._positionD:r==="playing"?g(()=>P(this._prismOfStatePointer.getValue().playing)):g(()=>{})}get positionFormatter(){return this._positionFormatterD.getValue()}get prismOfStatePointer(){return this._prismOfStatePointer}get length(){return this._lengthD.getValue()}get positionPrism(){return this._positionD}get position(){return this._playbackControllerBox.getState().getCurrentPosition()}get subUnitsPerUnit(){return this._subUnitsPerUnitD.getValue()}get positionSnappedToGrid(){return this.closestGridPosition(this.position)}set position(t){let r=t;this.pause(),r>this.length&&(r=this.length);let o=this.length;this._playbackControllerBox.getState().gotoPosition(r>o?o:r)}getDurationCold(){return this._lengthD.getValue()}get playing(){return P(this._playbackControllerBox.getState().statePointer.playing)}_makeRangeFromSequenceTemplate(){return g(()=>[0,P(this._lengthD)])}playDynamicRange(t){return this._playbackControllerBox.getState().playDynamicRange(t)}async play(t){let r=this.length,o=t&&t.range?t.range:[0,r],n=t&&typeof t.iterationCount=="number"?t.iterationCount:1,i=t&&typeof t.rate!="undefined"?t.rate:1,a=t&&t.direction?t.direction:"normal";return await this._play(n,[o[0],o[1]],i,a)}_play(t,r,o,n){return this._playbackControllerBox.getState().play(t,r,o,n)}pause(){this._playbackControllerBox.getState().pause()}replacePlaybackController(t){this.pause();let r=this._playbackControllerBox.getState();this._playbackControllerBox.setState(t);let o=r.getCurrentPosition();r.destroy(),t.gotoPosition(o)}},za=class{constructor(t){this._fps=t}formatSubUnitForGrid(t){let r=t%1,o=1/this._fps;return Math.round(r/o)+"f"}formatFullUnitForGrid(t){let r=t,o="";r>=ct&&(o+=Math.floor(r/ct)+"h",r=r%ct),r>=ze&&(o+=Math.floor(r/ze)+"m",r=r%ze),r>=Ue&&(o+=Math.floor(r/Ue)+"s",r=r%Ue);let n=1/this._fps;return r>=n&&(o+=Math.floor(r/n)+"f",r=r%n),o.length===0?"0s":o}formatForPlayhead(t){let r=t,o="";if(r>=ct){let i=Math.floor(r/ct);o+=Be(i.toString(),2,"0")+"h",r=r%ct}if(r>=ze){let i=Math.floor(r/ze);o+=Be(i.toString(),2,"0")+"m",r=r%ze}else o.length>0&&(o+="00m");if(r>=Ue){let i=Math.floor(r/Ue);o+=Be(i.toString(),2,"0")+"s",r=r%Ue}else o+="00s";let n=1/this._fps;if(r>=n){let i=Math.round(r/n);o+=Be(i.toString(),2,"0")+"f",r=r%n}else r/n>.98?(o+=Be(1 .toString(),2,"0")+"f",r=r%n):o+="00f";return o.length===0?"00s00f":o}formatBasic(t){return t.toFixed(2)+"s"}},Ue=1,ze=Ue*60,ct=ze*60;var Sr={};Lr(Sr,{boolean:()=>yo,compound:()=>It,image:()=>Ec,number:()=>go,rgba:()=>Lc,string:()=>bo,stringLiteral:()=>Uc});function jr(e,t){return e.length<=t?e:e.substr(0,t-3)+"..."}var Ac=e=>typeof e=="string"?`string("${jr(e,10)}")`:typeof e=="number"?`number(${jr(String(e),10)})`:e===null?"null":e===void 0?"undefined":typeof e=="boolean"?String(e):Array.isArray(e)?"array":typeof e=="object"?"object":"unknown",mt=Ac;function wc(e,{removeAlphaIfOpaque:t=!1}={}){let r=(e.a*255|1<<8).toString(16).slice(1);return`#${(e.r*255|1<<8).toString(16).slice(1)+(e.g*255|1<<8).toString(16).slice(1)+(e.b*255|1<<8).toString(16).slice(1)+(t&&r==="ff"?"":r)}`}function _r(e){return R(b({},e),{toString(){return wc(this,{removeAlphaIfOpaque:!0})}})}function Oc(e){return Object.fromEntries(Object.entries(e).map(([t,r])=>[t,xt(r,0,1)]))}function qa(e){function t(r){return r>=.0031308?1.055*r**(1/2.4)-.055:12.92*r}return Oc({r:t(e.r),g:t(e.g),b:t(e.b),a:e.a})}function mo(e){function t(r){return r>=.04045?((r+.055)/(1+.055))**2.4:r/12.92}return{r:t(e.r),g:t(e.g),b:t(e.b),a:e.a}}function ho(e){let t=.4122214708*e.r+.5363325363*e.g+.0514459929*e.b,r=.2119034982*e.r+.6806995451*e.g+.1073969566*e.b,o=.0883024619*e.r+.2817188376*e.g+.6299787005*e.b,n=Math.cbrt(t),i=Math.cbrt(r),a=Math.cbrt(o);return{L:.2104542553*n+.793617785*i-.0040720468*a,a:1.9779984951*n-2.428592205*i+.4505937099*a,b:.0259040371*n+.7827717662*i-.808675766*a,alpha:e.a}}function Wa(e){let t=e.L+.3963377774*e.a+.2158037573*e.b,r=e.L-.1055613458*e.a-.0638541728*e.b,o=e.L-.0894841775*e.a-1.291485548*e.b,n=t*t*t,i=r*r*r,a=o*o*o;return{r:4.0767416621*n-3.3077115913*i+.2309699292*a,g:-1.2684380046*n+2.6097574011*i-.3413193965*a,b:-.0041960863*n-.7034186147*i+1.707614701*a,a:e.alpha}}var he=Symbol("TheatrePropType_Basic");function Ga(e){return typeof e=="object"&&!!e&&e[he]==="TheatrePropType"}function Cc(e){if(typeof e=="number")return go(e);if(typeof e=="boolean")return yo(e);if(typeof e=="string")return bo(e);if(typeof e=="object"&&!!e){if(Ga(e))return e;if(Pt(e))return It(e);throw new ee(`This value is not a valid prop type: ${mt(e)}`)}else throw new ee(`This value is not a valid prop type: ${mt(e)}`)}function Ka(e){let t={};for(let r of Object.keys(e)){let o=e[r];Ga(o)?t[r]=o:t[r]=Cc(o)}return t}var kc=(e,t)=>{},It=(e,t={})=>{kc("t.compound(props, opts)",t);let r=Ka(e),o=new WeakMap;return{type:"compound",props:r,valueType:null,[he]:"TheatrePropType",label:t.label,default:so(r,i=>i.default),deserializeAndSanitize:i=>{if(typeof i!="object"||!i)return;if(o.has(i))return o.get(i);let a={},s=!1;for(let[u,p]of Object.entries(r))if(Object.prototype.hasOwnProperty.call(i,u)){let l=p.deserializeAndSanitize(i[u]);l!=null&&(s=!0,a[u]=l)}if(o.set(i,a),s)return a}}},Ec=(e,t={})=>{let r=(o,n,i)=>{var s;let a=(s=t.interpolate)!=null?s:xr;return{type:"image",id:a(o.id,n.id,i)}};return{type:"image",default:{type:"image",id:e},valueType:null,[he]:"TheatrePropType",label:t.label,interpolate:r,deserializeAndSanitize:Dc}},Dc=e=>{if(!e)return;let t=!0;if(typeof e.id!="string"&&![null,void 0].includes(e.id)&&(t=!1),e.type!=="image"&&(t=!1),!!t)return e},go=(e,t={})=>{var r;return R(b({type:"number",valueType:0,default:e,[he]:"TheatrePropType"},t||{}),{label:t.label,nudgeFn:(r=t.nudgeFn)!=null?r:zc,nudgeMultiplier:typeof t.nudgeMultiplier=="number"?t.nudgeMultiplier:void 0,interpolate:Nc,deserializeAndSanitize:Rc(t.range)})},Rc=e=>e?t=>{if(!!(typeof t=="number"&&isFinite(t)))return xt(t,e[0],e[1])}:Vc,Vc=e=>typeof e=="number"&&isFinite(e)?e:void 0,Nc=(e,t,r)=>e+r*(t-e),Lc=(e={r:0,g:0,b:0,a:1},t={})=>{let r={};for(let o of["r","g","b","a"])r[o]=Math.min(Math.max(e[o],0),1);return{type:"rgba",valueType:null,default:_r(r),[he]:"TheatrePropType",label:t.label,interpolate:$c,deserializeAndSanitize:Mc}},Mc=e=>{if(!e)return;let t=!0;for(let o of["r","g","b","a"])(!Object.prototype.hasOwnProperty.call(e,o)||typeof e[o]!="number")&&(t=!1);if(!t)return;let r={};for(let o of["r","g","b","a"])r[o]=Math.min(Math.max(e[o],0),1);return _r(r)},$c=(e,t,r)=>{let o=ho(mo(e)),n=ho(mo(t)),i={L:(1-r)*o.L+r*n.L,a:(1-r)*o.a+r*n.a,b:(1-r)*o.b+r*n.b,alpha:(1-r)*o.alpha+r*n.alpha},a=qa(Wa(i));return _r(a)},yo=(e,t={})=>{var r;return{type:"boolean",default:e,valueType:null,[he]:"TheatrePropType",label:t.label,interpolate:(r=t.interpolate)!=null?r:xr,deserializeAndSanitize:Bc}},Bc=e=>typeof e=="boolean"?e:void 0;function xr(e){return e}var bo=(e,t={})=>{var r;return{type:"string",default:e,valueType:null,[he]:"TheatrePropType",label:t.label,interpolate:(r=t.interpolate)!=null?r:xr,deserializeAndSanitize:Fc}};function Fc(e){return typeof e=="string"?e:void 0}function Uc(e,t,r={}){var o,n;return{type:"stringLiteral",default:e,valuesAndLabels:b({},t),[he]:"TheatrePropType",valueType:null,as:(o=r.as)!=null?o:"menu",label:r.label,interpolate:(n=r.interpolate)!=null?n:xr,deserializeAndSanitize(i){if(typeof i=="string"&&Object.prototype.hasOwnProperty.call(t,i))return i}}}var zc=({config:e,deltaX:t,deltaFraction:r,magnitude:o})=>{var i;let{range:n}=e;return console.log(t,r,e),!e.nudgeMultiplier&&n&&!n.includes(1/0)&&!n.includes(-1/0)?r*(n[1]-n[0])*o:t*o*((i=e.nudgeMultiplier)!=null?i:1)};var qc=e=>e.replace(/^[\s\/]*/,"").replace(/[\s\/]*$/,"").replace(/\s*\/\s*/g," / "),Wc=e=>{if(typeof e!="string")return`it is not a string. (it is a ${typeof e})`;let t=e.split(/\//);if(t.length===0)return"it is empty.";for(let r=0;r<t.length;r++){let o=t[r].trim();if(o.length===0)return`the component #${r+1} is empty.`;if(o.length>32)return`the component '${o}' must have 32 characters or less.`}};function At(e,t){let r=qc(e);return r}var jT=Et(Po());var ST=new WeakMap,Tr=class{get type(){return"Theatre_Sheet_PublicAPI"}constructor(t){ve(this,t)}object(t,r,o){let n=_(this),i=At(t,"sheet.object"),a=n.getObject(i),s=null;if(a)return(o==null?void 0:o.actions)&&(Object.entries(o.actions).forEach(([u,p])=>{a.template.registerAction(u,p)}),console.log("registered actions",o.actions)),a.publicApi;{let u=It(r);return n.createObject(i,s,u,o==null?void 0:o.actions).publicApi}}get sequence(){return _(this).getSequence().publicApi}get project(){return _(this).project.publicApi}get address(){return b({},_(this).address)}get ticker(){return _(this).ticker}detachObject(t){let r=_(this),o=At(t,`sheet.deleteObject("${t}")`);if(!r.getObject(o)){ne.warning(`Couldn't delete object "${o}"`,`There is no object with key "${o}".

To fix this, make sure you are calling \`sheet.deleteObject("${o}")\` with the correct key.`),console.warn(`Object key "${o}" does not exist.`);return}r.deleteObject(o)}};var wt;function jo(e){if(wt)throw new Error("coreTicker is already set");wt=e}function qe(){return wt||(wt=se.raf),wt}var vr=class{constructor(t,r){this.template=t;this.config=r;d(this,"_objects",new I({}));d(this,"_sequence");d(this,"address");d(this,"publicApi");d(this,"project");d(this,"objectsP",this._objects.pointer);d(this,"type","Theatre_Sheet");d(this,"_logger");d(this,"_ticker");this._logger=t.project._logger.named("Sheet",r.instanceId),this._logger._trace("creating sheet"),this.project=t.project,this.address=R(b({},t.address),{sheetInstanceId:r.instanceId}),this._ticker=r.ticker,this.publicApi=new Tr(this)}createObject(t,r,o,n={}){let a=this.template.getObjectTemplate(t,r,o,n).createInstance(this,r,o);return this._objects.setByPointer(s=>s[t],a),a}getObject(t){return this._objects.getState()[t]}deleteObject(t){this._objects.reduce(r=>{let o=b({},r);return delete o[t],o})}getSequence(){if(!this._sequence){let t=g(()=>{let o=P(this.project.pointers.historic.sheetsById[this.address.sheetId].sequence.length);return Gc(o)}),r=g(()=>{let o=P(this.project.pointers.historic.sheetsById[this.address.sheetId].sequence.subUnitsPerUnit);return Kc(o)});this._sequence=new Pr(this.template.project,this,t,r)}return this._sequence}get ticker(){var t;return(t=this._ticker)!=null?t:qe()}set ticker(t){this._ticker=t}},Gc=e=>typeof e=="number"&&isFinite(e)&&e>0?e:10,Kc=e=>typeof e=="number"&&ao(e)&&e>=1&&e<=1e3?e:30;var Ir=class{constructor(t,r){this.project=t;d(this,"type","Theatre_SheetTemplate");d(this,"address");d(this,"_instances",new I({}));d(this,"instancesP",this._instances.pointer);d(this,"_objectTemplates",new I({}));d(this,"objectTemplatesP",this._objectTemplates.pointer);this.address=R(b({},t.address),{sheetId:r})}getInstance(t){let r=this._instances.getState()[t.instanceId];return r?t.ticker&&(r.ticker=t.ticker):(r=new vr(this,t),this._instances.setByPointer(o=>o[t.instanceId],r)),r}getObjectTemplate(t,r,o,n){let i=this._objectTemplates.getState()[t];return i||(i=new dr(this,t,r,o,n),this._objectTemplates.setByPointer(a=>a[t],i)),i}};var Hc=e=>new Promise(t=>setTimeout(t,e)),Ja=Hc;function re(e){for(var t=arguments.length,r=Array(t>1?t-1:0),o=1;o<t;o++)r[o-1]=arguments[o];if(!1)var n,i;throw Error("[Immer] minified error nr: "+e+(r.length?" "+r.map(function(a){return"'"+a+"'"}).join(","):"")+". Find the full error at: https://bit.ly/3cXEKWf")}function We(e){return!!e&&!!e[W]}function Ge(e){return!!e&&(function(t){if(!t||typeof t!="object")return!1;var r=Object.getPrototypeOf(t);if(r===null)return!0;var o=Object.hasOwnProperty.call(r,"constructor")&&r.constructor;return o===Object||typeof o=="function"&&Function.toString.call(o)===rm}(e)||Array.isArray(e)||!!e[as]||!!e.constructor[as]||xo(e)||So(e))}function Ya(e){return We(e)||re(23,e),e[W].t}function Ot(e,t,r){r===void 0&&(r=!1),ht(e)===0?(r?Object.keys:Vo)(e).forEach(function(o){r&&typeof o=="symbol"||t(o,e[o],e)}):e.forEach(function(o,n){return t(n,o,e)})}function ht(e){var t=e[W];return t?t.i>3?t.i-4:t.i:Array.isArray(e)?1:xo(e)?2:So(e)?3:0}function _o(e,t){return ht(e)===2?e.has(t):Object.prototype.hasOwnProperty.call(e,t)}function Jc(e,t){return ht(e)===2?e.get(t):e[t]}function Xa(e,t,r){var o=ht(e);o===2?e.set(t,r):o===3?(e.delete(t),e.add(r)):e[t]=r}function Yc(e,t){return e===t?e!==0||1/e==1/t:e!=e&&t!=t}function xo(e){return em&&e instanceof Map}function So(e){return tm&&e instanceof Set}function Ke(e){return e.o||e.t}function To(e){if(Array.isArray(e))return Array.prototype.slice.call(e);var t=om(e);delete t[W];for(var r=Vo(t),o=0;o<r.length;o++){var n=r[o],i=t[n];i.writable===!1&&(i.writable=!0,i.configurable=!0),(i.get||i.set)&&(t[n]={configurable:!0,writable:!0,enumerable:i.enumerable,value:e[n]})}return Object.create(Object.getPrototypeOf(e),t)}function vo(e,t){return t===void 0&&(t=!1),Io(e)||We(e)||!Ge(e)||(ht(e)>1&&(e.set=e.add=e.clear=e.delete=Xc),Object.freeze(e),t&&Ot(e,function(r,o){return vo(o,!0)},!0)),e}function Xc(){re(2)}function Io(e){return e==null||typeof e!="object"||Object.isFrozen(e)}function ge(e){var t=nm[e];return t||re(18,e),t}function Za(){return Ct}function Ao(e,t){t&&(ge("Patches"),e.u=[],e.s=[],e.v=t)}function Ar(e){wo(e),e.p.forEach(Zc),e.p=null}function wo(e){e===Ct&&(Ct=e.l)}function Qa(e){return Ct={p:[],l:Ct,h:e,m:!0,_:0}}function Zc(e){var t=e[W];t.i===0||t.i===1?t.j():t.O=!0}function Oo(e,t){t._=t.p.length;var r=t.p[0],o=e!==void 0&&e!==r;return t.h.g||ge("ES5").S(t,e,o),o?(r[W].P&&(Ar(t),re(4)),Ge(e)&&(e=wr(t,e),t.l||Or(t,e)),t.u&&ge("Patches").M(r[W],e,t.u,t.s)):e=wr(t,r,[]),Ar(t),t.u&&t.v(t.u,t.s),e!==is?e:void 0}function wr(e,t,r){if(Io(t))return t;var o=t[W];if(!o)return Ot(t,function(i,a){return es(e,o,t,i,a,r)},!0),t;if(o.A!==e)return t;if(!o.P)return Or(e,o.t,!0),o.t;if(!o.I){o.I=!0,o.A._--;var n=o.i===4||o.i===5?o.o=To(o.k):o.o;Ot(o.i===3?new Set(n):n,function(i,a){return es(e,o,n,i,a,r)}),Or(e,n,!1),r&&e.u&&ge("Patches").R(o,r,e.u,e.s)}return o.o}function es(e,t,r,o,n,i){if(We(n)){var a=wr(e,n,i&&t&&t.i!==3&&!_o(t.D,o)?i.concat(o):void 0);if(Xa(r,o,a),!We(a))return;e.m=!1}if(Ge(n)&&!Io(n)){if(!e.h.F&&e._<1)return;wr(e,n),t&&t.A.l||Or(e,n)}}function Or(e,t,r){r===void 0&&(r=!1),e.h.F&&e.m&&vo(t,r)}function Co(e,t){var r=e[W];return(r?Ke(r):e)[t]}function ts(e,t){if(t in e)for(var r=Object.getPrototypeOf(e);r;){var o=Object.getOwnPropertyDescriptor(r,t);if(o)return o;r=Object.getPrototypeOf(r)}}function ko(e){e.P||(e.P=!0,e.l&&ko(e.l))}function Eo(e){e.o||(e.o=To(e.t))}function Do(e,t,r){var o=xo(t)?ge("MapSet").N(t,r):So(t)?ge("MapSet").T(t,r):e.g?function(n,i){var a=Array.isArray(n),s={i:a?1:0,A:i?i.A:Za(),P:!1,I:!1,D:{},l:i,t:n,k:null,o:null,j:null,C:!1},u=s,p=Cr;a&&(u=[s],p=kr);var l=Proxy.revocable(u,p),c=l.revoke,h=l.proxy;return s.k=h,s.j=c,h}(t,r):ge("ES5").J(t,r);return(r?r.A:Za()).p.push(o),o}function Qc(e){return We(e)||re(22,e),function t(r){if(!Ge(r))return r;var o,n=r[W],i=ht(r);if(n){if(!n.P&&(n.i<4||!ge("ES5").K(n)))return n.t;n.I=!0,o=rs(r,i),n.I=!1}else o=rs(r,i);return Ot(o,function(a,s){n&&Jc(n.t,a)===s||Xa(o,a,t(s))}),i===3?new Set(o):o}(e)}function rs(e,t){switch(t){case 2:return new Map(e);case 3:return Array.from(e)}return To(e)}var os,Ct,Ro=typeof Symbol!="undefined"&&typeof Symbol("x")=="symbol",em=typeof Map!="undefined",tm=typeof Set!="undefined",ns=typeof Proxy!="undefined"&&Proxy.revocable!==void 0&&typeof Reflect!="undefined",is=Ro?Symbol.for("immer-nothing"):((os={})["immer-nothing"]=!0,os),as=Ro?Symbol.for("immer-draftable"):"__$immer_draftable",W=Ro?Symbol.for("immer-state"):"__$immer_state",MT=typeof Symbol!="undefined"&&Symbol.iterator||"@@iterator";var rm=""+Object.prototype.constructor,Vo=typeof Reflect!="undefined"&&Reflect.ownKeys?Reflect.ownKeys:Object.getOwnPropertySymbols!==void 0?function(e){return Object.getOwnPropertyNames(e).concat(Object.getOwnPropertySymbols(e))}:Object.getOwnPropertyNames,om=Object.getOwnPropertyDescriptors||function(e){var t={};return Vo(e).forEach(function(r){t[r]=Object.getOwnPropertyDescriptor(e,r)}),t},nm={},Cr={get:function(e,t){if(t===W)return e;var r=Ke(e);if(!_o(r,t))return function(n,i,a){var s,u=ts(i,a);return u?"value"in u?u.value:(s=u.get)===null||s===void 0?void 0:s.call(n.k):void 0}(e,r,t);var o=r[t];return e.I||!Ge(o)?o:o===Co(e.t,t)?(Eo(e),e.o[t]=Do(e.A.h,o,e)):o},has:function(e,t){return t in Ke(e)},ownKeys:function(e){return Reflect.ownKeys(Ke(e))},set:function(e,t,r){var o=ts(Ke(e),t);if(o==null?void 0:o.set)return o.set.call(e.k,r),!0;if(!e.P){var n=Co(Ke(e),t),i=n==null?void 0:n[W];if(i&&i.t===r)return e.o[t]=r,e.D[t]=!1,!0;if(Yc(r,n)&&(r!==void 0||_o(e.t,t)))return!0;Eo(e),ko(e)}return e.o[t]===r&&typeof r!="number"&&(r!==void 0||t in e.o)||(e.o[t]=r,e.D[t]=!0,!0)},deleteProperty:function(e,t){return Co(e.t,t)!==void 0||t in e.t?(e.D[t]=!1,Eo(e),ko(e)):delete e.D[t],e.o&&delete e.o[t],!0},getOwnPropertyDescriptor:function(e,t){var r=Ke(e),o=Reflect.getOwnPropertyDescriptor(r,t);return o&&{writable:!0,configurable:e.i!==1||t!=="length",enumerable:o.enumerable,value:r[t]}},defineProperty:function(){re(11)},getPrototypeOf:function(e){return Object.getPrototypeOf(e.t)},setPrototypeOf:function(){re(12)}},kr={};Ot(Cr,function(e,t){kr[e]=function(){return arguments[0]=arguments[0][0],t.apply(this,arguments)}}),kr.deleteProperty=function(e,t){return Cr.deleteProperty.call(this,e[0],t)},kr.set=function(e,t,r){return Cr.set.call(this,e[0],t,r,e[0])};var im=function(){function e(r){var o=this;this.g=ns,this.F=!0,this.produce=function(n,i,a){if(typeof n=="function"&&typeof i!="function"){var s=i;i=n;var u=o;return function(f){var y=this;f===void 0&&(f=s);for(var x=arguments.length,S=Array(x>1?x-1:0),j=1;j<x;j++)S[j-1]=arguments[j];return u.produce(f,function(T){var w;return(w=i).call.apply(w,[y,T].concat(S))})}}var p;if(typeof i!="function"&&re(6),a!==void 0&&typeof a!="function"&&re(7),Ge(n)){var l=Qa(o),c=Do(o,n,void 0),h=!0;try{p=i(c),h=!1}finally{h?Ar(l):wo(l)}return typeof Promise!="undefined"&&p instanceof Promise?p.then(function(f){return Ao(l,a),Oo(f,l)},function(f){throw Ar(l),f}):(Ao(l,a),Oo(p,l))}if(!n||typeof n!="object")return(p=i(n))===is?void 0:(p===void 0&&(p=n),o.F&&vo(p,!0),p);re(21,n)},this.produceWithPatches=function(n,i){return typeof n=="function"?function(u){for(var p=arguments.length,l=Array(p>1?p-1:0),c=1;c<p;c++)l[c-1]=arguments[c];return o.produceWithPatches(u,function(h){return n.apply(void 0,[h].concat(l))})}:[o.produce(n,i,function(u,p){a=u,s=p}),a,s];var a,s},typeof(r==null?void 0:r.useProxies)=="boolean"&&this.setUseProxies(r.useProxies),typeof(r==null?void 0:r.autoFreeze)=="boolean"&&this.setAutoFreeze(r.autoFreeze)}var t=e.prototype;return t.createDraft=function(r){Ge(r)||re(8),We(r)&&(r=Qc(r));var o=Qa(this),n=Do(this,r,void 0);return n[W].C=!0,wo(o),n},t.finishDraft=function(r,o){var n=r&&r[W],i=n.A;return Ao(i,o),Oo(void 0,i)},t.setAutoFreeze=function(r){this.F=r},t.setUseProxies=function(r){r&&!ns&&re(20),this.g=r},t.applyPatches=function(r,o){var n;for(n=o.length-1;n>=0;n--){var i=o[n];if(i.path.length===0&&i.op==="replace"){r=i.value;break}}var a=ge("Patches").$;return We(r)?a(r,o):this.produce(r,function(s){return a(s,o.slice(n+1))})},e}(),Z=new im,$T=Z.produce,BT=Z.produceWithPatches.bind(Z),FT=Z.setAutoFreeze.bind(Z),UT=Z.setUseProxies.bind(Z),zT=Z.applyPatches.bind(Z),qT=Z.createDraft.bind(Z),WT=Z.finishDraft.bind(Z);var am={currentProjectStateDefinitionVersion:"0.4.0"},gt=am;async function No(e,t,r){await Ja(0),e.transaction(({drafts:o})=>{var l;let n=t.address.projectId;o.ephemeral.coreByProject[n]={lastExportedObject:null,loadingState:{type:"loading"}},o.ahistoric.coreByProject[n]={ahistoricStuff:""};function i(){o.ephemeral.coreByProject[n].loadingState={type:"loaded"},o.historic.coreByProject[n]={sheetsById:{},definitionVersion:gt.currentProjectStateDefinitionVersion,revisionHistory:[]}}function a(c){o.ephemeral.coreByProject[n].loadingState={type:"loaded"},o.historic.coreByProject[n]=c}function s(){o.ephemeral.coreByProject[n].loadingState={type:"loaded"}}function u(c){o.ephemeral.coreByProject[n].loadingState={type:"browserStateIsNotBasedOnDiskState",onDiskState:c}}let p=(l=Ya(o.historic))==null?void 0:l.coreByProject[t.address.projectId];p?r&&p.revisionHistory.indexOf(r.revisionHistory[0])==-1?u(r):s():r?a(r):i()})}function ss(){}function Er(e){var i,a;let t=((i=e==null?void 0:e.logging)==null?void 0:i.internal)?(a=e.logging.min)!=null?a:v.WARN:1/0,r=t<=v.DEBUG,o=t<=v.ERROR,n=vt(void 0,{_debug:r?console.debug.bind(console,"_coreLogger(TheatreInternalLogger) debug"):ss,_error:o?console.error.bind(console,"_coreLogger(TheatreInternalLogger) error"):ss});if(e){let{logger:s,logging:u}=e;s&&n.configureLogger(s),u?n.configureLogging(u):n.configureLogging({dev:!1})}return n.getLogger().named("Theatre")}var Dr=class{constructor(t,r={},o){this.config=r;this.publicApi=o;d(this,"pointers");d(this,"_pointerProxies");d(this,"address");d(this,"_studioReadyDeferred");d(this,"_assetStorageReadyDeferred");d(this,"_readyPromise");d(this,"_sheetTemplates",new I({}));d(this,"sheetTemplatesP",this._sheetTemplates.pointer);d(this,"_studio");d(this,"assetStorage");d(this,"ticker");d(this,"type","Theatre_Project");d(this,"_logger");var i;this._logger=Er({logging:{dev:!0}}).named("Project",t),this._logger.traceDev("creating project"),this.address={projectId:t};let n=new I({ahistoric:{ahistoricStuff:""},historic:(i=r.state)!=null?i:{sheetsById:{},definitionVersion:gt.currentProjectStateDefinitionVersion,revisionHistory:[]},ephemeral:{loadingState:{type:"loaded"},lastExportedObject:null}});this._assetStorageReadyDeferred=te(),this.assetStorage={getAssetUrl:a=>{var s;return`${(s=r.assets)==null?void 0:s.baseUrl}/${a}`},createAsset:()=>{throw new Error("Please wait for Project.ready to use assets.")}},this._pointerProxies={historic:new Ve(n.pointer.historic),ahistoric:new Ve(n.pointer.ahistoric),ephemeral:new Ve(n.pointer.ephemeral)},this.pointers={historic:this._pointerProxies.historic.pointer,ahistoric:this._pointerProxies.ahistoric.pointer,ephemeral:this._pointerProxies.ephemeral.pointer},Ne.add(t,this),this._studioReadyDeferred=te(),this._readyPromise=Promise.all([this._studioReadyDeferred.promise,this._assetStorageReadyDeferred.promise]).then(()=>{}),this.ticker=r.ticker,r.state?setTimeout(()=>{this._studio||(this._studioReadyDeferred.resolve(void 0),this._assetStorageReadyDeferred.resolve(void 0),this._logger._trace("ready deferred resolved with no state"))},0):typeof window=="undefined"?console.error(`Argument config.state in Theatre.getProject("${t}", config) is empty. You can safely ignore this message if you're developing a Next.js/Remix project in development mode. But if you are shipping to your end-users, then you need to set config.state, otherwise your project's state will be empty and nothing will animate. Learn more at https://www.theatrejs.com/docs/latest/manual/projects#state`):setTimeout(()=>{if(!this._studio)throw new Error(`Argument config.state in Theatre.getProject("${t}", config) is empty. This is fine while you are using @theatre/core along with @theatre/studio. But since @theatre/studio is not loaded, the state of project "${t}" will be empty.

To fix this, you need to add @theatre/studio into the bundle and export the project's state. Learn how to do that at https://www.theatrejs.com/docs/latest/manual/projects#state
`)},1e3)}attachToStudio(t){if(this._studio){if(this._studio!==t)throw new Error(`Project ${this.address.projectId} is already attached to studio ${this._studio.address.studioId}`);console.warn(`Project ${this.address.projectId} is already attached to studio ${this._studio.address.studioId}`);return}this._studio=t,t.initialized.then(async()=>{var r;await No(t,this,this.config.state),this._pointerProxies.historic.setPointer(t.atomP.historic.coreByProject[this.address.projectId]),this._pointerProxies.ahistoric.setPointer(t.atomP.ahistoric.coreByProject[this.address.projectId]),this._pointerProxies.ephemeral.setPointer(t.atomP.ephemeral.coreByProject[this.address.projectId]),t.createAssetStorage(this,(r=this.config.assets)==null?void 0:r.baseUrl).then(o=>{this.assetStorage=o,this._assetStorageReadyDeferred.resolve(void 0)}),this._studioReadyDeferred.resolve(void 0)})}get isAttachedToStudio(){return!!this._studio}get ready(){return this._readyPromise}isReady(){return this._studioReadyDeferred.status==="resolved"&&this._assetStorageReadyDeferred.status==="resolved"}getOrCreateSheet(t,r){let o=this._sheetTemplates.get()[t];return o||(o=new Ir(this,t),this._sheetTemplates.reduce(n=>R(b({},n),{[t]:o}))),o.getInstance({instanceId:r.instanceId,ticker:r.ticker||this.ticker})}destroy(){if(this._studio){console.warn(`Project ${this.address.projectId} is attached to studio ${this._studio.address.studioId} so will not be destroyed`);return}Ne.remove(this.address.projectId)}};var Rr=class{get type(){return"Theatre_Project_PublicAPI"}constructor(t,r={}){ve(this,new Dr(t,r,this))}get ready(){return _(this).ready}get isReady(){return _(this).isReady()}get address(){return b({},_(this).address)}getAssetUrl(t){return t.id?_(this).assetStorage.getAssetUrl(t.id):void 0}sheet(t,r){let o=At(t,"project.sheet"),n="default",i;typeof r=="string"?n=r:typeof r=="object"&&(r.instanceId&&(n=r.instanceId),i=r.ticker);let a={instanceId:n,ticker:i};return _(this).getOrCreateSheet(o,a).publicApi}destroy(){_(this).destroy()}};var Iv=Et(Po());function ps(e,t={}){let r=Ne.get(e);if(r)return r.publicApi;let n=Er().named("Project",e);return t.state?(pm(e,t.state),n._debug("deep validated config.state on disk")):n._debug("no config.state"),new Rr(e,t)}var sm=(e,t)=>{if(Array.isArray(t)||t==null||t.definitionVersion!==gt.currentProjectStateDefinitionVersion)throw new ee(`Error validating conf.state in Theatre.getProject(${JSON.stringify(e)}, conf). The state seems to be formatted in a way that is unreadable to Theatre.js. Read more at https://www.theatrejs.com/docs/latest/manual/projects#state`)},pm=(e,t)=>{sm(e,t)};function us(e,t){if(Se(e))return Re(e).onChange(qe(),t,!0);if(xe(e))return e.onChange(qe(),t,!0);throw new Error("Called onChange(p) where p is neither a pointer nor a prism.")}function ls(e){if(Se(e))return Re(e).getValue();throw new Error("Called val(p) where p is not a pointer.")}var Vr=class{constructor(){d(this,"_studio")}get type(){return"Theatre_CoreBundle"}get version(){return"0.6.0-dev.3"}getBitsForStudio(t,r){if(this._studio)throw new Error("@theatre/core is already attached to @theatre/studio");this._studio=t;let o={projectsP:Ne.atom.pointer.projects,privateAPI:_,coreExports:Lo};r(o)}};um();function um(){if(typeof window=="undefined")return;let e=window[hr];if(typeof e!="undefined")throw typeof e=="object"&&e&&typeof e.version=="string"?new Error(`It seems that the module '@theatre/core' is loaded more than once. This could have two possible causes:
1. You might have two separate versions of Theatre.js in node_modules.
2. Or this might be a bundling misconfiguration, in case you're using a bundler like Webpack/ESBuild/Rollup.

Note that it **is okay** to import '@theatre/core' multiple times. But those imports should point to the same module.`):new Error(`The variable window.${hr} seems to be already set by a module other than @theatre/core.`);let t=new Vr;window[hr]=t;let r=window[Fa];r&&r!==null&&r.type==="Theatre_StudioBundle"&&r.registerCoreBundle(t)}window.Theatre={core:Mo,get studio(){alert("Theatre.studio is only available in the core-and-studio.js bundle. You're using the core-only.min.js bundle.")}};})();
/**
 * @license
 * Lodash (Custom Build) <https://lodash.com/>
 * Build: `lodash modularize exports="es" -o ./`
 * Copyright OpenJS Foundation and other contributors <https://openjsf.org/>
 * Released under MIT license <https://lodash.com/license>
 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
 * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 */

/**
 * @name CSSConfig
 */

(function() {
	Hydra.ready(() => {
		TweenManager.Transforms = [
			'scale',
			'scaleX',
			'scaleY',
			'x',
			'y',
			'z',
			'rotation',
			'rotationX',
			'rotationY',
			'rotationZ',
			'skewX',
			'skewY',
			'perspective',
		];

		TweenManager.CubicEases = [
			{name: 'easeOutCubic', curve: 'cubic-bezier(0.215, 0.610, 0.355, 1.000)'},
			{name: 'easeOutQuad', curve: 'cubic-bezier(0.250, 0.460, 0.450, 0.940)'},
			{name: 'easeOutQuart', curve: 'cubic-bezier(0.165, 0.840, 0.440, 1.000)'},
			{name: 'easeOutQuint', curve: 'cubic-bezier(0.230, 1.000, 0.320, 1.000)'},
			{name: 'easeOutSine', curve: 'cubic-bezier(0.390, 0.575, 0.565, 1.000)'},
			{name: 'easeOutExpo', curve: 'cubic-bezier(0.190, 1.000, 0.220, 1.000)'},
			{name: 'easeOutCirc', curve: 'cubic-bezier(0.075, 0.820, 0.165, 1.000)'},
			{name: 'easeOutBack', curve: 'cubic-bezier(0.175, 0.885, 0.320, 1.275)'},

			{name: 'easeInCubic', curve: 'cubic-bezier(0.550, 0.055, 0.675, 0.190)'},
			{name: 'easeInQuad', curve: 'cubic-bezier(0.550, 0.085, 0.680, 0.530)'},
			{name: 'easeInQuart', curve: 'cubic-bezier(0.895, 0.030, 0.685, 0.220)'},
			{name: 'easeInQuint', curve: 'cubic-bezier(0.755, 0.050, 0.855, 0.060)'},
			{name: 'easeInSine', curve: 'cubic-bezier(0.470, 0.000, 0.745, 0.715)'},
			{name: 'easeInCirc', curve: 'cubic-bezier(0.600, 0.040, 0.980, 0.335)'},
			{name: 'easeInBack', curve: 'cubic-bezier(0.600, -0.280, 0.735, 0.045)'},

			{name: 'easeInOutCubic', curve: 'cubic-bezier(0.645, 0.045, 0.355, 1.000)'},
			{name: 'easeInOutQuad', curve: 'cubic-bezier(0.455, 0.030, 0.515, 0.955)'},
			{name: 'easeInOutQuart', curve: 'cubic-bezier(0.770, 0.000, 0.175, 1.000)'},
			{name: 'easeInOutQuint', curve: 'cubic-bezier(0.860, 0.000, 0.070, 1.000)'},
			{name: 'easeInOutSine', curve: 'cubic-bezier(0.445, 0.050, 0.550, 0.950)'},
			{name: 'easeInOutExpo', curve: 'cubic-bezier(1.000, 0.000, 0.000, 1.000)'},
			{name: 'easeInOutCirc', curve: 'cubic-bezier(0.785, 0.135, 0.150, 0.860)'},
			{name: 'easeInOutBack', curve: 'cubic-bezier(0.680, -0.550, 0.265, 1.550)'},

			{name: 'easeInOut', curve: 'cubic-bezier(.42,0,.58,1)'},
			{name: 'linear', curve: 'linear'}
		];

		TweenManager.useCSSTrans = function (props, ease, object) {
			if (props.math) return false;
			if (typeof ease === 'string' && (ease.includes(['Elastic', 'Bounce']))) return false;
			if (object.multiTween || TweenManager._inspectEase(ease).path) return false;
			if (!Device.tween.transition) return false;
			return true;
		}

		TweenManager._detectTween = function(object, props, time, ease, delay, callback) {
			if (!TweenManager.useCSSTrans(props, ease, object)) {
				return new FrameTween(object, props, time, ease, delay, callback);
			} else {
				return new CSSTransition(object, props, time, ease, delay, callback);
			}
		}

		TweenManager._parseTransform = function(props) {
			var unitRequiresCSSTween = [ '%', 'vw', 'vh', 'em' ];
			var transforms = '';
			var translate = '';

			if (props.perspective > 0) transforms += 'perspective('+props.perspective+'px)';

			if (typeof props.x !== 'undefined' || typeof props.y !== 'undefined' || typeof props.z !== 'undefined') {
				var x = (props.x || 0);
				var y = (props.y || 0);
				var z = (props.z || 0);
				var xUnit = (typeof props.x === 'string' && (props.x.includes( unitRequiresCSSTween ))) ? '' : 'px';
				var yUnit = (typeof props.y === 'string' && (props.y.includes( unitRequiresCSSTween ))) ? '' : 'px';
                translate += x + xUnit + ', ';
                translate += y + yUnit;
				if (Device.tween.css3d) {
					translate += ', ' + z + 'px';
					transforms += 'translate3d('+translate+')';
				} else {
					transforms += 'translate('+translate+')';
				}
			}

			if (typeof props.scale !== 'undefined') {
				transforms += 'scale('+props.scale+')';
			} else {
				if (typeof props.scaleX !== 'undefined') transforms += 'scaleX('+props.scaleX+')';
				if (typeof props.scaleY !== 'undefined') transforms += 'scaleY('+props.scaleY+')';
			}

			if (typeof props.rotation !== 'undefined') transforms += 'rotate('+props.rotation+'deg)';
			if (typeof props.rotationX !== 'undefined') transforms += 'rotateX('+props.rotationX+'deg)';
			if (typeof props.rotationY !== 'undefined') transforms += 'rotateY('+props.rotationY+'deg)';
			if (typeof props.rotationZ !== 'undefined') transforms += 'rotateZ('+props.rotationZ+'deg)';
			if (typeof props.skewX !== 'undefined') transforms += 'skewX('+props.skewX+'deg)';
			if (typeof props.skewY !== 'undefined') transforms += 'skewY('+props.skewY+'deg)';

			return transforms;
		}

		TweenManager._clearCSSTween = function(obj) {
			if (obj && !obj._cssTween && obj.div._transition && !obj.persistTween) {
				obj.div.style[HydraCSS.styles.vendorTransition] = '';
				obj.div._transition = false;
				obj._cssTween = null;
			}
		}

		TweenManager._isTransform = function(key) {
			var index = TweenManager.Transforms.indexOf(key);
			return index > -1;
		}

		TweenManager._getAllTransforms = function(object) {
			var obj = {};
			for (var i = TweenManager.Transforms.length-1; i > -1; i--) {
				var tf = TweenManager.Transforms[i];
				var val = object[tf];
				if (val !== 0 && (typeof val === 'number' || typeof val === 'string')) {
					obj[tf] = val;
				}
			}
			return obj;
		}

        const prefix = (function() {
            let pre = '';
            let dom = '';

            try {
                var styles = window.getComputedStyle(document.documentElement, '');
                pre = (Array.prototype.slice
                        .call(styles)
                        .join('')
                        .match(/-(moz|webkit|ms)-/) || (styles.OLink === '' && ['', 'o'])
                )[1];
                dom = ('WebKit|Moz|MS|O').match(new RegExp('(' + pre + ')', 'i'))[1];

                return {
                    unprefixed: Device.system.browser == 'ie' && !Device.detect('msie 9'),
                    dom: dom,
                    lowercase: pre,
                    css: '-' + pre + '-',
                    js: (Device.system.browser == 'ie' ? pre[0] : pre[0].toUpperCase()) + pre.substr(1)
                };
            } catch(e) {
                return {unprefixed: true, dom: '', lowercase: '', css: '', js: ''};
            }
        })();

		HydraCSS.styles = {};

		/**
		 * String of vender prefix for js-applied styles. eg, for webkitTransform vs -webkit-transform.
		 * @name HydraCSS.styles.vendor
		 * @memberof CSSConfig
		 */
		HydraCSS.styles.vendor = prefix.unprefixed ? '' : prefix.js;

		/**
		 * String of transition vender prefix for js-applied styles.
		 * @name HydraCSS.styles.vendorTransition
		 * @memberof CSSConfig
		 */
		HydraCSS.styles.vendorTransition = HydraCSS.styles.vendor.length ? HydraCSS.styles.vendor + 'Transition' : 'transition';

		/**
		 * String of transform vender prefix for js-applied styles.
		 * @name HydraCSS.styles.vendorTransform
		 * @memberof CSSConfig
		 */
		HydraCSS.styles.vendorTransform = HydraCSS.styles.vendor.length ? HydraCSS.styles.vendor + 'Transform' : 'transform';

		//*** Transforms
		/**
		 * String of css prefix. eg. '-webkit-', '-moz-' etc.
		 * @name HydraCSS.vendor
		 * @memberof CSSConfig
		 */
		HydraCSS.vendor = prefix.css;

		/**
		 * String of css transform prefix. eg. '-webkit-transform', '-moz-transform' etc.
		 * @name HydraCSS.transformProperty
		 * @memberof CSSConfig
		 */
		HydraCSS.transformProperty = (function() {
		    switch (prefix.lowercase) {
		        case 'moz': return '-moz-transform'; break;
		        case 'webkit': return '-webkit-transform'; break;
		        case 'o': return '-o-transform'; break;
		        case 'ms': return '-ms-transform'; break;
		        default: return 'transform'; break;
		    }
		})();

		HydraCSS.tween = {};

		/**
		 * @name HydraCSS.tween.complete
		 * @memberof CSSConfig
		 */
		HydraCSS.tween.complete = (function() {
		    if (prefix.unprefixed) return 'transitionend';
		    return prefix.lowercase + 'TransitionEnd';
		})();

	});
})();
/**
 * @name CSSTransition
 */

Class(function CSSTransition(_object, _props, _time, _ease, _delay, _callback) {
    const _this = this;
    let _transformProps, _transitionProps;

    this.playing = true;

    //*** Constructor
    (function() {
        // if (_this.overrideValues) {
        //     let values = _this.overrideValues(_this, _object, _props, _time, _ease, _delay);
        //     if (values) {
        //         _props = values.props || _props;
        //         _time = values.time || _time;
        //         _ease = values.ease || _ease;
        //         _delay = values.delay || _delay;
        //     }
        // }

        if (typeof _time !== 'number') throw 'CSSTween Requires object, props, time, ease';
        initProperties();
        initCSSTween();
    })();

    function killed() {
        return !_this || _this.kill || !_object || !_object.div;
    }

    function initProperties() {
        var transform = TweenManager._getAllTransforms(_object);
        var properties = [];

        for (var key in _props) {
            if (TweenManager._isTransform(key)) {
                transform.use = true;
                transform[key] = _props[key];
                delete _props[key];
            } else {
                if (typeof _props[key] === 'number' || key.includes(['-', 'color'])) properties.push(key);
            }
        }

        if (transform.use) {
            properties.push(HydraCSS.transformProperty);
            delete transform.use;
        }

        _transformProps = transform;
        _transitionProps = properties;
    }

    async function initCSSTween(values) {
        if (killed()) return;
        if (_object._cssTween) _object._cssTween.kill = true;
        _object._cssTween = _this;
        _object.div._transition = true;

        var strings = buildStrings(_time, _ease, _delay);

        _object.willChange(strings.props);

        var time = values ? values.time : _time;
        var delay = values ? values.delay : _delay;
        var props = values ? values.props : _props;
        var transformProps = values ? values.transform : _transformProps;
        var singleFrame = 1000 / Render.REFRESH_RATE;

        _this.time = _time;
        _this.delay = _delay;

        await Timer.delayedCall(3 * singleFrame);
        if (killed()) return;
        _object.div.style[HydraCSS.styles.vendorTransition] = strings.transition;
        _this.playing = true;

        if (Device.system.browser == 'safari') {
            if (Device.system.browserVersion < 11) await Timer.delayedCall(singleFrame);
            if (killed()) return;
            _object.css(props);
            _object.transform(transformProps);
        } else {
            _object.css(props);
            _object.transform(transformProps);
        }

        Timer.create(function() {
            if (killed()) return;
            clearCSSTween();
            if (_callback) _callback();
            if (_this.completePromise) _this.completePromise.resolve();
        }, time + delay);
    }

    function buildStrings(time, ease, delay) {
        var props = '';
        var str = '';
        var len = _transitionProps.length;
        for (var i = 0; i < len; i++) {
            var transitionProp = _transitionProps[i];
            props += (props.length ? ', ' : '') + transitionProp;
            str += (str.length ? ', ' : '') + transitionProp + ' ' + time+'ms ' + TweenManager._getEase(ease) + ' ' + delay+'ms';
        }

        return {props: props, transition: str};
    }

    function clearCSSTween() {
        if (killed()) return;
        _this.playing = false;
        _object._cssTween = null;
        _object.willChange(null);
        _object = _props = null;
        Utils.nullObject(this);
    }

    //*** Event handlers
    function tweenComplete() {
        if (!_callback && _this.playing) clearCSSTween();
    }

    //*** Public methods
    /**
     * @name this.stop
     * @memberof CSSTransition
     *
     * @function
     */
    this.stop = function() {
        if (!this.playing) return;
        this.kill = true;
        this.playing = false;
        _object.div.style[HydraCSS.styles.vendorTransition] = '';
        _object.div._transition = false;
        _object.willChange(null);
        _object._cssTween = null;
        Utils.nullObject(this);
    };


    /**
     * @name this.stop
     * @memberof CSSTransition
     *
     * @function
     * @param {Function} callback
     */
    this.onComplete = function(callback) {
        _callback = callback;
        return this;
    };

    /**
     * @name this.promise
     * @memberof CSSTransition
     *
     * @function
     * @param {Function}
     */
    this.promise = function() {
        _this.completePromise = Promise.create();
        return _this.completePromise;
    };
});
/**
 * @name FrameTween
 */

Class(function FrameTween(_object, _props, _time, _ease, _delay, _callback, _manual) {
    var _this = this;
    var _endValues, _transformEnd, _transformStart, _startValues;
    var _isTransform, _isCSS, _transformProps;
    var _cssTween, _transformTween, _update;

    this.playing = true;

    _this.object = _object;
    _this.props = _props;
    _this.time = _time;
    _this.ease = _ease;
    _this.delay = _delay;

    //*** Constructor
    defer(function() {
        if (_this.overrideValues) {
            let values = _this.overrideValues(_this, _object, _props, _time, _ease, _delay);
            if (values) {
                _this.props = _props = values.props || _props;
                _this.time = _time = values.time || _time;
                _this.ease = _ease = values.ease || _ease;
                _this.delay = _delay = values.delay || _delay;
            }
        }

        if (typeof _ease === 'object') _ease = 'easeOutCubic';
        if (_object && _props) {
            _this.object = _object;
            if (typeof _time !== 'number') throw 'FrameTween Requires object, props, time, ease';
            initValues();
            startTween();
        }
    });

    function killed() {
        return _this.kill || !_object || !_object.div || !_object.css;
    }

    function initValues() {
        if (_props.math) delete _props.math;
        if (Device.tween.transition && _object.div && _object.div._transition) {
            _object.div.style[HydraCSS.styles.vendorTransition] = '';
            _object.div._transition = false;
        }

        _this.time = _time;
        _this.delay = _delay;

        _endValues = {};
        _transformEnd = {};
        _transformStart = {};
        _startValues = {};

        if (!_object.multiTween) {
            if (typeof _props.x === 'undefined') _props.x = _object.x;
            if (typeof _props.y === 'undefined') _props.y = _object.y;
            if (typeof _props.z === 'undefined') _props.z = _object.z;
        }

        for (var key in _props) {
            if (key.includes(['damping', 'spring'])) {
                _endValues[key] = _props[key];
                _transformEnd[key] = _props[key];
                continue;
            }
            if (TweenManager._isTransform(key)) {
                _isTransform = true;
                _transformStart[key] = _object[key] || (key == 'scale' ? 1 : 0);
                _transformEnd[key] = _props[key];
            } else {
                _isCSS = true;
                var v = _props[key];
                if (typeof v === 'string') {
                    _object.div.style[key] = v;
                } else if (typeof v === 'number') {
                    _startValues[key] = _object.css ? Number(_object.css(key)) : 0;
                    _endValues[key] = v;
                }
            }
        }
    }

    function startTween() {
        if (_object._cssTween && !_manual && !_object.multiTween) _object._cssTween.kill = true;

        _this.time = _time;
        _this.delay = _delay;

        if (_object.multiTween) {
            if (!_object._cssTweens) _object._cssTweens = [];
            _object._cssTweens.push(_this);
        }

        _object._cssTween = _this;
        _this.playing = true;
        _props = copy(_startValues);
        _transformProps = copy(_transformStart);

        if (_isCSS) _cssTween = tween(_props, _endValues, _time, _ease, _delay, null, _manual).onUpdate(update).onComplete(tweenComplete);
        if (_isTransform) _transformTween = tween(_transformProps, _transformEnd, _time, _ease, _delay, null, _manual).onComplete(!_isCSS ? tweenComplete : null).onUpdate(!_isCSS ? update : null);
    }

    function copy(obj) {
        let newObj = {};
        for (let key in obj) {
            if (typeof obj[key] === 'number') newObj[key] = obj[key];
        }
        return newObj;
    }

    function clear() {
        if (_object._cssTweens) {
            _object._cssTweens.remove(_this);
        }

        _this.playing = false;
        _object._cssTween = null;
        _object = _props = null;
    }

    //*** Event handlers
    function update() {
        if (killed()) return;
        if (_isCSS) _object.css(_props);
        if (_isTransform) {
            if (_object.multiTween) {
                for (var key in _transformProps) {
                    if (typeof _transformProps[key] === 'number') _object[key] = _transformProps[key];
                }
                _object.transform();
            } else {
                _object.transform(_transformProps);
            }
        }

        if (_update) _update();
    }

    function tweenComplete() {
        if (_this.playing) {
            clear();
            if (_callback) _callback();
            if (_this.completePromise) _this.completePromise.resolve();
        }
    }

    //*** Public methods

    /**
     * @name this.stop
     * @memberof FrameTween
     *
     * @function
     */
    this.stop = function() {
        if (!this.playing) return;
        if (_cssTween && _cssTween.stop) _cssTween.stop();
        if (_transformTween && _transformTween.stop) _transformTween.stop();
        clear();
    };

    /**
     * @name this.interpolate
     * @memberof FrameTween
     *
     * @function
     * @param {Number} elapsed - Number between 0.0 and 1.0
     */
    this.interpolate = function(elapsed) {
        if (_cssTween) _cssTween.interpolate(elapsed);
        if (_transformTween) _transformTween.interpolate(elapsed);
        update();
    };

    /**
     * @name this.getValues
     * @memberof FrameTween
     *
     * @function
     * @returns {Object} Object with startm, transformStart, end and transformEnd properties.
     */
    this.getValues = function() {
        return {
            start: _startValues,
            transformStart: _transformStart,
            end: _endValues,
            transformEnd: _transformEnd,
        };
    };

    /**
     * @name this.setEase
     * @memberof FrameTween
     *
     * @function
     * @param {String} ease
     */
    this.setEase = function(ease) {
        if (_cssTween) _cssTween.setEase(ease);
        if (_transformTween) _transformTween.setEase(ease);
    };

    /**
     * @name this.onUpdate
     * @memberof FrameTween
     *
     * @function
     * @returns {FrameTween}
     */
    this.onUpdate = function() {
        return this;
    };

    /**
     * @name this.onComplete
     * @memberof FrameTween
     *
     * @function
     * @param {Function} callback
     * @returns {FrameTween}
     */
    this.onComplete = function(callback) {
        _callback = callback;
        return this;
    };

    /**
     * @name this.promise
     * @memberof FrameTween
     *
     * @function
     * @param {Function}
     */
    this.promise = function() {
        if (!_this.completePromise) _this.completePromise = Promise.create();
        return _this.completePromise;
    };
});
class DOMAttribute {
    constructor({name, value, belongsTo, bindingLookup}) {
        this.name = name;
        this.value = value;
        this.belongsTo = belongsTo; 
        this.bindingLookup = bindingLookup;
    }
}
class TemplateRoot {
    constructor(string, values) {
        this.string = string;
        this.values = values;
    }

    consolidate() {
        let template = this.string;
        const consolidatedValues = {};

        for (const [marker, value] of Object.entries(this.values)) {

            if (value instanceof TemplateHTML) {
                // If the marker resolves to a template we unroll the string and add the values of the
                // template to the root config.
                const [innerTemplate, innerValues] = value.consolidate();
                template = template.replace(marker , innerTemplate);
                Object.assign(consolidatedValues, innerValues);

            } else if (Array.isArray( value )) {
                // If the marker resolves to an array, we assume a collection of templates. All
                // templates are joined to one long template. Same for all configs.
                let childTemplate = "";

                for (let k = 0; k < value.length; k++ ) {
                    const [innerString, innerValue] = value[k].consolidate();
                    childTemplate += innerString;
                    Object.assign(consolidatedValues, innerValue);
                }

                template = template.replace(marker, childTemplate);
            } else {
                // All other markers are add to the accumulative config.
                consolidatedValues[marker] = value;
            }
        }

        return [template, consolidatedValues];
    }

    modifyMarkers(template, config, dataMarkers, bindings) {
        let count = 0;
        return template
            .replace(/@([a-z]+)="\{\{(hydra-[0-9]+)\}\}"/g, function(_, event, marker) {
                const dataMarker = `data-attach-event-${count++}`;
                dataMarkers.push(dataMarker);
                return `${dataMarker}="${event}|${marker}"`;
            })
            .replace(/\{\{hydra-[0-9]+\}\}/g, function(marker) {
                if (config[marker] && config[marker].state) {
                    bindings.push({lookup: marker.trim()});
                    return marker;
                }
                // handle converting style object references (i.e. from template.dynamicStyles)
                // to css properties and return a string
                // { fontSize: '1rem', letterSpacing: '2rem' } => "font-size: 1rem; letter-spacing: 2rem;"
                if (config[marker][`@style`]) {
                    const styles = config[marker][`@style`];
                    if (!styles || typeof styles !== 'object') {
                        console.error('@style must contain an object');
                        return;
                    }
                    let styleString = '';
                    Object.keys(styles).forEach(prop => {
                        // convert camelCase to kebab-case
                        const kebabProp = prop.replace(/([a-z0-9]|(?=[A-Z]))([A-Z])/g, '$1-$2').toLowerCase();
                        styleString += `${kebabProp}: ${styles[prop]};\n`;
                    })
                    return styleString;
                }
                return config[marker];
            });
    }
}

class TemplateHTML extends TemplateRoot {
    constructor(string, values) {
        super(string, values);
    }

    inflate(root, cssElement) {
        let [template, config] = this.consolidate();
        let dataMarkers = [];
        let nestedComponents = [];
        let bindings = new LinkedList();

        let scrollTop = root.firstChild?.scrollTop;

        const t = this.modifyMarkers(template, config, dataMarkers, bindings);

        while (root.firstChild) root.removeChild(root.firstChild);

        if (root.flatBindings) root.flatBindings.forEach(b => b.destroy());
        root.flatBindings = [];

        let fragment = document.createDocumentFragment();
        let newNode = DOMTemplate.parser.parseFromString(t, 'text/html');
        let els = newNode.body.firstChild.querySelectorAll('*');
        let length = els.length;
        fragment.appendChild(newNode.body.firstChild);
        if (cssElement) fragment.appendChild(cssElement);
        for (let index = length-1; index > -1; index--) {
            let el = els[index];

            // if an unknown elemnt is found, assume it is a nested component, in kabab-case
            if (~el.tagName.indexOf('-')) {
                nestedComponents.push(el);
            }

            let innerText = el.innerText;
            let innerHTML = el.innerHTML;
            let attributes = [...el.attributes].map(a => ({name: a.name, value: a.value}));

            if (~innerHTML.indexOf('<')) continue;
            let binding = bindings.start();
            while (binding) {
                let bindingLookup = binding.lookup;

                attributes.forEach(attr => {
                    if (~attr?.value?.indexOf(bindingLookup)) {
                        let obj = config[bindingLookup];
                        const attrObject = new DOMAttribute({
                            name: attr.name,
                            value: el.getAttribute(attr.name),
                            belongsTo: el,
                            bindingLookup
                        });
                        root.flatBindings.push(obj.state.bind(obj.key, attrObject));
                    }
                });

                if (~innerText.indexOf(bindingLookup)) {
                    let obj = config[bindingLookup];
                    if (~innerText.indexOf('@[')) el.innerText = innerText.replace(bindingLookup, obj.key);
                    root.flatBindings.push(obj.state.bind(obj.key, el));
                }
                binding = bindings.next();
            }
        }
        root.appendChild(fragment);

        dataMarkers.forEach(dataMarker => {
            const element = root.querySelector(`[${dataMarker}]`);
            const dataEvent = element.getAttribute(dataMarker);
            const [event, marker] = dataEvent.split("|");
            element.removeAttribute(dataMarker);
            element.addEventListener(`${event}`, config[`{{${marker}}}`]);
        });

        defer(() => {
            nestedComponents.forEach(template => {
                // kabab-case to PascalCase to infer class name
                const className = template.tagName.toLowerCase().replace(/(^\w|-\w)/g, str => str.replace(/-/, '').toUpperCase())
                const hydraObj = $(`#${template.id}`, className, true);
                hydraObj.add(new window[className]());
            });
        });

        if (scrollTop) root.firstChild.scrollTop = scrollTop;
    }
}

class TemplateCSS extends TemplateRoot {
    constructor(string, values) {
        super(string, values);
    }

    /**
     * Injects the template into a given parent element.
     *
     * @param {Element} root
     */
    inflate(root) {
        let [template, config] = this.consolidate();
        let dataMarkers = [];
        let bindings = new LinkedList();

        let element = document.createElement('style');
        element.innerHTML = this.modifyMarkers(template, config, dataMarkers, bindings);

        return element;
    }
}


function styleMap(object) {
    return Object.keys(object).map(key => object[key] ? key : "").join(" ");
}

/**
 * @name DOMTemplate
 */

(function() {
    let markerID = 0;

    function makeMarker() {
        return `{{hydra-${markerID++}}}`;
    }

    function html(strings, ...values) {
        const config = {};
        let string = '';

        for (let i = 0; i < strings.length - 1; i++) {
            const marker = makeMarker();
            string += strings[i];
            string += marker;
            config[marker] = values[i];
        }

        string += strings[strings.length - 1];

        return new TemplateHTML(string, config);
    }

    function css(strings, ...values) {
        const config = {};
        let string = '';

        for (let i = 0; i < strings.length - 1; i++) {
            const marker = makeMarker();
            string += strings[i];
            string += marker;
            config[marker] = values[i];
        }

        string += strings[strings.length - 1];

        return new TemplateCSS(string, config);
    }

    Class(function DOMTemplate() {
        Inherit(this, Element);
        const _this = this;

        this.data = [];

        if (Hydra.LOCAL && window.UILSocket) {
            let name = Utils.getConstructorName(_this);
            _this.events.sub(UILSocket.JS_FILE, e => {
                if (e.file.includes(name)) {
                    DOMTemplate.updateGlobalStyles();
                    _this.update();
                }
            });
        }

        function update() {
            let cssContent;
            if (_this.dynamicStyle) cssContent = _this.dynamicStyle(css).inflate(_this.element.div);
            _this.render?.(html).inflate?.(_this.element.div, cssContent);
            _this.postRender?.();
        }

        /**
         * @name this.update
         * @memberof DOMTemplate
         *
         * @function
         */
        this.update = function () {
            DOMTemplate.clearScheduled(update);
            DOMTemplate.schedule(update);
        };

        /**
         * @name this.render
         * @memberof DOMTemplate
         *
         * @function
         * @param html
         */
        this.render = function (html) {
            throw new Error('render() needs to be overwritten.');
        };

        /**
         * @name this.setSourceData
         * @memberof DOMTemplate
         *
         * @function
         * @param data
         */
        this.setSourceData = function(data) {
            _this.data = data;
            this.update();
            _this.events.sub(data, Events.UPDATE, this.update);
        }
        _this.update();
    }, _ => {
        DOMTemplate.parser = new DOMParser();

        const queue = [];
        const worker = new Render.Worker(_ => {
            let callback = queue.shift();
            if (callback) callback();
            else worker.pause();
        }, 2);
        worker.pause();

        DOMTemplate.schedule = function(callback) {
            queue.push(callback);
            worker.resume();
        }

        DOMTemplate.clearScheduled = function(callback) {
            for (let i = 0; i < queue.length; i++) {
                let cb = queue[i];
                if (cb == callback) return queue.splice(i, 1);
            }
        }

        var _css;
        DOMTemplate.updateGlobalStyles = function() {
            Utils.debounce(async _ => {
                let css = await get(Assets.getPath('assets/css/style-scss.css'));
                if (!_css) _css = $(document.head).create('DOMTemplate-hotload', 'style');
                _css.div.innerHTML = css;
            }, 20);
        }
    });
})();
/**
 * Mouse input controller class
 * @name Interaction
 * @example
 * const input = new Interaction(Stage);
 * _this.events.sub(input, Interaction.START, e => console.log(e, input.hold));
 * @example
 * // Events include
 * // Interaction.START - cursor down
 * // Interaction.MOVE - cursor move
 * // Interaction.DRAG - cursor move while down
 * // Interaction.END - cursor up
 * // Interaction.CLICK - cursor up within time and movement limits
 */

Class(function Interaction(_object) {
    Inherit(this, Events);
    const _this = this;
    var _touchId;

    var _velocity = [];
    var _moved = 0;
    var _time = performance.now();

    function Vec2() {
        this.x = 0;
        this.y = 0;
        this.length = function() {
            return Math.sqrt(this.x * this.x + this.y * this.y);
        };
    }

    var _vec2Pool = new ObjectPool(Vec2, 10);

    /**
     * Current mouse x position
     * @name x
     * @memberof Interaction
     */
    this.x = 0;

    /**
     * Current mouse y position
     * @name y
     * @memberof Interaction
     */
    this.y = 0;

    /**
     * Value of last cursor down event position.
     * Object with x, y properties, and length method.
     * @name hold
     * @memberof Interaction
     */
    this.hold = new Vec2();

    /**
     * Value of cursor position from last event.
     * Object with x, y properties, and length method.
     * @name last
     * @memberof Interaction
     */
    this.last = new Vec2();

    /**
     * Movement since last cursor event position.
     * Object with x, y properties, and length method.
     * @name delta
     * @memberof Interaction
     */
    this.delta = new Vec2();

    /**
     * Movement since last down event position.
     * Object with x, y properties, and length method.
     * @name move
     * @memberof Interaction
     */
    this.move = new Vec2();

    /**
     * Movement delta divided by time delta.
     * Object with x, y properties, and length method.
     * @name velocity
     * @memberof Interaction
     */
    this.velocity = new Vec2();

    let _distance, _timeDown, _timeMove;

    //*** Constructor
    (function () {
        if (!_object instanceof HydraObject) throw `Interaction.Input requires a HydraObject`;
        addHandlers();
        Render.start(loop);
    })();

    function loop() {
        if (_moved++ > 10) {
            _this.velocity.x = _this.velocity.y = 0;
            _this.delta.x = _this.delta.y = 0;
        }
    }

    function addHandlers() {
        if (_object == Stage || _object == __window) Interaction.bind('touchstart', down);
        else {
            _object.bind('touchstart', down);
            Interaction.bindObject(_object);
        }

        Interaction.bind('touchmove', move);
        Interaction.bind('touchend', up);
        Interaction.bind('leave', leave);
    }

    //*** Event handlers
    function down(e) {
        if ((_this.isTouching && !_this.multiTouch) || (e.target.className == 'hit' && e.target.hydraObject != _object) || Interaction.hitIsBound(e.target, _object)) return;
        _this.isTouching = true;

        let x = e.x;
        let y = e.y;

        if (e.changedTouches && !_touchId) {
            x = e.changedTouches[0].clientX;
            y = e.changedTouches[0].clientY;
            _touchId = e.changedTouches[0].identifier;
        }

        if (e.touches && typeof e.touches[0].force === 'number') e.force = e.touches[0].force;

        e.x = _this.x = x;
        e.y = _this.y = y;

        _this.hold.x = _this.last.x = x;
        _this.hold.y = _this.last.y = y;

        _this.delta.x = _this.move.x = _this.velocity.x = 0;
        _this.delta.y = _this.move.y = _this.velocity.y = 0;
        _distance = 0;

        _this.events.fire(Interaction.START, e, true);
        _timeDown = _timeMove = Render.TIME;
    }

    function move(e) {
        if (!_this.isTouching && !_this.unlocked) return;
        let now = performance.now();
        if (now - _time < 16) return;
        _time = now;

        let x = e.x;
        let y = e.y;

        if (e.touches) {
            for (let i = 0; i < e.touches.length; i++) {
                let touch = e.touches[i];
                if (touch.identifier == _touchId) {
                    x = touch.clientX;
                    y = touch.clientY;
                }
            }
        }

        if (_this.isTouching) {
            _this.move.x = x - _this.hold.x;
            _this.move.y = y - _this.hold.y;
        }

        if (e.touches && typeof e.touches[0].force === 'number') e.force = e.touches[0].force;

        e.x = _this.x = x;
        e.y = _this.y = y;

        _this.delta.x = x - _this.last.x;
        _this.delta.y = y - _this.last.y;

        _this.last.x = x;
        _this.last.y = y;

        _moved = 0;

        _distance += _this.delta.length();

        let delta = Render.TIME - (_timeMove || Render.TIME);
        _timeMove = Render.TIME;

        if (delta > 0.01) {
            let velocity = _vec2Pool.get();
            velocity.x = Math.abs(_this.delta.x) / delta;
            velocity.y = Math.abs(_this.delta.y) / delta;

            _velocity.push(velocity);
            if (_velocity.length > 5) _vec2Pool.put(_velocity.shift());
        }

        _this.velocity.x = _this.velocity.y = 0;

        for (let i = 0; i < _velocity.length; i++) {
            _this.velocity.x += _velocity[i].x;
            _this.velocity.y += _velocity[i].y;
        }

        _this.velocity.x /= _velocity.length;
        _this.velocity.y /= _velocity.length;

        _this.velocity.x = _this.velocity.x || 0;
        _this.velocity.y = _this.velocity.y || 0;

        _this.events.fire(Interaction.MOVE, e, true);
        if (_this.isTouching) _this.events.fire(Interaction.DRAG, e, true);
    }

    function up(e) {
        if (e && e.changedTouches) {
            let someTouchIdentified = false;
            for (let i = 0; i < e.changedTouches.length; i++) {
                if (e.changedTouches[i].identifier === _touchId) someTouchIdentified = true;
            }
            if (!someTouchIdentified) return;
        }

        if (!_this.isTouching && !_this.unlocked) return;

        _this.isTouching = false;

        _this.move.x = 0;
        _this.move.y = 0;

        // If user waited without moving before releasing, clear delta movement for correct inertia calculation
        let delta = Math.max(0.001, Render.TIME - (_timeMove || Render.TIME));
        if (delta >= 40) {
            _this.delta.x = 0;
            _this.delta.y = 0;
        }

        // If moved less than 20 pixels and quicker than 1000 milliseconds
        if (_distance < 20 && Render.TIME - _timeDown < 1000 && !e.isLeaveEvent) {
            _this.events.fire(Interaction.CLICK, e, true);
        }

        _this.events.fire(Interaction.END, e, true);
        _touchId = null;

        if (Device.mobile) _this.velocity.x = _this.velocity.y = 0;
    }

    function leave() {
        if (_this.ignoreLeave) return;
        _this.delta.x = 0;
        _this.delta.y = 0;
        up({isLeaveEvent: true});
    }

    //*** Public methods
    this.onDestroy = function() {
        Interaction.unbind('touchstart', down);
        Interaction.unbind('touchmove', move);
        Interaction.unbind('touchend', up);
        Render.stop(loop);
        Interaction.unbindObject(_object);
        _object && _object.unbind && _object.unbind('touchstart', down);
    }
}, () => {
    Namespace(Interaction);

    Interaction.CLICK = 'interaction_click';
    Interaction.START = 'interaction_start';
    Interaction.MOVE = 'interaction_move';
    Interaction.DRAG = 'interaction_drag';
    Interaction.END = 'interaction_end';

    const _objects = [];
    const _events = {touchstart: [], touchmove: [], touchend: [], leave: []};

    Hydra.ready(async () => {
        await defer();
        __window.bind('touchstart', touchStart);
        __window.bind('touchmove', touchMove);
        __window.bind('touchend', touchEnd);
        __window.bind('touchcancel', touchEnd);
        __window.bind('contextmenu', touchEnd);
        __window.bind('mouseleave', leave);
        __window.bind('mouseout', leave);
    });

    function touchMove(e) {
        _events.touchmove.forEach(c => c(e));
    }

    function touchStart(e) {
        _events.touchstart.forEach(c => c(e));
    }

    function touchEnd(e) {
        _events.touchend.forEach(c => c(e));
    }

    function leave(e) {
        e.leave = true;
        _events.leave.forEach(c => c(e));
    }

    Interaction.bind = function(evt, callback) {
        _events[evt].push(callback);
    };

    Interaction.unbind = function(evt, callback) {
        _events[evt].remove(callback);
    };

    Interaction.bindObject = function(obj) {
        _objects.push(obj);
    };

    Interaction.unbindObject = function(obj) {
        _objects.remove(obj);
    };

    Interaction.hitIsBound = function(element, boundObj) {
        let obj = element.hydraObject;
        if (!obj) return false;

        while (obj) {
            if (obj != boundObj && _objects.includes(obj)) return true;
            obj = obj._parent;
        }

        return false;
    }
});
/**
 * Mouse global position
 * @name Mouse
 */

Class(function Mouse() {
    Inherit(this, Events);
    const _this = this;
    /**
     * Current mouse x position
     * @name Mouse.x
     * @memberof Mouse
     */
    this.x = 0;

    /**
     * Current mouse y position
     * @name Mouse.y
     * @memberof Mouse
     */
    this.y = 0;

    /**
     * Current mouse x position in window from 0 > 1
     * @name Mouse.normal
     * @memberof Mouse
     */
    this.normal = {
        x: 0,
        y: 0,
    };

    /**
     * Current mouse x position in window from -1 > 1
     * @name Mouse.tilt
     * @memberof Mouse
     */
    this.tilt = {
        x: 0,
        y: 0,
    };

    /**
     * Current mouse x position in window from 0 > 1 where y is flipped for use in WebGL
     * @name Mouse.inverseNormal
     * @memberof Mouse
     */
    this.inverseNormal = {
        x: 0,
        y: 0,
    };

    /**
     * Have the Mouse x and y values reset to 0,0 when interaction stops on mobile
     * @name Mouse.resetOnRelease
     * @memberof Mouse
     */
    this.resetOnRelease = false;

    const _offset = {
        x: 0,
        y: 0,
    };

    (function() {
        Hydra.ready(init);
    })();

    function init() {
        _this.x = Stage.width / 2;
        _this.y = Stage.height / 2;

        defer(_ => {
            if (_this.resetOnRelease && Device.mobile) {
                _this.x = Stage.width / 2;
                _this.y = Stage.height / 2;
            }
        });

        /**
         * Interaction instance attached to window.
         * @name Mouse.input
         * @memberof Mouse
         * @example
         * _this.events.sub(Mouse.input, Interaction.MOVE, move);
         */
        _this.input = new Interaction(__window);
        _this.input.unlocked = true;
        _this.events.sub(_this.input, Interaction.START, start);
        _this.events.sub(_this.input, Interaction.MOVE, update);
        _this.events.sub(_this.input, Interaction.END, end);

        _this.hold = _this.input.hold;
        _this.last = _this.input.last;
        _this.delta = _this.input.delta;
        _this.move = _this.input.move;
        _this.velocity = _this.input.velocity;

        // Defer to be called after Stage is possibly manipulated
        defer(() => {
            _this.events.sub(Events.RESIZE, resize);
            resize();
        });
    }
    
    function start(e) {
    	_this.down = true;
    	update(e);
    }

    function update(e) {
        _this.x = e.x;
        _this.y = e.y;

        if (!Stage.width || !Stage.height) return;

        _this.normal.x = e.x / Stage.width - _offset.x;
        _this.normal.y = e.y / Stage.height - _offset.y;
        _this.tilt.x = _this.normal.x * 2.0 - 1.0;
        _this.tilt.y = 1.0 - _this.normal.y * 2.0;
        _this.inverseNormal.x = _this.normal.x;
        _this.inverseNormal.y = 1.0 - _this.normal.y;
    }

    function end(e) {
        _this.down = false;
        if (Device.mobile && _this.resetOnRelease) update({x: Stage.width/2, y: Stage.height/2});
    }

    function resize() {
        if (Stage.css('top')) _offset.y = Stage.css('top') / Stage.height;
        if (Stage.css('left')) _offset.x = Stage.css('left') / Stage.width;
    }

}, 'Static');
/**
 * @name Keyboard
 */

Class(function Keyboard() {
    Inherit(this, Component);
    var _this = this;

    this.pressing = [];

   /**
    * @name DOWN
    * @memberof Keyboard
    * @property
    */
    _this.DOWN = 'keyboard_down';
   /**
    * @name PRESS
    * @memberof Keyboard
    * @property
    */
    _this.PRESS = 'keyboard_press';
   /**
    * @name UP
    * @memberof Keyboard
    * @property
    */
    _this.UP = 'keyboard_up';

    //*** Constructor
    (function () {
        Hydra.ready(addListeners);
    })();

    //*** Event handlers
    function addListeners() {
        __window.keydown(keydown);
        __window.keyup(keyup);
        __window.keypress(keypress);
        window.addEventListener('focus', onFocus);
    }

    function keydown(e) {
        if (!_this.pressing.includes(e.key)) _this.pressing.push(e.key);
        _this.events.fire(_this.DOWN, e);

        if (_this.pressing.length == 2 && _this.pressing.includes('Meta') && _this.pressing.includes('Shift')) {
            _this.pressing.length = 0;
        }
    }

    function keyup(e) {
        _this.pressing.remove(e.key);
        _this.events.fire(_this.UP, e);
    }

    function keypress(e) {
        _this.events.fire(_this.PRESS, e);
    }

    function onFocus() {
        _this.pressing.length = 0;
    }

    //*** Public methods

}, 'static');

/**
 * @name Mobile
 */

Class(function Mobile() {
    Inherit(this, Component);
    Namespace(this);
    const _this = this;

    var $html;
    var $featureDetects;
    var _is100vh = false;

    Hydra.ready(() => {
        if (!Device.mobile) return;

        initFeatureDetects();
        addHandlers();

        // mobile full screen hack
        if (Device.mobile?.phone && !Device.mobile.native) {
            $html = $(document.documentElement);
            let ios = Device.system.browser === 'safari';
            if (ios) {
                $html.div.classList.add('ios');
            } else {
                $html.div.classList.add('mob');
            }
            _is100vh = true;
            if (ios) __body.css({height: '100%'}).div.scrollTop = 0;
            updateMobileFullscreen();
        }
        if (Device.mobile.native) Stage.css({width: '100vw', height: '100vh'});
    });

    function initFeatureDetects() {
        $featureDetects = __body.create('feature-detects');
    }

    function addHandlers() {
        _this.events.sub(Events.RESIZE, resize);
        if (!Device.mobile.native) window.addEventListener('touchstart', preventNativeScroll, {passive: false});
    }

    function preventNativeScroll(e) {
        if (_this.isAllowNativeScroll) return;

        let target = e.target;

        // Return if element is input type
        if (target.nodeName == 'LABEL' || target.nodeName == 'INPUT' || target.nodeName == 'TEXTAREA' || target.nodeName == 'SELECT' || target.nodeName == 'A') return;

        // Only prevent if none of the elements have requested native scroll using Mobile.overflowScroll()
        let prevent = target.hydraObject;
        while (target.parentNode && prevent) {
            if (target._scrollParent) prevent = false;
            target = target.parentNode;
        }
        if (prevent) e.preventDefault();
    }

    function resize() {
        updateOrientation();
        checkResizeRefresh();
        updateMobileFullscreen();

        // Keep page scrolled to the top for iOS fullscreen 101% hack
        if (!_this.isAllowNativeScroll) document.body.scrollTop = 0;
    }

    function updateOrientation() {
        _this.orientation = Stage.width > Stage.height ? 'landscape' : 'portrait';
        if (!_this.orientationSet) return;
        if (!window.Fullscreen.isOpen && !Device.mobile.pwa) return;
        if (window.screen && window.screen.orientation) window.screen.orientation.lock(_this.orientationSet);
    }

    const checkResizeRefresh = (function() {
        let _lastWidth;
        return function() {
            if (_this.isPreventResizeReload) return;
            if (_lastWidth == Stage.width) return;
            _lastWidth = Stage.width;
            if (Device.system.os !== 'ios' && !(Device.system.os == 'android' && Device.system.version >= 7)) return;

            // Need to use stage as screen doesn't reflect when user sets app to half of screen on tablet
            if (Device.mobile.tablet && !(Math.max(Stage.width, Stage.height) > 800)) window.location.reload();
        }
    })();

    function updateMobileFullscreen() {
        // iOS full screen hack, also works on Android Chrome after exiting a
        // fullscreen video.
        if ($html) {
            let vh100 = $featureDetects.div.offsetHeight;
            if ($html.div.offsetHeight !== Stage.height) {
                if (Stage.height === vh100) {
                    $html.css({height: ''});
                    Stage.css({height: '100%'});
                    _is100vh = true;
                } else {
                    $html.css({height: Stage.height});
                    Stage.css({height: Stage.height});
                    _is100vh = false;
                }
            } else if (!_is100vh && Stage.height === vh100) {
                $html.css({height: ''});
                Stage.css({height: '100%'});
                _is100vh = true;
            }
        }
    }

    //*** Public Methods
    /**
     * @name Mobile.vibrate
     * @memberof Mobile
     *
     * @function
     * @param {Number} duration
     */
    this.vibrate = function(duration) {
        navigator.vibrate && navigator.vibrate(duration);
    };

    /**
     * Add handler on touchend to go to fullscreen. Android-only.
     * @name Mobile.fullscreen
     * @memberof Mobile
     *
     * @function
     */
    this.fullscreen = function() {

        // Return if Native, Progressive Web App, or Emulator
        if (!Device.mobile || Device.mobile.native || Device.mobile.pwa || Dev.emulator) return;

        if (!window.Fullscreen) throw `Mobile.fullscreen requires Fullscreen module`;

        // Fullscreen doesn't work on iOS
        if (Device.system.os !== 'android' || Device.detect('oculus')) return;
        __window.bind('touchend', () => {
            Fullscreen.open();
        });

        if (_this.ScreenLock && _this.ScreenLock.isActive) window.onresize();
    };

    /**
     * Lock orientation if possible.
     * If orientation is utterly important, pass isForce as true - this will force portrait orientation only by rotating stage when necessary.
     * Forced orientation required ScreenLock module.
     * @name Mobile.setOrientation
     * @memberof Mobile
     *
     * @function
     * @param {String} orientation - Either 'portrait' or 'landscape'
     * @param {Boolean} [isForce] Whether to force portrait by rotating stage. For iOS mainly, or Android when not fullscreen.
     */
    this.setOrientation = function(orientation, isForce) {
        // Native orientation lock
        if (_this.System && _this.NativeCore.active) return _this.System.orientation = _this.System[orientation.toUpperCase()];

        _this.orientationSet = orientation;

        updateOrientation();

        if (!isForce) return;
        if (!_this.ScreenLock) throw `Mobile.setOrientation isForce argument requires ScreenLock module`;
        if (orientation === 'any') _this.ScreenLock.unlock();
        else _this.ScreenLock.lock();
    };

    /**
     * Returns a boolean indicating if the user has selected an input or text field and has the keyboard open
     * @name Mobile.isKeyboardOpen
     * @memberof Mobile
     *
     * @function
     */
    this.isKeyboardOpen = function() {
        return Device.mobile && document.activeElement.tagName.toLowerCase().includes(['textarea', 'input']);
    };

    /**
     * Stops preventing default on touch. This will make the body shift on touchmove, which is unwanted in full-screen experiences.
     * @name Mobile.allowNativeScroll
     * @memberof Mobile
     *
     * @function
     */
    this.allowNativeScroll = function(enabled = true) {
        _this.isAllowNativeScroll = enabled;
        let action = enabled ? 'unset' : '';
        [
            $(document.documentElement),
            __body,
            Stage,
        ].forEach($el => $el.css({
            touchAction: action,
            MSContentZooming: action,
            MSTouchAction: action,
        }));
    };

    /**
     * Prevent reload when resize is so drastic that re-definition of phone/tablet required
     * @name Mobile.preventResizeReload
     * @memberof Mobile
     *
     * @function
     */
    this.preventResizeReload = function() {
        _this.isPreventResizeReload = true;
    };

    /**
     * @name Mobile.addOverflowScroll
     * @memberof Mobile
     * @private
     *
     * @function
     * @param {HydraObject} $obj
     */
    this._addOverflowScroll = function($obj) {
        $obj.div._scrollParent = true;
        if (Device.mobile.native) return;
        $obj.div._preventEvent = function(e) {
            e.stopPropagation();
        };
        $obj.bind('touchmove', $obj.div._preventEvent);
    };

    /**
     * @name Mobile.removeOverflowScroll
     * @memberof Mobile
     * @private
     *
     * @function
     * @param {HydraObject} $obj
     */
    this._removeOverflowScroll = function($obj) {
        $obj.unbind('touchmove', $obj.div._preventEvent);
    };

    this.get('phone', () => {
        throw 'Mobile.phone is removed. Use Device.mobile.phone';
    });

    this.get('tablet', () => {
        throw 'Mobile.tablet is removed. Use Device.mobile.tablet';
    });

    this.get('os', () => {
        throw 'Mobile.os is removed. Use Device.system.os';
    });

    (function() {
        var _props = [
            '--safe-area-inset-top',
            '--safe-area-inset-right',
            '--safe-area-inset-bottom',
            '--safe-area-inset-left',
        ];

        function getSafeAreaInset(index) {
            if (!$featureDetects) return 0;
            let style = getComputedStyle($featureDetects.div);
            return parseInt(style.getPropertyValue(_props[index])) || 0;
        }

        _this.getSafeAreaInsets = () => _props.map((_, i) => getSafeAreaInset(i));
        _this.getSafeAreaInsetTop = () => getSafeAreaInset(0);
        _this.getSafeAreaInsetRight = () => getSafeAreaInset(1);
        _this.getSafeAreaInsetBottom = () => getSafeAreaInset(2);
        _this.getSafeAreaInsetLeft = () => getSafeAreaInset(3);
    })();

}, 'Static');


Class(function PushState(_isHash) {
    const _this = this;
    let _store, _useInternal

    let _root = '';

    if (typeof _isHash !== 'boolean') _isHash = Hydra.LOCAL || !Device.system.pushstate;

    this.isLocked = false;

    //*** Constructor
    (function() {
        if (!_this.flag) throw 'Inherit PushState/Router after main class';
        _this.flag('isNotBlocked', true);
        addHandlers();
        _store = getState();
    })();

    function addHandlers() {
        if (_isHash) return window.addEventListener('hashchange', () => handleStateChange(getState()), false);
        window.onpopstate = history.onpushstate = () => handleStateChange(getState());
    }

    function getState() {
        if (_useInternal) return new String(_store);
        else if (_isHash) return String(window.location.hash.slice(3));
        return (!(_root === '/' || _root === '') ? location.pathname.split(_root)[1] : location.pathname.slice(1)) || '';
    }

    function handleStateChange(state, forced) {
        if (state === _store && !forced) return;
        if (_this.isLocked && !forced) {
            if (!_store) return;
            if (_useInternal) _store = _store;
            else if (_isHash) window.location.hash = '!/' + _store;
            else window.history.pushState(null, null, Utils.addQueryToPath(_root + _store));
            return;
        }
        let prevValue = _store;
        _store = state;
        _this.events.fire(Events.UPDATE, {prevValue, value: state, split: state.split('/')});
    }

    //*** Public methods

    this.getState = this._getState = function() {
        if (Device.mobile.native) return Storage.get('app_state') || '';
        return getState();
    };

    this.setRoot = function(root) {
        _root = root.charAt(0) === '/' ? root : '/' + root;
    };

    this.setState = this._setState  = async function(state, forced) {
        _this.events.fire(PushState.SET_STATE);
        await _this.wait('isNotBlocked');
        if (Device.mobile.native) Storage.set('app_state', state);
        if (state === _store && !forced) return;

        if (_useInternal) _store = state;
        else if (_isHash) window.location.hash = '!/' + state;
        else window.history.pushState(null, null, Utils.addQueryToPath(_root + state));

        if (_this.fireChangeWhenSet) handleStateChange(getState(), forced);
        _store = state;
        return true;
    };

    this.enableBlocker = function() {
        _this.flag('isNotBlocked', false);
    };

    this.disableBlocker = function() {
        _this.flag('isNotBlocked', true);
    };

    this.replaceState = function(state) {
        if (state === _store) return;
        _store = state;
        if (_useInternal) _store = state;
        if (_isHash) window.location.hash = '!/' + state;
        else window.history.replaceState(null, null, Utils.addQueryToPath(_root + state));
    };

    this.setTitle = function(title) {
        document.title = title;
    };

    this.lock = function() {
        this.isLocked = true;
        _this.events.fire(PushState.LOCK);
    };

    this.unlock = function() {
        this.isLocked = false;
        _this.events.fire(PushState.UNLOCK);
    };

    this.useHash = function() {
        _isHash = true;
    };

    this.useInternal = function() {
        _useInternal = true;
    };
}, _ => {
    PushState.SET_STATE = 'push_state_set_state';
    PushState.LOCK = 'push_state_lock';
    PushState.UNLOCK = 'push_state_unlock';
});

/**
 * @name Router
 * @example https://www.notion.so/activetheory/Router-640a48eeef824aecad4d56e4822347e5
 */

Class(function Router(_isHash, _rootPath) {
  Inherit(this, PushState, _isHash);
  const _this = this;
  var _debounce, _prevView, _nextView;

  var _routes = [];
  var _404Route;

  _this.currentRoute = null;
  _this.fireChangeWhenSet = true;

  //*** Constructor
  (function () {
    setRootPath();
    initEvents();
  })();

  function initEvents() {
    _this.events.sub(_this, Events.UPDATE, handleState);
  }

  function matchRoute(path) {
    let matchedRoute = null;

    _routes.forEach(routesList => {
      const match = routesList.list.find(route => {
        // match on the route root
        if (route.root === path[0]) {
          if((route.pathSplit.length === path.length) && route.pathSplit[path.length - 1] === '*') {
            // the route we're at is a wildcard
            return true;
          }
          if (!path[1] && !route.params) {
            // route has no params
            return true;
          } else if (path[1] && route.params && !((route.children && route.children.length > 0) || path[2])) {
            // route has param without nesting
            return true;
          } else if (path[1] && (route.children && route.children.length > 0)) {
            // route has param with nesting
            route.children.forEach(c => {
              c.active = c.path === path[2]
            });
            return true;
          } else if (path[1] && route.pathSplit.length === path.length) {
            // if a static route like /test/child, and we found a match this will get hit.
            let didMatchAll = true;
            route.pathSplit.forEach((pathSplitPath, index) => {
              if(pathSplitPath !== path[index]) {
                didMatchAll = false;
              }
            });

            if(didMatchAll) {
              return true;
            }
          }
        }

        return false;
      })

      if (match) {
        matchedRoute = match;
      } else {
        //finally check for paramed routes on the root.
        if(path.length === 1) {
          const paramedRootMatch = routesList.list.find(route => {
            if(route.pathSplit.length === 1 && route.params) {
              return true;
            }
            return false;
          });
          if(paramedRootMatch) {
            matchedRoute = paramedRootMatch;
          }
        }
      }
    })

    return matchedRoute;
  }

  function handleState(e) {
    let value = e?.value;
    let split = e?.split;

    if (!value) {
      value = _this.getState();
      split = value.split('/');
    }
    
    let route = null;
    let cb = null;

    _this.lock();

    _routes.forEach(({ callback, list }) => {
      if (route) {
        return
      }
      route = matchRoute(split);
      cb = callback;
    });

    if(route && route.redirect) {
      let redirectedRoute = matchRoute(route.redirect.split('/'));
      if(redirectedRoute) {
        if(route.updateURL) {
          //if we need to update the URL, lets set the appstate, which will re-hit this handleState function.
          _this.unlock();
          _this.setState(route.redirect);
          return;
        }
        //else, lets set the route to the one we've chosen to go to.
        route = redirectedRoute;
      }
    }

    if (!route) {
      route = _404Route;
    }

    AppState.set('Router/state', value);
    doRoute(route, split, cb)
  }

  async function doRoute(route, split, callback) {
    _nextView = route.view;
    if (_nextView.charAt?.(0) == '$') {
      let ref = _nextView.slice(1);
      if (_this[ref]) _nextView = _this[ref];
      else {
        for (let key in _this.classes) {
          let obj = _this.classes[key];
          if (obj.ref == ref) obj.force();
          _nextView = _this[ref];
        }
      }
    }

    let params = null;

    if (route.params) {
      let param = split.length >= 2 ? split?.[1] : split?.[0];
      params = {
        [Object.keys(route.params)[0]]: param
      }
    } else {
      params = split?.[1]
    }

    await callback?.(_prevView, _nextView, split.join('/'), params, route);
    await _nextView?.onRouteChange?.({ params, path: split.join('/'), name: route.name, children: route.children, meta: route.meta });

    _prevView = _nextView;
    _this.currentRoute = {...route, params};
    _this.unlock();
  }

  function setRootPath(val) {
    let rootPath;
    if (typeof _rootPath === 'string') {
      //if this has manually been set in the constructor
      rootPath = _rootPath;
    } else {
      rootPath = Hydra.LOCAL ? '' : '/'; //without this, no routes get picked up on prod.
    }
    _this.setRoot(rootPath); //on PushState.js
  }

  this._initFragRoutes = function(array) {
    array.forEach(obj => {
      if (obj.view) obj.view = _this[obj.view.slice(1)];
      if (obj.lazyView) obj.view = obj.lazyView;
    });

    this.registerRoutes(_this.onRouteChange, array);
  }

  //*** Public methods
  /**
   * @name this.registerRoutes
   * @memberof Router
   *
   * @function
   * @param callback
   * @param list
  */
  this.registerRoutes = function (callback, list) {
    // check routes with params and append params to a seperate object
    list.forEach(element => {
      const split = element.path.split('/');
      if(element.path.startsWith('/')) {
        throw new Error('router paths should not start with /');
      }
      element.root = split[0];
      element.pathSplit = split;

      if(element.path === '404') {
        _404Route = element;
      }
      split.forEach(s => {
        if (s[0] === ':') {
          element.params = {
            [`${s.substring(1)}`]: ''
          }
          return;
        }
      })
    });

    if(!_404Route) {
      throw new Error('Error: no 404 route defined.  Please define a route whos path is "404" ')
    }

    _routes.push({ callback, list });
    clearTimeout(_debounce);
    _debounce = _this.delayedCall(handleState, 1);
  }

  /**
   * @name this.navigate
   * @memberof Router
   * - navigates to a new URL
   * @function
   * @param path - a path to navigate to.
  */
  this.navigate = function(path) {
    if(path.startsWith('/')) {
      path = path.substring(1);
    }
    _this.setState(path);
  }

  /**
   * @name this.navigate
   * @memberof Router
   * - updates the URL only.
   * @function
   * @param path - a path to navigate to.
  */
  this.replace = function(path) {
    if(path.startsWith('/')) {
      path = path.substring(1);
    }
    _this.replaceState(path);
  }

  /**
   * @name this.getState
   * @memberof Router
   *
   * @function
   * @returns {String}
   */

  /**
   * @name this.setRoot
   * @memberof Router
   *
   * @function
   * @param {String} root
   */

  /**
   * @name this.setState
   * @memberof Router
   *
   * @function
   * @param {String} state
   */

  /**
   * @name this.enableBlocker
   * @memberof Router
   *
   * @function
   */

  /**
   * @name this.replaceState
   * @memberof Router
   *
   * @function
   * @param {String} state
   */

  /**
   * @name this.setTitle
   * @memberof Router
   *
   * @function
   * @param {String} title
   */

  /**
   * @name this.unlock
   * @memberof Router
   *
   * @function
   */
  /**
   * @name this.lock
   * @memberof Router
   *
   * @function
   */
  /**
   * @name this.useInternal
   * @memberof Router
   *
   * @function
   */
  /**
   * @name this.useHash
   * @memberof Router
   *
   * @function
   */
});
/**
 * @name AppState
 */

Class(function AppState(_default) {
    Inherit(this, Component);
    const _this = this;

    var _map = new Map();
    var _bindings = new Map();

    const iGLUI = !!window.GLUI;

    //internal class
    class StateBinding {
        constructor(_keys, _obj) {
            this._keys = _keys;
            this._obj = _obj;
            this._string = '';
            this._oldValue = '';
            this._type = '';
            this._bindingLookup = '';
            this._onDestroy;

            if (_obj instanceof HTMLElement) {
                if (_obj.nodeName == 'INPUT') this._string = _obj.value;
                else this._string = _obj.innerText;
                this._type = 'HTMLElement';
            } else if (_obj instanceof DOMAttribute) {
                this._string = _obj.value
                this._name = _obj.name
                this._belongsTo = _obj.belongsTo
                this._bindingLookup = _obj.bindingLookup
                this._type = 'DOMAttribute'
            } else if (typeof Sprite === 'function' && _obj instanceof Sprite) {
                this._string = _obj.id;
                this._type = 'Sprite';
            } else if (_obj instanceof HydraObject) {
                if (_obj._type == 'input') this._string = _obj.val();
                else this._string = _obj.text();
                this._type = 'HydraObject';
            } else if (iGLUI && _obj instanceof GLUIText) {
                this._string = _obj.getTextString();
                this._type = 'GLUIText';
            } else {
                if (!!_obj.createLocal) this._type = 'appState';
                if (!!_obj.onStateChange) this._type = 'class';
                if (typeof _obj === 'function') this._type = 'function';
                if (Array.isArray(_obj) && _obj.every(el => typeof el === 'function')) {
                    this._type = 'piped'
                    const lastFunctionInChain = this._obj.pop();
                    this._operators = this._obj;
                    this._obj = lastFunctionInChain;
                    this._count = 0;
                }
            }
        }

        parse(key, value) {
            if (!this._string || !this._string.includes('@[')) return value;

            let string = this._string;
            this._keys.forEach(key => {
                string = string.replace(`@[${key}]`, _this.get(key));
            });
            return string;
        }

        /**
         * Pass emitted value through each operator function in this._operators
         * Allows for async functions to be passed in operators
         *
         * @param {*} value
         * @returns
         */
        async operateOnValue(value) {
            return await this._operators.reduce(async (prev, fn) => {
                const prevResolved = await prev;
                const fnResolved = await fn;
                return fnResolved(prevResolved, this._count++, this)
            }, value);
        }

        update(key, value, force) {
            let newValue = this.parse(key, value);
            if (newValue === this._oldValue && !(value && value.push) && !force) return;
            this._oldValue = newValue;

            try {
                switch (this._type) {
                    case 'HTMLElement':
                        if (this._obj._type == 'input') this._obj.value = newValue;
                        else this._obj.innerText = newValue;
                        break;

                    case 'DOMAttribute':
                        this._obj.belongsTo.setAttribute(this._obj.name, this._obj.value.replace(this._obj.bindingLookup, newValue));
                        break;

                    case 'Sprite':
                        this._obj.id = newValue;
                        break;

                    case 'HydraObject':
                        if (this._obj._type == 'input') this._obj.val(newValue);
                        else this._obj.text(newValue);
                        break;

                    case 'GLUIText':
                        this._obj.setText(newValue);
                        break;

                    case 'function':
                        this._obj(value);
                        break;

                    case 'piped':
                        this.operateOnValue(value).then(
                            val => this._obj(val),
                            reject => null
                        );
                        break;

                    case 'class':
                        this._obj.onStateChange(value);
                        break;

                    case 'appState':
                        this._obj.set(key, value);
                        break;

                }
            } catch(err) {
                console.error(`AppState binding failed to execute. You should probably be using _this.bindState instead`);
                console.error(err);
                throw err;
            }

            return true;
        }

        _bindOnDestroy(cb) {
            if (!this._onDestroy) this._onDestroy = [];
            this._onDestroy.push(cb);
        }

        destroy() {
            if (this._onDestroy) this._onDestroy.forEach(cb => cb());

            this._keys = null
            this._obj = null;
            this._string = null;
            this._oldValue = null;
            this._type = null;
            this._operators = null;
            this._count = null;
            this.update = null;
        }
    }

    //*** Event handlers

    //*** Public methods
    /**
     * @name this.set
     * @memberof AppState
     *
     * @function
     * @param key
     * @param value
    */
    this.set = function(key, value, force) {
        if (_this.flag('readonly')) return console.warn(`This AppState is locked and can not make changes`);
        _map.set(key, value);
        if (_this.onUpdate) _this.onUpdate();
        let array = _bindings.get(key);
        if (array) {
            let len = array.length;
            for (let i = 0; i < len; i++) {
                let b = array[i];
                if (b && b.update) {
                    b.update(key, value, force);
                } else {
                    array.splice(i, 1);
                    i -= 1;
                    len = array.length;
                }
            }
        }
    }

    /**
     * @name this.get
     * @memberof AppState
     *
     * @function
     * @param key
    */
    this.get = function(key) {
        return _map.get(key);
    }

    this.getMap = function() {
        return _map;
    }

    /**
     * @name this.toJSON
     * @memberof AppState
     *
     * @function
     */
    this.toJSON = function() {
        return Object.fromEntries(_map);
    }

    /**
     * @name this.bind
     * @memberof AppState
     *
     * @function
     * @param keys
     * @param rest - all remaining arguments passed, can be single callback or otherwise second parameter to pass to AppState.bind,
     * or multiple callbacks
    */
    this.bind = function(keys, ...rest) {
        if (!rest.length) return {state: _this, key: keys};
        if (!Array.isArray(keys)) keys = [keys];

        const obj = rest.length === 1 ? rest[0] : rest;

        let binding = new StateBinding(keys, obj);

        keys.forEach(key => {
            if (_bindings.has(key)) _bindings.get(key).push(binding);
            else _bindings.set(key, [binding]);

            let value = _map.get(key);
            if (typeof value !== 'undefined') binding.update(key, value);
        });

        return binding;
    }

    /**
     * @name this.createLocal
     * @memberof AppState
     *
     * @function
     * @param obj
    */
    this.createLocal = function(obj) {
        let appState = new AppState(obj);
        return new Proxy(appState, {
            set(target, property = '', value) {
                if (property.includes(['origin', 'onUpdate'])) appState[property] = value;
                else appState.set(property, value);
                return true;
            },

            get(target, property) {
                if (!!target[property]) return target[property];
                return appState.get(property);
            }
        });
    }

    this.setAll = function(obj) {
        for (let key in obj) {
            _this.set(key, obj[key]);
        }
    }

    this.lock = function() {
        _this.flag('readonly', true);
    }

    this.unlock = function() {
        _this.flag('readonly', false);
    }

    if (_default) this.setAll(_default);

}, 'static');

/**
 * @name AppStateOperators
 * 
 * operators that emitted value can be piped through
 * 
 * state.bind('myvalue',
 *  skip(1),
 *  map(value => value + 1),
 *  tap(value => console.log(value + 1)),
 *  // last function can be an operator or any function
 *  myFunction
 * )
 * 
 */

 Class(function AppStateOperators(_default) {
     Inherit(this, Component)

    /**
     * @name map
     * @memberof AppStateOperators
     * 
     * Apply a transformation to each emitted source value, return that transformed value
     * 
     * map(value => value + 1)
     * 
     * @param {function (value) {return modifiedValue}}
     */
     this.map = fn => value => fn(value);

    /**
     * @name tap
     * @memberof AppStateOperators
     * 
     * Perform side effects with each emission, return the source value unchanged
     * 
     * tap(value => _this.count = value)
     * 
     * @param {function (value) {return value}}
     */
     this.tap = fn => value => (fn(value), value);

     /**
     * @name filter
     * @memberof AppStateOperators
     * 
     * Check emitted source value against conditions
     *
     * If passes, returns source value
     * If fails, returns a rejected Promise which will prevent binding emission
     * 
     * Passed in function has access to both emitted value, as well as number of emissions
     * associated binding
     * 
     * // only take emissions with value greater than 4
     * filter(value => value > 4)
     * 
     * // only take first 3 emissions
     * filter((value, emittedCount) => emittedCount < 3)
     * 
     * @param {function (value, emittedCount) {return value}}
     */
     this.filter = fn => {
        return (value, emittedCount) => {
            if (!fn(value, emittedCount)) return Promise.reject()
            return value
        }
    }

    /**
     * @name skip
     * @memberof AppStateOperators
     * 
     * Skip the given number of emissions
     * 
     * // skip first
     * skip(1)
     * 
     * @param {skipCount} number of emissions to skip
     */
    this.skip = skipCount => this.filter((_,  emittedCount) => {
        return skipCount <= emittedCount
    })

    /**
     * !! EXPERIMENTAL !!
     * so use at your own risk
     * 
     * Allows for auto binding.destroy
     * 
     * untilDestroyed(ComponentContext)
     * untilDestroyed(_this)
     * 
     * @param {*} ctx - Component context
     * @returns 
     */
    this.untilDestroyed = ctx => {
        let checked = false;
        return (value, _, binding) => {
            if (checked) return value;
            checked = true;
            // _bindOnDestroy ok to use?
            ctx._bindOnDestroy(_ => {
                if (Hydra.LOCAL) console.log('binding destroyed ')
                binding.destroy?.()
            })
            return value
        }

    }

}, 'static');



/**
 * @name AppStore
 */

Class(function AppStore() {
    const _this = this;

    this.state = AppState.createLocal();
    const _mutations = {};
    const _actions = {};
    let _subscribers = [];
    let _actionSubscribers = [];

    // *** Notes
    /*
    A mutation is only a convention.
    It allows us to work the state with a more "human" approach (i.e "Paint the car in red", compared to "set car paint red").
    A mutation can also be bound to one or more subscribers, which is nice for listening to changes in the state.

    An action is a promise that regroups a bunch of mutations together because it makes sense to do so ("Repair the car: change tyres, check oil levels, check brakes"). An action can have "before" and "after" subscribers

    Subscribers are callbacks that respond to a certain mutation/action. Their architecture makes it possible to have multiple callbacks per mutation type.

    See https://github.com/vuejs/vuex/blob/4.0/src/store.js for inspiration
    */

    function setInitState(_params) {
        const { state } = _params;

        for (let key in state) {
            _this.state.set(key, state[key]);
        }
    }

    function mapMutations(_params) {
        const { mutations } = _params;

        for (let key in mutations) {
            registerMutation(key, mutations[key]);
        }
    }

    function mapActions(_params) {
        const { actions } = _params;

        for (let key in actions) {
            registerAction(key, actions[key]);
        }
    }

    function registerMutation(type, handler) {
        // we want to be able to have multiple handlers per type
        const entry = _mutations[type] || (_mutations[type] = []);

        // automaticaly pass the state to the handler and bind _this
        entry.push(function wrappedMutationHandler(payload) {
            handler.call(_this, _this.state, payload);
        });
    }

    function registerAction(type, handler) {
        const entry = _actions[type] || (_actions[type] = []);
        entry.push(function wrappedActionHandler(payload) {
            let res = handler.call(_this, {
                dispatch: _this.dispatch,
                commit: _this.commit,
                state: _this.state,
                rootState: _this.state
            }, payload);

            if (!isPromise(res)) {
                res = Promise.resolve(res);
            }
            return res;
        });
    }

    function isPromise(val) {
        return val && typeof val.then === 'function';
    }

    //*** Event handlers

    //*** Public methods
    /**
     * @name this.createAppStore
     * @memberof AppStore
     *
     * @function
     * @param _params
    */
    this.createAppStore = function(_params) {
        setInitState(_params);
        mapMutations(_params);
        mapActions(_params);
    }


    /**
     * @name this.commit
     * @memberof AppStore
     *
     * @function
     * @param type
     * @param payload
    */
    this.commit = function (type, payload) {
        const mutation = { type, payload };
        const entry = _mutations[type];

        if (!entry) {
            if (Hydra.LOCAL) {
                console.error(`Error: no mutation for type ${type}`);
            }
            return;
        }

        entry.forEach(function commitIterator(handler) {
            handler(payload);
        });

        _subscribers
            .slice() // shallow copy to prevent iterator invalidation if subscriber synchronously calls unsubscribe
            .forEach(sub => sub(mutation, this.state));
    };

    /**
     * @name this.dispatch
     * @memberof AppStore
     *
     * @function
     * @param type
     * @param payload
    */
    this.dispatch = function (type, payload) {
        const action = { type, payload };
        const entry = _actions[type];

        if (!entry) {
            if (Hydra.LOCAL) {
                console.error(`Error: no action for type ${type}`);
            }
        }

        try {
            _actionSubscribers
                .slice() // shallow copy to prevent iterator invalidation if subscriber synchronously calls unsubscribe
                .filter(sub => sub.before)
                .forEach(sub => sub.before(action, _this.state));
        } catch (e) {
            if (Hydra.LOCAL) {
                console.warn('Error in before action subscribers: ');
                console.error(e);
            }
        }

        const result = entry.length > 1 ?
            Promise.all(entry.map(handler => handler(payload))) :
            entry[0](payload);

        return new Promise((resolve, reject) => {
            result.then(res => {
                try {
                    _actionSubscribers
                        .filter(sub => sub.after)
                        .forEach(sub => sub.after(action, _this.state));
                } catch (e) {
                    if (Hydra.LOCAL) {
                        console.warn(`Error in after action subscribers: `);
                        console.error(e);
                    }
                }
                resolve(res);
            }, error => {
                try {
                    _actionSubscribers
                        .filter(sub => sub.error)
                        .forEach(sub => sub.error(action, _this.state, error));
                } catch (e) {
                    if (Hydra.LOCAL) {
                        console.warn(`Error in error action subscribers: `);
                        console.error(e);
                    }
                }
                reject(error);
            });
        });
    };

    function genericSubscribe(fn, subscribers, options) {
        if (subscribers.indexOf(fn) < 0) {
            options && options.prepend ?
                subscribers.unshift(fn) :
                subscribers.push(fn);
        }

        // return the unsubscriber
        return () => {
            const i = subscribers.indexOf(fn);

            if (i > -1) {
                subscribers.splice(i, 1);
            }
        };
    }

    /**
     * @name this.subscribeAction
     * @memberof AppStore
     *
     * @function
     * @param key
     * @param fn
     * @param options
    */
    this.subscribeAction = function (key, fn, options) {
        // when an action happens, all the subscriber wrappers are called and only the ones that correspond to the action type execute the actual subscriber

        function subscriberEmptyBeforeWrapper(action) {
            if (action.type === key) {
                fn(action);
            }
        }

        function subscriberBeforeWrapper(action) {
            if (action.type === key) {
                fn.before(action);
            }
        }

        function subscriberAfterWrapper(action) {
            if (action.type === key) {
                fn.after(action);
            }
        }

        let subs = {};

        if (typeof fn === 'function') {
            subs.before = subscriberEmptyBeforeWrapper;
        } else {
            if (fn.before) {
                subs.before = subscriberBeforeWrapper;
            }

            if (fn.after) {
                subs.after = subscriberAfterWrapper;
            }
        }

        return genericSubscribe(subs, _actionSubscribers, options);
    };

    /**
     * @name this.subscribe
     * @memberof AppStore
     *
     * @function
     * @param key
     * @param fn
     * @param options
    */
    this.subscribe = function (key, fn, options) {
        // when a mutation happens, all the subscriber wrappers are called and only the ones that correspond to the mutation type execute the actual subscriber
        function subscriberWrapper(mutation) {
            if (mutation.type === key) {
                fn(mutation);
            }
        }
        return genericSubscribe(subscriberWrapper, _subscribers, options);
    };

    /**
     * Alias to this.state.bind
     * @name this.bind
     * @memberof AppStore
     *
     * @function
     */
    /**
     * Alias to this.state.watch
     * @name this.watch
     * @memberof AppStore
     *
     * @function
     */
    /**
     * Alias to this.state.get
     * @name this.get
     * @memberof AppStore
     *
     * @function
     */
    this.bind = this.state.bind;
    this.watch = this.state.bind; //an alias that is more vue like

    this.get = this.state.get;
});
/**
 * @name StateArray
 * @example
 *
 * To filter data, pass a predicate as second argument when initializing
 * whose signature matches the shape of the data being processed
 *
 * const st = new StateArray([
 *   {
 *     name: 'Tom',
 *     animal: 'cat'
 *   },
 *   {
 *     name: 'Jerry',
 *     animal: 'mouse'
 *   }
 *  ],
 *  ({ name, animal }) =>  animal === 'cat'
 * );
 *
 * st.length // 1
 *
 * If you are subbing to the state array at a later point,
 * use the `setFilter()` to update the data and filter condition.
 *
 */


Class(function StateArray(_src = [], _filterFn = null) {
    Inherit(this, Events);
    const _this = this;

    var _data = [];

    Object.defineProperty(_this, 'length', {
        get: function () {
            return _data.length;
        }
    });

    function wrap(obj) {
        if (typeof obj !== 'object' || Array.isArray(obj)) throw `StateArray entries must be {objects}!`;
        if (!obj._uid) obj._uid = Utils.uuid();
        if (!!obj.createLocal) return obj;
        let state = AppState.createLocal(obj);
        state.origin = obj;
        return state;
    }

    /**
     * @name this.setFilter
     * @memberof StateArray
     *
     * @function
     * @param {Function} fn - filter predicate
     * @param {boolean} refresh - if false, previous unfiltered data will be retained
    */
     this.setFilter = function(fn, refresh = true) {
        _filterFn = fn;
        if (refresh) this.refresh(_data.filter(fn));
    }

    /**
     * @name this.push
     * @memberof StateArray
     *
     * @function
     * @param obj
    */
    this.push = function(obj) {
        if (_filterFn && !_filterFn(obj)) return;
        let state = wrap(obj);
        _data.push(state);

        let index = _data.length-1;
        if (_this[index] === undefined) {
            Object.defineProperty(_this, index, {
                set: function (v) {
                    for (let key in v) {
                        _data[index].set(key, v[key]);
                    }
                },

                get: function () {
                    return _data[index];
                }
            });
        }

        _this.events.fire(Events.UPDATE, {type: 'add', state});
        return state;
    }

    /**
     * @name this.remove
     * @memberof StateArray
     *
     * @function
     * @param obj
    */
    this.remove = function(obj) {
        for (let i = 0; i < _data.length; i++) {
            let state = _data[i];
            if (state.origin === obj || state === obj) {
                _data.splice(i, 1);
                _this.events.fire(Events.UPDATE, {type: 'remove', state}, true);
            }
        }
    }

    /**
     * @name this.update
     * @memberof StateArray
     *
     * @function
     * @param obj
    */
    this.update = async function(obj) {
        var _found = false;
        for (let i = 0; i < _data.length; i++) {
            var state = _data[i];
            if (state.origin._uid === obj._uid || state._uid === obj._uid) {
                await state.setAll(obj);
                _this.events.fire(Events.UPDATE, {type: 'modify', state, index: i });
                _found = true;
                return _found;
            }
        }
        return _found;
    }

    /**
     * @name this.forEach
     * @memberof StateArray
     *
     * @function
     * @param cb
    */
    this.forEach = function(cb) {
        _data.forEach(function (...args) {
            return cb.apply(this, args);
        });
    }

    /**
     * @name this.map
     * @memberof StateArray
     *
     * @function
     * @param cb
    */
    this.map = function(cb) {
        let array = [];
        _data.forEach(function (...args) {
            return array.push(cb.apply(this, args));
        });
        return array;
    }

    /**
     * @name this.toJSON
     * @memberof StateArray
     *
     * @function
     * @param array (optional)
     */
    this.toJSON = function() {
        let array = [];
        _data.forEach(appState => {
            array.push(appState.toJSON());
        });
        return array;
    }

    /**
     * @name this.getMap
     * @memberof StateArray
     *
     * @function
     * @returns {Map[]} an array of appState Maps
     */
     this.getMap = function() {
        let array = [];
        _data.forEach(appState => {
            array.push(appState.getMap());
        });
        return array;
    };

    /**
     * @name this.indexOf
     * @memberof StateArray
     *
     * @function
     * @param obj
    */
    this.indexOf = function(obj) {
        for (let i = 0; i < _data.length; i++) {
            let state = _data[i];
            if (state.origin === obj || state === obj) {
                return i;
            }
        }
    }

    /**
     * @name this.refresh
     * @memberof StateArray
     *
     * @function
     * @param array
    */
    this.refresh = function(array) {
        if (!Array.isArray(array) && !(array instanceof StateArray)) array = [array];
        _this.events.fire(StateArray.REFRESH, {type: 'refresh'}, true);

        let i = _data.length;
        while (i--) {
            let state = _data.pop();
            _this.events.fire(Events.UPDATE, {type: 'remove', state}, true);
        }

        _data.length = 0;
        array.forEach(_this.push);
    }

    this.reflow = function() {
        this.refresh(_data.map(d => d.origin));
    }

    if (!Array.isArray(_src)) throw `StateArray can only take an array as a parameter`;
    _src.forEach(_this.push);
}, _ => {
    StateArray.REFRESH = 'state_array_refresh';
});

/**
 * @name ViewState
 * @example
 */
Class(function ViewState(ViewClass, ...rest) {
    Inherit(this, Component);
    const _this = this;
    var _stateArray, _params;
    var _callbacks = {};
    var _bindings = [];

    if (typeof ViewClass === 'object' && ViewClass.view) {
        _params = ViewClass;
        ViewClass = _params.view;
        rest = [_params];
        delete _params.view;
        _this.listen = function(key, callback) {
            _bindings.push(key);
            _callbacks[key] = callback;
        };
    }
    
    if (typeof ViewClass === 'string') ViewClass = window[ViewClass];

    var _instances = this.views = [];

    function remove(data) {
        for (let i = 0; i < _instances.length; i++) {
            let inst = _instances[i];
            if (data == inst.data) {
                _this.onRemoveView?.(inst, i);
                _instances.splice(i, 1);
                _instances.length === 0 && _this.onEmpty?.();
                inst.destroy();
                break;
            }
        }
        ViewState.clearScheduled(data);
    }

    function update(data, index) {
        var _exists = false;
        for (let i = 0; i < _instances.length; i++) {
            let inst = _instances[i];
            if (data._uid === inst.data._uid) {
                _this.onUpdateView?.(_instances[i], i);
                _exists = true;
                return;
            }
        }
        if (!_exists) { // create a new instance
            ViewState.schedule(_this, ViewClass, data, _stateArray.indexOf(data));
        }
    }

    //*** Event handlers
    function dataUpdate(e) {
        switch (e.type) {
            case 'add':
                _this.dataFilter(e.state) && ViewState.schedule(_this, ViewClass, e.state, _stateArray.indexOf(e.state), rest);
                break;

            case 'remove':
                remove(e.state);
                break;

            case 'modify':
                _this.dataFilter(e.state) ? update(e.state, e.index) : remove(e.state);
                break;
        }
    }

    //*** Public methods
    /**
     * @name this.setSourceData
     * @memberof ViewState
     *
     * @function
     * @param array
    */
    this.setSourceData = function(array) {
        if (!(array instanceof StateArray)) throw `ViewState::setSourceData must be instance of StateArray`;
        _stateArray = _this.stateArray = array;
        _this.events.sub(array, Events.UPDATE, dataUpdate);

        array.forEach(state => {
            _this.dataFilter(state) && ViewState.schedule(_this, ViewClass, state, _stateArray.indexOf(state), rest);
        });
    };

    /**
     * @name this.dataFilter
     * @memberof ViewState
     *
     * @function
     * @param data
     *
     * Override this function in a Class that inherits ViewState
     * to set up any filtering of StateArray items prior to them
     * being added to the RenderWorker schedule
    */
    this.dataFilter = function(data) {
        return true
    };

    /**
     * @name this.onInitialize
     * @memberof ViewState
     *
     * @function
     * @param instance
    */
    this.onInitialize = function(instance) {
        // Insert in the correct order
        let unfilteredIndex = _stateArray.indexOf(instance.data);
        let filteredIndex = -1;
        for (let i = 0; i < _instances.length; ++i) {
            let data = _instances[i].data;
            let index = _stateArray.indexOf(data);
            if (index > unfilteredIndex) {
                filteredIndex = i;
                break;
            }
        }
        if (filteredIndex < 0) {
            filteredIndex = _instances.length;
        }

        if (instance.element && _this.parent.element && _this.parent.element.add) {
            let before = null;
            if (filteredIndex < _instances.length && _instances[filteredIndex].element) {
                before = _instances[filteredIndex];
            }
            _this.parent.element.add(instance.element, before);
        }
        _instances.splice(filteredIndex, 0, instance);

        if (_this.listen && instance.state) {
            _bindings.forEach(key => {
                _this.bindState(instance.state, key, data => {
                    _callbacks[key]?.({target: instance, data});
                });
            });
        }

        if (_params?.__parent) _params.__parent.add(instance);
        _this.onAddView?.(instance, filteredIndex);
        _params?.onAddView?.(instance, filteredIndex);
    };

    if (_params?.data) this.setSourceData(_params.data);
}, _ => {
    const queue = [];
    const worker = new Render.Worker(_ => {
        let obj = queue.shift();
        if (obj) {
            let { ref, ViewClass, data, index, additionalArgs } = obj;
            if (!ref.initClass) return;
            let args = [];
            additionalArgs.forEach(arg => {
                args.push(...arg);
            });
            // Pass null as last arg, to prevent adding instance to parent.element.
            // Will add in the correct (filtered) order in ref.onInitialize()
            let inst = ref.initClass(ViewClass, data, index, ...args, null);
            inst.data = data;
            ref.onInitialize(inst);
        } else {
            worker.pause();
        }
    }, 2);
    worker.pause();

    ViewState.clearScheduled = function(data) {
        for (let i = 0; i < queue.length; i++) {
            let obj = queue[i];
            if (obj.data === data) return queue.splice(i, 1);
        }
    };

    ViewState.schedule = function(ref, ViewClass, data, index, ...rest) {
        if (!ref.initClass) return;
        queue.push({ ref, ViewClass, data, index, additionalArgs: rest });
        worker.resume();
    };
});


Class(function ViewStateElement() {
    
});
/**
 * Inherit this class to add on some utility methods for subscribing to mutations / actions of an instance of an AppStore.
 * Important note: when using this class you should be inheriting from a class that eventually inherits Component.
 * If not, you should manually call this.unsubscribeAll on your own custom destroy method.
 * @name StateComponent
 * @example
 */
Class(function StateComponent() {
    const _this = this;

    let _mutationsUnsubscribers = [];
    let _actionsUnsubscribers = [];

    /**
     * @name this.unsubscribeMutations
     * @memberof StateComponent
     *
     * @function
    */
    this.unsubscribeMutations = function () {
        _mutationsUnsubscribers.forEach(u => u());
    };

    /**
     * @name this.unsubscribeActions
     * @memberof StateComponent
     *
     * @function
    */
    this.unsubscribeActions = function () {
        _actionsUnsubscribers.forEach(u => u());
    };

    /**
     * @name this.unsubscribeAll
     * @memberof StateComponent
     *
     * @function
    */
    this.unsubscribeAll = function () {
        _this.unsubscribeMutations();
        _this.unsubscribeActions();
    };

    /**
     * @name this.subscribeMutation
     * @memberof StateComponent
     *
     * @function
     * @param store
     * @param type
     * @param fn
    */
    this.subscribeMutation = function (store, type, fn) {
        _mutationsUnsubscribers.push(
            store.subscribe(type, fn)
        );
    };

    /**
     * @name this.subscribeAction
     * @memberof StateComponent
     *
     * @function
     * @param store
     * @param type
     * @param fn
    */
    this.subscribeAction = function (store, type, fn) {
        _actionsUnsubscribers.push(
            store.subscribeAction(type, fn)
        );
    };

    /**
     * @name this.commit
     * @memberof StateComponent
     *
     * @function
     * @param store
     * @param type
     * @param payload
    */
    this.commit = function (store, type, payload) {
        store.commit(type, payload);
    };

    this.dispatch = async function (store, type, payload) {
        await store.dispatch(type, payload);
    };

    /**
     * @name this.getState
     * @memberof StateComponent
     *
     * @function
     * @param store
     * @param key
    */
    this.getState = function (store, key) {
        return store.get(key);
    };

    /**
     * @name this.watch
     * @memberof StateComponent
     *
     * @function
     * @param store
     * @param key
     * @param fn
     * @param callInitial - boolean.  Call the callback function on initial data set?
    */
     this.watch = function(store, key, fn, callInitial = true) {
        let hasCalled = false;
        const callback = (params) => {
            if (!hasCalled && !callInitial) {
                hasCalled = true;
                return;
            }
            fn(params);
        };
        if (_this.bindState) {
            return _this.bindState(store, key, callback);
        }
        return store.watch(key, callback);
    };

    this.bind = this.watch;

    if(typeof this._bindOnDestroy === 'function') {
        //this assumes your component you're inheriting with also inherits component.
        //if not, you'll have to manually unsubscribe these events on your own custom destroy method.
        this._bindOnDestroy(() => {
            _this.unsubscribeAll();
        });

    }

});

/**
 * @name Dev
 */
Class(function Dev() {
    const _this = this;

    let _post, _alert, _inter, _timerName;

    let _id = Utils.timestamp();

    (function() {
        _post = `https://us-central1-at-services.cloudfunctions.net/logger?projectId=` + window.UIL_ID;
    })();

    function catchErrors() {
        window.onerror = function(message, file, line, column, e) {
            postError({message, file, line, column, stack: e && e.stack.toString()});
        };

        window.addEventListener("unhandledrejection", e => {
            postError({type: 'unhandledrejection', message: e.reason.message, stack: e.reason.stack});
        });
    }

    function postError(error) {
        let device = getDebugInfo();
        let tests = getTests();

        post(_post + '&type=error', {error, device, tests}).catch(function () {
            Hydra.LOCAL && console.log('Error whle posting to server')
        });
    }

    function getDebugInfo() {
        return {
            gpu: Device.graphics.webgl ? Device.graphics.webgl.gpu : 'WEBGL UNAVAILABLE',
            version: Device.graphics.webgl ? Device.graphics.webgl.version : 'WEBGL UNAVAILABLE',
            tier: window.GPU ? (Device.mobile ? GPU.M_TIER : GPU.TIER) : '',
            mobile: JSON.stringify(Device.mobile),
            userAgent: Device.agent,
            dpr: Device.pixelRatio,
            renderDPR: RenderManager.DPR,
            screenSize: `${screen.width} x ${screen.height}`,
            stageSize: `${Stage.width} x ${Stage.height}`,
            href: window.location.href,
            targetFPS: Render.REFRESH_RATE
        };
    }

    function getTests() {
        let tests = {};
        try {
            if (window.Tests) {
                for (let key in Tests) {
                    if (typeof Tests[key] === 'function') {
                        tests[key] = Tests[key]();
                    }
                }
            }
        } catch(e) { }
        return tests;
    }

    this.catchErrors = catchErrors;

    this.emulator = Device.mobile && navigator.platform && navigator.platform.toLowerCase().includes(['mac', 'windows']);

    /**
     * @name this.expose
     * @memberof Dev
     *
     * @function
     * @param name
     * @param val
     * @param force
    */
    this.expose = function(name, val, force) {
        if (Hydra.LOCAL || force) window[name] = val;
    }

    /**
     * @name this.unsupported
     * @memberof Dev
     *
     * @function
     * @param needsAlert
    */
    this.unsupported = function(needsAlert) {
        if (needsAlert) alert('Hi! This build is not yet ready for this device, things may not work as expected. Refer to build schedule for when this device will be supported.');
    }

    /**
     * @name this.checkForLeaks
     * @memberof Dev
     *
     * @function
     * @param flag
     * @param array
    */
    this.checkForLeaks = function(flag, array) {
        if (window.AURA) return;

        let exceptions = ['_ga', '_typeface_js', '_xdc_', '_babelPolyfill', '$jscomp'];

        if (window.HYDRA_LEAKS_EXCEPTIONS) {
            exceptions = exceptions.concat(window.HYDRA_LEAKS_EXCEPTIONS);
        }

        var matchArray = function(prop) {
            if (!array) return false;
            for (var i = 0; i < array.length; i++) {
                if (prop.includes(array[i])) return true;
            }
            return false;
        };

        clearInterval(_inter);
        if (flag) {
            _inter = setInterval(function() {
                for (var prop in window) {
                    if (prop.includes('webkit')) continue;
                    var obj = window[prop];
                    if (typeof obj !== 'function' && prop.length > 2) {
                        if (prop.includes(exceptions) || matchArray(prop)) continue;
                        var char1 = prop.charAt(0);
                        var char2 = prop.charAt(1);
                        if (char1 == '_' || char1 == '$') {
                            if (char2 !== char2.toUpperCase()) {
                                console.log(window[prop]);
                                throw 'Hydra Warning:: '+prop+' leaking into global scope';
                            }
                        }
                    }
                }
            }, 1000);
        }
    }

    this.postErrorsToServer = _ => {};

    this.postPerfLog = function(perf) {
        let device = getDebugInfo();
        let tests = getTests();

        post(_post + '&type=perf', {perf, device, tests}).catch(function () {
            Hydra.LOCAL && console.log('Error whle posting to server')
        });
    }

    /**
     * @name this.startTimer
     * @memberof Dev
     *
     * @function
     * @param name
    */
    this.startTimer = function(name) {
        _timerName = name || 'Timer';
        if (console.time && !window._NODE_) console.time(_timerName);
        else _timer = performance.now();
    }

    /**
     * @name this.stopTimer
     * @memberof Dev
     *
     * @function
    */
    this.stopTimer = function() {
        if (console.time && !window._NODE_) console.timeEnd(_timerName);
        else console.log('Render '+_timerName+': '+(performance.now() - _timer));
    }

    /**
     * @name this.writeFile
     * @memberof Dev
     *
     * @function
     * @param file
     * @param data
    */
    this.writeFile = function(file, data) {
        let promise = Promise.create();
        let protocol = location.protocol;
        let port = protocol === 'https:' ? ':8018' : ':8017';
        let url = protocol + '//' + location.hostname + port + location.pathname + file;
        post(url, data, {headers: {'content-type': 'text/plain'}}).then(e => {
            if (e != 'OK') {
                console.warn(`Unable to write to ${file}`);
                promise.reject();
            } else {
                promise.resolve();
            }
        });
        return promise;
    }

    /**
     * @name this.execUILScript
     * @memberof Dev
     *
     * @function
     * @param name
     * @param data
     */
    this.execUILScript = async function(name, data) {
        if (!Hydra.LOCAL) return;

        let url = `${location.protocol}//${location.hostname}:8017${(_this.pathName || location.pathname)}/uil/${name}`;

        let response = await post(url, data, { headers: { 'Content-Type': 'text/plain' } });
        if (response === 'ERROR' || response.success === false) {
            throw response;
        }

        return response;
    }

    if (Hydra.LOCAL) _this.checkForLeaks(true);
}, 'static');

/**
 * @name Service
 */

Class(function Service() {
    Inherit(this, Component);
    var _this = this;
    var _sw;

   /**
    * @name active
    * @memberof Service
    * @property
    */
    this.active = false;
   /**
    * @name ready
    * @memberof Service
    * @property
    */
    this.ready = false;
   /**
    * @name cached
    * @memberof Service
    * @property
    */
    this.cached = false;
   /**
    * @name offline
    * @memberof Service
    * @property
    */
    this.offline = false;
   /**
    * @name disabled
    * @memberof Service
    * @property
    */
    this.disabled = false;

    //*** Constructor
    (function () {
    })();

    function initWorker() {
        _this.active = true;
        navigator.serviceWorker.register(`${window._SW_PATH_ ? window._SW_PATH_ : ''}sw.js`).then(handleRegistration).then(handleReady).then(handleError);
    }

    function checkCache() {
        var cache = Storage.get('service_cache');
        if (cache != window._CACHE_) _this.post('clearCache');
    }

    function getSWAssets() {
        if (!window.ASSETS.SW || _this.cached) return [];
        var assets = window.ASSETS.SW;

        assets.forEach((asset, i) => {
            if (asset.includes('.js')) asset = assets[i].replace('.js', '.js?' + window._CACHE_);
        });

        return assets;
    }

    //*** Event handlers
    function handleRegistration(e) {

    }

    function handleReady(e) {
        _this.isReady = true;
        _this.events.fire(Events.READY, e, true);
        _sw = navigator.serviceWorker.controller;

        checkCache();
    }

    function handleError(e) {
        if (e) {
            _this.events.fire(Events.ERROR, e, true);
            _this.active = false;
        }
    }

    function handleMessage(e) {
        var data = e.data;
        if (data.evt) _this.events.fire(data.evt, data);
    }

    //*** Public methods
    /**
     * @name Service.ready
     * @memberof Service
     *
     * @function
    */
    this.ready = function() {
        return this.wait(this, 'isReady');
    }

    /**
     * @name Service.init
     * @memberof Service
     *
     * @function
    */
    this.init = function() {
        Hydra.ready(() => {
            if ('serviceWorker' in navigator && (!Hydra.LOCAL || location.port != '') && !window.process && !_this.disabled) initWorker();
        });
    }

    /**
     * @name Service.cache
     * @memberof Service
     *
     * @function
     * @param assets
    */
    this.cache = function(assets = []) {
        assets = Array.from(assets);

        let upload = function() {
            _this.post('upload', {assets: assets, cdn: Assets.CDN, hostname: location.hostname, sw: getSWAssets(), offline: _this.offline});
            Storage.set('service_cache', window._CACHE_);
            _this.cached = true;
        };

        if (_this.active) _this.wait(_this, 'ready', upload);
    }

    /**
     * @name Service.post
     * @memberof Service
     *
     * @function
     * @param fn
     * @param data
    */
    this.post = function(fn, data = {}) {
        if (!_this.active) return;

        let send = function() {
            let mc = new MessageChannel();
            mc.port1.onmessage = handleMessage;

            data.fn = fn;
            _sw && _sw.postMessage(data, [mc.port2]);
        };

        _this.wait(_this, 'ready', send);
    }
}, 'static');
/**
 * @name Storage
 */

Class(function Storage() {
    var _this = this;
    var _storage;
    var _sessionData = {};

    this.noTracking = false;

    (function() {
        testStorage();
    })();

    function testStorage() {
        try {
            if (window.localStorage) {
                try {
                    window.localStorage['test'] = 1;
                    window.localStorage.removeItem('test');
                    _storage = true;
                } catch (e) {
                    _storage = false;
                }
            } else {
                _storage = false;
            }
        } catch(e) {
            _storage = false;
        }
    }

    function cookie(key, value, expires) {
        var options;
        if (arguments.length > 1 && (value === null || typeof value !== "object")) {
            options = {};
            options.path = '/';
            options.expires = expires || 1;

            if (value === null) {
                options.expires = -1;
            }

            if (typeof options.expires === 'number') {
                var days = options.expires, t = options.expires = new Date();
                t.setDate(t.getDate() + days);
            }

            return (document.cookie = [
                encodeURIComponent(key), '=',
                options.raw ? String(value) : encodeURIComponent(String(value)),
                options.expires ? '; expires=' + options.expires.toUTCString() : '',
                options.path ? '; path=' + options.path : '',
                options.domain ? '; domain=' + options.domain : '',
                options.secure ? '; secure' : ''
            ].join(''));
        }

        options = value || {};
        var result, decode = options.raw ? function (s) { return s; } : decodeURIComponent;
        return (result = new RegExp('(?:^|; )' + encodeURIComponent(key) + '=([^;]*)').exec(document.cookie)) ? decode(result[1]) : null;
    }

    //*** Public Methods
    /**
     * @name Storage.setCookie
     * @memberof Storage
     *
     * @function
     * @param key
     * @param value
     * @param expires
    */
    this.setCookie = function(key, value, expires) {
        cookie(key, value, expires);
    }

    /**
     * @name Storage.getCookie
     * @memberof Storage
     *
     * @function
     * @param key
    */
    this.getCookie = function(key) {
        return cookie(key);
    }

    /**
     * @name Storage.set
     * @memberof Storage
     *
     * @function
     * @param key
     * @param value
    */
    this.set = function(key, value) {
        if (_this.noTracking) {
            _sessionData[key] = value;
            return;
        }

        if (value != null && typeof value === 'object') value = JSON.stringify(value);
        if (_storage) {
            if (value === null) window.localStorage.removeItem(key);
            else window.localStorage[key] = value;
        } else {
            cookie(key, value, 365);
        }
    }

    /**
     * @name Storage.get
     * @memberof Storage
     *
     * @function
     * @param key
    */
    this.get = function(key) {
        if (_this.noTracking) {
            return _sessionData[key];
        }

        var val;
        if (_storage) val = window.localStorage[key];
        else val = cookie(key);

        if (val) {
            var char0;
            if (val.charAt) char0 = val.charAt(0);
            if (char0 == '{' || char0 == '[') val = JSON.parse(val);
            if (val == 'true' || val == 'false') val = val == 'true' ? true : false;
        }
        return val;
    }
} ,'Static');

/**
 * @name Thread
 */

Class(function Thread(_class) {
    Inherit(this, Component);
    var _this = this;
    var _worker, _callbacks, _path, _mvc;

    var _msg = {};

    //*** Constructor
    (function() {
        init();
        importClasses();
        addListeners();
    })();

    function init() {
        let file = window._ES5_ ? '/hydra-thread-es5.js' : '/hydra-thread.js';
        _callbacks = {};
        _worker = new Worker(Thread.PATH + file);
    }

    function importClasses() {
        importClass(Utils);
        importClass(Component);
        importClass(Events);
        importClass(_class, true);
        importES5();
    }

    function importClass(_class, scoped) {
        if (!_class) return;
        var code, namespace;

        if (!scoped) {
            if (typeof _class !== 'function') {
                code = _class.constructor.toString();
                if (code.includes('[native')) return;
                namespace = _class._namespace ? _class._namespace +'.' : '';
                code = namespace + 'Class(' + code + ', "static");';
            } else {
                namespace = _class._namespace ? _class._namespace+'.' : '';
                code = namespace + 'Class(' + _class.toString() + ');';
            }
        } else {
            code = _class.toString().replace('{', '!!!');
            code = code.split('!!!')[1];

            while (code.includes('this.')) {
                var split = code.slice(code.indexOf('this.'));
                var name = split.split('this.')[1].split(/\s*=/)[0];
                code = code.replace('this', 'self');
                createMethod(name);
            }

            code = code.slice(0, -1);
            code = code.replace(/_self/g, '_this');
        }

        _worker.postMessage({code: code});
    }

    function createMethod(name) {
        _this[name] = function(message = {}, callback, buffer) {
            let promise;

            if (Array.isArray(callback)) {
                buffer = callback;
                callback = undefined;
            }

            if (Array.isArray(buffer)) {
                message = {msg: message, transfer: true};
                message.buffer = buffer;
            }

            if (callback === undefined) {
                promise = Promise.create();
                callback = promise.resolve;
            }

            _this.send(name, message, callback);
            return promise;
        };
    }

    function importES5() {
        if (!window._ES5_) return;
        [
            '_createSuper',
            '_isNativeReflectConstruct',
        ].forEach(name => {
            let code = window[name].toString();
            if (code.includes('[native')) return;
            _worker.postMessage({code});
        });
        _worker.postMessage({code: `function _getPrototypeOf(o){_getPrototypeOf=Object.setPrototypeOf?Object.getPrototypeOf:function _getPrototypeOf(o){return o.__proto__||Object.getPrototypeOf(o);};return _getPrototypeOf(o);}`});
    }

    //*** Event Handlers
    function addListeners() {
        _worker.addEventListener('message', workerMessage);
    }

    function workerMessage(e) {
        if (e.data.console) {

            console.log(e.data.message);

        } else if (e.data.id) {

            var callback = _callbacks[e.data.id];
            if (callback) callback(e.data.message);
            delete _callbacks[e.data.id];

        } else if (e.data.emit) {

            var callback = _callbacks[e.data.evt];
            if (callback) callback(e.data.msg);

        } else {

            var callback = _callbacks['transfer'];
            if (callback) callback(e.data);

        }

    }

    //*** Public methods
    /**
     * @name Thread.on
     * @memberof Thread
     *
     * @function
     * @param evt
     * @param callback
     */
    this.on = function(evt, callback) {
        _callbacks[evt] = callback;
    }

    /**
     * @name Thread.off
     * @memberof Thread
     *
     * @function
     * @param evt
     */
    this.off = function(evt) {
        delete _callbacks[evt];
    }

    /**
     * @name Thread.loadFunction
     * @memberof Thread
     *
     * @function
     */
    this.loadFunction = function() {
        let names = [];
        let load = code => {
            code = code.toString();
            code = code.replace('(', '!!!');
            var split = code.split('!!!');
            var name = split[0].split(' ')[1];
            code = 'self.'+name+' = function('+split[1];
            _worker.postMessage({code: code});
            createMethod(name);
            names.push(name);
        };
        for (var i = 0; i < arguments.length; i++) load(arguments[i]);
        return names;
    }

    /**
     * @name Thread.importScript
     * @memberof Thread
     *
     * @function
     * @param path
     */
    this.importScript = function(path) {
        _worker.postMessage({path: Thread.absolutePath(path), importScript: true});
    }

    /**
     * @name Thread.importCode
     * @memberof Thread
     *
     * @function
     * @param code
     */
    this.importCode = function(code) {
        _worker.postMessage({code});
    }

    /**
     * @name Thread.importClass
     * @memberof Thread
     *
     * @function
     */
    this.importClass = function() {
        for (var i = 0; i < arguments.length; i++) {
            var code = arguments[i];
            importClass(code);
        }
    }

    /**
     * @name Thread.importModule
     * @memberof Thread
     *
     * @function
     */
    this.importModules = this.importModule = function() {
        for (var i = 0; i < arguments.length; i++) {
            let code = Modules.getConstructor(arguments[i]).toString();
            _worker.postMessage({code: `Module(${code})`});
        }
    }

    /**
     * @name Thread.importES6Class
     * @memberof Thread
     *
     * @function
     * @param name
     */
    this.importES6Class = function(name) {
        if (window._ES5_) {
            let Class = window[name];
            let base = Class.toString();
            let proto = [];
            let sup;
            // The class constructor may refer to an enclosed superclass
            // variable like _super37 in the below:
            //   _inherits(Shape, _Path);
            //   var _super37 = _createSuper(Shape);
            //   function Shape(points) {
            //     var _this47;
            //     _this47 = _super37.call(this, points);
            //     ...
            //   }
            let matches = /(_this\w+)\s*=\s*(_super\w+)\.call/g.exec(base);
            if (matches) {
                let superVar = matches[2];
                let superConstructor = Object.getPrototypeOf(Class);
                if (!superConstructor.toString().includes('[native')) {
                    let superName = Utils.getConstructorName(superConstructor);
                    sup = `_inherits(${name}, ${superName}); var ${superVar} = _createSuper(${name});`;
                }
            }
            Object.getOwnPropertyNames(Class.prototype).forEach(fn => {
                if (fn == 'constructor' || !Class.prototype[fn]) return;
                proto.push({key: fn, string: Class.prototype[fn].toString()});
            })
            _worker.postMessage({es5: base, name, proto, sup});
        } else {
            _worker.postMessage({es6: `(${eval(name)})`, name});
        }
    }

    /**
     * @name Thread.send
     * @memberof Thread
     *
     * @function
     * @param name
     * @param message
     * @param callback
     */
    this.send = function(name, message, callback) {
        if (typeof name === 'string') {
            var fn = name;
            message = message || {};
            message.fn = name;
        } else {
            callback = message;
            message = name;
        }

        if (Thread.UNIQUE_ID > 999999) Thread.UNIQUE_ID = 1;
        var id = Thread.UNIQUE_ID++;
        if (callback) _callbacks[id] = callback;

        if (message.transfer) {
            message.msg.id = id;
            message.msg.fn = message.fn;
            message.msg.transfer = true;
            _worker.postMessage(message.msg, message.buffer);
        } else {
            _msg.message = message;
            _msg.id = id;
            _worker.postMessage(_msg);
        }
    }

    /**
     * @name Thread.onDestroy
     * @memberof Thread
     *
     * @function
     */
    this.onDestroy = function() {
        if (_worker.terminate) _worker.terminate();
    }

}, () => {
    Thread.PATH = window._THREAD_PATH_ || 'assets/js/hydra';

    Thread.UNIQUE_ID = 1;

    Thread.absolutePath = Hydra.absolutePath;

    Thread.cluster = function() {
        return new function() {
            let index = 0;
            let array = [];

            this.push = function(thread) {
                array.push(thread);
            }

            this.get = function() {
                let thread = array[index];
                index++;
                if (index >= array.length) index = 0;
                return thread;
            }

            this.array = array;
        }
    }

    Thread.upload = function(...args) {
        Thread.shared();
        let name;
        for (let i = 0; i < _shared.array.length; i++) {
            name = _shared.array[i].loadFunction(...args);
        }
        return name;
    }

    Thread.uploadClass = function(...args) {
        Thread.shared();
        let name;
        for (let i = 0; i < _shared.array.length; i++) {
            name = _shared.array[i].importClass(...args);
        }
        return name;
    }

    var _shared;
    Thread.shared = function(list) {
        if (!_shared) {
            _shared = Thread.cluster();
            let hardware = navigator.hardwareConcurrency || 4;
            let count = Math.max(Math.min(hardware, 8), 4);
            for (let i = 0; i < count; i++) {
                _shared.push(new Thread());
            }
        }

        return list ? _shared : _shared.get();
    }
});

/**
 * @name TweenManager
 */

Class(function TweenManager() {
    Namespace(this);
    var _this = this;
    var _tweens = [];

   /**
    * @name CubicEases
    * @memberof TweenManager
    * @property
    */
    this.CubicEases = [];

    //*** Constructor
    (function() {
        Render.start(updateTweens);
    })();
    
    function updateTweens(time, dt) {
        for (let i = _tweens.length - 1; i >= 0; i--) {
            let tween = _tweens[i];
            if (tween.update) tween.update(dt);
            else _this._removeMathTween(tween);
        }
    }

    function stringToValues(str) {
        var values = str.split('(')[1].slice(0, -1).split(',');
        for (var i = 0; i < values.length; i++) values[i] = parseFloat(values[i]);
        return values;
    }

    function findEase(name) {
        var eases = _this.CubicEases;
        for (var i = eases.length-1; i > -1; i--) {
            if (eases[i].name == name) {
                return eases[i];
            }
        }
        return false;
    }

    //*** Event Handlers

    //*** Public methods
    /**
     * @name TweenManager._addMathTween
     * @memberof TweenManager
     *
     * @function
     * @param tween
    */
    this._addMathTween = function(tween) {
        _tweens.push(tween);
    };
    
    /**
     * @name TweenManager._removeMathTween
     * @memberof TweenManager
     *
     * @function
     * @param tween
    */
    this._removeMathTween = function(tween) {
        _tweens.remove(tween);
    };

    /**
     * @name TweenManager._getEase
     * @memberof TweenManager
     *
     * @function
     * @param name
     * @param values
    */
	this._getEase = function(name, values) {
        var ease = findEase(name);
        if (!ease) return false;

        if (values) {
            return ease.path ? ease.path.solve : ease.values;
        } else {
            return ease.curve;
        }
	};

    /**
     * @name TweenManager._inspectEase
     * @memberof TweenManager
     *
     * @function
     * @param name
    */
    this._inspectEase = function(name) {
        return findEase(name);
    };

    /**
     * @name window.tween
     * @memberof TweenManager
     *
     * @function
     * @param {Object} object
     * @param {Object} props
     * @param {Number} time
     * @param {String} ease
     * @param {Number} [delay]
     * @param {Function} [complete]
     * @param {Function} [update]
     * @param {Boolean} [isManual]
     * @returns {MathTween}
     * @example
     * const obj = {x: 0};
     * tween(obj, {x: 1}, 1000, 'easeOutCubic')
     *     .onUpdate(() => console.log('update'))
     *     .onComplete(() => console.log('complete'));
     * @example
     * // Tweaking elastic ease using spring and damping
     * // 'spring' and 'damping' properties used for elastic eases
     * // 'spring' alters initial speed (recommended 1.0 > 5.0)
     * // 'damping' alters amount of oscillation, lower is more (recommended 0.1 > 1.0)
     * tween(obj, {x: 1, spring: 2, damping: 0.6}, 1000, 'easeOutElastic');
     */
    this.tween = function(object, props, time, ease, delay, complete, isManual, scaledTime) {
        if (typeof delay !== 'number') {
            update = complete;
            complete = delay;
            delay = 0;
        }

        const tween = new MathTween(object, props, time, ease, delay, complete, isManual, scaledTime);

        let usePromise = null;
        if (complete && complete instanceof Promise) {
            usePromise = complete;
            complete = complete.resolve;
        }

        return usePromise || tween;
    };

    /**
     * @name window.clearTween
     * @memberof TweenManager
     *
     * @function
     * @param object
     */
    this.clearTween = function(object) {
        if (object._mathTween && object._mathTween.stop) object._mathTween.stop();

        if (object._mathTweens) {
            var tweens = object._mathTweens;
            for (var i = 0; i < tweens.length; i++) {
                var tw = tweens[i];
                if (tw && tw.stop) tw.stop();
            }

            object._mathTweens = null;
        }
    };

    /**
     * @name TweenManager.addCustomEase
     * @memberof TweenManager
     *
     * @function
     * @param {Object} ease - {name, curve}
     * @returns {Object}
     */
    this.addCustomEase = function(ease) {
        var add = true;
        if (typeof ease !== 'object' || !ease.name || !ease.curve) throw 'TweenManager :: addCustomEase requires {name, curve}';
        for (var i = _this.CubicEases.length-1; i > -1; i--) {
            if (ease.name == _this.CubicEases[i].name) {
                add = false;
            }
        }

        if (add) {
            if (ease.curve.charAt(0).toLowerCase() == 'm') {
                if (!window.EasingPath) throw 'Using custom eases requires easingpath module';
                ease.path = new EasingPath(ease.curve);
            } else {
                ease.values = stringToValues(ease.curve);
            }

            _this.CubicEases.push(ease);
        }

        return ease;
    };

    /**
     * @name Math.interpolate
     * @memberof TweenManager
     *
     * @function
     * @param {Number} start
     * @param {Number} end
     * @param {Number} alpha - 0.0 to 1.0
     * @param {String} ease
     * @returns {Number}
     */
    Math.interpolate = function(start, end, alpha, ease) {
        const fn = _this.Interpolation.convertEase(ease);
        return Math.mix(start, end, (typeof fn == 'function' ? fn(alpha) : _this.Interpolation.solve(fn, alpha)));
    };

    window.tween = this.tween;
    window.clearTween = this.clearTween;
}, 'Static');
/**
 * @name Interpolation
 */

TweenManager.Class(function Interpolation() {
    
    function calculateBezier(aT, aA1, aA2) {
        return ((A(aA1, aA2)*aT + B(aA1, aA2))*aT + C(aA1))*aT;
    }
    
    function getTForX(aX, mX1, mX2) {
        var aGuessT = aX;
        for (var i = 0; i < 4; i++) {
            var currentSlope = getSlope(aGuessT, mX1, mX2);
            if (currentSlope == 0.0) return aGuessT;
            var currentX = calculateBezier(aGuessT, mX1, mX2) - aX;
            aGuessT -= currentX / currentSlope;
        }
        return aGuessT;
    }
    
    function getSlope(aT, aA1, aA2) {
        return 3.0 * A(aA1, aA2)*aT*aT + 2.0 * B(aA1, aA2) * aT + C(aA1);
    }
    
    function A(aA1, aA2) { 
        return 1.0 - 3.0 * aA2 + 3.0 * aA1; 
    }
    
    function B(aA1, aA2) { 
        return 3.0 * aA2 - 6.0 * aA1; 
    }
    
    function C(aA1) { 
        return 3.0 * aA1; 
    }

    /**
     * Converts easing string to relative function.
     * @name TweenManager.Interpolation.convertEase
     * @memberof Interpolation
     *
     * @function
     * @param {String} ease
     * @example
     * const ease = TweenManager.Interpolation.convertEase('easeOutCubic');
     * console.log(ease(0.7)); // logs 0.973
     */
    this.convertEase = function(ease) {
        var fn = (function() {
            switch (ease) {
                case 'easeInQuad': return TweenManager.Interpolation.Quad.In; break;
                case 'easeInCubic': return TweenManager.Interpolation.Cubic.In; break;
                case 'easeInQuart': return TweenManager.Interpolation.Quart.In; break;
                case 'easeInQuint': return TweenManager.Interpolation.Quint.In; break;
                case 'easeInSine': return TweenManager.Interpolation.Sine.In; break;
                case 'easeInExpo': return TweenManager.Interpolation.Expo.In; break;
                case 'easeInCirc': return TweenManager.Interpolation.Circ.In; break;
                case 'easeInElastic': return TweenManager.Interpolation.Elastic.In; break;
                case 'easeInBack': return TweenManager.Interpolation.Back.In; break;
                case 'easeInBounce': return TweenManager.Interpolation.Bounce.In; break;
                
                case 'easeOutQuad': return TweenManager.Interpolation.Quad.Out; break;
                case 'easeOutCubic': return TweenManager.Interpolation.Cubic.Out; break;
                case 'easeOutQuart': return TweenManager.Interpolation.Quart.Out; break;
                case 'easeOutQuint': return TweenManager.Interpolation.Quint.Out; break;
                case 'easeOutSine': return TweenManager.Interpolation.Sine.Out; break;
                case 'easeOutExpo': return TweenManager.Interpolation.Expo.Out; break;
                case 'easeOutCirc': return TweenManager.Interpolation.Circ.Out; break;
                case 'easeOutElastic': return TweenManager.Interpolation.Elastic.Out; break;
                case 'easeOutBack': return TweenManager.Interpolation.Back.Out; break;
                case 'easeOutBounce': return TweenManager.Interpolation.Bounce.Out; break;
                
                case 'easeInOutQuad': return TweenManager.Interpolation.Quad.InOut; break;
                case 'easeInOutCubic': return TweenManager.Interpolation.Cubic.InOut; break;
                case 'easeInOutQuart': return TweenManager.Interpolation.Quart.InOut; break;
                case 'easeInOutQuint': return TweenManager.Interpolation.Quint.InOut; break;
                case 'easeInOutSine': return TweenManager.Interpolation.Sine.InOut; break;
                case 'easeInOutExpo': return TweenManager.Interpolation.Expo.InOut; break;
                case 'easeInOutCirc': return TweenManager.Interpolation.Circ.InOut; break;
                case 'easeInOutElastic': return TweenManager.Interpolation.Elastic.InOut; break;
                case 'easeInOutBack': return TweenManager.Interpolation.Back.InOut; break;
                case 'easeInOutBounce': return TweenManager.Interpolation.Bounce.InOut; break;
                            
                case 'linear': return TweenManager.Interpolation.Linear.None; break;
            }
        })();
        
        if (!fn) {
            var curve = TweenManager._getEase(ease, true);
            if (curve) fn = curve;
            else fn = TweenManager.Interpolation.Cubic.Out;
        }
        
        return fn;
    };

    /**
     * @name TweenManager.Interpolation.solve
     * @memberof Interpolation
     *
     * @function
     * @param {Number[]} values
     * @param {Number} elapsed
     * @returns {Number}
     */
    this.solve = function(values, elapsed) {
        if (values[0] == values[1] && values[2] == values[3]) return elapsed;
        return calculateBezier(getTForX(elapsed, values[0], values[2]), values[1], values[3]);
    };

    this.Linear = {
        None: function(k) {
            return k;
        }
    };
    this.Quad = {
        In: function(k) {
            return k*k;
        },
        Out: function(k) {
            return k * (2 - k);
        },
        InOut: function(k) {
            if ((k *= 2) < 1) return 0.5 * k * k;
            return - 0.5 * (--k * (k - 2) - 1);
        }
    };
    this.Cubic = {
        In: function(k) {
            return k * k * k;
        },
        Out: function(k) {
            return --k * k * k + 1;
        },
        InOut: function(k) {
            if ((k *= 2) < 1) return 0.5 * k * k * k;
            return 0.5 * ((k -= 2) * k * k + 2 );
        }
    };
    this.Quart = {
        In: function(k) {
            return k * k * k * k;
        },
        Out: function(k) {
            return 1 - --k * k * k * k;
        },
        InOut: function(k) {
            if ((k *= 2) < 1) return 0.5 * k * k * k * k;
            return - 0.5 * ((k -= 2) * k * k * k - 2);
        }
    };
    this.Quint = {
        In: function(k) {
            return k * k * k * k * k;
        },
        Out: function(k) {
            return --k * k * k * k * k + 1;
        },
        InOut: function(k) {
            if ((k *= 2) < 1) return 0.5 * k * k * k * k * k;
            return 0.5 * ((k -= 2) * k * k * k * k + 2);
        }
    };
    this.Sine = {
        In: function(k) {
            return 1 - Math.cos(k * Math.PI / 2);
        },
        Out: function(k) {
            return Math.sin(k * Math.PI / 2);
        },
        InOut: function(k) {
            return 0.5 * (1 - Math.cos(Math.PI * k));
        }
    };
    this.Expo = {
        In: function(k) {
            return k === 0 ? 0 : Math.pow(1024, k - 1);
        },
        Out: function(k) {
            return k === 1 ? 1 : 1 - Math.pow(2, -10 * k);
        },
        InOut: function(k) {
            if (k === 0) return 0;
            if (k === 1) return 1;
            if ((k *= 2) < 1) return 0.5 * Math.pow(1024, k - 1);
            return 0.5 * (-Math.pow(2, - 10 * (k - 1)) + 2);
        }
    };
    this.Circ = {
        In: function(k) {
            return 1 - Math.sqrt(1 - k * k);
        },
        Out: function(k) {
            return Math.sqrt(1 - --k * k);
        },
        InOut: function(k) {
            if ( ( k *= 2 ) < 1) return - 0.5 * ( Math.sqrt( 1 - k * k) - 1);
            return 0.5 * ( Math.sqrt( 1 - ( k -= 2) * k) + 1);
        }
    };
    this.Elastic = {
        In: function(k, a = 1, p = 0.4) {
            var s;
            if ( k === 0 ) return 0;
            if ( k === 1 ) return 1;
            if ( !a || a < 1 ) { a = 1; s = p / 4; }
            else s = p * Math.asin( 1 / a ) / ( 2 * Math.PI );
            return - ( a * Math.pow( 2, 10 * ( k -= 1 ) ) * Math.sin( ( k - s ) * ( 2 * Math.PI ) / p ) );
        },
        Out: function(k, a = 1, p = 0.4) {
            var s;
            if ( k === 0 ) return 0;
            if ( k === 1 ) return 1;
            if ( !a || a < 1 ) { a = 1; s = p / 4; }
            else s = p * Math.asin( 1 / a ) / ( 2 * Math.PI );
            return ( a * Math.pow( 2, - 10 * k) * Math.sin( ( k - s ) * ( 2 * Math.PI ) / p ) + 1 );
        },
        InOut: function(k, a = 1, p = 0.4) {
            var s;
            if ( k === 0 ) return 0;
            if ( k === 1 ) return 1;
            if ( !a || a < 1 ) { a = 1; s = p / 4; }
            else s = p * Math.asin( 1 / a ) / ( 2 * Math.PI );
            if ( ( k *= 2 ) < 1 ) return - 0.5 * ( a * Math.pow( 2, 10 * ( k -= 1 ) ) * Math.sin( ( k - s ) * ( 2 * Math.PI ) / p ) );
            return a * Math.pow( 2, -10 * ( k -= 1 ) ) * Math.sin( ( k - s ) * ( 2 * Math.PI ) / p ) * 0.5 + 1;
        }
    };
    this.Back = {
        In: function(k) {
            var s = 1.70158;
            return k * k * ( ( s + 1 ) * k - s );
        },
        Out: function(k) {
            var s = 1.70158;
            return --k * k * ( ( s + 1 ) * k + s ) + 1;
        },
        InOut: function(k) {
            var s = 1.70158 * 1.525;
            if ( ( k *= 2 ) < 1 ) return 0.5 * ( k * k * ( ( s + 1 ) * k - s ) );
            return 0.5 * ( ( k -= 2 ) * k * ( ( s + 1 ) * k + s ) + 2 );
        }
    };
    this.Bounce = {
        In: function(k) {
            return 1 - this.Bounce.Out( 1 - k );
        },
        Out: function(k) {
            if ( k < ( 1 / 2.75 ) ) {
                return 7.5625 * k * k;
            } else if ( k < ( 2 / 2.75 ) ) {
                return 7.5625 * ( k -= ( 1.5 / 2.75 ) ) * k + 0.75;
            } else if ( k < ( 2.5 / 2.75 ) ) {
                return 7.5625 * ( k -= ( 2.25 / 2.75 ) ) * k + 0.9375;
            } else {
                return 7.5625 * ( k -= ( 2.625 / 2.75 ) ) * k + 0.984375;
            }
        },
        InOut: function(k) {
            if ( k < 0.5 ) return this.Bounce.In( k * 2 ) * 0.5;
            return this.Bounce.Out( k * 2 - 1 ) * 0.5 + 0.5;
        }
    };
}, 'Static');
/**
 * Tween constructor class, initiated through window.tween().
 * @name MathTween
 *
 * @constructor
 */

Class(function MathTween(_object, _props, _time, _ease, _delay, _callback, _manual, _scaledTime) {
    var _this = this;

    var _startTime, _startValues, _endValues;
    var _easeFunction, _paused, _newEase;
    var _spring, _damping, _update, _currentTime;

    var _elapsed = 0;

   /**
    * @name object
    * @memberof MathTween
    * @property
    */
    _this.object = _object;
   /**
    * @name props
    * @memberof MathTween
    * @property
    */
    _this.props = _props;
   /**
    * @name time
    * @memberof MathTween
    * @property
    */
    _this.time = _time;
   /**
    * @name ease
    * @memberof MathTween
    * @property
    */
    _this.ease = _ease;
   /**
    * @name delay
    * @memberof MathTween
    * @property
    */
    _this.delay = _delay;

    //*** Constructor
    defer(function() {
        if (_this.stopped) return;
        if (_this.overrideValues) {
            let values = _this.overrideValues(_this, _object, _props, _time, _ease, _delay);
            if (values) {
                _this.props = _props = values.props || _props;
                _this.time = _time = values.time || _time;
                _this.ease = _ease = values.ease || _ease;
                _this.delay = _delay = values.delay || _delay;
            }
        }

        if (_object && _props) {
            _this.object = _object;
            if (typeof _time !== 'number') throw 'MathTween Requires object, props, time, ease';
            start();
        }
    });

    function start() {
        if (!_object.multiTween && _object._mathTween && !_manual) TweenManager.clearTween(_object);
        if (!_manual) TweenManager._addMathTween(_this);

        _this.time = _time;
        _this.delay = _delay;

        let propString = getPropString();

            _object._mathTween = _this;
        if (_object.multiTween) {
            if (!_object._mathTweens) _object._mathTweens = [];
            _object._mathTweens.forEach(t => {
                if (t.props == propString) t.tween.stop();
            });
            _this._tweenWrapper = {props: propString, tween: _this};
            _object._mathTweens.push(_this._tweenWrapper);
        }

        if (!_ease) _ease = 'linear';

        if (typeof _ease == 'string') {
            _ease = TweenManager.Interpolation.convertEase(_ease);
            _easeFunction = typeof _ease === 'function';
        }

        _startTime = _scaledTime ? Render.now() : performance.now();
        _currentTime = _startTime;
        _startTime += _delay;
        _endValues = _props;
        _startValues = {};

        if (_props.spring) _spring = _props.spring;
        if (_props.damping) _damping = _props.damping;

        _this.startValues = _startValues;

        for (var prop in _endValues) {
            if (typeof _object[prop] === 'number') _startValues[prop] = _object[prop];
        }
    }

    function getPropString() {
        let string = '';
        for (let key in _props) {
            if (typeof _props[key] === 'number') string += key+' ';
        }
        return string;
    }

    function clear() {
        if (!_object && !_props) return false;
        _object._mathTween = null;
        TweenManager._removeMathTween(_this);
        Utils.nullObject(_this);

        if (_object._mathTweens) {
            _object._mathTweens.remove(_this._tweenWrapper);
        }
    }

    //*** Event Handlers

    //*** Public methods
    /**
     * @name this.update
     * @memberof MathTween
     *
     * @function
     * @param {Number} time - Performance.now value
     */
    this.update = function(dt) {
        if (_paused) return;
        _currentTime += _scaledTime ? dt : Render.DT;
        if (_currentTime < _startTime) return;

        _elapsed = (_currentTime - _startTime) / _time;
        _elapsed = _elapsed > 1 ? 1 : _elapsed;

        let delta = this.interpolate(_elapsed);

        if (_update) _update(delta);
        if (_elapsed == 1) {
            if (_callback) _callback();
            if (_this.completePromise) _this.completePromise.resolve();
            clear();
        }
    };

    /**
     * @name this.pause
     * @memberof MathTween
     *
     * @function
     */
    this.pause = function() {
        _paused = true;
    };

    /**
     * @name this.resume
     * @memberof MathTween
     *
     * @function
     */
    this.resume = function() {
        _paused = false;
    };

    /**
     * @name this.stop
     * @memberof MathTween
     *
     * @function
     */
    this.stop = function() {
        _this.stopped = true;
        clear();
        return null;
    };

    /**
     * @name this.setEase
     * @memberof MathTween
     *
     * @function
     * @param {String} ease
     */
    this.setEase = function(ease) {
        if (_newEase != ease) {
            _newEase = ease;
            _ease = TweenManager.Interpolation.convertEase(ease);
            _easeFunction = typeof _ease === 'function';
        }
    };

    /**
     * @name this.getValues
     * @memberof MathTween
     *
     * @function
     */
    this.getValues = function() {
        return {
            start: _startValues,
            end: _endValues,
        }
    };

    /**
     * @name this.interpolate
     * @memberof MathTween
     *
     * @function
     * @param {Number} elapsed - 0.0 to 1.0
     */
    this.interpolate = function(elapsed) {
        var delta = _easeFunction ? _ease(elapsed, _spring, _damping) : TweenManager.Interpolation.solve(_ease, elapsed);

        for (var prop in _startValues) {
            if (typeof _startValues[prop] === 'number' && typeof _endValues[prop] === 'number') {
                var start = _startValues[prop];
                var end = _endValues[prop];
                _object[prop] = start + (end - start) * delta;
            }
        }

        return delta;
    };

    /**
     * @name this.onUpdate
     * @memberof MathTween
     *
     * @function
     * @param {Function} callback
     */
    this.onUpdate = function(callback) {
        _update = callback;
        return this;
    };

    /**
     * @name this.onComplete
     * @memberof MathTween
     *
     * @function
     * @param {Function} callback
     */
    this.onComplete = function(callback) {
        _callback = callback;
        return this;
    };

    /**
     * @name this.promise
     * @memberof MathTween
     *
     * @function
     * @param {Function}
     */
    this.promise = function() {
        _this.completePromise = Promise.create();
        return _this.completePromise;
    };

    /**
     * @name this.setElapsed
     * @memberof MathTween
     *
     * @function
     * @param elapsed
    */
    this.setElapsed = function(elapsed) {
        _startTime = performance.now();
        _currentTime = _startTime + (_time * elapsed);
    }
});

/**
 * @name TweenTimeline
 *
 * @constructor
 */

Class(function TweenTimeline() {
    Inherit(this, Component);
    const _this = this;
    let _tween;

    let _total = 0;
    const _tweens = [];

    /**
     * @name this.elapsed
     * @memberof TweenTimeline
     */
    this.elapsed = 0;

    function calculate() {
        _tweens.sort(function(a, b) {
            const ta = a.time + a.delay;
            const tb = b.time + b.delay;
            return tb - ta;
        });

        const first = _tweens[0];
        _total = first.time + first.delay;
    }

    function loop() {
        let time = _this.elapsed * _total;
        for (let i = _tweens.length - 1; i > -1; i--) {
            let t = _tweens[i];
            let relativeTime = time - t.delay;
            let elapsed = Math.clamp(relativeTime / t.time, 0, 1);

            t.interpolate(elapsed);
        }

        _this.events.fire(Events.UPDATE, _this, true);
    }

    //*** Public methods

    /**
     * @name this.timeRemaining
     * @memberof TweenTimeline
     */
    this.get('timeRemaining', () => {
        return _total - (_this.elapsed * _total)
    });

    /**
     * @name this.add
     * @memberof TweenTimeline
     *
     * @function
     * @param {Object} object
     * @param {Object} props
     * @param {Number} time
     * @param {String} ease
     * @param {Number} delay
     * @returns {MathTween}
     */
    this.add = function(object, props, time, ease, delay = 0) {
        if (object instanceof MathTween || object instanceof FrameTween) {
            props = object.props;
            time = object.time;
            ease = object.ease;
            delay = object.delay;
            object = object.object;
        }

        let tween;
        if (object instanceof HydraObject) tween = new FrameTween(object, props, time, ease, delay, null, true);
        else tween = new MathTween(object, props, time, ease, delay, null, true);
        _tweens.push(tween);

        defer(calculate);

        return tween;
    };

    /**
     * Tween elapsed value, which controls the timing of the timeline animation.
     * @name this.tween
     * @memberof TweenTimeline
     *
     * @function
     * @param {Number} to
     * @param {Number} time
     * @param {String} ease
     * @param {Number} delay
     * @param {Function} callback
     */
    this.tween = function(to, time, ease, delay, callback) {
        _this.clearTween();
        _tween = tween(_this, {elapsed: to}, time, ease, delay).onUpdate(loop).onComplete(callback);
        return _tween;
    };

    /**
     * @name this.clearTween
     * @memberof TweenTimeline
     *
     * @function
     */
    this.clearTween = function() {
        if (_tween && _tween.stop) _tween.stop();
    };

    /**
     * @name this.startRender
     * @memberof TweenTimeline
     *
     * @function
     */
    this.start = function() {
        _this.startRender(loop);
    };

    /**
     * @name this.stopRender
     * @memberof TweenTimeline
     *
     * @function
     */
    this.stop = function() {
        _this.stopRender(loop);
    };

    /**
     * Manually call update. Useful if manipulating elapsed value.
     * @name this.update
     * @memberof TweenTimeline
     *
     * @function
     */
    this.update = function() {
        loop();
    };

    /**
     * @name this.destroy
     * @memberof TweenTimeline
     * @private
     *
     * @function
     */
    this.onDestroy = function() {
        _this.clearTween();
        Render.stop(loop);
        for (var i = 0; i < _tweens.length; i++) _tweens[i].stop();
    };

});

window.ASSETS = ["assets/js/lib/basis_transcoder.js","assets/js/lib/basis_transcoder.wasm","assets/js/lib/firebase-app.js","assets/js/lib/firebase-auth.js","assets/js/lib/firebase-database.js","assets/js/lib/firebase-storage.js","assets/data/uil.1675992195953.json","assets/shaders/compiled.1675992195953.vs"];
ASSETS.SW = ["assets/css/style.css","assets/js/app.1675992195953.js"];
window.UIL_ASSETS_GEOMETRIES = [];
window.UIL_ASSETS_TEXTURES = [{"filename":"_scenelayout/black.jpg","bytes":1129,"lastChange":"2023-02-10T00:32:51.558Z"},{"filename":"_scenelayout/mask.jpg","bytes":1129,"lastChange":"2023-02-10T00:32:51.558Z"},{"filename":"_scenelayout/uv.jpg","bytes":138695,"lastChange":"2023-02-10T00:32:51.558Z"}];

/**
 * Attaches to Mobile namespace. Use as Mobile.Accelerometer
 * @name Accelerometer
 */

Mobile.Class(function Accelerometer() {
    var _this = this;

    this.x = 0;
    this.y = 0;
    this.z = 0;

    this.alpha = 0;
    this.beta = 0;
    this.gamma = 0;

    this.heading = 0;

    this.rotationRate = {};
    this.rotationRate.alpha = 0;
    this.rotationRate.beta = 0;
    this.rotationRate.gamma = 0;

    this.toRadians = Device.system.os == 'ios' ? Math.PI / 180 : 1;

    //*** Event Handlers
    function updateAccel(e) {
        _this.connected = true;
        switch (window.orientation) {
            case 0:
                _this.x = -e.accelerationIncludingGravity.x;
                _this.y = e.accelerationIncludingGravity.y;
                _this.z = e.accelerationIncludingGravity.z;

                if (e.rotationRate) {
                    _this.rotationRate.alpha = e.rotationRate.beta * _this.toRadians;
                    _this.rotationRate.beta = -e.rotationRate.alpha * _this.toRadians;
                    _this.rotationRate.gamma = e.rotationRate.gamma * _this.toRadians;
                }
            break;

            case 180:
                _this.x = e.accelerationIncludingGravity.x;
                _this.y = -e.accelerationIncludingGravity.y;
                _this.z = e.accelerationIncludingGravity.z;

                if (e.rotationRate) {
                    _this.rotationRate.alpha = -e.rotationRate.beta * _this.toRadians;
                    _this.rotationRate.beta = e.rotationRate.alpha * _this.toRadians;
                    _this.rotationRate.gamma = e.rotationRate.gamma * _this.toRadians;
                }
            break;

            case 90:
                _this.x = e.accelerationIncludingGravity.y;
                _this.y = e.accelerationIncludingGravity.x;
                _this.z = e.accelerationIncludingGravity.z;

                if (e.rotationRate) {
                    _this.rotationRate.alpha = e.rotationRate.alpha * _this.toRadians;
                    _this.rotationRate.beta = e.rotationRate.beta * _this.toRadians;
                    _this.rotationRate.gamma = e.rotationRate.gamma * _this.toRadians;
                }
            break;

            case -90:
                _this.x = -e.accelerationIncludingGravity.y;
                _this.y = -e.accelerationIncludingGravity.x;
                _this.z = e.accelerationIncludingGravity.z;

                if (e.rotationRate) {
                    _this.rotationRate.alpha = -e.rotationRate.alpha * _this.toRadians;
                    _this.rotationRate.beta = -e.rotationRate.beta * _this.toRadians;
                    _this.rotationRate.gamma = e.rotationRate.gamma * _this.toRadians;
                }
            break;
        }

        if (Device.system.os == 'android') {
            _this.x *= -1;
            _this.y *= -1;
            _this.z *= -1;
        }
    }

    function updateOrientation(e) {
        for (var key in e) {
            if (key.toLowerCase().includes('heading')) _this.heading = e[key];
        }

        switch (window.orientation) {
            case 0:
                _this.alpha = e.beta * _this.toRadians;
                _this.beta = -e.alpha * _this.toRadians;
                _this.gamma = e.gamma * _this.toRadians;
                break;

            case 180:
                _this.alpha = -e.beta * _this.toRadians;
                _this.beta = e.alpha * _this.toRadians;
                _this.gamma = e.gamma * _this.toRadians;
                break;

            case 90:
                _this.alpha = e.alpha * _this.toRadians;
                _this.beta = e.beta * _this.toRadians;
                _this.gamma = e.gamma * _this.toRadians;
                break;

            case -90:
                _this.alpha = -e.alpha * _this.toRadians;
                _this.beta = -e.beta * _this.toRadians;
                _this.gamma = e.gamma * _this.toRadians;
                break;
        }

        _this.tilt = e.beta * _this.toRadians;
        _this.yaw = e.alpha * _this.toRadians;
        _this.roll = -e.gamma * _this.toRadians;

        if (Device.system.os == 'android') _this.heading = compassHeading(e.alpha, e.beta, e.gamma);
    }

    function compassHeading(alpha, beta, gamma) {
        var degtorad = Math.PI / 180;

        var _x = beta  ? beta  * degtorad : 0; // beta value
        var _y = gamma ? gamma * degtorad : 0; // gamma value
        var _z = alpha ? alpha * degtorad : 0; // alpha value

        var cX = Math.cos( _x );
        var cY = Math.cos( _y );
        var cZ = Math.cos( _z );
        var sX = Math.sin( _x );
        var sY = Math.sin( _y );
        var sZ = Math.sin( _z );

        // Calculate Vx and Vy components
        var Vx = - cZ * sY - sZ * sX * cY;
        var Vy = - sZ * sY + cZ * sX * cY;

        // Calculate compass heading
        var compassHeading = Math.atan( Vx / Vy );

        // Convert compass heading to use whole unit circle
        if( Vy < 0 ) {
            compassHeading += Math.PI;
        } else if( Vx < 0 ) {
            compassHeading += 2 * Math.PI;
        }

        return compassHeading * ( 180 / Math.PI ); // Compass Heading (in degrees)

    }

    //*** Public methods
    this.capture = async function(callback) {
        let promises = [];
        if (!this.active) {
            this.active = true;
            if (window.DeviceMotionEvent && typeof DeviceMotionEvent.requestPermission === "function") {
                promises.push((async () => {
                    let permissionState = await DeviceMotionEvent.requestPermission();
                    if (permissionState === "granted") {
                        window.addEventListener("devicemotion", updateAccel);
                    } else {
                        throw new Error(permissionState);
                    }
                })());
            } else {
                window.addEventListener("devicemotion", updateAccel);
            }


            if (window.DeviceOrientationEvent && typeof DeviceOrientationEvent.requestPermission === "function") {
                promises.push((async () => {
                    let permissionState = await DeviceOrientationEvent.requestPermission();
                    if (permissionState === "granted") {
                        window.addEventListener("deviceorientation", updateOrientation);
                    } else {
                        throw new Error(permissionState);
                    }
                })());
            } else {
                window.addEventListener("deviceorientation", updateOrientation);
            }
        }

        let promise = (async () => {
            let results = await Promise.allSettled(promises);
            if (!results.length) return;
            let error;
            let ok = false;
            results.forEach(result => {
                if (result.status === 'rejected') {
                    console.error(result.reason);
                    if (!error) error = result.reason;
                } else {
                    ok = true;
                }
            });
            if (!ok) {
                throw error;
            }
        })();

        if (typeof callback === 'function') {
            promise = promise.then(callback).catch(callback);
        }
        return promise;
    }

    this.stop = function() {
        this.active = false;
        window.ondevicemotion = null;
        _this.x = _this.y = _this.z = 0;
        window.removeEventListener('deviceorientation', updateOrientation);
    }
}, 'Static');

class CubicPoly {
    constructor(x0, x1, t0, t1) {
        this.init(x0, x1, t0, t1);
    }

    init(x0, x1, t0, t1) {
        this.c0 = x0;
        this.c1 = t0;
        this.c2 = - 3 * x0 + 3 * x1 - 2 * t0 - t1;
        this.c3 = 2 * x0 - 2 * x1 + t0 + t1;
    }

    initCatmullRom(x0, x1, x2, x3, tension) {
       this.init( x1, x2, tension * ( x2 - x0 ), tension * ( x3 - x1 ) );
    }

    initNonuniformCatmullRom(x0, x1, x2, x3, dt0, dt1, dt2) {
        let t1 = ( x1 - x0 ) / dt0 - ( x2 - x0 ) / ( dt0 + dt1 ) + ( x2 - x1 ) / dt1;
        let t2 = ( x2 - x1 ) / dt1 - ( x3 - x1 ) / ( dt1 + dt2 ) + ( x3 - x2 ) / dt2;

        t1 *= dt1;
        t2 *= dt1;

        this.init( x1, x2, t1, t2 );
    }

    calc(t) {
        let t2 = t * t;
        let t3 = t2 * t;
        let c0 = this.c0;
        let c1 = this.c1;
        let c2 = this.c2;
        let c3 = this.c3;
        return c0 + c1 * t + c2 * t2 + c3 * t3;
    }
}
Class(function Curve(_input, _type) {
    Inherit(this, Component);
    const _this = this;
    var _curve;

    this.root = new Group();

    //*** Constructor
    (function () {
        if (Array.isArray(_input) && Array.isArray(_input[0])) initFromArray();
        else if (Array.isArray(_input) && _input[0] instanceof Vector3) initFromVecArray();
        else if (Array.isArray(_input) && typeof _input[0] === 'number') initFromFlatArray();
        else if (_input instanceof CurvePath) _curve = _input;
        else initFromObj(_input);
    })();

    function initFromArray() {
        let points = [];
        for (let i = 0; i < _input.length; i++) {
            points.push(new Vector3().fromArray(_input[i]));
        }
        _this.points = points;
        initCurve(points);
    }

    function initFromFlatArray() {
        let points = [];
        for (let i = 0; i < _input.length; i += 3) {
            points.push(new Vector3(
                _input[i + 0],
                _input[i + 1],
                _input[i + 2]
            ));
        }
        _this.points = points;
        initCurve(points);
    }

    function initFromVecArray() {
        _this.points = _input;
        initCurve(_input);
    }

    function initFromObj(obj) {
        if (typeof obj === 'string') {
            let name = obj;
            obj = Assets.JSON[obj];
            if (!obj) throw `No curve ${name} found`;
            obj.curves = obj.curves[0];
        } else {
            obj.curves = Array.isArray(obj.curves[0]) ? obj.curves[0] : obj.curves;
        }

        var data = obj.curves;
        var points = [];
        for (var j = 0; j < data.length; j += 3) {
            points.push(new Vector3(
                data[j + 0],
                data[j + 1],
                data[j + 2]
            ));
        }

        initCurve(points);
    }

    function initCurve(input) {
        switch (_type) {
            case 'line': {
                _curve = new CurvePath();
                for (let i = 0; i < input.length - 1; i += 1) {
                    let newCurve = new LineCurve(input[i], input[i + 1]);
                    _curve.add(newCurve);
                }
                break;
            }
            default:
            case 'catmull':
                _curve = new CatmullRomCurve(input);
                break;
        }
    }

    //*** Event handlers

    //*** Public methods
    this.debug = function () {
        let points = _curve.getPoints(50);
        let geometry = new Geometry().setFromPoints(points);
        let shader = Utils3D.getTestShader(0x000fff);
        let curveObject = new Line(geometry, shader);
        _this.root.add(curveObject);
        return _this.root;
    }

    this.getPointAt = function (t) {
        t = Math.max(0, Math.min(1, t));
        if (!window.THREAD && this.root.matrixDirty) this.root.updateMatrixWorld();
        let pos = _curve.getPointAt(t);
        if (!window.THREAD && pos.applyMatrix4) pos.applyMatrix4(this.root.matrixWorld);
        return pos;
    }
    this.getPoint = function (t) {
        t = Math.max(0, Math.min(1, t));
        if (!window.THREAD && this.root.matrixDirty) this.root.updateMatrixWorld();
        let pos = _curve.getPoint(t);
        if (!window.THREAD && pos.applyMatrix4) pos.applyMatrix4(this.root.matrixWorld);
        return pos;
    }

    this.getTangent = function (t) {
        t = Math.max(0, Math.min(1, t));
        if (!window.THREAD && this.root.matrixDirty) this.root.updateMatrixWorld();
        let pos = _curve.getTangent(t);
        if (!window.THREAD && pos.applyMatrix4) pos.applyMatrix4(this.root.matrixWorld);
        return pos;
    }

    this.applyDataTexture = function (shader, subdivisions) {
        if (!_this.dataTexture) {
            let findSize = (num) => {
                var values = [2, 4, 8, 16, 32, 64, 128, 256, 512, 1024, 2048, 4096];
                for (let i = 0; i < values.length; i++) {
                    var p2 = values[i];
                    if (p2 * p2 >= num) return p2;
                }
            };

            let size = findSize(subdivisions);
            let total = size * size;
            let buffer = new Float32Array(total * 3);
            for (let i = 0; i < total; i++) {
                let percent = i / (total - 1);
                let pos = _this.getPoint(percent);
                buffer[i * 3 + 0] = pos.x;
                buffer[i * 3 + 1] = pos.y;
                buffer[i * 3 + 2] = pos.z;
            }

            _this.dataTexture = new DataTexture(buffer, size, size, Texture.RGBFormat, Texture.FLOAT);
        }

        shader.addUniforms({
            tCurve: { value: _this.dataTexture },
            uCurveSize: { value: _this.dataTexture.width }
        });
    }

    this.onDestroy = function () {
        if (_this.dataTexture) _this.dataTexture.destroy();
    }

    this.set('closed', v => {
        _curve.closed = v;
    });

    this.get('curve', _ => _curve);

}, _ => {
    Curve.parseFile = async function (data) {
        if (typeof data === 'string') data = await get(Assets.getPath(data));
        let curves = [];
        data.curves.forEach(array => {
            curves.push(new Curve({ curves: [array] }));
        });
        return curves;
    }

    Curve.loadOnThread = function (thread) {
        if (thread._curveLoaded) return;
        thread._curveLoaded = true;
        thread.importES6Class('CubicPoly');
        thread.importES6Class('Curve3D');
        thread.importES6Class('CurvePath');
        thread.importES6Class('CatmullRomCurve');
        thread.importES6Class('LineCurve');
        thread.importClass(Curve);
    }
});

class Curve3D {
    constructor() {
        this.arcLengthDivisions = 200;
    }

    getPointAt(u) {
        let t = this.getUtoTmapping( u );
        return this.getPoint( t );
    }

    getPoints(divisions = 5) {
        let points = [];
        for ( let d = 0; d <= divisions; d ++ ) {
            points.push( this.getPoint( d / divisions ) );
        }
        return points;
    }

    getSpacedPoints(divisions = 5) {
        let points = [];
        for ( let d = 0; d <= divisions; d ++ ) {
            points.push( this.getPointAt( d / divisions ) );
        }
        return points;
    }

    getLength() {
        let lengths = this.getLengths();
        return lengths[ lengths.length - 1 ];
    }

    getLengths(divisions = this.arcLengthDivisions) {
        if ( this.cacheArcLengths &&
            ( this.cacheArcLengths.length === divisions + 1 ) &&
            ! this.needsUpdate ) {
            return this.cacheArcLengths;

        }

        this.needsUpdate = false;

        let cache = [];
        let current, last = this.getPoint( 0 );
        let p, sum = 0;

        cache.push( 0 );

        for ( p = 1; p <= divisions; p ++ ) {

            current = this.getPoint( p / divisions );
            sum += current.distanceTo( last );
            cache.push( sum );
            last = current;

        }

        this.cacheArcLengths = cache;

        return cache;
    }

    updateArtLengths() {
        this.needsUpdate = true;
        this.getLengths();
    }

    getUtoTmapping(u, distance) {
        let arcLengths = this.getLengths();

        let i = 0, il = arcLengths.length;

        let targetArcLength; // The targeted u distance value to get

        if ( distance ) {

            targetArcLength = distance;

        } else {

            targetArcLength = u * arcLengths[ il - 1 ];

        }

        // binary search for the index with largest value smaller than target u distance

        let low = 0, high = il - 1, comparison;

        while ( low <= high ) {

            i = Math.floor( low + ( high - low ) / 2 ); // less likely to overflow, though probably not issue here, JS doesn't really have integers, all numbers are floats

            comparison = arcLengths[ i ] - targetArcLength;

            if ( comparison < 0 ) {

                low = i + 1;

            } else if ( comparison > 0 ) {

                high = i - 1;

            } else {

                high = i;
                break;

                // DONE

            }

        }

        i = high;

        if ( arcLengths[ i ] === targetArcLength ) {

            return i / ( il - 1 );

        }

        // we could get finer grain at lengths, or use simple interpolation between two points

        let lengthBefore = arcLengths[ i ];
        let lengthAfter = arcLengths[ i + 1 ];

        let segmentLength = lengthAfter - lengthBefore;

        // determine where we are between the 'before' and 'after' points

        let segmentFraction = ( targetArcLength - lengthBefore ) / segmentLength;

        // add that fractional amount to t

        let t = ( i + segmentFraction ) / ( il - 1 );

        return t;
    }

    getTangent(t) {
        let delta = 0.0001;
        let t1 = t - delta;
        let t2 = t + delta;

        // Capping in case of danger

        if ( t1 < 0 ) t1 = 0;
        if ( t2 > 1 ) t2 = 1;

        let pt1 = this.getPoint( t1 );
        let pt2 = this.getPoint( t2 );

        let vec = pt2.clone().sub( pt1 );
        return vec.normalize();
    }

    getTangentAt(u) {
        let t = this.getUtoTmapping( u );
        return this.getTangent( t );
    }

    computeFrenetFrames(segments, closed) {
        let normal = new Vector3();

        let tangents = [];
        let normals = [];
        let binormals = [];

        let vec = new Vector3();
        let mat = new Matrix4();

        let i, u, theta;

        // compute the tangent vectors for each segment on the curve

        for ( i = 0; i <= segments; i ++ ) {

            u = i / segments;

            tangents[ i ] = this.getTangentAt( u );
            tangents[ i ].normalize();

        }

        // select an initial normal vector perpendicular to the first tangent vector,
        // and in the direction of the minimum tangent xyz component

        normals[ 0 ] = new Vector3();
        binormals[ 0 ] = new Vector3();
        let min = Number.MAX_VALUE;
        let tx = Math.abs( tangents[ 0 ].x );
        let ty = Math.abs( tangents[ 0 ].y );
        let tz = Math.abs( tangents[ 0 ].z );

        if ( tx <= min ) {

            min = tx;
            normal.set( 1, 0, 0 );

        }

        if ( ty <= min ) {

            min = ty;
            normal.set( 0, 1, 0 );

        }

        if ( tz <= min ) {

            normal.set( 0, 0, 1 );

        }

        vec.crossVectors( tangents[ 0 ], normal ).normalize();

        normals[ 0 ].crossVectors( tangents[ 0 ], vec );
        binormals[ 0 ].crossVectors( tangents[ 0 ], normals[ 0 ] );


        // compute the slowly-letying normal and binormal vectors for each segment on the curve

        for ( i = 1; i <= segments; i ++ ) {

            normals[ i ] = normals[ i - 1 ].clone();

            binormals[ i ] = binormals[ i - 1 ].clone();

            vec.crossVectors( tangents[ i - 1 ], tangents[ i ] );

            if ( vec.length() > Number.EPSILON ) {

                vec.normalize();

                theta = Math.acos( Math.clamp( tangents[ i - 1 ].dot( tangents[ i ] ), - 1, 1 ) ); // clamp for floating pt errors

                normals[ i ].applyMatrix4( mat.makeRotationAxis( vec, theta ) );

            }

            binormals[ i ].crossVectors( tangents[ i ], normals[ i ] );

        }

        // if the curve is closed, postprocess the vectors so the first and last normal vectors are the same

        if ( closed === true ) {

            theta = Math.acos( Math.clamp( normals[ 0 ].dot( normals[ segments ] ), - 1, 1 ) );
            theta /= segments;

            if ( tangents[ 0 ].dot( vec.crossVectors( normals[ 0 ], normals[ segments ] ) ) > 0 ) {

                theta = - theta;

            }

            for ( i = 1; i <= segments; i ++ ) {

                // twist a little...
                normals[ i ].applyMatrix4( mat.makeRotationAxis( tangents[ i ], theta * i ) );
                binormals[ i ].crossVectors( tangents[ i ], normals[ i ] );

            }

        }

        return {
            tangents: tangents,
            normals: normals,
            binormals: binormals
        };
    }
}
Class(function CurveLayer(_input, _group) {
    Inherit(this, Object3D);
    const _this = this;
    var _config, _curve, _debug;

    //*** Constructor
    (async function () {
        _config = InputUIL.create(_input.prefix+'curve', _group);
        _config.setLabel('Curve');
        _config.add('json');
        _config.addToggle('debug');

        let json = _config.get('json');
        if (json) await initCurve(getJSONPath());

        _config.onUpdate = _ => {
            if (_debug) {
                _debug.visible = Global.PLAYGROUND && _config.get('debug');
            }
        }

        _this.flag('loaded', true);
    })();

    function getJSONPath() {
        let path = _config.get('json');
        if (!path.includes('assets/geometry')) path = 'assets/geometry/' + path;
        if (!path.includes('.json')) path += '.json';
        return path;
    }

    async function initCurve(path) {
        let data = _this.data = await get(Assets.getPath(path));
        _curve = _this.initClass(Curve, data);
        if (Global.PLAYGROUND) {
            _debug = _curve.debug();
            _debug.visible = _config.get('debug');
            _this.add(_debug);
        }
    }

    //*** Event handlers

    //*** Public methods
    this.getData = async function() {
        if (!_config.get('json')) console.warn(`No json path set on CurveLayer :: Promise won't resolve`);
        await _this.wait('data');
        return _this.data;
    }

    this.getJSONPath = function() {
        if (!_config.get('json')) console.warn(`No json path set on CurveLayer`);
        return getJSONPath();
    }

    this.getCurve = async function() {
        await _this.wait('loaded');
        return _curve;
    }
});
Class(function CurveTweener() {
    var _v1;
    var _m;
    var _e;

    //*** Public methods
    this.create = function(object3d, curve, direction = 1) {
        object3d.rotation.order = 'YXZ'; // yaw then pitch then roll
        let value = 0;
        let yaw = 0;
        let y = object3d.rotation.y;
        return {
            get value() {
                return value;
            },
            set value(v) {
                value = v;
                let t = Math.clamp(direction < 1 ? (1 - value) : value);
                let point = curve.getPointAt(t);
                let tangent = curve.curve.getTangentAt(t);
                if (direction < 1) {
                    tangent.negate();
                }
                if (!_v1) _v1 = new Vector3();
                if (!_m) _m = new Matrix4();
                if (!_e) _e = new Euler(0, 0, 0, 'YXZ'); // want to extract y-rotation (yaw) only, so order y first
                let eye = _v1.setScalar(0);
                _m.lookAt(eye, tangent, object3d.up);
                object3d.position.copy(point);
                _e.setFromRotationMatrix(_m);
                y = _e.y;
                object3d.rotation.y = y + yaw;
            },
            get pitch() {
                return Math.degrees(object3d.rotation.x);
            },
            set pitch(x) {
                object3d.rotation.x = Math.radians(x);
            },
            get roll() {
                return Math.degrees(object3d.rotation.z);
            },
            set roll(z) {
                object3d.rotation.z = Math.radians(z);
            },
            get yaw() {
                return Math.degrees(yaw);
            },
            set yaw(nextYaw) {
                yaw = Math.radians(nextYaw);
                object3d.rotation.y = y + yaw;
            }
        };
    };
}, 'static');

class CubicBezierCurve extends Curve3D {
    constructor(v0, v1, v2, v3) {
        super();

        this.type = 'CubicBezierCurve';

        this.v0 = v0 || new Vector3();
        this.v1 = v1 || new Vector3();
        this.v2 = v2 || new Vector3();
        this.v3 = v3 || new Vector3();
    }

    getLength() {
        const tmp = this.tmp;
        let length = 0;

        this.points.forEach((p, i) => {
            if (i === 0) return;
            tmp.subVectors(p, this.points[i - 1]);
            length += tmp.length();
        });

        return length;
    }

    getPoint( t, optionalTarget ) {

        var point = optionalTarget || new Vector3();

        var v0 = this.v0, v1 = this.v1, v2 = this.v2, v3 = this.v3;

        point.set(
            this.cubicBezier( t, v0.x, v1.x, v2.x, v3.x ),
            this.cubicBezier( t, v0.y, v1.y, v2.y, v3.y ),
            this.cubicBezier( t, v0.z, v1.z, v2.z, v3.z )
        );

        return point;

    }

    copy ( source ) {

        this.copy.call( this, source );

        this.v0.copy( source.v0 );
        this.v1.copy( source.v1 );
        this.v2.copy( source.v2 );
        this.v3.copy( source.v3 );

        return this;

    }


    cubicBezierP0( t, p ) {

        var k = 1 - t;
        return k * k * k * p;

    }

    cubicBezierP1( t, p ) {

        var k = 1 - t;
        return 3 * k * k * t * p;

    }

    cubicBezierP2( t, p ) {

        return 3 * ( 1 - t ) * t * t * p;

    }

    cubicBezierP3( t, p ) {

        return t * t * t * p;

    }

    cubicBezier( t, p0, p1, p2, p3 ) {

        return this.cubicBezierP0( t, p0 ) + this.cubicBezierP1( t, p1 ) + this.cubicBezierP2( t, p2 ) +
            this.cubicBezierP3( t, p3 );

    }
}

// Utils

class CatmullRomCurve extends Curve3D {
    constructor(points = []) {
        super();

        this.tmp = new Vector3();
        this.px = new CubicPoly();
        this.py = new CubicPoly();
        this.pz = new CubicPoly();

        if ( points.length < 2 ) throw 'CatmullRomCurve: Points array needs at least two entries.';

        this.points = points;
        this.closed = false;
    }

    getLength() {
        const tmp = this.tmp;
        let length = 0;

        this.points.forEach((p, i) => {
            if (i === 0) return;
            tmp.subVectors(p, this.points[i - 1]);
            length += tmp.length();
        });
        
        return length;
    }

    getPoint(t, target) {
        let tmp = this.tmp;
        let px = this.px;
        let py = this.py;
        let pz = this.pz;
        let points = this.points;
        let l = points.length;

        let point = ( l - ( this.closed ? 0 : 1 ) ) * t;
        let intPoint = Math.floor( point );
        let weight = point - intPoint;

        if ( this.closed ) {
            
            intPoint += intPoint > 0 ? 0 : ( Math.floor( Math.abs( intPoint ) / points.length ) + 1 ) * points.length;
            
        } else if ( weight === 0 && intPoint === l - 1 ) {

            intPoint = l - 2;
            weight = 1;

        }

        let p0, p1, p2, p3; // 4 points

        if ( this.closed || intPoint > 0 ) {

            p0 = points[ ( intPoint - 1 ) % l ];

        } else {

            // extrapolate first point
            tmp.subVectors( points[ 0 ], points[ 1 ] ).add( points[ 0 ] );
            p0 = tmp;

        }

        p1 = points[ intPoint % l ];
        p2 = points[ ( intPoint + 1 ) % l ];

        if ( this.closed || intPoint + 2 < l ) {

            p3 = points[ ( intPoint + 2 ) % l ];

        } else {

            // extrapolate last point
            tmp.subVectors( points[ l - 1 ], points[ l - 2 ] ).add( points[ l - 1 ] );
            p3 = tmp;

        }

        if ( this.type === undefined || this.type === 'centripetal' || this.type === 'chordal' ) {
            

            // init Centripetal / Chordal Catmull-Rom
            let pow = this.type === 'chordal' ? 0.5 : 0.25;
            let dt0 = Math.pow( p0.distanceToSquared( p1 ), pow );
            let dt1 = Math.pow( p1.distanceToSquared( p2 ), pow );
            let dt2 = Math.pow( p2.distanceToSquared( p3 ), pow );

            // safety check for repeated points
            if ( dt1 < 1e-4 ) dt1 = 1.0;
            if ( dt0 < 1e-4 ) dt0 = dt1;
            if ( dt2 < 1e-4 ) dt2 = dt1;

            px.initNonuniformCatmullRom( p0.x, p1.x, p2.x, p3.x, dt0, dt1, dt2 );
            py.initNonuniformCatmullRom( p0.y, p1.y, p2.y, p3.y, dt0, dt1, dt2 );
            pz.initNonuniformCatmullRom( p0.z, p1.z, p2.z, p3.z, dt0, dt1, dt2 );

        } else if ( this.type === 'catmullrom' ) {

            let tension = this.tension !== undefined ? this.tension : 0.5;
            px.initCatmullRom( p0.x, p1.x, p2.x, p3.x, tension );
            py.initCatmullRom( p0.y, p1.y, p2.y, p3.y, tension );
            pz.initCatmullRom( p0.z, p1.z, p2.z, p3.z, tension );

        }

        if (target) target.set(px.calc( weight ), py.calc( weight ), pz.calc( weight ));
        else return new Vector3( px.calc( weight ), py.calc( weight ), pz.calc( weight ) );
    }
}
Class(function ImageDecoder() {
    Inherit(this, Component);
    var _this = this;
    var _ktx1Settings;

    const ACTIVE = !!(window.fetch && window.createImageBitmap && Device.system.browser.includes('chrome') && !window.AURA);

    this.scale = 1;

    (async function() {
        await Hydra.ready();
        Thread.upload(decodeImage);
        Thread.upload(findDominantColors);
        Thread.upload(decodeKtx1CompressedImage);
    })();

    function decodeImage(data, id) {
        let run = async _ => {
            try {
                let e = await fetch(data.path, {mode: 'cors'});

                if (e.status != 200) {
                    resolve({fail: true}, id);
                    throw `Image not found :: ${data.path}`;
                }

                let blob = await e.blob();

                let obj = {imageOrientation: 'flipY', crossOrigin: 'anonymous'};
                if (data.params && data.params.premultiplyAlpha === false) obj.premultiplyAlpha = 'none';
                obj.imageOrientation = data.params && data.params.flipY === false ? undefined : 'flipY';

                let bitmap = await createImageBitmap(blob, obj);
                let message = {post: true, id, message: bitmap};
                self.postMessage(message, [bitmap]);

            } catch(e) {
                resolve({fail: true}, id);
                throw e;
            }
        };

        run();
    }

    function decodeKtx1CompressedImage(data, id) {
        let run = async _ => {

            let ext;
            if (data.settings.dxt) ext = 'dxt';
            else if (data.settings.etc) ext = 'astc';
            else if (data.settings.pvrtc) ext = 'pvrtc';
            else if (data.settings.astc) ext = 'astc';

            let fileName = data.path.split('/');
            fileName = fileName[fileName.length-1];

            let e = await fetch(`${data.path}/${fileName}-${ext}.ktx`);
            if (e.status != 200) throw `Image not found :: ${data.path}`;

            try {
                let arrayBuffer = await e.arrayBuffer();
                let header = new Int32Array(arrayBuffer, 12, 13);

                let glType = header[1];
                let glTypeSize = header[2];
                let glFormat = header[3];
                let gliFormat = header[4];
                let glBaseInternalFormat = header[5];
                let baseWidth = header[6];
                let baseHeight = header[7];
                let width = baseWidth;
                let height = baseHeight;
                let numberOfArrayElements = header[9];
                let numberOfFaces = header[10];
                let miplevels = header[11];
                let bytesOfKeyValueData = header[12];

                let buffers = [];
                let compressedData = [];
                let sizes = [];
                let cube = numberOfFaces === 6 && numberOfArrayElements === 0;

                let dataOffset = 12 + (13 * 4) + bytesOfKeyValueData;

                for (let level = 0; level < miplevels; level++) {
                    let imageSize = new Int32Array(arrayBuffer, dataOffset, 1)[0];
                    dataOffset += 4;
                    if (cube) imageSize *= 6;

                    let byteArray = new Uint8Array(arrayBuffer, dataOffset, imageSize);

                    dataOffset += imageSize;
                    dataOffset += 3 - ((imageSize + 3) % 4);

                    sizes.push(width);
                    width = Math.max(1.0, width * 0.5);
                    height = Math.max(1.0, height * 0.5);

                    let clone = new Uint8Array(byteArray);

                    compressedData.push(clone);
                    buffers.push(clone.buffer);
                }

                resolve({gliFormat, compressedData, sizes, width: baseWidth, height: baseHeight, cube}, id, buffers);

            } catch(e) {
                throw `${data.path} could not be decoded`;
            }
        };

        run();
    }

    function process(bitmap, scale) {
        let s = scale * _this.scale;
        if (s == 1) return bitmap;

        let pow2 = Math.isPowerOf2(bitmap.width, bitmap.height);

        let canvas = document.createElement('canvas');
        canvas.context = canvas.getContext('2d');
        canvas.width = Math.round(bitmap.width * _this.scale * scale);
        canvas.height = Math.round(bitmap.height * _this.scale * scale);

        if (pow2 && scale * _this.scale < 1) {
            canvas.width = canvas.height = Math.floorPowerOf2(Math.max(canvas.width, canvas.height));
        }

        canvas.context.drawImage(bitmap, 0, 0, canvas.width, canvas.height);
        return canvas;
    }

    function findDominantColors(e, id) {

        let imageData = e.imageData;

        let run = async _ => {

            try {

                let threshold = 40 / 255;
                let colors = [];

                for(let i = 0; i < imageData.length; i += 4) {

                    let r = imageData[i + 0] / 255;
                    let g = imageData[i + 1] / 255;
                    let b = imageData[i + 2] / 255;

                    let color = new Color(r, g, b);

                    if(i == 0) colors.push([color, 1]);

                    else {

                        let below = colors.filter(data => {
                            let c = data[0];
                            let dist = Math.pow(c.r - r, 2) + Math.pow(c.g - g, 2) + Math.pow(c.b - b, 2);
                            return dist < threshold * threshold;
                        })

                        if(below.length == 0) colors.push([color, 1]);

                        else {

                            let sorted = below.sort( (a, b) => {

                                let d1 = a[0];
                                d1 = Math.pow(d1.r - r, 2) + Math.pow(d1.g - g, 2) + Math.pow(d1.b - b, 2);

                                let d2 = b[0];
                                d2 = Math.pow(d2.r - r, 2) + Math.pow(d2.g - g, 2) + Math.pow(d2.b - b, 2);

                                return d1 - d2;

                            })

                            let closestColor = sorted[0][0];
                            closestColor = colors.filter(el => el[0].equals(closestColor));
                            closestColor = closestColor[0];
                            let index = colors.indexOf(closestColor);
                            colors[index][1] ++;

                        }
                    }
                }


                let l = Math.floor(colors.length / 8);
                let c = [colors[0][0], colors[1 * l][0], colors[2 * l][0], colors[3 * l][0]];


                resolve({colors: c}, id);

            } catch(e) {

                resolve({fail: true}, id);
                throw e;
            }
        };

        run();
    }

    //*** Event handlers

    //*** Public methods
    this.decode = async function(path, params = {}) {
        let fallback = Thread.absolutePath(Assets.getPath('assets/images/_scenelayout/uv.jpg'));
        path = Thread.absolutePath(Assets.getPath(path));

        if (typeof _ktx1Settings === 'undefined') {
            _ktx1Settings = {
                dxt: !!Renderer.extensions.s3tc,
                etc: !!Renderer.extensions.etc1,
                pvrtc: !!Renderer.extensions.pvrtc,
                astc: !!Renderer.extensions.astc
            };
            let found = false;
            for (let key in _ktx1Settings) {
                if (_ktx1Settings[key] === true) found = true;
            }
            if (!found) _ktx1Settings = null;
        }

        let compressedIdentifier = /-compressedKtx2?/.exec(path)?.[0];
        let compressed = !!compressedIdentifier &&
            (compressedIdentifier.endsWith('2') ? 'ktx2' : 'ktx1');
        if (Utils.query('noKtx') || (!_ktx1Settings && compressed === 'ktx1')) {
            path = path.replace(compressedIdentifier, '');
            compressed = false;
        }
        if (/\.ktx2(?:\?|#|$)/.test(path)) {
            // No fallback
            compressed = 'ktx2';
            if (Utils.query('noKtx')) params.uncompressed = true;
        }

        if (compressed) {
            try {
                path = path.substring(0, path.lastIndexOf('.'));
                let bitmap;
                if (compressed === 'ktx1') {
                    bitmap = await Thread.shared().decodeKtx1CompressedImage({path, params, settings: _ktx1Settings});
                } else {
                    bitmap = await Ktx2Transcoder.transcode({ path: `${path}.ktx2`, params });
                }
                return bitmap;
            } catch(e) {
                return _this.decode( fallback, params);
            }
        } else {
            let getBitmap = ( path, params ) => (ACTIVE ? Thread.shared().decodeImage({path, params}) : Assets.decodeImage(path, params));
            try {
                let bitmap = await getBitmap( path, params );
                if (bitmap.fail) {
                    bitmap = await getBitmap( fallback, params );
                    if (bitmap.fail) throw 'could not decode '+path;
                }
                return process(bitmap, params.scale || 1);
            } catch(e) {
                throw 'could not decode '+path;
            }
        }
    }

    this.parseColors = async function(imageData) {
        return await Thread.shared().findDominantColors({imageData});
    }
}, 'static');

/**
 * Decode images on a separate thread, preventing jank
 * @name ImageDecoder
 * @constructor
 * @example
 *
 * async function loadImage() {
        let canvas = await ImageDecoder.decode(_data.image);
        let texture = new THREE.Texture(canvas);
        texture.needsUpdate = true;
        texture.minFilter = texture.magFilter = THREE.LinearFilter;
        _shader.set('tBG', texture);
    }
 **/

Class(function Ktx2Transcoder() {
    Inherit(this, Component);
    const _this = this;

    var _transcoderReady;
    var _basisAssets = [
        '~assets/js/lib/basis_transcoder.js',
        '~assets/js/lib/basis_transcoder.wasm',
    ].map(Assets.getPath).map(Thread.absolutePath);

    async function initBasisTranscoder() {
        if (_transcoderReady) {
            await _transcoderReady;
        } else {
            _transcoderReady = Promise.create();
            let [js, wasmBinary] = await Promise.all(_basisAssets.map(async (path, i) => {
                let response = await fetch(path);
                if (i === 0) return response.text();
                return response.arrayBuffer();
            }));

            let formats = getSupportedFormats();
            let threads = Thread.shared(true).array; //.slice(0, 1);
            await Promise.all(threads.map(async thread => {
                thread.importCode(js);
                thread.loadFunction(initKtx2TranscoderThread);
                thread.loadFunction(function transcodeKtx2(){}); // Need this for main thread side. Will be replaced by init
                await thread.initKtx2TranscoderThread({ wasmBinary, formats })
            }));

            _transcoderReady.resolve();
            _this.flag('transcoderLoaded', true);
        }
    }

    function getSupportedFormats() {
        let supported = {
            astc: !!Renderer.extensions.astc,
            etc1: !!Renderer.extensions.etc1,
            etc2: !!Renderer.extensions.etc,
            dxt: !!Renderer.extensions.s3tc,
            bptc: !!Renderer.extensions.bptc,
            pvrtc: !!Renderer.extensions.pvrtc,
            uncompressed: true
        };
        if (Renderer.type === Renderer.WEBGL2) {
            supported.etc1 = false; // False-positive in Safari https://github.com/mrdoob/three.js/pull/22928
        }

        let formats = {};
        Object.keys(supported).filter(id => supported[id]).forEach(id => {
            let format = {
                id,
                needsPowerOfTwo: false
            };
            formats[id] = format;
            switch (id) {
                case 'astc':
                    format.gliFormat = [
                        Renderer.extensions.astc.COMPRESSED_RGBA_ASTC_4x4_KHR,
                        Renderer.extensions.astc.COMPRESSED_RGBA_ASTC_4x4_KHR
                    ];
                    break;
                case 'bptc':
                    format.gliFormat = [
                        Renderer.extensions.bptc.COMPRESSED_RGBA_BPTC_UNORM_EXT,
                        Renderer.extensions.bptc.COMPRESSED_RGBA_BPTC_UNORM_EXT
                    ];
                    break;
                case 'dxt':
                    format.gliFormat = [
                        Renderer.extensions.s3tc.COMPRESSED_RGB_S3TC_DXT1_EXT,
                        Renderer.extensions.s3tc.COMPRESSED_RGBA_S3TC_DXT5_EXT
                    ];
                    break;
                case 'etc2':
                    format.gliFormat = [
                        Renderer.extensions.etc.COMPRESSED_RGB8_ETC2,
                        Renderer.extensions.etc.COMPRESSED_RGBA8_ETC2_EAC
                    ];
                    break;
                case 'etc1':
                    format.gliFormat = [
                        Renderer.extensions.etc.COMPRESSED_RGB_ETC1_WEBGL
                    ];
                    break;
                case 'pvrtc':
                    format.gliFormat = [
                        Renderer.extensions.pvrtc.COMPRESSED_RGB_PVRTC_4BPPV1_IMG,
                        Renderer.extensions.pvrtc.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG
                    ];
                    format.needsPowerOfTwo = true;
                    break;
                case 'uncompressed':
                    format.gliFormat = [
                        Renderer.context.RGBA,
                        Renderer.context.RGBA
                    ];
                    break;
            }
        });
        return formats;
    }

    function initKtx2TranscoderThread(e, id) {
        var _formats;

        const KHR_DF_FLAG_ALPHA_STRAIGHT = 0;
        const KHR_DF_FLAG_ALPHA_PREMULTIPLIED = 1;
        const KHR_DF_TRANSFER_LINEAR = 1;
        const KHR_DF_TRANSFER_SRGB = 2;

        function initFormats(formats) {
            Object.keys(formats).forEach(id => {
                let format = formats[id];
                switch (id) {
                    case 'astc':
                        format.transcoderFormat = [
                            BasisModule.transcoder_texture_format.cTFASTC_4x4_RGBA.value,
                            BasisModule.transcoder_texture_format.cTFASTC_4x4_RGBA.value
                        ];
                        break;
                    case 'bptc':
                        format.transcoderFormat = [
                            BasisModule.transcoder_texture_format.cTFBC7_RGBA.value, // BC7_M5 (7) missing??
                            BasisModule.transcoder_texture_format.cTFBC7_RGBA.value
                        ];
                        break;
                    case 'dxt':
                        format.transcoderFormat = [
                            BasisModule.transcoder_texture_format.cTFBC1_RGB.value,
                            BasisModule.transcoder_texture_format.cTFBC3_RGBA.value
                        ];
                        break;
                    case 'etc2':
                        format.transcoderFormat = [
                            BasisModule.transcoder_texture_format.cTFETC1_RGB.value,
                            BasisModule.transcoder_texture_format.cTFETC2_RGBA.value
                        ];
                        break;
                    case 'etc1':
                        format.transcoderFormat = [
                            BasisModule.transcoder_texture_format.cTFETC1_RGB.value
                        ];
                        break;
                    case 'pvrtc':
                        format.transcoderFormat = [
                            BasisModule.transcoder_texture_format.cTFPVRTC1_4_RGB.value,
                            BasisModule.transcoder_texture_format.cTFPVRTC1_4_RGBA.value
                        ];
                        break;
                    case 'uncompressed':
                        format.transcoderFormat = [
                            BasisModule.transcoder_texture_format.cTFRGBA32.value,
                            BasisModule.transcoder_texture_format.cTFRGBA32.value
                        ];
                        break;
                }
            });
            _formats = {
                uastc: [
                    formats.astc,
                    formats.bptc,
                    formats.etc2,
                    formats.etc1,
                    formats.dxt,
                    formats.pvrtc,
                    formats.uncompressed
                ].filter(Boolean),
                etc1s: [
                    formats.etc2,
                    formats.etc1,
                    formats.bptc,
                    formats.dxt,
                    formats.pvrtc,
                    formats.uncompressed
                ].filter(Boolean),
                uncompressed: formats.uncompressed
            };
        }

        async function transcodeKtx2({ path, params }, id) {
            let ktx2File;
            try {
                let response = await fetch(path);
                if (response.status !== 200) throw new Error(`Image not found :: ${path}`);

                let arrayBuffer = await response.arrayBuffer();
                ktx2File = new BasisModule.KTX2File(new Uint8Array(arrayBuffer));

                if (!ktx2File.isValid()) {
                    throw new Error('Invalid or unsupported .ktx2 file');
                }

                let basisFormat = ktx2File.isUASTC() ? 'uastc' : 'etc1s';
                let baseWidth = ktx2File.getWidth();
                let baseHeight = ktx2File.getHeight();
                let layers = ktx2File.getLayers() || 1;
                let levels = ktx2File.getLevels();
                let faceCount = ktx2File.getFaces();
                let hasAlpha = ktx2File.getHasAlpha();
                let dfdFlags = ktx2File.getDFDFlags();
                let premultiplyAlpha = !!(dfdFlags & KHR_DF_FLAG_ALPHA_PREMULTIPLIED);
                // let dfdTransferFn = ktx2File.getDFDTransferFunc();
                // let encoding = dfdTransferFn === KHR_DF_TRANSFER_SRGB ? sRGBEncoding : LinearEncoding;

                let { transcoderFormat, gliFormat, uncompressed } = getTranscoderFormat(basisFormat, baseWidth, baseHeight, hasAlpha, params);

                if (!baseWidth || !baseHeight || !levels) {
                    throw new Error('Invalid texture');
                }

                if (layers > 1) {
                    throw new Error('Array textures not implemented');
                }

                if (!ktx2File.startTranscoding()) {
                    throw new Error('startTranscoding failed');
                }

                let buffers = [];
                let compressedData = [];
                let sizes = [];
                let cube = faceCount === 6;
                for (let level = 0; level < levels; level++) {
                    let faces = [];
                    let width;
                    let height;
                    for (let faceIndex = 0; faceIndex < faceCount; ++faceIndex) {
                        let levelInfo = ktx2File.getImageLevelInfo(level, 0, faceIndex);
                        width = levelInfo.origWidth;
                        height = levelInfo.origHeight;
                        let data = new Uint8Array(ktx2File.getImageTranscodedSizeInBytes(level, 0, faceIndex, transcoderFormat));
                        let status = ktx2File.transcodeImage(
                            data,
                            level,
                            0,
                            faceIndex,
                            transcoderFormat,
                            0,
                            -1,
                            -1,
                        );

                        if (!status) throw new Error('transcodeImage failed');
                        faces.push(data);
                    }
                    let data;
                    if (faces.length > 1) {
                        let totalLength = 0;
                        faces.forEach(face => {
                            totalLength += face.byteLength;
                        });
                        data = new Uint8Array(totalLength);
                        let offset = 0;
                        faces.forEach(face => {
                            data.set(face, offset);
                            offset += face.byteLength;
                        });
                    } else {
                        data = faces[0];
                    }

                    compressedData.push(data);
                    buffers.push(data.buffer);
                    sizes.push({ width, height });
                }

                resolve({
                    gliFormat,
                    compressedData,
                    sizes,
                    width: baseWidth,
                    height: baseHeight,
                    cube,
                    premultiplyAlpha,
                    uncompressed
                }, id, buffers);
            } catch (e) {
                console.log(e.toString());
                resolve({ fail: `${path} could not be decoded: ${e.message || e}` }, id);
            } finally {
                if (ktx2File) {
                    ktx2File.close();
                    ktx2File.delete();
                }
            }
        }

        function getTranscoderFormat(basisFormat, width, height, hasAlpha, params) {
            let format;
            if (params.uncompressed) {
                format = _formats.uncompressed;
            } else {
                format = _formats[basisFormat].find(format => !(
                    (hasAlpha && format.transcoderFormat.length < 2) ||
                    (format.needsPowerOfTwo && !Math.isPowerOf2(width, height))
                ));
            }

            let uncompressed = format.id === 'uncompressed';
            if (uncompressed && !params.uncompressed) {
                console.warn('No suitable compressed texture format found. Decoding to RGBA32.');
            }

            let which = hasAlpha ? 1 : 0;
            return {
                transcoderFormat: format.transcoderFormat[which],
                gliFormat: format.gliFormat[which],
                uncompressed
            };
        }

        var BasisModule = {
            wasmBinary: e.wasmBinary,
            onRuntimeInitialized: function() {
                BasisModule.initializeBasis();
                initFormats(e.formats);
                self.transcodeKtx2 = transcodeKtx2;
                delete self.initKtx2TranscoderThread;
                resolve(id);
            }
        };
        BASIS(BasisModule);
    }

    //*** Event handlers

    //*** Public methods
    _this.transcode = async function({ path, params }) {
        if (!_this.flag('transcoderLoaded')) await initBasisTranscoder();
        let result = await Thread.shared().transcodeKtx2({ path, params });
        if (result.fail) {
            throw new Error(result.fail);
        }
        return result;
    };
}, 'static');

/**
 * @name BaseCamera
 */
Class(function BaseCamera(_input, _group) {
    Inherit(this, Object3D);
    const _this = this;
    var _debugCamera;

    var _type = 'perspective';

    function resize() {
        if (_this.overrideResize) {
            if (typeof _this.overrideResize === 'function') _this.overrideResize();
            return;
        }
        switch ( _type ) {
            case 'perspective':
                _this.camera.aspect = Stage.width / Stage.height;
                _this.camera.updateProjectionMatrix();
                break;
            case 'orthographic':
                if ( !_this.width && !_this.height ) {
                    let m = (900 / Stage.height) / 100;
                    _this.camera.setViewport( Stage.width * m, Stage.height * m );
                } else {
                    _this.camera.setViewport( _this.width, _this.height );
                }
                break;
        }
    }

    this.camera = new PerspectiveCamera(30, Stage.width / Stage.height, 0.1, 1000);
    this.group.add(this.camera);

    this.startRender(_ => {
        _this.group.updateMatrixWorld(true);
        if (_debugCamera && _debugCamera.visible) {
            Utils3D.decompose(_this.camera, _debugCamera);
            let active = AppState.get('playground_camera_active');
            let viewportHeight;
            if (active.isOrthographicCamera) {
                viewportHeight = (active.top - active.bottom) / active.zoom;
            } else {
                viewportHeight = Utils3D.getHeightFromCamera(active, _this.camera.position.distanceTo(active.position));
            }
            _debugCamera.scale.setScalar((viewportHeight * 0.025) / 0.1);
        }
    });

    this.onResize(resize);

    if (_input) {
        _this.prefix = _input.prefix;
        let cameraUIL = CameraUIL.add(_this, _group);
        cameraUIL.setLabel('Camera');
        _this.group._cameraUIL = cameraUIL;
    }

    if (Global.PLAYGROUND) {
        AppState.bind('playground_camera_active', active => {
            if (!_this.group._parent) return;
            if (active) {
                if (!_debugCamera) {
                    _debugCamera = new Mesh(new BoxGeometry(0.1, 0.1, 0.2), new Shader('DebugCamera', {uColor: {value: new Color('#ffffff')}, transparent: true, depthTest: false}));
                    _debugCamera.renderOrder = 9999;
                    _this.delayedCall(_ => _this.group._parent.add(_debugCamera), 50);
                }

                _debugCamera.visible = true;
            } else {
                if (_debugCamera) _debugCamera.visible = false;
            }
        });
    }

    /**
     * @name camera
     * @memberof GeometryAttribute
     * @property
     */

    /**
     * @name group
     * @memberof GeometryAttribute
     * @property
     */

    //*** Public methods

    /**
     * @name playgroundLock()
     * @memberof BaseCamera
     *
     * @function
     */
    this.playgroundLock = function(camera = Camera.instance()) {
        if (!Global.PLAYGROUND) return;

        let parent = Utils.getConstructorName(_this.parent);
        if (parent.includes(Global.PLAYGROUND.split('/')[0])) {
            if (RenderManager.type == RenderManager.NORMAL) camera.lock(_this.camera);
        }
    };

    /**
     * @name lock()
     * @memberof BaseCamera
     *
     * @function
     */
    this.lock = function(camera = Camera.instance()) {
        if (_type == 'orthographic' && !camera.worldCamera.isOrthographicCamera) return console.error(`You can't lock an orthographic camera to the main camera. Use an FXScene .setCamera`);
        if (RenderManager.type == RenderManager.NORMAL) camera.lock(_this.camera);
    };

    /**
     * @name transition()
     * @memberof BaseCamera
     *
     * @function
     * @param {Number} time
     * @param {String} ease
     * @param {Number} delay
     */
    this.transition = function(time, ease, delay, camera = Camera.instance()) {
        if (typeof delay == 'object') {
            camera = delay;
            delay = 0;
        }

        let p = Promise.create();

        camera.transition(_this.camera, time, ease, delay || 0);
        _this.delayedCall(_ => p.resolve(), time + (delay || 0));

        return p;
    };

    /**
     * @name manualTransition()
     * @memberof BaseCamera
     */
    this.manualTransition = function(camera = Camera.instance()) {
        return camera.manualTransition(_this.camera);
    };

    /**
     * @name setFOV()
     * @memberof BaseCamera
     *
     * @function
     * @param {Number} fov
     */
    this.setFOV = function(fov) {
        if (_type === 'orthographic') return;
        if (fov != this.camera.fov) {
            this.camera.fov = fov;
            this.camera.updateProjectionMatrix();
        }
    };

    /**
     * @name this.getFOV
     * @memberof BaseCamera
     *
     * @function
    */
    this.getFOV = function() {
        return this.camera.fov;
    }

    /**
     * @name this.useOrthographic
     * @memberof BaseCamera
     *
     * @function
     * @param w
     * @param h
    */
    this.useOrthographic = function (w,h) {
        if ( _type === 'orthographic' ) return;
        if ( !isNaN( w )) this.width = w;
        if ( !isNaN( h )) this.height = h;
        if ( this.camera ) this.group.remove( this.camera );
        this.camera = new OrthographicCamera();
        this.group.add(this.camera);
        this.camera.position.z = 1;
        _type = 'orthographic';
        resize();
    }

    /**
     * @name this.usePerspective
     * @memberof BaseCamera
     *
     * @function
    */
    this.usePerspective = function () {
        if ( _type === 'perspective' ) return;
        if ( this.camera ) this.group.remove( this.camera );
        this.camera = new PerspectiveCamera();
        this.group.add(this.camera);
        _type = 'perspective';
        resize();
    }

    /**
     * @name this.useCurve
     * @memberof BaseCamera
     *
     * @function
     * @param curve
    */
    this.useCurve = function(curve) {
        _this.camera.curve = curve;
        return this;
    }

    _this.get('zoom', () => _this.camera.zoom);
    _this.set('zoom', zoom => {
        _this.camera.zoom = zoom;
        _this.camera.updateProjectionMatrix();
    });

    _this.get('near', () => _this.camera.near);
    _this.set('near', near => {
        _this.camera.near = near;
        _this.camera.updateProjectionMatrix();
    });

    _this.get('far', () => _this.camera.far);
    _this.set('far', far => {
        _this.camera.far = far;
        _this.camera.updateProjectionMatrix();
    });
});

/**
 * Singleton
 * @name Camera
 */

Class(function Camera(_worldCamera) {
    Inherit(this, Component);
    const _this = this;
    var _debug, _prevCamera, _lockCamera, _curve, _manual;

    var _calc = new Vector3();

    var _target = new Group();
    var _anim = {weight: 0, weight2: 0};
    var _center = new Vector3();
    var _cameraTarget = new Group();
    var _cameraTarget2 = new Group();
    var _scheduleSlot;

   /**
    * @name lerp
    * @memberof Camera
    * @property
    */
    this.lerp = 1;
   /**
    * @name lerp2
    * @memberof Camera
    * @property
    */
    this.lerp2 = 1;
   /**
    * @name worldCamera
    * @memberof Camera
    * @property
    */
    this.worldCamera = _worldCamera;

    this.finalLerp = 1;
    this.multiTween = true;

    //*** Constructor
    (function () {
        if (RenderManager.type != RenderManager.NORMAL) {
            _worldCamera = undefined;
            _this.worldCamera = _worldCamera;
            return;
        }
        _this.startRender(loop, RenderManager.AFTER_LOOPS);
    })();

    function loop() {
        if (!_scheduleSlot) render();
    }

    function render() {
        if (_debug) _debug.visible = !_debug.position.equals(_center);

        if (_manual) _anim.weight2 = _manual.value;
        _anim.weight += (_anim.weight2 - _anim.weight) * _this.lerp;

        if (_prevCamera) {
            _prevCamera.updateMatrixWorld();
            _lockCamera.updateMatrixWorld();

            if (!_curve) {
                _target.position.copy(_prevCamera.getWorldPosition()).lerp(_lockCamera.getWorldPosition(), _anim.weight, false);
            } else {
                if (!_curve.lerpPos) {
                    _curve.lerpPos = new Vector3().copy(_prevCamera.getWorldPosition());
                }
                if (!_curve.lerpOffset) {
                    // To account for the destination camera moving during the transition (e.g. gaze camera),
                    // use a technique inspired by [FLIP](https://css-tricks.com/animating-layouts-with-the-flip-technique/):
                    // treat the curve as backward offsets from the end position. During the animation,
                    // those offsets can be applied to the destination camera’s current position to
                    // calculate where the animated camera should be positioned at any moment.
                    _curve.lerpOffset = new Vector3().copy(_curve.getPointAt(1))
                        .multiplyScalar(-2)
                        .add(_lockCamera.getWorldPosition());
                }

                let pos = _calc.copy(_curve.getPointAt(_anim.weight))
                    .add(_curve.lerpOffset)
                    .add(_lockCamera.getWorldPosition());

                _curve.lerpPos.lerp(pos, _curve.lerp || 1, false);

                _target.position.copy(_curve.lerpPos);

                if (_anim.weight >= 1) {
                    _curve = _curve.lerpPos = _curve.lerpOffset = null;
                    _this.onCurveComplete && _this.onCurveComplete();
                }
            }

            _target.quaternion.copy(_prevCamera.getWorldQuaternion()).slerp(_lockCamera.getWorldQuaternion(), _anim.weight, false);

            let needsUpdate = false;
            let zoom = Math.mix(_prevCamera.zoom, _lockCamera.zoom, _anim.weight);
            if (_worldCamera.zoom !== zoom) {
                _worldCamera.zoom = zoom;
                needsUpdate = true;
            }
            let fov = !_worldCamera.isOrthographicCamera && Math.mix(_prevCamera.fov, _lockCamera.fov, _anim.weight);
            if (fov && _worldCamera.fov !== fov) {
                _worldCamera.fov = fov;
                needsUpdate = true;
            }
            if (needsUpdate) _worldCamera.updateProjectionMatrix();

            _cameraTarget.position.lerp(_target.position, _this.lerp2, false);
            _cameraTarget.quaternion.slerp(_target.quaternion, _this.lerp2, false);

        } else {
            if (_lockCamera) {
                _lockCamera.updateMatrixWorld();
                _lockCamera.decomposeDirty = true;
                Utils3D.decompose(_lockCamera, _cameraTarget);
                let needsUpdate = false;
                if (_lockCamera.zoom && _worldCamera.zoom != _lockCamera.zoom) {
                    _worldCamera.zoom = _lockCamera.zoom;
                    needsUpdate = true;
                }
                if (!_worldCamera.isOrthographicCamera && _worldCamera.fov != _lockCamera.fov) {
                    _worldCamera.fov = _lockCamera.fov;
                    needsUpdate = true;
                }
                if (needsUpdate) _worldCamera.updateProjectionMatrix();
            }
        }

        _cameraTarget2.position.lerp(_cameraTarget.position, _this.finalLerp, false);
        _cameraTarget2.quaternion.slerp(_cameraTarget.quaternion, _this.finalLerp, false);

        _worldCamera.position.lerp(_cameraTarget2.position, _this.finalLerp, false);
        _worldCamera.quaternion.slerp(_cameraTarget2.quaternion, _this.finalLerp, false);

        _worldCamera.updateMatrixWorld();

        if (_debug) {
            _debug.position.copy(_worldCamera.position);
            _debug.quaternion.copy(_worldCamera.quaternion);
        }

        RenderManager.fire(_this);
    }

    //*** Event handlers

    //*** Public methods
    /**
     * @name this.lock
     * @memberof Camera
     *
     * @function
     * @param {PerspectiveCamera|Camera} camera
     * @param scheduleSlot optionally specify a render slot for updating this instance. Can also
     *                     pass a Camera instance as the first parameter to update after that
     *                     instance automatically.
    */
    this.lock = function(camera, scheduleSlot) {
        if (camera instanceof Camera) {
            scheduleSlot = camera;
            camera = camera.worldCamera;
        }
        _lockCamera = camera;
        _prevCamera = null;
        if (!_worldCamera) return;
        if (_scheduleSlot) _this.stopRender(render, _scheduleSlot);
        _scheduleSlot = scheduleSlot;
        if (_scheduleSlot) _this.startRender(render, _scheduleSlot);
        if (_lockCamera.zoom) _worldCamera.zoom = _lockCamera.zoom;
        if (!_worldCamera.isOrthographicCamera) {
            _worldCamera.fov = _lockCamera.fov;
        }
        _worldCamera.updateProjectionMatrix();
        render();
    };

    /**
     * @name this.transition
     * @memberof Camera
     *
     * @function
     * @param camera
     * @param duration
     * @param ease
    */
    this.transition = function(camera, duration = 1000, ease = 'easeInOutCubic', scheduleSlot) {
        if (camera instanceof Camera) {
            scheduleSlot = camera;
            camera = camera.worldCamera;
        }
        if (_curve) {
            _curve = _curve.lerpPos = _curve.lerpOffset = null;
        }

        if (camera.curve) {
            _curve = camera.curve;
            _curve.lerpPos = camera.lerpPos;
        }

        // If transitioning back to the same camera, don't reset values
        if (_prevCamera === camera) {
            // If previous transition cut short, shorten return transition. minimum of 0.5;
            duration *= Math.smoothStep(0.5, 1, _anim.weight) * 0.5 + 0.5;
            _anim.weight = 1 - _anim.weight;
        } else {
            _anim.weight = 0;
        }

        _manual = undefined;

        if (scheduleSlot && _worldCamera) {
            if (_scheduleSlot) _this.stopRender(render, _scheduleSlot);
            _scheduleSlot = scheduleSlot;
            _this.startRender(render, _scheduleSlot);
        }
        _anim.weight2 = _anim.weight;
        _prevCamera = _lockCamera;
        _lockCamera = camera;
        return tween(_anim, {weight2: 1}, duration, ease);
    };

    /**
     * @name this.manualTransition
     * @memberof Camera
     *
     * @function
     * @param camera
     */
    this.manualTransition = function(camera) {
        let tween = this.transition(camera);
        tween.stop();
        _manual = {value: 0};
        return _manual;
    }

    /**
     * @name this.setPrevCamera
     * @memberof Camera
     *
     * @function
     * @param camera
     */
    this.setPrevCamera = function(camera) {
        _prevCamera = camera.camera || camera;
    }

    this.get('worldCamera', _ => {
        return _worldCamera;
    });

    this.get('lockCamera', _ => {
        return _lockCamera;
    });

    this.set('debugScale', s => {
        if (_debug) _debug.scale.setScalar(s);
    });

    /**
     * @name this.createLocal
     * @memberof Camera
     *
     * @function
     * @param camera
    */
    this.createLocal = function(camera) {
        if (!camera) {
            camera = World.CAMERA.clone();
            _this.onResize(_ => {
                camera.aspect = Stage.width / Stage.height;
                camera.updateProjectionMatrix();
            });
        }

        return new Camera(camera.camera || camera);
    }

}, 'singleton');

/**
 * @name GazeCamera
 * @extends BaseCamera
 */
Class(function GazeCamera(_input, _group) {
    Inherit(this, BaseCamera);
    const _this = this;

    var _strength = {v: 1};
    var _cacheObj = {};
    var _move = new Vector3();
    var _position = new Vector3();
    var _wobble = new Vector3();
    var _rotation = 0;
    var _wobbleAngle = Math.radians(Math.rand(0, 360));
    var _innerGroup = new Group();
    var _viewportFocusOffset = new Vector3();
    var _hasViewportFocusOffset = false;
    var _manualRender = false;
    var _quaternion = new Quaternion();

    const V3_ZERO = new Vector3(0);

   /**
    * @name strength
    * @memberof GazeCamera
    * @property
    */
    this.strength = 1;
   /**
    * @name moveXY
    * @memberof GazeCamera
    * @property
    */
    this.moveXY = new Vector2(4, 4);
   /**
    * @name position
    * @memberof GazeCamera
    * @property
    */
    this.position = new Position();
   /**
    * @name lerpSpeed
    * @memberof GazeCamera
    * @property
    */
    this.lerpSpeed = 0.05;
   /**
    * @name lerpSpeed2
    * @memberof GazeCamera
    * @property
    */
    this.lerpSpeed2 = 1;
   /**
    * @name lookAt
    * @memberof GazeCamera
    * @property
    */
    this.lookAt = new Vector3(0, 0, 0);
    /**
     * Local camera rotation, applied after the camera is rotated by lookAt.
     * @name cameraRotation
     * @memberof GazeCamera
     * @property
     * @type {Euler}
     */
    this.cameraRotation = new Euler();
    /**
     * The camera points at lookAt, so an object at that position will appear
     * centered in the viewport. To make it appear at some other viewport
     * position independently of the other camera movements, set `viewportFocus`
     * to a viewport position. The center of the viewport is 0,0 (default),
     * and the top right is 1,1.
     * @name viewportFocus
     * @memberof GazeCamera
     * @property
     */
    this.viewportFocus = new Vector2(0, 0);
   /**
    * @name deltaRotate
    * @memberof GazeCamera
    * @property
    */
    this.deltaRotate = 0;
   /**
    * @name deltaLerp
    * @memberof GazeCamera
    * @property
    */
    this.deltaLerp = 1;
   /**
    * @name wobbleSpeed
    * @memberof GazeCamera
    * @property
    */
    this.wobbleSpeed = 1;
   /**
    * @name wobbleStrength
    * @memberof GazeCamera
    * @property
    */
    this.wobbleStrength = 0;
   /**
    * @name wobbleZ
    * @memberof GazeCamera
    * @property
    */
    this.wobbleZ = 1;

    this.zoomOffset = 0;

    //_options.useTouch = true;

    //*** Constructor
    (function () {
        if (_input) {
            _this.prefix = _input.prefix;
            let cameraUIL = CameraUIL.add(_this, _group);
            cameraUIL.setLabel('Camera');
            _this.group._cameraUIL = cameraUIL;
        }

        _this.startRender(loop);
        _innerGroup.add(_this.camera);
        _this.group.add(_innerGroup);
    })();

    function loop() {
        if (_hasViewportFocusOffset) _this.camera.position.sub(_viewportFocusOffset);
        if (_this.useAccelerometer && Mobile.Accelerometer && Mobile.Accelerometer.connected) {
            _move.x = _this.position.x + (Math.range(Mobile.Accelerometer.x, -2, 2, -1, 1, true) * _strength.v * _this.moveXY.x * _this.strength);
            _move.y = _this.position.y;
        } else {
            _move.x = _this.position.x + (Math.range(Mouse.x, 0, Stage.width, -1, 1, true) * _strength.v * _this.moveXY.x * _this.strength);
            _move.y = _this.position.y + (Math.range(Mouse.y, 0, Stage.height, -1, 1, true) * _strength.v * _this.moveXY.y * _this.strength);

            let rotateStrength = Math.range(Math.abs(Mouse.delta.x) / Stage.width, 0, 0.02, 0, 1, true);
            _rotation = Math.lerp((Math.radians(_this.deltaRotate) * rotateStrength * Math.sign(Mouse.delta.x)), _rotation, 0.02 * _this.deltaLerp * _strength.v);
            _innerGroup.rotation.z = Math.lerp(_rotation, _innerGroup.rotation.z, 0.07 * _this.deltaLerp);
        }

        _move.z = _this.position.z;

        _position.lerp(_move, _this.lerpSpeed2);
        _position.z += _this.zoomOffset;
        _this.camera.position.lerp(_position, _this.lerpSpeed);

        _this.camera.lookAt(_this.lookAt);
        if (Math.abs(_this.cameraRotation.x) > Base3D.DIRTY_EPSILON || Math.abs(_this.cameraRotation.y) > Base3D.DIRTY_EPSILON || Math.abs(_this.cameraRotation.z) > Base3D.DIRTY_EPSILON) {
            _quaternion.setFromEuler(_this.cameraRotation);
            _this.camera.quaternion.multiply(_quaternion);
        }
        focusViewport();

        if (_this.wobbleStrength > 0) {
            let t = Render.TIME;
            _wobble.x = Math.cos(_wobbleAngle + t * (.00075 * _this.wobbleSpeed)) * (_wobbleAngle + Math.sin(t * (.00095 * _this.wobbleSpeed)) * 200);
            _wobble.y = Math.sin(Math.asin(Math.cos(_wobbleAngle + t * (.00085 * _this.wobbleSpeed)))) * (Math.sin(_wobbleAngle + t * (.00075 * _this.wobbleSpeed)) * 150);
            _wobble.x *= Math.sin(_wobbleAngle + t * (.00075 * _this.wobbleSpeed)) * 2;
            _wobble.y *= Math.cos(_wobbleAngle + t * (.00065 * _this.wobbleSpeed)) * 1.75;
            _wobble.x *= Math.cos(_wobbleAngle + t * (.00075 * _this.wobbleSpeed)) * 1.1;
            _wobble.y *= Math.sin(_wobbleAngle + t * (.00025 * _this.wobbleSpeed)) * 1.15;
            _wobble.z = Math.sin(_wobbleAngle + _wobble.x * 0.0025) * (100 * _this.wobbleZ);
            _wobble.multiplyScalar(_this.wobbleStrength * 0.001 * _strength.v);
            _innerGroup.position.lerp(_wobble, 0.07);
            _this.flag('hasWobble', true);
        } else if ( _this.flag('hasWobble')) {
            _innerGroup.position.lerp(V3_ZERO, 0.07);
            if ( _innerGroup.position.length() < 0.001 ) {
                _innerGroup.position.set(0,0,0);
                _this.flag('hasWobble', false);
            }
        }
    }

    /**
     * Adjust camera position so the lookAt target appears at the desired focus
     * position within the viewport. 0,0 is the center, 1,1 is the top right,
     * -1, -1 is the bottom left.
     */
    function focusViewport() {
        let nextHasViewportFocusOffset = Math.abs(_this.viewportFocus.x) > 0.0001 || Math.abs(_this.viewportFocus.y) > 0.0001;
        if (nextHasViewportFocusOffset !== _hasViewportFocusOffset) {
            if (!nextHasViewportFocusOffset) _viewportFocusOffset.setScalar(0);
            _hasViewportFocusOffset = nextHasViewportFocusOffset;
        }
        if (!_hasViewportFocusOffset) return;
        let localCamera = _cacheObj;
        let camera = _this.camera;
        if (camera.matrixDirty) camera.updateMatrix();
        localCamera.matrixWorld = camera.matrix;
        localCamera.projectionMatrix = camera.projectionMatrix;
        _viewportFocusOffset.copy(_this.lookAt).project(localCamera);
        _viewportFocusOffset.x -= _this.viewportFocus.x;
        _viewportFocusOffset.y -= _this.viewportFocus.y;
        _viewportFocusOffset.unproject(localCamera);
        _viewportFocusOffset.sub(_this.lookAt);
        _this.camera.position.add(_viewportFocusOffset);
    }

    //*** Event handlers

    //*** Public methods
    /**
     * @name this.orbit
     * @memberof GazeCamera
     *
     * @function
     * @param time
     * @param ease
    */
    this.orbit = function(time = 1000, ease = 'easeInOutSine') {
        return tween(_strength, {v: 1}, time, ease);
    }

    /**
     * @name this.still
     * @memberof GazeCamera
     *
     * @function
     * @param time
     * @param ease
    */
    this.still = function(time = 300, ease = 'easeInOutSine') {
        return tween(_strength, {v: 0}, time, ease);
    }

    var _v1 = new Vector3();
    var _v2 = new Vector3();
    var _v3 = new Vector3();

    /**
     * Moves the camera immediately (without lerping), but without interrupting the
     * interactive gaze/wobble/rotation effects or their lerps.
     * Used by TweenUIL when tweening the camera position, because the animation
     * timeline incorporates its own easing.
     * @param vec
     */
    this.move = function(vec) {
        let moveDiff = _v1.subVectors(_move, _this.position);
        let positionDiff = _v2.subVectors(_move, _position);
        let cameraPosDiff = _v3.subVectors(_this.camera.position, _position);
        _this.position.set(vec.x, vec.y, vec.z, true);
        _move.copy(vec).add(moveDiff);
        _position.copy(_move).add(positionDiff);
        _this.camera.position.copy(_position).add(cameraPosDiff);
    };

    this.get('manualRender', () => _manualRender);
    this.set('manualRender', value => {
        value = !!value;
        if (value === _manualRender) return;
        _manualRender = value;
        if (_manualRender) {
            _this.stopRender(loop);
        } else {
            _this.startRender(loop);
        }
    });

    this.update = function() {
        if (!_manualRender && Hydra.LOCAL && !_this.flag('manualRenderWarned')) {
            console.warn('Set manualRender to true if using GazeCamera.update()');
            _this.flag('manualRenderWarned', true);
        }
        loop();
    };

    //*** Internal Class
    function Position() {
        Inherit(this, Component);
        var _x = 0;
        var _y = 0;
        var _z = 0;

        this.get('x', _ => _x);
        this.get('y', _ => _y);
        this.get('z', _ => _z);

        this.set('x', x => {
            _x = x;
        });

        this.set('y', y => {
            _y = y;
        });

        this.set('z', z => {
            _z = z;
            _move.z = _z;
            _this.camera.position.copy(_move);
            _position.copy(_move);
        });

    /**
     * @name this.set
     * @memberof GazeCamera
     *
     * @function
     * @param x
     * @param y
     * @param z
     * @param noCopy
    */
        this.set = function(x, y, z, noCopy) {
            _x = x;
            _y = y;
            _z = z;
            _move.z = z;
            if (!noCopy) _this.camera.position.copy(_move);
            _position.copy(_move);
        }

    /**
     * @name this.toArray
     * @memberof GazeCamera
     *
     * @function
    */
        this.toArray = function() {
            return [_x, _y, _z];
        }

    /**
     * @name this.fromArray
     * @memberof GazeCamera
     *
     * @function
     * @param array
    */
        this.fromArray = function(array) {
            _x = array[0];
            _y = array[1];
            _z = array[2];
            _move.set(_x, _y, _z);
            _this.camera.position.copy(_move);
            _position.copy(_move);
        }

    /**
     * @name this.copy
     * @memberof GazeCamera
     *
     * @function
     * @param vec
    */
        this.copy = function(vec) {
            _x = vec.x;
            _y = vec.y;
            _z = vec.z;
            _move.set(_x, _y, _z);
            _this.camera.position.copy(_move);
            _position.copy(_move);
        }
    }
});

/**
 * @name Base3D
 */

 class Base3D {
    constructor() {
        this.position = new Vector3D();
        this.rotation = new Euler();
        this.quaternion = new Quaternion();
        this.scale = new Vector3D(1, 1, 1);

        this._parent = null;

        this.up = new Vector3(0, 1, 0);
        this.isObject3D = true;
        this.children = [];
        this.childrenLength = 0;

        this.modelViewMatrix = new Matrix4();
        this.normalMatrix = new Matrix3();
        this.matrix = new Matrix4();
        this.matrixWorld = new Matrix4();

        this.matrixAutoUpdate = true;
        this.matrixWorldNeedsUpdate = false;
        this.matrixDirty = true;
        this.decomposeDirty = true;

        this.visible = true;
        this.hidden = false;

        this.castShadow = false;

        this.frustumCulled = true;
        this._renderOrder = 0;

        this.worldPos = new Vector3();
        this.worldQuat = new Quaternion();

        const _this = this;
        this.quaternion.onChange(_ => {
            _this.matrixDirty = true;
            _this.decomposeDirty = true;
            _this.onMatrixDirty && _this.onMatrixDirty();
            _this.rotation.setFromQuaternion(_this.quaternion, undefined, false);
        });

        this.rotation.onChange(_ => {
            _this.matrixDirty = true;
            _this.decomposeDirty = true;
            _this.onMatrixDirty && _this.onMatrixDirty();
            _this.quaternion.setFromEuler(_this.rotation, false);
        });

        this.scale.onChange(_ => {
            _this.matrixDirty = true;
            _this.decomposeDirty = true;
            _this.onMatrixDirty && _this.onMatrixDirty();
        });

        this.position.onChange(_ => {
            _this.matrixDirty = true;
            _this.decomposeDirty = true;
            _this.onMatrixDirty && _this.onMatrixDirty();
        });

        /**
         * @name position
         * @memberof Base3D
         *
         * @property
         */

        /**
         * @name rotation
         * @memberof Base3D
         *
         * @property
         */

        /**
         * @name quaternion
         * @memberof Base3D
         *
         * @property
         */

        /**
         * @name scale
         * @memberof Base3D
         *
         * @property
         */

        /**
         * @name matrix
         * @memberof Base3D
         *
         * @property
         */

        /**
         * @name matrixWorld
         * @memberof Base3D
         *
         * @property
         */

        /**
         * @name castShadow
         * @memberof Base3D
         *
         * @property
         */

        /**
         * @name visible
         * @memberof Base3D
         *
         * @property
         */

        /**
         * @name frustumCulled
         * @memberof Base3D
         *
         * @property
         */

        /**
         * @name renderOrder
         * @memberof Base3D
         *
         * @property
         */
    }

    get renderOrder() {
        return this._renderOrder;
    }

    /**
     * @name this.set renderOrder
     * @memberof Base3D
     *
     * @function
     * @param value
    */
    set renderOrder(value) {
        this._renderOrder = value;
        let p = this._parent;
    /**
     * @name this.while
     * @memberof Base3D
     *
     * @function
     * @param p
    */
        while (p) {
            if (p instanceof Scene) p.displayNeedsUpdate = true;
            p = p._parent;
        }

        for (let i = 0; i < this.children.length; i++) {
            this.children[i].renderOrder += value;
        }
    }

    /**
     * @name applyMatrix()
     * @memberof Base3D
     *
     * @function
     * @param {Matrix4} matrix
     */
    applyMatrix(matrix) {
        this.matrix.multiplyMatrices(matrix, this.matrix);
        this.matrix.decompose(this.position, this.quaternion, this.scale);
        return this;
    }

    /**
     * @name applyQuaternion()
     * @memberof Base3D
     *
     * @function
     * @param {Quaternion} q
     */
    applyQuaternion(q) {
        this.quaternion.premultiply(q);
        return this;
    }

    /**
     * @name setRotationFromAxisAngle()
     * @memberof Base3D
     *
     * @function
     * @param {Number} axis
     * @param {Number} angle
     */
    setRotationFromAxisAngle(axis, angle) {
        this.quaternion.setFromAxisAngle(axis, angle);
    }

    /**
     * @name setRotationFromMatrix()
     * @memberof Base3D
     *
     * @function
     * @param {Matrix4} matrix
     */
    setRotationFromMatrix(m) {
        this.quaternion.setFromRotationMatrix(m);
    }

    /**
     * @name setRotationFromQuaternion()
     * @memberof Base3D
     *
     * @function
     * @param {Quaternion} q
     */
    setRotationFromQuaternion(q) {
        this.quaternion.copy(q);
    }

    /**
     * @name localToWorld()
     * @memberof Base3D
     *
     * @function
     * @param {Vector3} v
     */
    localToWorld(v) {
        return v.applyMatrix4(this.matrixWorld);
    }

    /**
     * @name worldToLocal()
     * @memberof Base3D
     *
     * @function
     * @param {Vector3} v
     */
    worldToLocal(v) {
        let m1 = this.M1 || new Matrix4();
        this.M1 = m1;

        return v.applyMatrix4(m1.getInverse(this.matrixWorld));
    }

    /**
     * @name lookAt()
     * @memberof Base3D
     *
     * @function
     * @param {Vector3} v
     */
    lookAt(x, y, z) {
        let m1 = this.M1 || new Matrix4();
        this.M1 = m1;

        let v = this.V1 || new Vector3();
        this.V1 = v;

        if (x.isVector3) {
            v.copy(x);
        } else {
            v.set(x, y, z);
        }

        if (this.isCamera) {
            m1.lookAt(this.position, v, this.up);
        } else {
            m1.lookAt(v, this.position, this.up);
        }

        this.quaternion.setFromRotationMatrix(m1);
    }

    /**
     * @name add()
     * @memberof Base3D
     *
     * @function
     * @param {Base3D} object
     */
    add(object) {
        if (arguments.length > 1) {
            for (let i = 0; i < arguments.length; i++) this.add(arguments[i]);
            return this;
        }

        if (object === this) return this;

        if (object && object.isObject3D) {
            if (object._parent !== null) object._parent.remove(object);
            object._parent = this;
            this.children.push(object);
            this.childrenLength = this.children.length;
        } else {
            console.error(`Object is not instance of Object3D`, object);
        }

        if (this.isScene) this.displayNeedsUpdate = true;
        else {
            let p = this._parent;
    /**
     * @name this.while
     * @memberof Base3D
     *
     * @function
     * @param p
    */
            while (p) {
                if (p instanceof Scene) p.displayNeedsUpdate = true;
                p = p._parent;
            }
        }

        return this;
    }

    /**
     * @name attach()
     * @memberof Base3D
     *
     * @function
     * @param {Base3D} object
     */
     attach(object) {
        this.updateMatrixWorld(true);

        let m1 = this.M1 || new Matrix4();
        this.M1 = m1;

        const worldInverse = this.M1.getInverse(this.matrixWorld);

        if (object._parent !== null) {
            object._parent.updateMatrixWorld(true);
            worldInverse.multiply(object._parent.matrixWorld);
        }

        object.applyMatrix(worldInverse);
        this.add(object);
        object.updateMatrixWorld(true);
    }

    /**
     * @name remove()
     * @memberof Base3D
     *
     * @function
     * @param {Base3D} object
     */
    remove(object) {
        if (arguments.length > 1) {
            for (let i = 0; i < arguments.length; i++) this.remove(arguments[i]);
            return this;
        }

        if (this.isScene) this.displayNeedsUpdate = true;
        else {
            let p = this._parent;
            while (p) {
                if (p instanceof Scene) p.displayNeedsUpdate = true;
                p = p._parent;
            }
        }

        this.children.remove(object);
        this.childrenLength = this.children.length;
    }

    /**
     * @name getWorldPosition()
     * @memberof Base3D
     *
     * @function
     * @param {Vector3} target
     */
    getWorldPosition(target) {
        let v = this.V1 || new Vector3();
        this.V1 = v;

        if (!target) target = v;

        this.updateMatrixWorld();
        return target.setFromMatrixPosition(this.matrixWorld);
    }

    /**
     * @name getWorldScale()
     * @memberof Base3D
     *
     * @function
     * @param {Vector3} target
     */
    getWorldScale(target) {
        let v = this.V1S || new Vector3();
        this.V1S = v;

        let v2 = this.V12|| new Vector3();
        this.V2 = v2;

        let q = this.Q1 || new Quaternion();
        this.Q1 = q;

        if (!target) target = v2;

        this.updateMatrixWorld();
        this.matrixWorld.decompose(v, q, target);

        return target;
    }

    /**
     * @name getWorldQuaternion()
     * @memberof Base3D
     *
     * @function
     * @param {Quaternion} target
     */
    getWorldQuaternion(target) {
        let v = this.V1Q || new Vector3();
        this.V1Q = v;

        let q = this.Q1 || new Quaternion();
        this.Q1 = q;

        if (!target) target = q;

        this.updateMatrixWorld();
        this.matrixWorld.decompose(v, target, v);

        return target;
    }

    /**
     * @name this.traverse
     * @memberof Base3D
     *
     * @function
     * @param callback
    */
    traverse(callback) {
        callback(this);

        let children = this.children;
        for (let i = 0; i < children.length; i++) {
            children[i].traverse(callback);
        }
    }

    /**
     * @name updateMatrix()
     * @memberof Base3D
     */
    updateMatrix() {
        if (this.matrixAutoUpdate === false) return;
        this.matrix.compose(this.position, this.quaternion, this.scale);
        this.matrixWorldNeedsUpdate = true;
    }

    /**
     * @name updateMatrixWorld()
     * @memberof Base3D
     */
    updateMatrixWorld(force) {
        if (this.matrixAutoUpdate === false) return;

        if (!force && !this.determineVisible()) return;
        let dirty = this.determineDirty();

        if ((dirty || force) && this.matrixAutoUpdate === true) this.updateMatrix();
        if (this.matrixWorldNeedsUpdate === true || force === true) {
            if (this._parent === null || this.determineNoTransform()) {
                this.matrixWorld.copy(this.matrix);
            } else {
                this.matrixWorld.multiplyMatrices(this._parent.matrixWorld, this.matrix);
                if (RenderStats.active) RenderStats.update('updateMatrixWorld');
            }

            this.decomposeDirty = true;
            this.matrixWorldNeedsUpdate = false;
        }

        for (let i = this.childrenLength-1; i > -1; i--) this.children[i].updateMatrixWorld(force);
        this.matrixDirty = false;
    }

    /**
     * @name clone()
     * @memberof Base3D
     */
    clone(recursive) {
        new this.constructor().copy(this, recursive);
    }

    /**
     * @name this.copy
     * @memberof Base3D
     *
     * @function
     * @param source
     * @param recursive
    */
    copy(source, recursive) {
        this.name = source.name;

        this.up.copy(source.up);

        this.position.copy( source.position );
        this.quaternion.copy( source.quaternion );
        this.scale.copy( source.scale );

        this.matrix.copy( source.matrix );
        this.matrixWorld.copy( source.matrixWorld );

        this.matrixAutoUpdate = source.matrixAutoUpdate;
        this.matrixWorldNeedsUpdate = source.matrixWorldNeedsUpdate;

        this.visible = source.visible;

        this.castShadow = source.castShadow;
        this.receiveShadow = source.receiveShadow;

        this.frustumCulled = source.frustumCulled;
        this.renderOrder = source.renderOrder;

        if (recursive === true) {
            for (let i = 0; i < source.children.length; i++) {
                let child = source.children[i];
                this.add(child.clone());
            }
        }

        return this;
    }

    /**
     * @name this.render
     * @memberof Base3D
     *
     * @function
    */
    render() {

    }

    /**
     * @name this.determineVisible
     * @memberof Base3D
     *
     * @function
    */
    determineVisible() {
        if (!this.visible) {
            return false;
        }

        let p = this._parent;
        while (p) {
            if (!p.visible) {
                return false;
            }
            p = p._parent;
        }

        return true;
    }

    /**
     * @name this.determineDirty
     * @memberof Base3D
     *
     * @function
    */
    determineDirty() {
        let p = this._parent;
        while (p) {
            if (p.matrixDirty) {
                return true;
            }
            p = p._parent;
        }

        return this.matrixDirty;
    }

    /**
     * @name this.determineNoTransform
     * @memberof Base3D
     *
     * @function
     * @param distance
     */
    determineNoTransform() {
        if (!this._parent) return this.matrix.isIdentity();
        else return this._parent.determineNoTransform() && this.matrix.isIdentity();
    }

    /**
     * @name this.translateX
     * @memberof Base3D
     *
     * @function
     * @param distance
    */
    translateX(distance) {
        if (!this.xAxis) this.xAxis = new Vector3(1, 0, 0);
        this.translateOnAxis(this.xAxis, distance);
    }

    /**
     * @name this.translateY
     * @memberof Base3D
     *
     * @function
     * @param distance
    */
    translateY(distance) {
        if (!this.yAxis) this.yAxis = new Vector3(0, 1, 0);
        this.translateOnAxis(this.yAxis, distance);
    }

    /**
     * @name this.translateZ
     * @memberof Base3D
     *
     * @function
     * @param distance
    */
    translateZ(distance) {
        if (!this.zAxis) this.zAxis = new Vector3(0, 0, 1);
        this.translateOnAxis(this.zAxis, distance);
    }

    /**
     * @name this.translateOnAxis
     * @memberof Base3D
     *
     * @function
     * @param axis
     * @param distance
    */
    translateOnAxis(axis, distance) {
        let v = this.V1 || new Vector3();
        this.V1 = v;
        v.copy( axis ).applyQuaternion( this.quaternion );
        this.position.add( v.multiplyScalar( distance ) );
        return this;
    }

    /**
     * @name this.upload
     * @memberof Base3D
     *
     * @function
    */
    upload() {
        if (this.shader) {
            this.shader.upload(this, this.geometry);
            if (this.shader.shadow) this.shader.shadow.upload(this, this.geometry);
        }
        if (this.geometry) this.geometry.upload(this, this.shader);
    }

    /**
     * @name this.destroy
     * @memberof Base3D
     */
    destroy() {
        if (this.geometry && this.geometry.destroy) this.geometry.destroy(this);
        if (this.shader && this.shader.destroy) this.shader.destroy(this);
        if (this.hitDestroy) this.hitDestroy();
        if (this._gl && this._gl.ubo) this._gl.ubo.destroy();
        if (this._gl && this._gl.vao) this._gl.vao.destroy();
        if (this._gl) this._gl = null;
        if (this._parent) this._parent.remove(this);
        if (this.parent && this.parent.__destroyChild) this.parent.__destroyChild(this.__id);
    }
}

Base3D.DIRTY_EPSILON = 0.0001;
Class(function Renderer(_params = {}) {
    Inherit(this, Component);
    const _this = this;
    var _canvas, _gl, _width, _height, _anisotropy, _clearColor;
    var _projScreenMatrix, _vector3, _frustum, _ubo;

    var _dpr = 1;
    var _resolution = new Vector2();
    var _m0 = new Matrix4();
    var _m1 = new Matrix4();
    var _time = {value: 0};
    var _stencilActive = false;

    this.autoClear = true;
    this.shadows = Renderer.SHADOWS_MED;

    //*** Constructor
    (function () {
        Renderer.instance = _this;
        Renderer.CLEAR = [0, 0, 0, 1];

        initContext();
        setExtensions();
        initRenderers();
        initMath();
        initUBO();
        _this.startRender(loop);
    })();

    function initContext() {
        let contextAttributes = {
            antialias: _params.antialias !== undefined ? _params.antialias : false,
            powerPreference: _params.powerPreference,
            preserveDrawingBuffer: _params.preserveDrawingBuffer,
            xrCompatible: _params.xrCompatible,
            alpha: _params.alpha !== undefined ? _params.alpha : false,
            stencil: _params.stencil
        };

        _this.stencil = !!_params.stencil;

        _canvas = _params.canvas || document.createElement('canvas');

        if (!_params.gl) {
            if (!Device.graphics.webgl) {
                _gl = new NoGLPolyfill();
                _this.type = Renderer.WEBGL2;
            } else {
                ['webgl2', 'webgl', 'experimental-webgl'].forEach(name => {
                    if (_gl || (name == 'webgl2' && _params.forceWebGL1)) return;

                    _gl = _canvas.getContext(name, contextAttributes);

                    if (_gl && name == 'webgl2') _this.type = Renderer.WEBGL2;
                    else _this.type = Renderer.WEBGL1;
                });
            }
        } else {
            _gl = _params.gl;
            _this.type = Device.graphics.webgl.version.includes(['webgl 2', 'webgl2']) ? Renderer.WEBGL2 : Renderer.WEBGL1;
        }

        if (!_gl) throw 'Error! Could not create WebGL context';

        _this.domElement = _canvas;

        _canvas.style.background = 'black';

        Renderer.type = _this.type;
        Renderer.context = _this.context = _gl;
    }

    function setExtensions() {
        _this.extensions = {};
        if (_this.type != Renderer.WEBGL2) {
            _this.extensions.VAO = _gl.getExtension('OES_vertex_array_object');
            _this.extensions.instancedArrays = _gl.getExtension('ANGLE_instanced_arrays');
            _this.extensions.standardDerivatives = _gl.getExtension('OES_standard_derivatives');
            _this.extensions.elementIndexUint = _gl.getExtension('OES_element_index_uint');
            _this.extensions.depthTextures = _gl.getExtension('WEBGL_depth_texture');
            _this.extensions.drawBuffers = _gl.getExtension('WEBGL_draw_buffers');
            _this.extensions.halfFloat = _gl.getExtension('OES_texture_half_float');
            _this.extensions.float = _gl.getExtension('OES_texture_float');
            _this.extensions.colorBufferFloat = _gl.getExtension('WEBGL_color_buffer_float');
            _this.extensions.lod = _gl.getExtension('EXT_shader_texture_lod');
        } else {
            _this.extensions.colorBufferFloat = _gl.getExtension('EXT_color_buffer_float');
        }

        _this.extensions.filterFloat = _gl.getExtension('OES_texture_float_linear');
        _this.extensions.anisotropy = _gl.getExtension('EXT_texture_filter_anisotropic') || _gl.getExtension('WEBKIT_EXT_texture_filter_anisotropic');
        _this.extensions.astc = _gl.getExtension('WEBGL_compressed_texture_astc');
        _this.extensions.atc = _gl.getExtension('WEBGL_compressed_texture_atc');
        _this.extensions.etc = _gl.getExtension('WEBGL_compressed_texture_etc');
        _this.extensions.etc1 = _gl.getExtension('WEBGL_compressed_texture_etc1');
        _this.extensions.pvrtc = _gl.getExtension('WEBGL_compressed_texture_pvrtc') || _gl.getExtension('WEBKIT_WEBGL_compressed_texture_pvrtc');
        _this.extensions.s3tc = _gl.getExtension('WEBGL_compressed_texture_s3tc') || _gl.getExtension('WEBKIT_WEBGL_compressed_texture_s3tc');
        _this.extensions.bptc = _gl.getExtension('EXT_texture_compression_bptc');
        _this.extensions.s3tc_srgb = _gl.getExtension('WEBGL_compressed_texture_s3tc_srgb');

        Renderer.extensions = _this.extensions;
    }

    function initUBO() {
        if (_this.type == Renderer.WEBGL2) {
            _ubo = true;
        }

        Renderer.UBO = _ubo;
    }

    function initCameraUBO(camera) {
        camera._ubo = new UBO(0, _gl);
        camera._ubo.push({value: camera.projectionMatrix});
        camera._ubo.push({value: camera.matrixWorldInverse});
        camera._ubo.push({value: camera.worldPos});
        camera._ubo.push({value: camera.worldQuat});
        camera._ubo.push({value: _resolution});
        camera._ubo.push(_time);
        camera._ubo.push(Render.timeScaleUniform);
        camera._ubo.upload();
    }

    function initRenderers() {
        Geometry.renderer = new GeometryRendererWebGL(_gl);
        Texture.renderer = new TextureRendererWebGL(_gl);
        Shader.renderer = new ShaderRendererWebGL(_gl);
        RenderTarget.renderer = new FBORendererWebGL(_gl);
    }

    function initMath() {
        _projScreenMatrix = new Matrix4();
        _vector3 = new Vector3();
        _frustum = new Frustum();
    }

    function sortFrontToBack(array, sortOrder, camera) {
        for (let i = array.length-1; i > -1; i--) {
            let obj = array[i];
            if (!obj.__sortVec) obj.__sortVec = new Vector3();
            if (sortOrder == Scene.FRONT_TO_BACK_BOUNDING && obj.geometry && obj.geometry.boundingSphere) {
                obj.__sortVec.copy(obj.geometry.boundingSphere.center);
            } else {
                obj.__sortVec.setFromMatrixPosition(camera.modelViewMatrix);
            }
        }

        array.sort((a, b) => {
            return b.__sortVec.z - a.__sortVec.z;
        });
    }

    function sortOpaque(array, sortOrder, camera) {
        for (let i = array.length-1; i > -1; i--) {
            let obj = array[i];
            if (!obj.shader._gl) obj.shader.upload();
        }
        if (sortOrder == Scene.FRONT_TO_BACK) {
            sortFrontToBack(array, sortOrder, camera);
        } else {
            array.sort((a, b) => {
                if (a.renderOrder !== b.renderOrder) return a.renderOrder - b.renderOrder;
                let aid = a.shader._gl._id;
                let bid = b.shader._gl._id;
                if (aid !== bid) return aid - bid;
                return a.id - b.id;
            });
        }
    }

    function sortTransparent(array, sortOrder, camera) {
        RenderStats.update('SortTransparent', array.length);

        if (sortOrder == Scene.FRONT_TO_BACK || sortOrder == Scene.FRONT_TO_BACK_BOUNDING) {
            sortFrontToBack(array, sortOrder, camera);
        } else {
            array.sort((a, b) => {
                if (a.renderOrder !== b.renderOrder) return a.renderOrder - b.renderOrder;
                if (a.worldPos.z !== b.worldPos.z) return a.worldPos.z - b.worldPos.z;
                return a.id - b.id;
            });
        }
    }

    function projectObject(object, camera, scene) {
        if (object.doNotProject) return;
        let isVisible = false;
        if (object.shader !== undefined) {
            let visible = object.determineVisible() && object.shader.visible && !object.shader.neverRender && !object.hidden;
            if (visible) {
                object.modelViewMatrix.multiplyMatrices(camera.matrixWorldInverse, object.matrixWorld);
                object.normalMatrix.getNormalMatrix(object.modelViewMatrix);
            }
            isVisible = visible;

            if (scene.displayNeedsUpdate || (object.shader.transparent && !scene.disableAutoSort && visible)) object.getWorldPosition(object.worldPos);
            if (scene.displayNeedsUpdate) scene.toRender[object.shader.transparent ? 1 : 0].push(object);
        } else {
            isVisible = object.visible && !object.hidden;
        }

        if (isVisible || scene.displayNeedsUpdate) {
            for (let i = object.childrenLength - 1; i > -1; i--) {
                projectObject(object.children[i], camera, scene);
            }
        }
    }

    function attachSceneUniforms(object, scene, camera) {
        Shader.renderer.appendUniform(object.shader, 'normalMatrix', object.normalMatrix);
        Shader.renderer.appendUniform(object.shader, 'modelMatrix', object.matrixWorld);
        Shader.renderer.appendUniform(object.shader, 'modelViewMatrix', object.modelViewMatrix);

        if (!_ubo) {
            Shader.renderer.appendUniform(object.shader, 'projectionMatrix', camera.projectionMatrix);
            Shader.renderer.appendUniform(object.shader, 'viewMatrix', camera.matrixWorldInverse);
            Shader.renderer.appendUniform(object.shader, 'cameraPosition', camera.worldPos);
            Shader.renderer.appendUniform(object.shader, 'cameraQuaternion', camera.worldQuat);
            Shader.renderer.appendUniform(object.shader, 'resolution', _resolution);
            Shader.renderer.appendUniform(object.shader, 'time', _time.value);
            Shader.renderer.appendUniform(object.shader, 'timeScale', Render.timeScaleUniform.value);
        } else {
            camera._ubo.bind(object.shader._gl.program, 'global');
        }

        if (_this.shadows && object.shader.receiveShadow && !_this.overridePreventShadows) {
            let lights = Lighting.getShadowLights();
            if (!object._gl) object._gl = {};
            if (!object._gl.shadowData) object._gl.shadowData = {combined: new Float32Array(lights.length * 16)};

            for (let i = 0; i < lights.length; i++) {
                let light = lights[i];
                _m1.multiplyMatrices(light.shadow.camera.matrixWorldInverse, object.matrixWorld);
                _m0.multiplyMatrices(light.shadow.camera.projectionMatrix, _m1);
                _m0.toArray(object._gl.shadowData.combined, i * 16);
            }

            if (scene._shadowData && scene._shadowData.count) {
                object.shader.uniforms.shadowMap.value = scene._shadowData[_this.overridePreventShadows ? 'emptyMaps' : 'maps'];
                Shader.renderer.appendUniform(object.shader, 'shadowMatrix', object._gl.shadowData.combined, 'matrix');
                Shader.renderer.appendUniform(object.shader, 'shadowLightPos', scene._shadowData.pos, 'vec3');
                Shader.renderer.appendUniform(object.shader, 'shadowSize', scene._shadowData.size, 'float');
            }
        }
    }

    function attachShadowUniforms(object, scene, light) {
        if (!light._mvm) light._mvm = new Matrix4();
        if (!light._nm) light._nm = new Matrix3();
        light._mvm.multiplyMatrices(light.shadow.camera.matrixWorldInverse, object.matrixWorld);
        light._nm.getNormalMatrix(object.modelViewMatrix);

        Shader.renderer.appendUniform(object.shader.shadow, 'normalMatrix', light._nm);
        Shader.renderer.appendUniform(object.shader.shadow, 'modelMatrix', object.matrixWorld);
        Shader.renderer.appendUniform(object.shader.shadow, 'modelViewMatrix', light._mvm);

        if (!_ubo) {
            Shader.renderer.appendUniform(object.shader.shadow, 'projectionMatrix', light.shadow.camera.projectionMatrix);
            Shader.renderer.appendUniform(object.shader.shadow, 'viewMatrix', light.shadow.camera.matrixWorldInverse);
        } else {
            light.shadow.camera._ubo.bind(object.shader._gl.program, 'global');
        }
    }

    function loop(t, dt) {
        _time.value += dt * 0.001;
    }

    function render(scene, camera, rt) {
        if (rt && !!rt.width) {
            _resolution.set(rt.width, rt.height);

            if(rt.multisample) {
                RenderTarget.renderer.bind(rt._rtMultisample);
            } else {
                RenderTarget.renderer.bind(rt);
            }

        } else {
            if (!Renderer.overrideViewport) {
                _gl.viewport(0, 0, _width * _dpr, _height * _dpr);
                _resolution.set(_canvas.width, _canvas.height);
            }
            if (_this.autoClear) {
                _gl.clearColor(Renderer.CLEAR[0], Renderer.CLEAR[1], Renderer.CLEAR[2], Renderer.CLEAR[3]);
                _gl.clear(_gl.COLOR_BUFFER_BIT | _gl.DEPTH_BUFFER_BIT);
            }
        }

        if (!camera.parent) camera.updateMatrixWorld();
        camera.getWorldPosition(camera.worldPos);
        camera.getWorldQuaternion(camera.worldQuat);
        _frustum.setFromCamera(camera);

        if (_ubo) {
            if (!camera._ubo) initCameraUBO(camera);
            else camera._ubo.update();
        }

        for (let l = 0; l < 2; l++) {
            let len = scene.toRender[l].length;
            for (let i = 0; i < len; i++) {
                let object = scene.toRender[l][i];
                object.onBeforeRender && object.onBeforeRender();
                object._drawing = false;

                if (!object.determineVisible() || !object.shader.visible || object.shader.neverRender || object.neverRender) continue;

                if (object.frustumCulled === false || _frustum.intersectsObject(object) === true) {
                    object._drawing = true;
                    if (object.shader.nullRender) continue;

                    let doubleSideTransparency = object.shader.side === Shader.DOUBLE_SIDE_TRANSPARENCY;

                    if (doubleSideTransparency) {
                        object.shader.side = Shader.BACK_SIDE;
                    }

                    object.shader.draw(object, object.geometry);
                    attachSceneUniforms(object, scene, camera);
                    object.geometry.draw(object, object.shader);

                    if (doubleSideTransparency) {
                        object.shader.side = Shader.FRONT_SIDE;

                        object.shader.draw(object, object.geometry);
                        attachSceneUniforms(object, scene, camera);
                        object.geometry.draw(object, object.shader);

                        object.shader.side = Shader.DOUBLE_SIDE_TRANSPARENCY;
                    }
                }
            }
        }

        if (rt && !!rt.width) {

            if(rt.texture.generateMipmaps) {
                _gl.bindTexture(_gl.TEXTURE_2D, rt.texture._gl);
                _gl.generateMipmap(_gl.TEXTURE_2D);
                _gl.bindTexture(_gl.TEXTURE_2D, null);
            }

            if(rt.multisample) {

                _this.blit(rt._rtMultisample, rt);
                RenderTarget.renderer.unbind(rt._rtMultisample);

            } else {

                RenderTarget.renderer.unbind(rt);

            }
        }
    }

    function renderShadows(scene, camera) {
        let render = (light, lightIndex) => {
            RenderTarget.renderer.bind(light.shadow.rt);

            RenderStats.update('ShadowLights');

            light.shadow.camera.updateMatrixWorld();
            camera.getWorldPosition(camera.worldPos);
            _frustum.setFromCamera(camera);

            if (_ubo) {
                if (!light.shadow.camera._ubo) initCameraUBO(light.shadow.camera);
                else light.shadow.camera._ubo.update();
            }

            for (let l = 0; l < 2; l++) {
                for (let i = 0; i < scene.toRender[l].length; i++) {
                    let object = scene.toRender[l][i];
                    if (object.onBeforeRenderShadow && object.onBeforeRenderShadow(light, lightIndex)) continue;

                    if (object.castShadow !== true || !object.determineVisible() || !object.shader.visible || object.shader.neverRender) continue;

                    if (object.frustumCulled === false || _frustum.intersectsObject(object) === true) {
                        if (!object.shader.shadow) Lighting.initShadowShader(object);
                        object.shader.shadow.draw(object, object.geometry);
                        attachShadowUniforms(object, scene, light);
                        object.geometry.draw(object, object.shader.shadow);
                        if (_ubo) light.shadow.camera._ubo.unbind();
                        RenderStats.update('ShadowMesh');
                    }
                }
            }

            RenderTarget.renderer.unbind(light.shadow.rt);
        };

        let lights = Lighting.getShadowLights();
        if (!scene._shadowData) scene._shadowData = {maps: [], emptyMaps: [], size: new Float32Array(lights.length), pos: new Float32Array(lights.length * 3), count: lights.length};
        if (scene._shadowData.count != lights.length) {
            scene._shadowData.size = new Float32Array(lights.length);
            scene._shadowData.pos = new Float32Array(lights.length * 3);
            scene._shadowData.count = lights.length;
        }
        for (let i = 0; i < lights.length; i++) {
            let light = lights[i];
            light.prepareRender();
            scene._shadowData.maps[i] = light.shadow.rt.depth;
            scene._shadowData.emptyMaps[i] = Utils3D.getEmptyTexture();
            scene._shadowData.size[i] = light.shadow.size;
            light.position.toArray(scene._shadowData.pos, i * 3);
        }

        for (let i = 0; i < lights.length; i++) {
            let light = lights[i];
            if (!light.shadow.frozen && light.determineVisible()) render(light, i);
        }
    }

    //*** Event handlers

    //*** Public methods

    this.render = function(scene, camera, rt, forceToScreen) {
        if (scene.displayNeedsUpdate) {
            scene.toRender[0].length = 0;
            scene.toRender[1].length = 0;
        }

        if (_this.modifyCameraBeforeRender) {
            if (!camera.renderCamera) camera.renderCamera = camera.clone();
            camera.renderCamera.copy(camera);
            camera = camera.renderCamera;
            _this.modifyCameraBeforeRender(camera);
        }

        scene.updateMatrixWorld();

        projectObject(scene, camera, scene);

        if (scene.displayNeedsUpdate || scene.opaqueSortOrder == Scene.FRONT_TO_BACK) sortOpaque(scene.toRender[0], scene.opaqueSortOrder, camera);
        if (scene.displayNeedsUpdate || (scene.toRender[1].length && !scene.disableAutoSort)) sortTransparent(scene.toRender[1], scene.transparentSortOrder, camera);

        if (_this.shadows && !_this.overridePreventShadows && !_this.pauseShadowRendering && scene.hasShadowLight) {
            renderShadows(scene, camera);
        }

        if ((!rt || rt.vrRT) && _this.vrRenderingPath && !forceToScreen) _this.vrRenderingPath(scene, camera, _projScreenMatrix, _frustum, attachSceneUniforms, rt);
        else if (!rt && _this.arRenderingPath && !forceToScreen) _this.arRenderingPath(render, scene, camera);
        else render(scene, camera, rt);

        scene.displayNeedsUpdate = false;
        Shader.renderer.resetState();
    }

    this.renderSingle = function(object, camera, rt) {
        if (rt) {
            _resolution.set(rt.width, rt.height);

            if(rt.multisample) {
                RenderTarget.renderer.bind(rt._rtMultisample);
            } else {
                RenderTarget.renderer.bind(rt);
            }

        } else {
            if (!Renderer.overrideViewport) {
                _gl.viewport(0, 0, _width * _dpr, _height * _dpr);
                _resolution.set(_canvas.width, _canvas.height);
            }
            if (_this.autoClear) {
                _gl.clearColor(Renderer.CLEAR[0], Renderer.CLEAR[1], Renderer.CLEAR[2], Renderer.CLEAR[3]);
                _gl.clear(_gl.COLOR_BUFFER_BIT | _gl.DEPTH_BUFFER_BIT);
            }
        }

        camera.getWorldPosition(camera.worldPos);
        object.modelViewMatrix.multiplyMatrices(camera.matrixWorldInverse, object.matrixWorld);
        object.normalMatrix.getNormalMatrix(object.modelViewMatrix);
        object.getWorldPosition(object.worldPos);

        if (_ubo) {
            if (!camera._ubo) initCameraUBO(camera);
            else if (!camera.pauseUBO) camera._ubo.update();
        }

        let doubleSideTransparency = object.shader.side === Shader.DOUBLE_SIDE_TRANSPARENCY;

        if (doubleSideTransparency) {
            object.shader.side = Shader.BACK_SIDE;

            if (object.shader._renderFrontFirst) {
                object.shader.side = Shader.FRONT_SIDE;
            }
        }

        object.shader.draw(object, object.geometry);

        if (!object.noMatrices) {
            Shader.renderer.appendUniform(object.shader, 'normalMatrix', object.normalMatrix);
            Shader.renderer.appendUniform(object.shader, 'modelMatrix', object.matrixWorld);
            Shader.renderer.appendUniform(object.shader, 'modelViewMatrix', object.modelViewMatrix);
        }

        if (!_ubo) {
            Shader.renderer.appendUniform(object.shader, 'projectionMatrix', camera.projectionMatrix);
            Shader.renderer.appendUniform(object.shader, 'viewMatrix', camera.matrixWorldInverse);
            Shader.renderer.appendUniform(object.shader, 'cameraPosition', camera.worldPos);
            Shader.renderer.appendUniform(object.shader, 'cameraQuaternion', camera.worldQuat);
            Shader.renderer.appendUniform(object.shader, 'resolution', _resolution);
            Shader.renderer.appendUniform(object.shader, 'time', _time.value);
            Shader.renderer.appendUniform(object.shader, 'timeScale', Render.timeScaleUniform.value);
        } else {
            camera._ubo.bind(object.shader._gl.program, 'global');
        }

        object.geometry.draw(object, object.shader);

        if (doubleSideTransparency) {
            object.shader.side = Shader.FRONT_SIDE;

            if (object.shader._renderFrontFirst) {
                object.shader.side = Shader.BACK_SIDE;
            }

            object.shader.draw(object, object.geometry);
            object.geometry.draw(object, object.shader);

            object.shader.side = Shader.DOUBLE_SIDE_TRANSPARENCY;
        }

        if (_ubo) camera._ubo.unbind();

        if (rt) {

            if(rt.texture.generateMipmaps) {
                _gl.bindTexture(_gl.TEXTURE_2D, rt.texture._gl);
                _gl.generateMipmap(_gl.TEXTURE_2D);
                _gl.bindTexture(_gl.TEXTURE_2D, null);
            }

            if(rt.multisample) {

                _this.blit(rt._rtMultisample, rt);
                RenderTarget.renderer.unbind(rt._rtMultisample);

            } else {

                RenderTarget.renderer.unbind(rt);

            }
        }

        Shader.renderer.resetState();
    }

    this.setClearColor = function(color, alpha = 1) {
        _clearColor = new Color(color);
        Renderer.CLEAR = [_clearColor.r, _clearColor.g, _clearColor.b, alpha];
    }

    this.setClearAlpha = function(alpha) {
        Renderer.CLEAR[3] = alpha;
    }

    this.getClearColor = function() {
        if (!_clearColor) _clearColor = new Color(0, 0, 0);
        return _clearColor;
    }

    this.getClearAlpha = function() {
        return Renderer.CLEAR[3];
    }

    this.setPixelRatio = function(dpr) {
        _dpr = dpr;
        this.setSize(_width, _height);
    }

    this.setSize = function(width, height) {
        _width = width;
        _height = height;
        _canvas.width = width * _dpr;
        _canvas.height = height * _dpr;
        _canvas.style.width = `${width}px`;
        _canvas.style.height = `${height}px`;
        _resolution.set(_canvas.width, _canvas.height);
    }

    this.getMaxAnisotropy = function() {
        if (!Device.graphics.webgl || !_this.extensions.anisotropy) return 0;
        if (!_anisotropy) _anisotropy = _gl.getParameter(_this.extensions.anisotropy.MAX_TEXTURE_MAX_ANISOTROPY_EXT);
        return _anisotropy;
    }

    this.readPixels = function(rt, x = 0, y = 0, width, height, array, type) {
        if (!width) width = rt ? rt.width : 1;
        if (!height) height = rt ? rt.height : 1;
        width = Math.round(width);
        height = Math.round(height);
        type = type || _gl.UNSIGNED_BYTE;

        let w = Math.round(width - x);
        let h = Math.round(height - y);
        if (!array) array = new Uint8Array(w * h * 4);
        _gl.bindFramebuffer(_gl.FRAMEBUFFER, rt ? rt._gl : null);
        _gl.readPixels(x, y, width, height, _gl.RGBA, type, array);
        _gl.bindFramebuffer(_gl.FRAMEBUFFER, null);

        return array;
    }

    this.blit = function(input, output, mask = _gl.COLOR_BUFFER_BIT) {
        if (_this.type != Renderer.WEBGL2) return false;
        if (!input._gl) input.upload();
        if (!output._gl) output.upload();
        _gl.bindFramebuffer(_gl.READ_FRAMEBUFFER, input._gl);
        _gl.bindFramebuffer(_gl.DRAW_FRAMEBUFFER, output._gl);
        if (input === output._rtMultisample) {
            if (output.depth) {
                mask = mask | _gl.DEPTH_BUFFER_BIT;
            }
            if (output.stencil) {
                mask = mask | _gl.STENCIL_BUFFER_BIT;
            }
        }
        _gl.blitFramebuffer(0, 0, input.width, input.height, 0, 0, output.width, output.height, mask, _gl.NEAREST);
        if (input === output._rtMultisample && output.multi) {
            let attachments = output.attachments;
            for (let i = 1; i < attachments.length; i++) {
                let texture = attachments[i];
                _gl.readBuffer(_gl[`COLOR_ATTACHMENT${i}`]);
                _gl.bindFramebuffer(_gl.DRAW_FRAMEBUFFER, texture._blitFramebuffer);
                _gl.blitFramebuffer(0, 0, input.width, input.height, 0, 0, output.width, output.height, _gl.COLOR_BUFFER_BIT, _gl.NEAREST);
            }
            _gl.readBuffer(_gl.COLOR_ATTACHMENT0);
        }
        _gl.bindFramebuffer(_gl.READ_FRAMEBUFFER, null);
        _gl.bindFramebuffer(_gl.DRAW_FRAMEBUFFER, null);
        return true;
    }

    this.setupStencilMask = function(ref = 1) {
        if (!_stencilActive) {
            _gl.enable(_gl.STENCIL_TEST);
            _gl.clear(_gl.STENCIL_BUFFER_BIT | _gl.DEPTH_BUFFER_BIT);
        }
        _stencilActive = true;
        _gl.stencilFunc(_gl.ALWAYS, ref, 0xff);
        _gl.stencilOp(_gl.KEEP, _gl.KEEP, _gl.REPLACE);
        _gl.stencilMask(0xff);
        _gl.colorMask(false, false, false, false);
        _gl.disable(_gl.DEPTH_TEST);
    }

    this.setupStencilDraw = function(mode, ref = 1) {
        _gl.colorMask(true, true, true, true);
        _gl.enable(_gl.DEPTH_TEST);
        _gl.stencilFunc(mode == 'inside' ? _gl.EQUAL : _gl.NOTEQUAL, ref, 0xff);
        _gl.stencilOp(_gl.KEEP, _gl.KEEP, _gl.KEEP);
    }

    this.clearStencil = function() {
        _gl.disable(_gl.STENCIL_TEST);
        _stencilActive = false;
    }

    this.clearDepth = function(rt) {
        if (rt && !rt._gl) rt.upload();
        if (rt) _gl.bindFramebuffer(_gl.FRAMEBUFFER, rt._gl);
        _gl.clear(_gl.DEPTH_BUFFER_BIT);
        if (rt) _gl.bindFramebuffer(_gl.FRAMEBUFFER, null);
    }

    this.clearColor = function(rt) {
        if (rt && !rt._gl) rt.upload();
        if (rt) _gl.bindFramebuffer(_gl.FRAMEBUFFER, rt._gl);
        _gl.clearColor(Renderer.CLEAR[0], Renderer.CLEAR[1], Renderer.CLEAR[2], Renderer.CLEAR[3]);
        _gl.clear(_gl.COLOR_BUFFER_BIT);
        if (rt) _gl.bindFramebuffer(_gl.FRAMEBUFFER, null);
    }

    this.get('resolution', _ => {
        return _resolution;
    });

    this.get('time', _ => {
        return _time;
    });

    this.get('canvas', _ =>{
        return _canvas;
    });

}, _ => {
    Renderer.WEBGL1 = 'webgl1';
    Renderer.WEBGL2 = 'webgl2';
    Renderer.STATIC_SHADOWS = 'static_shadows';
    Renderer.SHADOWS_LOW = 'shadows_low';
    Renderer.SHADOWS_MED = 'shadows_med';
    Renderer.SHADOWS_HIGH = 'shadows_high';
    Renderer.ID = 0;
});

/**
 * @name CameraBase3D
 * @extends Base3D
 */
class CameraBase3D extends Base3D {
    constructor() {
        super();

        this.matrixWorldInverse = new Matrix4();
        this.projectionMatrix = new Matrix4();
        this.isCamera = true;
    }

    /**
     * @name this.copy
     * @memberof CameraBase3D
     *
     * @function
     * @param source
     * @param recursive
    */
    copy(source, recursive) {
        Base3D.prototype.copy.call(this, source, recursive);
        this.matrixWorldInverse.copy( source.matrixWorldInverse );
        this.projectionMatrix.copy( source.projectionMatrix );

        return this;
    }

    updateMatrixWorld(force) {
        Base3D.prototype.updateMatrixWorld.call( this, force );
        if (this.offsetMatrixWorld) this.matrixWorld.multiply(this.offsetMatrixWorld);
        this.matrixWorldInverse.getInverse(this.matrixWorld);
    }

    /**
     * @name this.clone
     * @memberof CameraBase3D
     *
     * @function
    */
    clone() {
        return new this.constructor().copy(this);
    }
}
/**
 * @name CubeCamera
 * @extends Base3D
 * @param near
 * @param far
 * @param cubeResolution
 */
class CubeCamera extends Base3D {
    constructor(near = 0.1, far = 1000, cubeResolution = 512) {
        super();
        const fov = 90;
        const aspect = 1;

        this.px = new PerspectiveCamera(fov, aspect, near, far);
        this.px.up.set(0, -1, 0);
        this.px.lookAt(new Vector3(1, 0, 0));
        this.add(this.px);

        this.nx = new PerspectiveCamera(fov, aspect, near, far);
        this.nx.up.set(0, -1, 0);
        this.nx.lookAt(new Vector3(-1, 0, 0));
        this.add(this.nx);

        this.py = new PerspectiveCamera(fov, aspect, near, far);
        this.py.up.set(0, 0, 1);
        this.py.lookAt(new Vector3(0, 1, 0));
        this.add(this.py);

        this.ny = new PerspectiveCamera(fov, aspect, near, far);
        this.ny.up.set(0, 0, -1);
        this.ny.lookAt(new Vector3(0, -1, 0));
        this.add(this.ny);

        this.pz = new PerspectiveCamera(fov, aspect, near, far);
        this.pz.up.set(0, -1, 0);
        this.pz.lookAt(new Vector3(0, 0, 1));
        this.add(this.pz);

        this.nz = new PerspectiveCamera(fov, aspect, near, far);
        this.nz.up.set(0, -1, 0);
        this.nz.lookAt(new Vector3(0, 0, -1));
        this.add(this.nz);

        this.rt = new CubeRenderTarget(cubeResolution, cubeResolution);
    }

    /**
     * @name this.render
     * @memberof CubeCamera
     *
     * @function
     * @param scene
     * @param renderer
    */
    render(scene = World.SCENE, renderer = World.RENDERER) {
        let rt = this.rt;

        this.updateMatrixWorld(true);

        this.beforeRender && this.beforeRender(this.px);
        rt.activeFace = 0;
        renderer.render(scene, this.px, rt);
        this.afterRender && this.afterRender(rt);

        this.beforeRender && this.beforeRender(this.nx);
        rt.activeFace = 1;
        renderer.render(scene, this.nx, rt);
        this.afterRender && this.afterRender(rt);

        this.beforeRender && this.beforeRender(this.py);
        rt.activeFace = 2;
        renderer.render(scene, this.py, rt);
        this.afterRender && this.afterRender(rt);

        this.beforeRender && this.beforeRender(this.ny);
        rt.activeFace = 3;
        renderer.render(scene, this.ny, rt);
        this.afterRender && this.afterRender(rt);

        this.beforeRender && this.beforeRender(this.pz);
        rt.activeFace = 4;
        renderer.render(scene, this.pz, rt);
        this.afterRender && this.afterRender(rt);

        this.beforeRender && this.beforeRender(this.nz);
        rt.activeFace = 5;
        renderer.render(scene, this.nz, rt);
        this.afterRender && this.afterRender(rt);
    }
}

/**
 * @name OrthographicCamera
 * @extends CameraBase3D
 * @param left
 * @param right
 * @param top
 * @param bottom
 * @param near
 * @param far
 */

class OrthographicCamera extends CameraBase3D {
    constructor(left, right, top, bottom, near, far) {
        super();

        this.isOrthographicCamera = true;

        this.zoom = 1;

        this.left = left;
        this.right = right;
        this.top = top;
        this.bottom = bottom;

        this.near = ( near !== undefined ) ? near : 0.1;
        this.far = ( far !== undefined ) ? far : 2000;

        this.position.z = 1;

        this.updateProjectionMatrix();
    }

    clone() {
        return new OrthographicCamera().copy(this);
    }

    copy(source, recursive) {
        CameraBase3D.prototype.copy.call( this, source, recursive );

        this.left = source.left;
        this.right = source.right;
        this.top = source.top;
        this.bottom = source.bottom;
        this.near = source.near;
        this.far = source.far;

        this.zoom = source.zoom;
        this.view = source.view === null ? null : Object.assign( {}, source.view );

        return this;
    }

    /**
     * @name updateProjectionMatrix()
     * @memberof OrthographicCamera
     *
     * @function
     */
    updateProjectionMatrix() {
        let dx = ( this.right - this.left ) / ( 2 * this.zoom );
        let dy = ( this.top - this.bottom ) / ( 2 * this.zoom );
        let cx = ( this.right + this.left ) / 2;
        let cy = ( this.top + this.bottom ) / 2;

        let left = cx - dx;
        let right = cx + dx;
        let top = cy + dy;
        let bottom = cy - dy;

        this.projectionMatrix.makeOrthographic( left, right, top, bottom, this.near, this.far );
    }

    /**
     * Automatically sets the frustum to the correct width and height
     * @name setViewport()
     * @memberof OrthographicCamera
     *
     * @function
     * @param {Number} width
     * @param {Number} height
     */
    setViewport(width, height) {
        this.left = width/-2;
        this.right = width/2;
        this.top = height/2;
        this.bottom = height/-2;
        this.updateProjectionMatrix();
    }
}
/**
 * @name PerspectiveCamera
 * @extends CameraBase3D
 * @param fov
 * @param aspect
 * @param near
 * @param far
 * @example
 * new PerspectiveCamera(40, Stage.width / Stage.height, 0.1, 200);
 */

class PerspectiveCamera extends CameraBase3D {
    constructor(fov, aspect, near, far) {
        super();
        this.type = 'PerspectiveCamera';

        this.fov = fov || 50;
        this.zoom = 1;

        this.near = near || 0.1;
        this.far = far || 2000;
        this.focus = 10;

        this.aspect = aspect || 1;
        this.filmGauge = 35;
        this.filmOffset = 0;

        this.updateProjectionMatrix();
    }

    /**
     * @name this.clone
     * @memberof PerspectiveCamera
     *
     * @function
    */
    clone() {
        return new PerspectiveCamera().copy(this);
    }

    /**
     * @name this.copy
     * @memberof PerspectiveCamera
     *
     * @function
     * @param source
     * @param recursive
    */
    copy(source, recursive) {
        CameraBase3D.prototype.copy.call( this, source, recursive );

        this.fov = source.fov;
        this.zoom = source.zoom;

        this.near = source.near;
        this.far = source.far;
        this.focus = source.focus;

        this.aspect = source.aspect;

        this.filmGauge = source.filmGauge;
        this.filmOffset = source.filmOffset;

        return this;
    }

    /**
     * @name setFocalLength
     * @memberof PerspectiveCamera
     *
     * @function
     * @param {Number} focalLength
     */
    setFocalLength(focalLength) {
        let vExtentSlope = 0.5 * this.getFilmHeight() / focalLength;

        this.fov = Math.degrees(2 * Math.atan( vExtentSlope ));
        this.updateProjectionMatrix();
    }

    /**
     * @name getFocalLength
     * @memberof PerspectiveCamera
     *
     * @function
     * @returns {Number}
     */
    getFocalLength() {
        let vExtentSlope = Math.tan( Math.radians(0.5 * this.fov) );
        return 0.5 * this.getFilmHeight() / vExtentSlope;
    }

    /**
     * @name getEffectiveFOV
     * @memberof PerspectiveCamera
     *
     * @function
     * @returns {Number}
     */
    getEffectiveFOV() {
        return Math.degrees(2 * Math.atan( Math.tan( Math.radians(0.5 * this.fov) ) / this.zoom ));
    }

    /**
     * @name getFilmWidth
     * @memberof PerspectiveCamera
     *
     * @function
     * @returns {Number}
     */
    getFilmWidth() {
        return this.filmGauge * Math.min( this.aspect, 1 );
    }

    /**
     * @name getFilmHeight
     * @memberof PerspectiveCamera
     *
     * @function
     * @returns {Number}
     */
    getFilmHeight() {
        return this.filmGauge / Math.max( this.aspect, 1 );
    }

    /**
     * @name updateProjectionMatrix()
     * @memberof PerspectiveCamera
     *
     * @function
     */
    updateProjectionMatrix() {
        let near = this.near,
            top = near * Math.tan(Math.radians(0.5 * this.fov) ) / this.zoom,
            height = 2 * top,
            width = this.aspect * height,
            left = - 0.5 * width,
            view = this.view;

        let skew = this.filmOffset;
        if ( skew !== 0 ) left += near * skew / this.getFilmWidth();

        this.projectionMatrix.makePerspective( left, left + width, top, top - height, near, this.far );
    }
}
/**
 * @name Geometry
 */
class Geometry {
    constructor() {
        this.attributes = Geometry.createAttributes(this);
        this.drawRange = {start: 0, end: 0};
        this.boundingBox = null;
        this.boundingSphere = null;
        this.index = null;
        this.maxInstancedCount = undefined;
        this.keepAlive = false;
        this.id = Utils.timestamp();
    }

    /**
     * @name this.draw
     * @memberof Geometry
     *
     * @function
     * @param mesh
     * @param shader
    */
    draw(mesh, shader) {
        Geometry.renderer.draw(this, mesh, shader);
    }

    /**
     * @name this.upload
     * @memberof Geometry
     *
     * @function
     * @param mesh
     * @param shader
    */
    upload(mesh, shader) {
        Geometry.renderer.upload(this, mesh, shader);
    }

    /**
     * @name this.destroy
     * @memberof Geometry
     *
     * @function
     * @param mesh
    */
    destroy(mesh) {
    	if (!this.keepAlive) Geometry.renderer.destroy(this, mesh);
    }

    /**
     * @name addAttribute()
     * @memberof Geometry
     *
     * @function
     * @param {String} name
     * @param {GeometryAttribute} attribute
     */
    addAttribute(name, attribute) {
        if (attribute.meshPerAttribute >= 1) {
        	this.isInstanced = true;
        	this.maxInstancedCount = attribute.count;
        }
        this.attributes[name] = attribute;
    }

    /**
     * @name setIndex()
     * @memberof Geometry
     *
     * @function
     * @param {Float32Array} array
     */
    setIndex(attribute) {
        this.index = attribute.array || attribute;
    }

    /**
     * @name toNonIndexed()
     * @memberof Geometry
     */
    toNonIndexed() {
        let geometry2 = new Geometry();

        let indices = this.index;
        let attributes = this.attributes;

        for (let name in attributes) {
            let attribute = attributes[ name ];
            let array = attribute.array;
            let itemSize = attribute.itemSize;
            let array2 = new array.constructor( indices.length * itemSize );
            let index = 0, index2 = 0;

            for (let i = 0, l = indices.length; i < l; i++) {
                index = indices[ i ] * itemSize;
                for ( let j = 0; j < itemSize; j ++ ) {
                    array2[ index2 ++ ] = array[ index ++ ];
                }
            }

            geometry2.addAttribute(name, new GeometryAttribute(array2, itemSize));
        }

        return geometry2;
    }

    /**
     * @name normalizeNormals()
     * @memberof Geometry
     */
    normalizeNormals() {
        let vector = this._V1 || new Vector3();
        this._V1 = vector;

        let normals = this.attributes.normal;
        let x, y, z;
        for (let i = 0, il = normals.count; i < il; i++) {
            x = i*3+0;
            y = i*3+1;
            z = i*3+2;
            vector.x = normals.array[x];
            vector.y = normals.array[y];
            vector.z = normals.array[z];
            vector.normalize();
            normals.array[x] = vector.x;
            normals.array[y] = vector.y;
            normals.array[z] = vector.z;
        }
	}

    /**
     * @name computeFaceNormals()
     * @memberof Geometry
     */
    computeFaceNormals() {
		let cb = new Vector3(), ab = new Vector3();
		for (let f = 0, fl = this.faces.length; f < fl; f++) {
			let face = this.faces[f];
			let vA = this.vertices[face.a];
			let vB = this.vertices[face.b];
			let vC = this.vertices[face.c];
			cb.subVectors(vC, vB);
			ab.subVectors(vA, vB);
			cb.cross(ab);
			cb.normalize();
			face.normal.copy(cb);
		}
	}

    /**
     * @name computeVertexNormals()
     * @memberof Geometry
     */
	computeVertexNormals() {
		let index = this.index;
		let attributes = this.attributes;
		let groups = this.groups;

		if ( attributes.position ) {
			let positions = attributes.position.array;
			if ( attributes.normal === undefined ) {
				this.addAttribute( 'normal', new GeometryAttribute( new Float32Array( positions.length ), 3 ) );
			} else {
				let array = attributes.normal.array;
				for ( let i = 0, il = array.length; i < il; i ++ ) {
					array[ i ] = 0;
				}
            }

			let normals = attributes.normal.array;
			let vA, vB, vC;
			let pA = new Vector3(), pB = new Vector3(), pC = new Vector3();
			let cb = new Vector3(), ab = new Vector3();

			if ( index ) {
				let indices = index.array;
				if ( groups.length === 0 ) {
					this.addGroup( 0, indices.length );
				}

				for ( let j = 0, jl = groups.length; j < jl; ++ j ) {
					let group = groups[ j ];
					let start = group.start;
					let count = group.count;
					for ( let i = start, il = start + count; i < il; i += 3 ) {

						vA = indices[ i + 0 ] * 3;
						vB = indices[ i + 1 ] * 3;
						vC = indices[ i + 2 ] * 3;

						pA.fromArray( positions, vA );
						pB.fromArray( positions, vB );
						pC.fromArray( positions, vC );

						cb.subVectors( pC, pB );
						ab.subVectors( pA, pB );
						cb.cross( ab );

						normals[ vA ] += cb.x;
						normals[ vA + 1 ] += cb.y;
						normals[ vA + 2 ] += cb.z;

						normals[ vB ] += cb.x;
						normals[ vB + 1 ] += cb.y;
						normals[ vB + 2 ] += cb.z;

						normals[ vC ] += cb.x;
						normals[ vC + 1 ] += cb.y;
						normals[ vC + 2 ] += cb.z;
					}
				}
			} else {
				for ( let i = 0, il = positions.length; i < il; i += 9 ) {
					pA.fromArray( positions, i );
					pB.fromArray( positions, i + 3 );
					pC.fromArray( positions, i + 6 );

					cb.subVectors( pC, pB );
					ab.subVectors( pA, pB );
					cb.cross( ab );

					normals[ i ] = cb.x;
					normals[ i + 1 ] = cb.y;
					normals[ i + 2 ] = cb.z;

					normals[ i + 3 ] = cb.x;
					normals[ i + 4 ] = cb.y;
					normals[ i + 5 ] = cb.z;

					normals[ i + 6 ] = cb.x;
					normals[ i + 7 ] = cb.y;
					normals[ i + 8 ] = cb.z;
				}
			}
			this.normalizeNormals();
			attributes.normal.needsUpdate = true;
		}
	}

    /**
     * @name computeBoundingBox()
     * @memberof Geometry
     */
	computeBoundingBox() {
    	if (!this.boundingBox) this.boundingBox = new Box3();

        let position = this.attributes.position;
        if ( position ) {
            this.boundingBox.setFromBufferAttribute(position);
        } else {
            this.boundingBox.makeEmpty();
        }
	}

    /**
     * @name computeBoundingSphere()
     * @memberof Geometry
     */
	computeBoundingSphere() {
        let box = new Box3();
        let vector = new Vector3();

		if (!this.boundingSphere) this.boundingSphere = new Sphere();

		let position = this.attributes.position;
		if (position) {
			let center = this.boundingSphere.center;

			box.setFromBufferAttribute(position);
			box.getCenter(center);

			let maxRadiusSq = 0;
			for ( let i = 0, il = position.count; i < il; i ++ ) {
				vector.x = position.array[i * 3 + 0];
				vector.y = position.array[i * 3 + 1];
				vector.z =  position.array[i * 3 + 2];
				maxRadiusSq = Math.max(maxRadiusSq, center.distanceToSquared(vector));
			}

			this.boundingSphere.radius = Math.sqrt(maxRadiusSq);

			if (isNaN(this.boundingSphere.radius)) {
				console.error( 'Bounding Sphere came up NaN, broken position buffer.', this );
			}
		}
	}

    /**
     * @name merge()
     * @memberof Geometry
     *
     * @function
     * @param {Geometry} geometry
     */
	merge(geometry) {
        let Float32ArrayConcat = (first, second) => {
            let firstLength = first.length,
                result = new Float32Array(firstLength + second.length);

            result.set(first);
            result.set(second, firstLength);

            return result;
        };

        let UintArrayConcat = (first, second) => {
            let firstLength = first.length,
                result = new (Geometry.arrayNeedsUint32(second) ? Uint32Array : Uint16Array)(firstLength + second.length);

            result.set(first);
            result.set(second, firstLength);

            return result;
        };

        let attributes = this.attributes;

        if (this.index) {
            let indices = geometry.index;
            let offset = attributes.position.count;
            for( let i = 0, il = indices.length; i < il; i++ ) {
                indices[i] = offset + indices[i];
            }

            this.index = UintArrayConcat( this.index, indices );
        }

        for ( let key in attributes ) {
            if ( geometry.attributes[ key ] === undefined ) continue;
            attributes[ key ].array = Float32ArrayConcat( attributes[ key ].array, geometry.attributes[ key ].array );
            attributes[key].count = attributes[key].array.length / attributes[key].itemSize;
        }

        return this;
	}

    /**
     * @name clone()
     * @memberof Geometry
     */
	clone(noCopy) {
    	return new Geometry().copy(this, noCopy);
	}

    /**
     * @name this.copy
     * @memberof Geometry
     *
     * @function
     * @param source
     * @param noCopy
    */
	copy(source, noCopy) {
        this.index = null;
        this.boundingBox = null;
        this.boundingSphere = null;
        this.index = source.index;

        let attributes = source.attributes;
        for (let name in attributes) {
            this.addAttribute(name, attributes[name].clone(noCopy));
        }

        let boundingBox = source.boundingBox;
        if (boundingBox && boundingBox.clone) this.boundingBox = boundingBox.clone();

        let boundingSphere = source.boundingSphere;
        if (boundingSphere && boundingSphere.clone) this.boundingSphere = boundingSphere.clone();

        return this;
	}

    /**
     * @name this.center
     * @memberof Geometry
     */
	center() {
		let offset = new Vector3();
        this.computeBoundingBox();
        this.boundingBox.getCenter(offset).negate();
        this.applyMatrix(new Matrix4().makeTranslation(offset.x, offset.y, offset.z));
        return this;
	}

    /**
     * @name applyMatrix()
     * @memberof Geometry
     *
     * @function
     * @param {Matrix4} matrix
     */
	applyMatrix(matrix) {
        let position = this.attributes.position;

        if (position) {
            matrix.applyToBufferAttribute(position);
            position.needsUpdate = true;
        }

        let normal = this.attributes.normal;
        if (normal) {
            let normalMatrix = new Matrix3().getNormalMatrix(matrix);
            normalMatrix.applyToBufferAttribute(normal);
            normal.needsUpdate = true;
        }

        if (this.boundingBox) this.computeBoundingBox();
        if (this.boundingSphere) this.computeBoundingSphere();

        return this;
	}

    /**
     * @name this.scale
     * @memberof Geometry
     *
     * @function
     * @param {Number} x
     * @param {Number} y
     * @param {Number} z
     */
	scale(x, y, z) {
        this.applyMatrix(new Matrix4().makeScale(x, y, z));
    }

    /**
     * @name this.setFromPoints
     * @memberof Geometry
     *
     * @function
     * @param points
    */
	setFromPoints(points) {
        let position = [];
        for (let i = 0, l = points.length; i < l; i++) {
            let point = points[i];
            position.push(point.x, point.y, point.z || 0);

        }
        this.addAttribute('position', new GeometryAttribute(new Float32Array(position), 3 ));

        return this;
    }

    /**
     * @name this.instanceFrom
     * @memberof Geometry
     *
     * @function
     * @param geom
    */
    instanceFrom(geom) {
        return geom.clone();
    }

    /**
     * @name this.uploadBuffersAsync
     * @memberof Geometry
     *
     * @function
    */
    uploadBuffersAsync() {
	    return Geometry.renderer.uploadBuffersAsync(this);
    }

    /**
     * @name this.toJSON
     * @memberof Geometry
     *
     * @function
    */
    toJSON() {
        let props = {};
        if (this.index) props.index = Array.from(this.index);
        for (let key in this.attributes) {
            props[key] = Array.from(this.attributes[key].array);
        }
        return JSON.stringify(props);
    }
}

/**
 * @name GeometryAttribute
 * @param {Float32Array} array
 * @param {Number} itemSize
 * @param {Number} meshPerAttribute
 */
class GeometryAttribute {
    constructor(_array, _itemSize, _meshPerAttribute, _dynamic = false) {
        /**
         * @name array
         * @memberof GeometryAttribute
         * @property
         */
        this.array = _array;

        /**
         * @name itemSize
         * @memberof GeometryAttribute
         * @property
         */
        this.itemSize = _itemSize;

        /**
         * @name count
         * @memberof GeometryAttribute
         * @property
         */
        this.count = _array !== undefined ? _array.length / _itemSize : 0;

        /**
         * @name dynamic
         * @memberof GeometryAttribute
         * @property
         */
        this.dynamic = _dynamic;

        /**
         * @name updateRange
         * @memberof GeometryAttribute
         * @property
         */
        this.updateRange = {offset: 0, count: -1};

        this.meshPerAttribute = _meshPerAttribute;
    }

    /**
     * @name this.setArray
     * @memberof GeometryAttribute
     *
     * @function
     * @param array
    */
    setArray(array) {
    	let newCount = array !== undefined ? array.length / this.itemSize : 0;
    	if (newCount != this.count) this.needsNewBuffer = true;
        this.array = array;
        this.count = newCount;
        this.needsUpdate = true;
    }

    /**
     * @name this.clone
     * @memberof GeometryAttribute
     *
     * @function
     * @param noCopy
    */
    clone(noCopy) {
    	if (noCopy) return this;
        return new GeometryAttribute(new Float32Array(this.array), this.itemSize, this.meshPerAttribute);
    }

    /**
     * @name this.getX
     * @memberof GeometryAttribute
     *
     * @function
     * @param index
    */
	getX(index ) {

		return this.array[ index * this.itemSize ];

	}

    /**
     * @name this.setX
     * @memberof GeometryAttribute
     *
     * @function
     * @param index
     * @param x
    */
	setX ( index, x ) {

		this.array[ index * this.itemSize ] = x;

		return this;

	}

    /**
     * @name this.getY
     * @memberof GeometryAttribute
     *
     * @function
     * @param index
    */
	getY ( index ) {

		return this.array[ index * this.itemSize + 1 ];

	}

    /**
     * @name this.setY
     * @memberof GeometryAttribute
     *
     * @function
     * @param index
     * @param y
    */
	setY ( index, y ) {

		this.array[ index * this.itemSize + 1 ] = y;

		return this;

	}

    /**
     * @name this.getZ
     * @memberof GeometryAttribute
     *
     * @function
     * @param index
    */
	getZ ( index ) {

		return this.array[ index * this.itemSize + 2 ];

	}

    /**
     * @name this.setZ
     * @memberof GeometryAttribute
     *
     * @function
     * @param index
     * @param z
    */
	setZ ( index, z ) {

		this.array[ index * this.itemSize + 2 ] = z;

		return this;

	}

    /**
     * @name this.getW
     * @memberof GeometryAttribute
     *
     * @function
     * @param index
    */
	getW ( index ) {

		return this.array[ index * this.itemSize + 3 ];

	}

    /**
     * @name this.setW
     * @memberof GeometryAttribute
     *
     * @function
     * @param index
     * @param w
    */
	setW ( index, w ) {

		this.array[ index * this.itemSize + 3 ] = w;

		return this;

	}

    /**
     * @name this.setXY
     * @memberof GeometryAttribute
     *
     * @function
     * @param index
     * @param x
     * @param y
    */
	setXY( index, x, y ) {

		index *= this.itemSize;

		this.array[ index + 0 ] = x;
		this.array[ index + 1 ] = y;

		return this;

	}

    /**
     * @name this.setXYZ
     * @memberof GeometryAttribute
     *
     * @function
     * @param index
     * @param x
     * @param y
     * @param z
    */
	setXYZ( index, x, y, z ) {

		index *= this.itemSize;

		this.array[ index + 0 ] = x;
		this.array[ index + 1 ] = y;
		this.array[ index + 2 ] = z;

		return this;

	}

    /**
     * @name this.setXYZW
     * @memberof GeometryAttribute
     *
     * @function
     * @param index
     * @param x
     * @param y
     * @param z
     * @param w
    */
	setXYZW( index, x, y, z, w ) {

		index *= this.itemSize;

		this.array[ index + 0 ] = x;
		this.array[ index + 1 ] = y;
		this.array[ index + 2 ] = z;
		this.array[ index + 3 ] = w;

		return this;

	}
}
class InterleavedBuffer {
    constructor(array, stride) {
        this.array = array;
        this.stride = stride;
        this.count = !!array ? array.length / stride : 0;
        this.isInterleaved = true;
        this.needsUpdate = false;
        this.dynamic = false;
        this.updateRange = { offset: 0, count: - 1 };
    }
}

class InterleavedGeometryAttribute {
    constructor(interleavedBuffer, itemSize, offset) {
        this.data = interleavedBuffer;
        this.itemSize = itemSize;
        this.offset = offset;
        this.isInterleaved = true;
    }
}
/**
 * @name Group
 */
class Group extends Base3D {
    constructor() {
        super();
        this.isGroup = true;
    }
}
/**
 * @name BaseLight
 * @param {Color} color
 * @param {Number} intensity
 * @param {Number} distance
 */
class BaseLight extends Base3D {
    constructor(color = 0xffffff, intensity = 1, distance = 9999) {
        super();
        this.color = new Color(color);
        this.data = new Vector4();
        this.data2 = new Vector4();
        this.data3 = new Vector4();
        this.properties = new Vector4(intensity, distance, 0, 0);
    }

    destroy() {
        if (this.shadow) {
            Lighting.removeFromShadowGroup(this);
            this.shadow.destroy();
        }
    }

    prepareRender() {
        this.shadow.camera.position.copy(this.position);
        this.shadow.camera.lookAt(this.shadow.target);
    }

    /**
     * @name castShadow
     * @memberof GeometryAttribute
     *
     * @property
     */
    set castShadow(bool) {
        if (!this.shadow && !bool) return;
        if (!this.shadow) this.shadow = new Shadow(this);
        this.shadow.enabled = bool;

        if (!this.silentShadow) {
            if (bool) Lighting.addToShadowGroup(this);
            else Lighting.removeFromShadowGroup(this);
        }
    }

    set intensity(v) {
        this.properties.x = v;
    }

    get intensity() {
        return this.properties.x;
    }

    set distance(v) {
        this.properties.y = v;
    }

    get distance() {
        return this.properties.y;
    }

    set bounce(v) {
        this.properties.z = v;
    }

    get bounce() {
        return this.properties.z;
    }


}
/**
 * Don't use this! Use Line3D module for lines. This is just used for debugging.
 * @name Line
 * @param {Geometry} geometry
 * @param {Shader} shader
 * @extends Base3D
 */
class Line extends Base3D {
    constructor(geometry, shader) {
        super();
        this.geometry = geometry;
        this.shader = shader;
        this.isLine = true;
        this.id = Renderer.ID++;
    }

    clone() {
        return new Line(this.geometry, this.shader).copy(this);
    }
}
/**
 * @name Mesh
 * @param {Geometry} geometry
 * @param {Shader} shader
 * @extends Base3D
 */
class Mesh extends Base3D {
    constructor(geometry, shader) {
        super();
        if (!shader && !window.THREAD) shader = new Shader('TestMaterial');

        this._geometry = geometry;
        this._shader = shader && shader.shader ? shader.shader : shader;
        this.isMesh = true;
        this.id = Utils.timestamp();
        if (shader) this._shader.mesh = this;
    }

    /**
     * @name this.clone
     * @memberof Mesh
     *
     * @function
    */
    clone() {
        return new Mesh(this._geometry, this.shader).copy(this);
    }

    /**
     * @name this.set geometry
     * @memberof Mesh
     *
     * @function
     * @param g
    */
    set geometry(g) {
        Geometry.renderer.resetMeshGeom(this);
        this._geometry = g;
    }

    /**
     * @name this.get geometry
     * @memberof Mesh
     *
     * @function
    */
    get geometry() {
        return this._geometry;
    }

    /**
     * @name this.set shader
     * @memberof Mesh
     *
     * @function
     * @param shader
    */
    set shader(shader) {
        this._shader = shader && shader.shader ? shader.shader : shader;
    }

    /**
     * @name this.get shader
     * @memberof Mesh
     *
     * @function
    */
    get shader() {
        return this._shader;
    }

    /**
     * @name this.isInsideOf
     * @memberof Mesh
     *
     * @function
     * @param mesh
    */
    isInsideOf(mesh) {
        if (!this.box3) this.box3 = new Box3();
        this.box3.setFromObject(this);
        return mesh.isMeshInside(this);
    }

    /**
     * @name this.isMeshInside
     * @memberof Mesh
     *
     * @function
     * @param mesh
    */
    isMeshInside(mesh) {
        if (!this.box3) this.box3 = new Box3();
        this.box3.setFromObject(this);
        return mesh.box3.intersectsBox(this.box3);
    }
}
/**
 * @name Points
 * @param {Geometry} geometry
 * @param {Shader} shader
 * @extends Base3D
 */
class Points extends Base3D {
    constructor(geometry, shader) {
        super();
        this._geometry = geometry;
        this.shader = shader;
        this.isPoints = true;
        this.id = Renderer.ID++;
        if (shader) this.shader.mesh = this;
    }

    /**
     * @name this.clone
     * @memberof Points
     *
     * @function
    */
    clone() {
        return new Points(this._geometry, this.shader).copy(this);
    }

    /**
     * @name this.set geometry
     * @memberof Points
     *
     * @function
     * @param g
    */
    set geometry(g) {
        Geometry.renderer.resetMeshGeom(this);
        this._geometry = g;
    }

    /**
     * @name this.get geometry
     * @memberof Points
     *
     * @function
    */
    get geometry() {
        return this._geometry;
    }
}

/**
 * @name Scene
 * @extends Base3D
 */
class Scene extends Base3D {
    constructor() {
        super();
        this.autoUpdate = true;
        this.toRender = [[], []];
        this._displayNeedsUpdate = true;
        this.isScene = true;
        this.changes = [];
    }

    set displayNeedsUpdate(v) {
        if (v === true) this.changes.forEach(cb => cb());
        this._displayNeedsUpdate = v;
    }

    get displayNeedsUpdate() {
        return this._displayNeedsUpdate;
    }

    bindSceneChange(cb) {
        this.changes.push(cb);
    }
}
Class(function FBORendererWebGL(_gl) {
    const _this = this;

    const WEBGL2 = Renderer.type == Renderer.WEBGL2;
    let _maxSamples = WEBGL2 && _gl.getParameter(_gl.MAX_SAMPLES);

    const {getFormat, getInternalFormat, getProperty, getType, getFloatParams} = require('GLTypes');

    function prepareTexture(texture) {
        texture._gl = _gl.createTexture();
        _gl.bindTexture(_gl.TEXTURE_2D, texture._gl);

        _gl.texParameteri(_gl.TEXTURE_2D, _gl.TEXTURE_WRAP_S, getProperty(texture.wrapS));
        _gl.texParameteri(_gl.TEXTURE_2D, _gl.TEXTURE_WRAP_T, getProperty(texture.wrapT));
        _gl.texParameteri(_gl.TEXTURE_2D, _gl.TEXTURE_MAG_FILTER, getProperty(texture.magFilter));
        _gl.texParameteri(_gl.TEXTURE_2D, _gl.TEXTURE_MIN_FILTER, getProperty(texture.minFilter));

        texture.needsUpdate = false;
    }

    function texImageDB(rt, texture) {
        if (texture.type.includes('float')) {
            let {internalformat, format, type} = getFloatParams(texture);
            _gl.texImage2D(_gl.TEXTURE_2D, 0, internalformat, rt.width, rt.height, 0, format, type, null);
        } else {
            _gl.texImage2D(_gl.TEXTURE_2D, 0, getFormat(texture), rt.width, rt.height, 0, getFormat(texture), getType(texture), null);
        }
        _gl.bindTexture(_gl.TEXTURE_2D, null);
    }

    function getRenderBufferInternalFormat(texture) {
        if (texture.type.includes('float')) {
            return getFloatParams(texture).internalformat;
        }
        return getInternalFormat(texture);
    }

    function uploadCube(rt) {
        rt._gl = _gl.createFramebuffer();

        _gl.bindFramebuffer(_gl.FRAMEBUFFER, rt._gl);

        let texture = rt.texture;
        texture._gl = _gl.createTexture();

        texture.cube = true;
        texture.needsUpdate = false;

        _gl.bindTexture(_gl.TEXTURE_CUBE_MAP, texture._gl);
        for (let i = 0; i < 6; i++) {
            _gl.texImage2D(_gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, 0, getFormat(texture), rt.width, rt.height, 0, getFormat(texture), _gl.UNSIGNED_BYTE, null);
        }
        _gl.texParameteri(_gl.TEXTURE_CUBE_MAP, _gl.TEXTURE_WRAP_S, getProperty(texture.wrapS));
        _gl.texParameteri(_gl.TEXTURE_CUBE_MAP, _gl.TEXTURE_WRAP_T, getProperty(texture.wrapT));
        _gl.texParameteri(_gl.TEXTURE_CUBE_MAP, _gl.TEXTURE_MAG_FILTER, getProperty(texture.magFilter));
        _gl.texParameteri(_gl.TEXTURE_CUBE_MAP, _gl.TEXTURE_MIN_FILTER, getProperty(texture.minFilter));

        rt._depthBuffer = _gl.createRenderbuffer();
        _gl.bindRenderbuffer(_gl.RENDERBUFFER, rt._depthBuffer);
        _gl.renderbufferStorage(_gl.RENDERBUFFER, _gl.DEPTH_COMPONENT16, rt.width, rt.height);
        _gl.framebufferRenderbuffer(_gl.FRAMEBUFFER, _gl.DEPTH_ATTACHMENT, _gl.RENDERBUFFER, rt._depthBuffer);

        _gl.bindFramebuffer(_gl.FRAMEBUFFER, null);
        _gl.bindTexture(_gl.TEXTURE_2D, null);
        _gl.bindRenderbuffer(_gl.RENDERBUFFER, null);
    }

    //*** Event handlers

    //*** Public methods
    this.upload = function(rt) {

        if (rt._gl) return;
        if (rt.cube) return uploadCube(rt);

        rt._gl = _gl.createFramebuffer();

        if (!rt.depth && !rt.disableDepth) {

            rt._depthBuffer = _gl.createRenderbuffer();

            _gl.bindRenderbuffer(_gl.RENDERBUFFER, rt._depthBuffer);

            if(rt.internalMultisample) {

                let samples = Math.min(_maxSamples, rt._samplesAmount);
                _gl.renderbufferStorageMultisample(_gl.RENDERBUFFER, samples, rt.stencil ? _gl.DEPTH24_STENCIL8 : _gl.DEPTH_COMPONENT24, rt.width, rt.height);

            } else {

                _gl.renderbufferStorage(_gl.RENDERBUFFER, rt.stencil ? (WEBGL2 ? _gl.DEPTH24_STENCIL8 : _gl.DEPTH_STENCIL) : (WEBGL2 ? _gl.DEPTH_COMPONENT24 : _gl.DEPTH_COMPONENT16), rt.width, rt.height);

            }
        }

        RenderCount.add(`fbo_${Math.round(rt.width)}x${Math.round(rt.height)}`, rt);

        _gl.bindFramebuffer(_gl.FRAMEBUFFER, rt._gl);

        if (rt.multi) {
            if (WEBGL2) {

                let colorAttachments = [];

                for (let i = 0; i < rt.attachments.length; i++) {
                    let key = 'COLOR_ATTACHMENT'+i;
                    let texture = rt.attachments[i];
                    colorAttachments.push(_gl[key]);

                    prepareTexture(texture);
                    texImageDB(rt, texture);
                    _gl.framebufferTexture2D(_gl.FRAMEBUFFER, _gl[key], _gl.TEXTURE_2D, texture._gl, 0);

                    if (rt.multisample && i > 0) {
                        // Also need a framebuffer for blitting each multisampled attachment
                        texture._blitFramebuffer = _gl.createFramebuffer();
                        _gl.bindFramebuffer(_gl.FRAMEBUFFER, texture._blitFramebuffer);
                        _gl.framebufferTexture2D(_gl.FRAMEBUFFER, _gl.COLOR_ATTACHMENT0, _gl.TEXTURE_2D, texture._gl, 0);
                    }
                }

                _gl.drawBuffers(colorAttachments);

            } else {

                let ext = Renderer.extensions.drawBuffers;
                let colorAttachments = [];

                for (let i = 0; i < rt.attachments.length; i++) {
                    let key = 'COLOR_ATTACHMENT'+i+'_WEBGL';
                    let texture = rt.attachments[i];
                    colorAttachments.push(ext[key]);

                    prepareTexture(texture);
                    texImageDB(rt, texture);
                    _gl.framebufferTexture2D(_gl.FRAMEBUFFER, ext[key], _gl.TEXTURE_2D, texture._gl, 0);
                }

                ext.drawBuffersWEBGL(colorAttachments);
            }
        } else {

            if(rt.internalMultisample) {
                let samples = Math.min(_maxSamples, rt._samplesAmount);
                if (rt.parent.multi) {
                    let colorAttachments = [];
                    let attachments = rt.parent.attachments;

                    for (let i = 0; i < attachments.length; i++) {
                        let key = 'COLOR_ATTACHMENT'+i;
                        let texture = attachments[i];
                        colorAttachments.push(_gl[key]);

                        texture._colorBuffer = _gl.createRenderbuffer();
                        _gl.bindRenderbuffer(_gl.RENDERBUFFER, texture._colorBuffer);
                        _gl.renderbufferStorageMultisample(_gl.RENDERBUFFER, samples, getRenderBufferInternalFormat(texture), rt.width, rt.height);
                        _gl.framebufferRenderbuffer(_gl.FRAMEBUFFER, _gl[key], _gl.RENDERBUFFER, texture._colorBuffer);
                        _gl.bindRenderbuffer(_gl.RENDERBUFFER, null);
                    }
                    _gl.drawBuffers(colorAttachments);

                } else {
                    rt._colorBuffer = _gl.createRenderbuffer();
                    _gl.bindRenderbuffer(_gl.RENDERBUFFER, rt._colorBuffer);
                    _gl.renderbufferStorageMultisample(_gl.RENDERBUFFER, samples, getRenderBufferInternalFormat(rt.texture), rt.width, rt.height);
                    _gl.framebufferRenderbuffer(_gl.FRAMEBUFFER, _gl.COLOR_ATTACHMENT0, _gl.RENDERBUFFER, rt._colorBuffer);
                }

            } else {

                prepareTexture(rt.texture);
                if (rt.texture.type.includes('float')) {
                    let {internalformat, format, type} = getFloatParams(rt.texture);
                    _gl.texImage2D(_gl.TEXTURE_2D, 0, internalformat, rt.width, rt.height, 0, format, type, null);
                } else {
                    _gl.texImage2D(_gl.TEXTURE_2D, 0, getFormat(rt.texture), rt.width, rt.height, 0, getFormat(rt.texture), getType(rt.texture), null);
                }

                _gl.framebufferTexture2D(_gl.FRAMEBUFFER, _gl.COLOR_ATTACHMENT0, _gl.TEXTURE_2D, rt.texture._gl, 0);
            }

        }

        if (rt.depth) {
            prepareTexture(rt.depth);
            let iformat = rt.stencil
                ? (WEBGL2 ? _gl.DEPTH24_STENCIL8 : _gl.DEPTH_STENCIL)
                : (WEBGL2 ? _gl.DEPTH_COMPONENT24 : _gl.DEPTH_COMPONENT);
            let type = rt.stencil
                ? (WEBGL2 ? _gl.UNSIGNED_INT_24_8 : Renderer.extensions.depthTextures.UNSIGNED_INT_24_8_WEBGL)
                : _gl.UNSIGNED_INT;
            _gl.texImage2D(_gl.TEXTURE_2D, 0, iformat, rt.width, rt.height, 0, rt.stencil ? _gl.DEPTH_STENCIL : _gl.DEPTH_COMPONENT, type, null);
            _gl.framebufferTexture2D(_gl.FRAMEBUFFER, rt.stencil ? _gl.DEPTH_STENCIL_ATTACHMENT : _gl.DEPTH_ATTACHMENT, _gl.TEXTURE_2D, rt.depth._gl, 0);
        } else if (!rt.disableDepth) {

            if(rt.internalMultisample) {

                _gl.framebufferRenderbuffer(_gl.FRAMEBUFFER, rt.stencil ? _gl.DEPTH_STENCIL_ATTACHMENT : _gl.DEPTH_ATTACHMENT, _gl.RENDERBUFFER, rt._depthBuffer);

            } else {

                _gl.framebufferRenderbuffer(_gl.FRAMEBUFFER, rt.stencil ? _gl.DEPTH_STENCIL_ATTACHMENT : _gl.DEPTH_ATTACHMENT, _gl.RENDERBUFFER, rt._depthBuffer);

            }
        }

        _gl.bindFramebuffer(_gl.FRAMEBUFFER, null);
        _gl.bindTexture(_gl.TEXTURE_2D, null);
        _gl.bindRenderbuffer(_gl.RENDERBUFFER, null);
    }

    this.bind = function(rt) {
        if (!rt._gl) this.upload(rt);

        _gl.bindFramebuffer(_gl.FRAMEBUFFER, rt._gl);

        if (rt.cube) _gl.framebufferTexture2D(_gl.FRAMEBUFFER, _gl.COLOR_ATTACHMENT0, _gl.TEXTURE_CUBE_MAP_POSITIVE_X + rt.activeFace, rt.texture._gl, 0);

        if (rt.scissor) {
            _gl.enable(_gl.SCISSOR_TEST);
            _gl.scissor(rt.scissor.x, rt.scissor.y, rt.scissor.width, rt.scissor.height);
        }

        _gl.viewport(rt.viewport.x, rt.viewport.y, rt.width, rt.height);

        if(rt.customViewport) _gl.viewport(rt.customViewport.x, rt.customViewport.y, rt.customViewport.z, rt.customViewport.w);

        if (Renderer.instance.autoClear) {

            _gl.clearColor(Renderer.CLEAR[0], Renderer.CLEAR[1], Renderer.CLEAR[2], Renderer.CLEAR[3]);

            if(rt.sharedRenderbuffer) {

                if(rt.clearDepth) {

                    _gl.clear(_gl.COLOR_BUFFER_BIT | _gl.DEPTH_BUFFER_BIT);

                } else {

                    _gl.clear(_gl.COLOR_BUFFER_BIT);

                }

            } else {
            _gl.clear(_gl.COLOR_BUFFER_BIT | _gl.DEPTH_BUFFER_BIT | _gl.STENCIL_BUFFER_BIT);
        }

        }
    }

    this.unbind = function(rt) {
        if (rt.scissor) _gl.disable(_gl.SCISSOR_TEST);
        _gl.bindFramebuffer(_gl.FRAMEBUFFER, null);
    }

    this.resize = function(rt) {
        if (!rt.texture._gl || !rt._gl) return;

        _gl.bindFramebuffer(_gl.FRAMEBUFFER, rt._gl);

        if (rt.multi) {
            for (let i = 0; i < rt.attachments.length; i++) {
                let texture = rt.attachments[i];

                _gl.bindTexture(_gl.TEXTURE_2D, texture._gl);
                if (texture.type.includes('float')) {
                    let {internalformat, format, type} = getFloatParams(texture);
                    _gl.texImage2D(_gl.TEXTURE_2D, 0, internalformat, rt.width, rt.height, 0, format, type, null);
                } else {
                    _gl.texImage2D(_gl.TEXTURE_2D, 0, getFormat(texture), rt.width, rt.height, 0, getFormat(texture), getType(texture), null);
                }
            }
        } else {

            if(rt.internalMultisample) {
                let samples = Math.min(_maxSamples, rt._samplesAmount);
                if (rt.parent.multi) {
                    let attachments = rt.parent.attachments;
                    for (let i = 0; i < attachments.length; i++) {
                        let texture = attachments[i];
                        _gl.bindRenderbuffer(_gl.RENDERBUFFER, texture._colorBuffer);
                        _gl.renderbufferStorageMultisample(_gl.RENDERBUFFER, samples, getRenderBufferInternalFormat(texture), rt.width, rt.height);
                        _gl.bindRenderbuffer(_gl.RENDERBUFFER, null);
                    }

                } else {
                    _gl.bindRenderbuffer(_gl.RENDERBUFFER, rt._colorBuffer);
                    _gl.renderbufferStorageMultisample(_gl.RENDERBUFFER, samples, getRenderBufferInternalFormat(rt.texture), rt.width, rt.height);
                    _gl.framebufferRenderbuffer(_gl.FRAMEBUFFER, _gl.COLOR_ATTACHMENT0, _gl.RENDERBUFFER, rt._colorBuffer);
                }

            } else {

                _gl.bindTexture(_gl.TEXTURE_2D, rt.texture._gl);

                if (rt.texture.type.includes('float')) {
                    let {internalformat, format, type} = getFloatParams(rt.texture);
                    _gl.texImage2D(_gl.TEXTURE_2D, 0, internalformat, rt.width, rt.height, 0, format, type, null);
                } else {
                    _gl.texImage2D(_gl.TEXTURE_2D, 0, getFormat(rt.texture), rt.width, rt.height, 0, getFormat(rt.texture), getType(rt.texture), null);
                }

            }

        }

        if (!rt.depth) {
            if (!rt.disableDepth) {

                _gl.bindRenderbuffer(_gl.RENDERBUFFER, rt._depthBuffer);

                if(rt.internalMultisample) {

                    let samples = Math.min(_maxSamples, rt._samplesAmount);
                    _gl.renderbufferStorageMultisample(_gl.RENDERBUFFER, samples, rt.stencil ? _gl.DEPTH24_STENCIL8 : _gl.DEPTH_COMPONENT24, rt.width, rt.height);

                } else {

                    _gl.renderbufferStorage(_gl.RENDERBUFFER, rt.stencil ? (WEBGL2 ? _gl.DEPTH24_STENCIL8 : _gl.DEPTH_STENCIL) : (WEBGL2 ? _gl.DEPTH_COMPONENT24 : _gl.DEPTH_COMPONENT16), rt.width, rt.height);

                }

            }
        } else {
            _gl.bindTexture(_gl.TEXTURE_2D, rt.depth._gl);
            let iformat = rt.stencil
                ? (WEBGL2 ? _gl.DEPTH24_STENCIL8 : _gl.DEPTH_STENCIL)
                : (WEBGL2 ? _gl.DEPTH_COMPONENT24 : _gl.DEPTH_COMPONENT);
            let type = rt.stencil
                ? (WEBGL2 ? _gl.UNSIGNED_INT_24_8 : Renderer.extensions.depthTextures.UNSIGNED_INT_24_8_WEBGL)
                : _gl.UNSIGNED_INT;
            _gl.texImage2D(_gl.TEXTURE_2D, 0, iformat, rt.width, rt.height, 0, rt.stencil ? _gl.DEPTH_STENCIL : _gl.DEPTH_COMPONENT, type, null);
            _gl.framebufferTexture2D(_gl.FRAMEBUFFER, rt.stencil ? _gl.DEPTH_STENCIL_ATTACHMENT : _gl.DEPTH_ATTACHMENT, _gl.TEXTURE_2D, rt.depth._gl, 0);
        }

        _gl.bindTexture(_gl.TEXTURE_2D, null);
        _gl.bindFramebuffer(_gl.FRAMEBUFFER, null);
        _gl.bindRenderbuffer(_gl.RENDERBUFFER, null);
    }

    this.destroy = function(rt) {
        _gl.deleteFramebuffer(rt._gl);
        if (rt._depthBuffer) _gl.deleteRenderbuffer(rt._depthBuffer);
        Texture.renderer.destroy(rt.texture);

        RenderCount.remove(`fbo_${Math.round(rt.width)}x${Math.round(rt.height)}`);

        if (rt.multi) {
            rt.attachments.forEach(t => {
                if (t._colorBuffer) {
                    _gl.deleteRenderbuffer(t._colorBuffer);
                }
                if (t._blitFramebuffer) {
                    _gl.deleteFramebuffer(t._blitFramebuffer);
                }
                Texture.renderer.destroy(t);
            });
        }

        rt._gl = null;
    }
});

Class(function GeometryRendererWebGL(_gl) {
    const _this = this;

    var _cache = {};
    var _isDebbugingShader = Utils.query('displayShaderError');

    const WEBGL2 = Renderer.type == Renderer.WEBGL2;

    function getMode(mesh, shader) {
        if (mesh.isPoints) return _gl.POINTS;
        if (mesh.isLine) return _gl.LINE_STRIP;
        if (shader.wireframe) return _gl.LINES;
        return _gl.TRIANGLES;
    }

    function updateBuffer(attrib) {
        if (!attrib._gl) return;
        attrib.needsUpdate = false;

        _gl.bindBuffer(_gl.ARRAY_BUFFER, attrib._gl.buffer);

        RenderStats.update('BufferUpdates');

        let array = attrib.array;
        let updateRange = attrib.updateRange;
        if (updateRange.count === -1) {
            if (attrib.needsNewBuffer) {
                _gl.bufferData(_gl.ARRAY_BUFFER, attrib.array, _gl.DYNAMIC_DRAW);
                attrib.needsNewBuffer = false;
            } else {
                _gl.bufferSubData(_gl.ARRAY_BUFFER, 0, array);
            }
        } else {
            if (Array.isArray(updateRange)) {
                for (let i = updateRange.length-1; i > -1; i--) {
                    let {offset, count} = updateRange[i];
                    _gl.bufferSubData(_gl.ARRAY_BUFFER, offset * array.BYTES_PER_ELEMENT,
                        array.subarray(offset, offset + count));
                }
                updateRange.length = 0;
            } else {
                _gl.bufferSubData(_gl.ARRAY_BUFFER, updateRange.offset * array.BYTES_PER_ELEMENT,
                    array.subarray(updateRange.offset, updateRange.offset + updateRange.count));
            }

        }

        _gl.bindBuffer(_gl.ARRAY_BUFFER, null);
    }

    function renderingCount(count, mode, instanceCount = 1) {
        if (!RenderStats.active) return;

        switch ( mode ) {
            case _gl.TRIANGLES:
                RenderStats.update('Triangles', instanceCount * ( count / 3 ));
                break;

            case _gl.LINES:
                RenderStats.update('Lines', instanceCount * ( count / 2 ));
                break;

            case _gl.LINE_STRIP:
                RenderStats.update('LineStrip', instanceCount * ( count - 1 ));
                break;

            case _gl.LINE_LOOP:
                RenderStats.update('LineLoop', instanceCount * ( count ));
                break;

            case _gl.POINTS:
                RenderStats.update('Points', instanceCount * count);
                break;
        }
    }

    //*** Event handlers

    //*** Public methods
    this.draw = function(geom, mesh, shader) {
        if (!geom._gl || geom.needsUpdate || !mesh._gl || !mesh._gl.geomInit) this.upload(geom, mesh, shader);

        if (RenderStats.active) RenderStats.update('DrawCalls', 1, shader.vsName+'|'+shader.fsName, mesh);

        for (let i = geom._attributeKeys.length-1; i > -1; i--) {
            let key = geom._attributeKeys[i];
            let attrib = geom._attributeValues[i];

            if (mesh._gl.program != shader._gl.program || mesh._gl[key] === undefined) {
                mesh._gl[key] = _gl.getAttribLocation(shader._gl.program, key);
            }

            if (mesh._gl[key] === -1) continue;

            if (attrib.isInterleaved && attrib.data.needsUpdate) updateBuffer(attrib.data);
            else if (attrib.needsUpdate || attrib.dynamic) updateBuffer(attrib);
        }
        mesh._gl.program = shader._gl.program;

        if (geom.indexNeedsUpdate) {
            geom._gl.indexType = geom.index instanceof Uint16Array ? _gl.UNSIGNED_SHORT : _gl.UNSIGNED_INT;
            _gl.bindBuffer(_gl.ELEMENT_ARRAY_BUFFER, geom._gl.index);
            if (geom.indexUpdateRange) {
                let updateRange = geom.indexUpdateRange;
                _gl.bufferSubData(_gl.ELEMENT_ARRAY_BUFFER, updateRange.offset * geom.index.BYTES_PER_ELEMENT,
                    geom.index.subarray(updateRange.offset, updateRange.offset + updateRange.count));
            } else {
                _gl.bufferData(_gl.ELEMENT_ARRAY_BUFFER, geom.index, _gl.STATIC_DRAW);
            }
            _gl.bindBuffer(_gl.ELEMENT_ARRAY_BUFFER, null);
            geom.indexNeedsUpdate = false;
        }

        mesh._gl.vao.bind();

        let mode = mesh._gl.mode;
        if (!mode) mesh._gl.mode = mode = getMode(mesh, shader);

        let drawStart = geom.drawRange.start || 0;
        let drawEnd = geom.drawRange.end || geom.attributes.position.count;
        if (geom.isInstanced) {
            let maxInstancedCount = mesh.maxInstancedCount ? Math.min(mesh.maxInstancedCount, geom.maxInstancedCount) : geom.maxInstancedCount;
            if (shader.maxInstancedCount) maxInstancedCount = Math.min(maxInstancedCount || 9999, shader.maxInstancedCount);
            if (WEBGL2) {
                if (geom.index) _gl.drawElementsInstanced(mode, geom.index.length, geom._gl.indexType, 0, maxInstancedCount);
                else _gl.drawArraysInstanced(mode, drawStart, drawEnd, maxInstancedCount);
            } else {
                if (geom.index) Renderer.extensions.instancedArrays.drawElementsInstancedANGLE(mode, geom.index.length, geom._gl.indexType, 0, maxInstancedCount);
                else Renderer.extensions.instancedArrays.drawArraysInstancedANGLE(mode, drawStart, drawEnd, maxInstancedCount);
            }

            renderingCount(geom.index ? geom.index.length : drawEnd, mode, maxInstancedCount);

        } else {
            if (geom.index) _gl.drawElements(mode, geom.index.length, geom._gl.indexType, 0);
            else _gl.drawArrays(mode, drawStart, drawEnd);

            renderingCount(geom.index ? geom.index.length : drawEnd, mode, 1);
        }

        if (_isDebbugingShader && _gl.getError() != _gl.NO_ERROR) {
            console.log(mesh, shader);
            debugger;
        }

        mesh._gl.vao.unbind();
    }

    this.upload = function(geom, mesh, shader, hotload) {
        if (!mesh) return;
        if (!geom._gl) geom._gl = {id: Utils.timestamp()};
        if (!mesh._gl) mesh._gl = {};
        mesh._gl.geomInit = true;
        geom.uploaded = true;

        const KEY = `${geom._gl.id}_${shader._gl._id}`;
        let cached = _cache[KEY];
        if (cached && !hotload) {
            cached.count++;
            mesh._gl.vao = cached.vao;
            mesh._gl.lookup = KEY;
            return;
        }

        if (Utils.query('debugUpload')) {
            console.log('?debugUpload – upload geometry', geom);
        }

        RenderCount.add('geometry');

        if (mesh._gl.vao) mesh._gl.vao.destroy();
        mesh._gl.vao = new VAO(_gl);

        if (!geom.distributeBufferData) RenderCount.add(`geom_upload`, geom);

        for (let i = geom._attributeKeys.length-1; i > -1; i--) {
            let key = geom._attributeKeys[i];
            let attrib = geom._attributeValues[i];

            let location = (mesh._gl.program === shader._gl.program && mesh._gl[key]) || _gl.getAttribLocation(shader._gl.program, key);
            mesh._gl[key] = location;

            if (attrib._gl) continue;

            attrib._gl = {};

            let {array, dynamic} = attrib;

            if (attrib.isInterleaved) {
                if (!attrib.data._gl) attrib.data._gl = attrib._gl;
                attrib._gl = attrib.data._gl;
                array = attrib.data.array;
                dynamic = attrib.data.dynamic;
            }

            if (!attrib._gl.buffer) {
                attrib._gl.buffer = _gl.createBuffer();
                attrib._gl.bufferUploaded = !geom.distributeBufferData;

                _gl.bindBuffer(_gl.ARRAY_BUFFER, attrib._gl.buffer);
                _gl.bufferData(_gl.ARRAY_BUFFER,
                    geom.distributeBufferData ? array.length * array.BYTES_PER_ELEMENT : array,
                    dynamic ? _gl.DYNAMIC_DRAW : _gl.STATIC_DRAW);
                _gl.bindBuffer(_gl.ARRAY_BUFFER, null);
            }

            attrib.needsUpdate = false;
        }

        if (geom.index) {
            if (!geom._gl.index) {
                geom._gl.index = _gl.createBuffer();
                geom._gl.indexType = geom.index instanceof Uint16Array ? _gl.UNSIGNED_SHORT : _gl.UNSIGNED_INT;
                _gl.bindBuffer(_gl.ELEMENT_ARRAY_BUFFER, geom._gl.index);
                _gl.bufferData(_gl.ELEMENT_ARRAY_BUFFER, geom.index, _gl.STATIC_DRAW);
                _gl.bindBuffer(_gl.ELEMENT_ARRAY_BUFFER, null);
            }
        }

        mesh._gl.vao.bind();
        for (let i = geom._attributeKeys.length-1; i > -1; i--) {
            let key = geom._attributeKeys[i];
            let attrib = geom._attributeValues[i];
            let location =  mesh._gl[key];
            if (location == -1) continue;

            let stride = 0;
            let offset = 0;

            if (attrib.isInterleaved) {
                let bytes = attrib.data.array.BYTES_PER_ELEMENT;
                stride = attrib.data.stride * bytes;
                offset = attrib.offset * bytes;
            }

            _gl.bindBuffer(_gl.ARRAY_BUFFER, attrib._gl.buffer);
            _gl.vertexAttribPointer(location, attrib.itemSize, _gl.FLOAT, false, stride, offset);
            _gl.enableVertexAttribArray(location);

            if (geom.isInstanced) {
                if (WEBGL2) {
                    _gl.vertexAttribDivisor(location, attrib.meshPerAttribute);
                } else {
                    Renderer.extensions.instancedArrays.vertexAttribDivisorANGLE(location, attrib.meshPerAttribute);
                }
            }
        }
        if (geom.index) _gl.bindBuffer(_gl.ELEMENT_ARRAY_BUFFER, geom._gl.index);
        mesh._gl.vao.unbind();

        _cache[KEY] = {count: 1, vao: mesh._gl.vao};
    }

    this.destroy = function(geom, mesh) {
        for (let i = geom._attributeKeys.length-1; i > -1; i--) {
            let key = geom._attributeKeys[i];
            let attrib = geom._attributeValues[i];
            if (attrib._gl) {
                _gl.deleteBuffer(attrib._gl.buffer);
                attrib._gl = null;
            }
        }

        if (geom._gl?.index) {
            _gl.deleteBuffer(geom._gl.index);
        }

        RenderCount.remove('geometry');

        if (mesh && mesh._gl && mesh._gl.vao) {
            let cache = _cache[mesh._gl.lookup];
            if (cache) {
                cache.count--;
                if (cache.count == 0) {
                    cache.vao.destroy();
                    delete _cache[mesh._gl.lookup];
                }
            } else {
                mesh._gl.vao.destroy();
            }
            delete mesh._gl.vao;
        }

        delete geom._gl;
    }

    this.resetMeshGeom = function(mesh) {
        if (mesh._gl) mesh._gl.geomInit = false;
    }

    this.uploadBuffersAsync = async function(geom) {
        if (geom._gl && geom._gl.uploadedAsync) return;

        let upload = attrib => {
            let array = attrib.array;
            let buffer = attrib._gl.buffer;
            let promise = Promise.create();
            let amt = 4;
            let match = false;
            while (!match) {
                amt--;
                if (array.length % amt == 0) match = true;
            }

            let chunk = array.length / amt;
            let i = 0;

            let worker = new Render.Worker(function uploadBuffersAsync() {
                let offset = i * chunk;
                let subarray = array.subarray(offset, offset + chunk);

                if (!attrib._gl) {
                    worker.stop();
                    return promise.resolve();
                }

                if (subarray.length) {
                    _gl.bindBuffer(_gl.ARRAY_BUFFER, buffer);
                    _gl.bufferSubData(_gl.ARRAY_BUFFER, offset * array.BYTES_PER_ELEMENT, subarray);
                    _gl.bindBuffer(_gl.ARRAY_BUFFER, null);
                }

                if (++i == amt) {
                    promise.resolve();
                    worker.stop();
                }
            });
            return promise;
        };

        let uploaded = false;
        for (let i = geom._attributeKeys.length-1; i > -1; i--) {
            let key = geom._attributeKeys[i];
            let attrib = geom._attributeValues[i];

            if (!attrib._gl) {
                geom.distributeBufferData = true;

                let {array, dynamic} = attrib;

                attrib._gl = {};

                if (attrib.isInterleaved) {
                    if (!attrib.data._gl) attrib.data._gl = attrib._gl;
                    attrib._gl = attrib.data._gl;
                    array = attrib.data.array;
                    dynamic = attrib.data.dynamic;
                }

                if (!attrib._gl.buffer) {
                    attrib._gl.buffer = _gl.createBuffer();
                    attrib._gl.bufferUploaded = !geom.distributeBufferData;

                    if (attrib.array.length) {
                        _gl.bindBuffer(_gl.ARRAY_BUFFER, attrib._gl.buffer);
                        _gl.bufferData(_gl.ARRAY_BUFFER, array.length * array.BYTES_PER_ELEMENT, dynamic ? _gl.DYNAMIC_DRAW : _gl.STATIC_DRAW);
                        _gl.bindBuffer(_gl.ARRAY_BUFFER, null);
                    }
                }

                attrib.needsUpdate = false;
                geom.needsUpdate = true;
            }

            if (attrib._gl.bufferUploaded) continue;
            attrib._gl.bufferUploaded = true;
            uploaded = true;

            await upload(attrib);
            attrib.needsUpdate = false;
        }

        geom._gl.uploadedAsync = true;

        if (uploaded) RenderCount.add('geom_uploadAsync', geom);
    }

});

Class(function ShaderRendererWebGL(_gl) {
    const _this = this;

    var _pool = {};
    var _programID = 0;
    var _cached = {};
    var _uboCache = {};

    const PROFILER = !!window.OptimizationProfiler;
    const WEBGL2 = Renderer.type == Renderer.WEBGL2;
    const FAIL_A = null;
    const FAIL_B = -1;
    const FAIL_C = 'U';

    const GLOBAL_UNIFORMS = ['normalMatrix', 'modelMatrix', 'modelViewMatrix', 'projectionMatrix', 'viewMatrix',
                            'cameraPosition', 'cameraQuaternion', 'resolution', 'time', 'shadowMatrix', 'shadowLightPos', 'shadowSize'];

    const DEPTH_FUNC_KEYS = {
        [Shader.DEPTH_FUNC_NEVER]: 'NEVER',
        [Shader.DEPTH_FUNC_LESS]: 'LESS',
        [Shader.DEPTH_FUNC_EQUAL]: 'EQUAL',
        [Shader.DEPTH_FUNC_LEQUAL]: 'LEQUAL',
        [Shader.DEPTH_FUNC_GREATER]: 'GREATER',
        [Shader.DEPTH_FUNC_NOTEQUAL]: 'NOTEQUAL',
        [Shader.DEPTH_FUNC_GEQUAL]: 'GEQUAL',
        [Shader.DEPTH_FUNC_ALWAYS]: 'ALWAYS'
    };

    function toTypedArray(uni) {
        let value = uni.value;
        if (!uni._gl) uni._gl = {};
        if (!uni._gl.array || uni._gl.array.length != uni.value.length) uni._gl.array = new Float32Array(uni.value);
        else uni._gl.array.set(uni.value);
        return uni._gl.array;
    }

    function createShader(str, type, name = 'Shader') {
        let shader = _gl.createShader(type);

        if (typeof window.SPECTOR !== 'undefined') {
            shader.__SPECTOR_Metadata = { name };
        }

        _gl.shaderSource(shader, str);
        _gl.compileShader(shader);

        if (Hydra.LOCAL) {
            if (!_gl.getShaderParameter(shader, _gl.COMPILE_STATUS)) {
                logPrettyShaderError(shader);
                _gl.deleteShader(shader);
            }
        }

        return shader;
    }

    // Inspired by pixi
    // https://github.com/pixijs/pixi.js/blob/170e890aad69828c394417cafbb3c0a0d928e8d3/packages/core/src/shader/utils/logProgramError.ts
    function logPrettyShaderError(shader) {
        const shaderSrc = _gl.getShaderSource(shader)
            .split('\n')
            .map((line, index) => `${index}: ${line}`);

        const shaderLog = _gl.getShaderInfoLog(shader);
        const splitShader = shaderLog.split('\n');
        const dedupe = {};

        const lineNumbers = splitShader
            .map(line => parseFloat(line.replace(/^ERROR\: 0\:([\d]+)\:.*$/, '$1')))
            .filter(n =>
            {
                if (n && !dedupe[n])
                {
                    dedupe[n] = true;

                    return true;
                }

                return false;
            });

        const logArgs = [''];

        lineNumbers.forEach((number) =>
        {
            shaderSrc[number - 1] = `%c${shaderSrc[number - 1]}%c`;
            logArgs.push('background: #FF0000; color:#FFFFFF; font-size: 10px', 'font-size: 10px');
        });

        const fragmentSourceToLog = shaderSrc
            .join('\n');

        logArgs[0] = fragmentSourceToLog;

        console.error(shaderLog);

        console.groupCollapsed('click to view full shader code');
        console.warn(...logArgs);
        console.groupEnd();
    }

    function createProgram(shader) {
        if (!shader.vertexShader) Shader.runPreProcess(shader);

        let vsCode = shader.onBeforeCompile(shader.vertexShader, 'vs');
        let fsCode = shader.onBeforeCompile(shader.fragmentShader, 'fs');

        if (PROFILER && OptimizationProfiler.active) [vsCode, fsCode] = OptimizationProfiler.override(shader, vsCode, fsCode);
        RenderCount.add('shader', shader);

        let vs = createShader(vsCode, _gl.VERTEX_SHADER, `${shader.vsName} - ${shader.UILPrefix}`);
        let fs = createShader(fsCode, _gl.FRAGMENT_SHADER, `${shader.fsName} - ${shader.UILPrefix}`);

        if (Hydra.LOCAL && window.GLSLLinter) GLSLLinter.lint(shader, vsCode, fsCode);

        let program = _gl.createProgram();
        _gl.attachShader(program, vs);
        _gl.attachShader(program, fs);
        _gl.linkProgram(program);

        if (Hydra.LOCAL) {
            if (!_gl.getProgramParameter(program, _gl.LINK_STATUS)) {
                console.warn(`Shader: ${shader.vsName} | ${shader.vsName}`);
                console.error(`Could not compile WebGL program. ${shader.vsName} ${shader.fsName} \n\n` + _gl.getProgramInfoLog(program));
            }
        }

        _gl.deleteShader(vs);
        _gl.deleteShader(fs);

        return program;
    }

    function setupShaders(shader) {
        for (let i = shader._uniformKeys.length-1; i > -1; i--) {
            let key = shader._uniformKeys[i];
            let uniform = shader._uniformValues[i];

            if (typeof shader._gl[key] !== 'undefined') continue;

            if (!uniform) continue;

            if (uniform.ubo) {
                if (WEBGL2) {
                    if (_uboCache[shader.UILPrefix] && !shader.ubo) shader.ubo = _uboCache[shader.UILPrefix];

                    //UBO is already cached, so dont add any uniforms to it
                    if (_uboCache[shader.UILPrefix]) {
                        shader._gl[key] = 'U';
                        continue;
                    }

                    //This shader is uploading for the first time so has not been cached yet
                    if (!shader.ubo) shader.ubo = new UBO(1, _gl);
                    shader.ubo.push(uniform);
                    shader._gl[key] = 'U';
                } else {
                    //Not WEBGL2, so fallback UBO to uniform
                    shader._gl[key] = _gl.getUniformLocation(shader._gl.program, key);
                }
            } else if (WEBGL2 && uniform.lightUBO) {
                shader._gl[key] = 'U';
                shader.uboLight = true;
            } else {
                shader._gl[key] = _gl.getUniformLocation(shader._gl.program, key);
            }
        }

        if (shader.ubo && !_uboCache[shader.UILPrefix]) _uboCache[shader.UILPrefix] = shader.ubo;

        if (!shader._gl.setupGlobals) {
            shader._gl.setupGlobals = true;
            GLOBAL_UNIFORMS.forEach(key => {
                shader._gl[key] = _gl.getUniformLocation(shader._gl.program, key);
            });
        }

        if (shader.uboLight) _gl.getUniformBlockIndex(shader._gl.program, 'lights');
        if (WEBGL2) _gl.getUniformBlockIndex(shader._gl.program, 'global');
    }

    function findUniformType(uniform) {
        if (typeof uniform.type === 'string') return uniform.type;
        if (typeof uniform.value === 'boolean') return 'b';
        if (uniform.value === null || uniform.value instanceof Texture || uniform.value.texture || uniform.value.rt && uniform.value.rt.texture) return 't';
        if (uniform.value instanceof Vector2) return 'v2';
        if (uniform.value instanceof Vector3) return 'v3';
        if (uniform.value instanceof Vector3D) return 'v3';
        if (uniform.value instanceof Vector4) return 'v4';
        if (uniform.value instanceof Matrix4) return 'm4';
        if (uniform.value instanceof Matrix3) return 'm3';
        if (uniform.value instanceof Color) return 'c';
        if (uniform.value instanceof Quaternion) return 'q';

        if (Array.isArray(uniform.value)) {
            if (uniform.value[0] instanceof Texture) return 'tv';
        }

        return 'f';
    }

    function uniformTextureArray(uni, uLoc, shader) {
        let array = shader._gl.texArray || [];
        array.length = 0;
        shader._gl.texArray = array;

        for (let i = 0; i < uni.value.length; i++) {
            array.push(shader._gl.texIndex);

            let texture = uni.value[i];
            if (texture.loaded === false) texture = Utils3D.getEmptyTexture();
            if (texture._gl === undefined || texture.needsReupload) Texture.renderer.upload(texture);

            _gl.activeTexture(_gl[`TEXTURE${shader._gl.texIndex++}`]);
            _gl.bindTexture(_gl.TEXTURE_2D, texture._gl);
        }

        _gl.uniform1iv(uLoc, array);
    }

    //*** Event handlers

    //*** Public methods
    this.upload = function(shader) {
        if (PROFILER && OptimizationProfiler.active) OptimizationProfiler.setupShader(shader);

        if (!shader._gl) {
            shader._gl = {};
            let key = `${shader.vsName}_${shader.fsName}_${shader.customCompile}`;
            let cached = _pool[key];

            if (cached) {
                shader._gl.program = cached.program;
                shader._gl._id = cached.id;
                shader.onBeforePrecompilePromise.resolve();
                cached.count++;
                if (Hydra.LOCAL) _pool[key].references.push(shader)
            } else {
                shader._gl.program = createProgram(shader);
                shader._gl._id = _programID++;
                _pool[key] = {count: 1, program: shader._gl.program, id: shader._gl._id};
                Shader.registerPreProcess(shader);
                if (Hydra.LOCAL) _pool[key].references = [shader];
            }
        }

        setupShaders(shader);
        if (shader.ubo) shader.ubo.upload();

        if (!(Renderer.type == Renderer.WEBGL1 && FXLayer.exists)) shader.vertexShader = shader.fragmentShader = '';
    }

    this.findCachedProgram = function(shader) {
        let key = `${shader.vsName}_${shader.fsName}_${shader.customCompile}`;
        let cached = _pool[key];

        if (cached) {
            shader._gl = {};
            shader._gl.program = cached.program;
            shader._gl._id = cached.id;
            shader.onBeforePrecompilePromise.resolve();
            if (_uboCache[shader.UILPrefix]) shader.ubo = shader.UILPrefix;
            cached.count++;
            if (Hydra.LOCAL) _pool[key].references.push(shader)
            return true;
        }

        return false;
    }

    this.draw = function(shader) {
        if (shader._gl === undefined) this.upload(shader);

        shader._gl.texIndex = 0;

        if (shader._gl.program != _cached.program) {
            _gl.useProgram(shader._gl.program);
            _cached.program = shader._gl.program;
        }

        if (shader.ubo) shader.ubo.bind(shader._gl.program, 'ubo');
        if (shader.uboLight) Lighting.bindUBO(shader._gl.program);

        for (let i = shader._uniformKeys.length-1; i > -1; i--) {
            let key = shader._uniformKeys[i];
            let uni = shader._uniformValues[i];
            if (!uni) continue;
            let uLoc = shader._gl[key];
            if (uLoc === undefined) {
                setupShaders(shader);
                uLoc = shader._gl[key];
            }
            if (uLoc === FAIL_A || uLoc === FAIL_B || uLoc === FAIL_C) continue;
            if (uni.value === null) uni.value = Utils3D.getEmptyTexture();
            if (Hydra.LOCAL && uni.value === undefined) throw `Uniform ${key} value is undefined. | ${shader.vsName} ${shader.fsName}`;

            if (!uni.type) uni.type = findUniformType(uni);
            switch (uni.type) {
                case 'f': _gl.uniform1f(uLoc, uni.value); break;
                case 'i': _gl.uniform1i(uLoc, Math.floor(uni.value)); break;
                case 'b': _gl.uniform1i(uLoc, uni.value); break;
                case 'v2': _gl.uniform2f(uLoc, uni.value.x, uni.value.y); break;
                case 'v3': _gl.uniform3f(uLoc, uni.value.x, uni.value.y, uni.value.z); break;
                case 'c': _gl.uniform3f(uLoc, uni.value.r, uni.value.g, uni.value.b); break;
                case 'q': case 'v4': _gl.uniform4f(uLoc, uni.value.x, uni.value.y, uni.value.z, uni.value.w); break;
                case 'v3v': _gl.uniform3fv(uLoc, toTypedArray(uni)); break;
                case 'v4v': _gl.uniform4fv(uLoc, toTypedArray(uni)); break;
                case 'v2v': _gl.uniform2fv(uLoc, toTypedArray(uni)); break;
                case 'fv': _gl.uniform1fv(uLoc, toTypedArray(uni)); break;
                case 'm4': _gl.uniformMatrix4fv(uLoc, false, uni.value.elements); break;
                case 'm3': _gl.uniformMatrix3fv(uLoc, false, uni.value.elements); break;
                case 'tv': uniformTextureArray(uni, uLoc, shader); break;
                case 't':
                    let texture = uni.value;

                    if (!texture.isTexture) {
                        if (uni.value.rt) texture = uni.value.rt.overrideTexture || uni.value.rt.texture;
                        if (uni.value.texture) texture = uni.value.texture;
                    }
                    if (texture.loaded === false) texture = Utils3D.getEmptyTexture();

                    let texIndex = shader._gl.texIndex++;
                    if (uni.value.vrRT) {
                        shader._gl.vrRT = true;
                        uni.value._glTexIndex = texIndex;
                    }

                    Texture.renderer.draw(texture, uLoc, key, texIndex);
                    break;
            }
        }

        if(!shader.glCustomState) {

            if (shader.polygonOffset) {
                let key = shader.polygonOffsetFactor+'_'+shader.polygonOffsetUnits;
                if (_cached.polygonOffset != key) {
                    _gl.enable(_gl.POLYGON_OFFSET_FILL);
                    _gl.polygonOffset(shader.polygonOffsetFactor, shader.polygonOffsetUnits);
                }
                _cached.polygonOffset = key;
            } else {
                if (_cached.polygonOffset) _gl.disable(_gl.POLYGON_OFFSET_FILL);
                _cached.polygonOffset = false;
            }

            if (shader.transparent || shader.opacity) {
                if (!_cached.transparent) _gl.enable(_gl.BLEND);
                _cached.transparent = true;
            } else {
                if (_cached.transparent) _gl.disable(_gl.BLEND);
                _cached.transparent = false;
            }

            if (_cached.blending != shader.blending) {
                switch (shader.blending) {
                    case Shader.ADDITIVE_BLENDING:
                        _gl.blendEquation(_gl.FUNC_ADD);
                        _gl.blendFunc(_gl.SRC_ALPHA, _gl.ONE);
                        break;

                    case Shader.PREMULTIPLIED_ALPHA_BLENDING:
                        _gl.blendEquation(_gl.FUNC_ADD);
                        _gl.blendFunc(_gl.ONE, _gl.ONE_MINUS_SRC_ALPHA);
                        break;


                    case Shader.ADDITIVE_COLOR_ALPHA:
                        _gl.blendEquation(_gl.FUNC_ADD);
                        _gl.blendFunc(_gl.ONE, _gl.ONE);
                        break;

                    default:
                        _gl.blendEquationSeparate(_gl.FUNC_ADD, _gl.FUNC_ADD);
                        _gl.blendFuncSeparate(_gl.SRC_ALPHA, _gl.ONE_MINUS_SRC_ALPHA, _gl.ONE, _gl.ONE_MINUS_SRC_ALPHA);
                        break;
                }
                _cached.blending = shader.blending;
            }

            if (shader.depthTest) {
                if (!_cached.depthTest) _gl.enable(_gl.DEPTH_TEST);
                _cached.depthTest = true;
            } else {
                if (_cached.depthTest) _gl.disable(_gl.DEPTH_TEST);
                _cached.depthTest = false;
            }

            let depthFunc = _gl[DEPTH_FUNC_KEYS[shader.depthFunc || Shader.DEPTH_FUNC_LESS]];
            if (_cached.depthFunc !== depthFunc) {
                _gl.depthFunc(depthFunc);
                _cached.depthFunc = depthFunc;
            }

            if (shader.stencilTest) {
                if (!_cached.stencilTest) _gl.enable(_gl.STENCIL_TEST);
                _cached.stencilTest = true;

                if(shader.stencilMask) {

                    _gl.stencilFunc(_gl.ALWAYS, 1, 0xff);
                    _gl.stencilOp(_gl.KEEP, _gl.KEEP, _gl.REPLACE);
                    _gl.stencilMask(0xff);
                    _gl.colorMask(false, false, false, false);
                    _gl.disable(_gl.DEPTH_TEST);

                } else {

                    _gl.colorMask(true, true, true, true);
                    _gl.enable(_gl.DEPTH_TEST);
                    let mode = "inside";
                    _gl.stencilFunc(mode == 'inside' ? _gl.EQUAL : _gl.NOTEQUAL, 1, 0xff);
                    _gl.stencilOp(_gl.KEEP, _gl.KEEP, _gl.KEEP);

                }
            } else {
                if (_cached.stencilTest) _gl.disable(_gl.STENCIL_TEST);
                _cached.stencilTest = false;
            }


            switch (shader.side) {
                case Shader.BACK_SIDE:
                    if (_cached.side != Shader.BACK_SIDE) {
                        _gl.enable(_gl.CULL_FACE);
                        _gl.cullFace(_gl.FRONT);
                        _cached.side = Shader.BACK_SIDE;
                    }
                    break;

                case Shader.DOUBLE_SIDE:
                    if (_cached.side != Shader.DOUBLE_SIDE) {
                        _gl.disable(_gl.CULL_FACE);
                        _cached.side = Shader.DOUBLE_SIDE;
                    }
                    break;

                default:
                    if (_cached.side != Shader.FRONT_SIDE) {
                        _gl.enable(_gl.CULL_FACE);
                        _gl.cullFace(_gl.BACK);
                        _cached.side = Shader.FRONT_SIDE;
                    }
                    break;
            }

            if (_cached.depthMask != shader.depthWrite) {
                _gl.depthMask(shader.depthWrite ? true : false);
                _cached.depthMask = shader.depthWrite;
            }

            if (shader.colorMask && !!shader.colorMask.push) {
                _gl.colorMask(shader.colorMask[0] || false, shader.colorMask[1] || false, shader.colorMask[2] || false, shader.colorMask[3] || false);
            } else {
                switch (shader.colorMask) {
                    case Shader.COLOR_MASK_NONE:
                        if (_cached.colorMask != shader.colorMask) {
                            _gl.colorMask(true, true, true, true);
                            _cached.colorMask = shader.colorMask;
                        }
                        break;

                    case Shader.COLOR_MASK_RGB:
                        if (_cached.colorMask != shader.colorMask) {
                            _gl.colorMask(false, false, false, true);
                            _cached.colorMask = shader.colorMask;
                        }
                        break;

                    case Shader.COLOR_MASK_RGBA:
                        if (_cached.colorMask != shader.colorMask) {
                            _gl.colorMask(false, false, false, false);
                            _cached.colorMask = shader.colorMask;
                        }
                        break;
                }
            }
        }

        if (shader.customState) {
            for (let i = 0; i < shader.customState.length; i++) {
                let obj = shader.customState[i];
                _gl[obj.fn].apply(_gl, obj.params);
            }
        }
    }

    this.destroy = function(shader) {
        delete shader._gl;
        if (shader.ubo) shader.ubo.destroy();
        // let key = `${shader.vsName}_${shader.fsName}_${shader.customCompile}`;
        // let cached = _pool[key];
        // if (cached && !ShaderRendererWebGL.persistPrograms) {
        //     if (--cached.count == 0) {
        //         _gl.deleteProgram(cached.program);
        //         delete _pool[key];
        //     }
        // }
    }

    this.appendUniform = function(shader, key, value, hint) {
        let loc = shader._gl[key];
        if (loc === undefined) loc = loc = _gl.getUniformLocation(shader._gl.program, key);

        if (loc === FAIL_A) return;

        if (value.isMatrix4) {

            _gl.uniformMatrix4fv(loc, false, value.elements);

        } else if (value.isMatrix3) {

            _gl.uniformMatrix3fv(loc, false, value.elements);

        } else if (value.isVector4) {

            _gl.uniform4f(loc, value.x, value.y, value.z, value.w);

        }  else if (value.isQuaternion) {

            _gl.uniform4f(loc, value.x, value.y, value.z, value.w);
        }
        else if (value.isVector3) {

            _gl.uniform3f(loc, value.x, value.y, value.z);

        } else if (value.isVector2) {

            _gl.uniform2f(loc, value.x, value.y);

        } else if (value instanceof Float32Array) {

            switch (hint) {
                case 'matrix':
                    _gl.uniformMatrix4fv(loc, false, value);
                    break;

                case 'float':
                    _gl.uniform1fv(loc, value);
                    break;

                case 'vec3':
                    _gl.uniform3fv(loc, value);
                    break;
            }

        } else if (Array.isArray(value)) {

            let array = shader._gl.texArray || [];
            array.length = 0;
            shader._gl.texArray = array;

            for (let i = 0; i < value.length; i++) {
                array.push(shader._gl.texIndex);
                _gl.activeTexture(_gl[`TEXTURE${shader._gl.texIndex++}`]);
                _gl.bindTexture(_gl.TEXTURE_2D, value[i]._gl);
            }

            _gl.uniform1iv(loc, array);

        } else {

            _gl.uniform1f(loc, value);

        }

    }

    this.resetState = function() {
        if (!_cached.depthMask) {
            _gl.depthMask(true);
            _cached.depthMask = true;
        }

        if (!_cached.depthTest) _gl.enable(_gl.DEPTH_TEST);
        _cached.depthTest = true;

        if (_cached.depthFunc !== _gl.LESS) _gl.depthFunc(_gl.LESS);
        _cached.depthFunc = _gl.LESS;

        if (_cached.colorMask != Shader.COLOR_MASK_NONE) {
            _gl.colorMask(true, true, true, true);
            _cached.colorMask = Shader.COLOR_MASK_NONE;
        }

        _cached.program = null;
    }

    this.clearState = function() {
        _cached = {};
    }

    this.hotReload = function(file) {
        file = file.split('.')[0].trim();
        for (let key in _pool){
            if (key.includes(file) && !['|instance', '|Line3D', '|MergedLine'].find(part => key.includes(part))) {
                let obj = _pool[key];
                let rootShader = obj.references[0];
                for (let i = 0; i < obj.references.length; i++) {
                    let shader = obj.references[i];
                    if (i === 0) {
                        shader.restoreFS = shader.restoreVS = null;
                        shader.resetProgram();
                        shader._gl = {};
                        shader._gl.program = createProgram(shader);
                        shader._gl._id = _programID++;
                        obj.program = shader._gl.program;
                        obj.id = shader._gl._id;
                    } else {
                        shader.destroy();
                        shader.restoreFS = rootShader.restoreFS;
                        shader.restoreVS = rootShader.restoreVS;
                        shader.vertexShader = rootShader.vertexShader;
                        shader.fragmentShader = rootShader.fragmentShader;
                        rootShader._gl = {};
                        rootShader._gl.program = obj.program;
                        rootShader._gl._id = obj.id;
                    }
                    setupShaders(rootShader);
                }
            }
        }
    }

    this.hotReloadClearProgram = function(id) {
        for (let key in _pool){
            if (key.includes(id)) {
                delete _pool[key];
            }
        }
    }

});

Class(function TextureRendererWebGL(_gl) {
    const _this = this;

    var _state = {};

    const DATA = new Uint8Array([0, 0, 0, 0]);

    const {getFormat, getProperty, getType, getFloatParams} = require('GLTypes');

    function uploadTexture3D(texture) {

        if(typeof texture._gl === 'undefined') {

            texture._gl = _gl.createTexture();
            _gl.bindTexture(_gl.TEXTURE_3D, texture._gl);
            _gl.pixelStorei(_gl.UNPACK_FLIP_Y_WEBGL, false);
            _gl.pixelStorei(_gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, false);
            _gl.texParameteri(_gl.TEXTURE_3D, _gl.TEXTURE_WRAP_S, getProperty(texture.wrapS));
            _gl.texParameteri(_gl.TEXTURE_3D, _gl.TEXTURE_WRAP_T, getProperty(texture.wrapT));
            _gl.texParameteri(_gl.TEXTURE_3D, _gl.TEXTURE_WRAP_R, getProperty(texture.wrapR));
            _gl.texParameteri(_gl.TEXTURE_3D, _gl.TEXTURE_MAG_FILTER, getProperty(texture.magFilter));
            _gl.texParameteri(_gl.TEXTURE_3D, _gl.TEXTURE_MIN_FILTER, getProperty(texture.minFilter));
            _gl.texImage3D(_gl.TEXTURE_3D,
                0,
                _gl.RGBA32F,
                texture.width,
                texture.height,
                texture.depth,
                0,
                _gl.RGBA,
                _gl.FLOAT,
                texture.image);

            texture.needsUpdate = texture.needsReupload = false;
            if (texture.onUpdate) texture.onUpdate();
        }
    }

    function uploadCube(texture) {
        if (typeof texture._gl === 'undefined') {
            texture._gl = _gl.createTexture();

            _gl.bindTexture(_gl.TEXTURE_CUBE_MAP, texture._gl);

            let needsFlipY = texture.flipY === true;
            if (needsFlipY !== !!_state.flipY) {
                _gl.pixelStorei(_gl.UNPACK_FLIP_Y_WEBGL, needsFlipY);
                _state.flipY = needsFlipY;
            }

            setTextureParams(texture, _gl.TEXTURE_CUBE_MAP);
        }

        let format = getFormat(texture);
        if (texture.compressed) {
            let image = texture.cube[0];
            for (let i = 0; i < image.compressedData.length; i++) {
                let size = image.sizes[i];
                let data = image.compressedData[i];
                let faceLength = data.length / 6;
                for (let j = 0; j < 6; j++) {
                    if (image.uncompressed) {
                        let view = new Uint8Array(data.buffer, j * faceLength, faceLength);
                        _gl.texImage2D(_gl.TEXTURE_CUBE_MAP_POSITIVE_X + j, i, _gl.RGBA, size.width, size.height, 0, _gl.RGBA, _gl.UNSIGNED_BYTE, view);
                    } else {
                        let view = new DataView(data.buffer, j * faceLength, faceLength);
                        _gl.compressedTexImage2D(_gl.TEXTURE_CUBE_MAP_POSITIVE_X + j, i, image.gliFormat, size.width || size, size.height || size, 0, view);
                    }
                }
            }
        } else {
            for (let i = 0; i < 6; i++) {
                _gl.texImage2D(_gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, 0, format, format, getType(texture), texture.cube[i]);
            }
            _gl.generateMipmap(_gl.TEXTURE_CUBE_MAP);
        }

        texture.needsUpdate = texture.needsReupload = false;
        if (texture.onUpdate) texture.onUpdate();
    }

    function setTextureParams(texture, textureType = _gl.TEXTURE_2D) {
        let format = getFormat(texture);
        if (textureType == _gl.TEXTURE_2D && !texture.compressed) _gl.texImage2D(textureType, 0, format, 1, 1, 0, format, _gl.UNSIGNED_BYTE, DATA);
        _gl.texParameteri(textureType, _gl.TEXTURE_WRAP_S, getProperty(texture.wrapS));
        _gl.texParameteri(textureType, _gl.TEXTURE_WRAP_T, getProperty(texture.wrapT));
        _gl.texParameteri(textureType, _gl.TEXTURE_MAG_FILTER, getProperty(texture.magFilter));
        _gl.texParameteri(textureType, _gl.TEXTURE_MIN_FILTER, getProperty(texture.minFilter));

        if (!texture.data && texture.format == Texture.RGBAFormat) {
            if (texture.premultiplyAlpha === false) {
                _gl.pixelStorei(_gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, false);
                _state.premultiply = false;
            } else {
                _gl.pixelStorei(_gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, true);
                _state.premultiply = true;
            }
        }  else {
            if (_state.premultiply == true) {
                _gl.pixelStorei(_gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, false);
                _state.premultiply = false;
            }
        }


        if (texture.anisotropy > 1) _gl.texParameterf(textureType, Renderer.extensions.anisotropy.TEXTURE_MAX_ANISOTROPY_EXT, texture.anisotropy);
    }

    function updateDynamic(texture) {
        if (texture.isDataTexture) {
            if (texture.flipY === true) {
                if (!_state.flipY) {
                    _gl.pixelStorei(_gl.UNPACK_FLIP_Y_WEBGL, true);
                    _state.flipY = true;
                }
            } else {
                if (_state.flipY) {
                    _gl.pixelStorei(_gl.UNPACK_FLIP_Y_WEBGL, false);
                    _state.flipY = false;
                }
            }

            if (_state.premultiply) {
                _gl.pixelStorei(_gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, false);
                _state.premultiply = false;
            }

            if (!texture.glFormat) {
                let {internalformat, format, type} = getFloatParams(texture);
                texture.iformat = internalformat;
                texture.glFormat = format;
                texture.glType = type;
            }
            _gl.texSubImage2D(_gl.TEXTURE_2D, 0, 0, 0, texture.width, texture.height, texture.glFormat, texture.glType, texture.data);
        } else {

            if (!_state.flipY) {
                _gl.pixelStorei(_gl.UNPACK_FLIP_Y_WEBGL, true);
                _state.flipY = true;
            }

            if (texture.format == Texture.RGBAFormat) {
                if (texture.premultiplyAlpha === false) {
                    _gl.pixelStorei(_gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, false);
                    _state.premultiply = false;
                } else {
                    _gl.pixelStorei(_gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, true);
                    _state.premultiply = true;
                }
            } else {
                if (_state.premultiply) {
                    _gl.pixelStorei(_gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, false);
                    _state.premultiply = false;
                }
            }

            if (!texture.glFormat) texture.glFormat = getFormat(texture);
            try {
            _gl.texImage2D(_gl.TEXTURE_2D, 0, texture.glFormat, texture.glFormat, getType(texture), texture.image);
            } catch(e) { }
        }
    }

    //*** Event handlers

    //*** Public methods
    this.draw = function(texture, loc, key, id) {
        if (texture._gl === undefined || texture.needsReupload) this.upload(texture);
        _gl.activeTexture(_gl[`TEXTURE${id}`]);

        if (texture.cube) {
            _gl.bindTexture(_gl.TEXTURE_CUBE_MAP, texture._gl);
        } else {
            if(texture.isTexture3D) {
                _gl.bindTexture(_gl.TEXTURE_3D, texture._gl);
            } else {
                let texType = texture.EXT_OES ? _gl.TEXTURE_EXTERNAL_OES : _gl.TEXTURE_2D;
                _gl.bindTexture(texType, texture._gl);
            }
        }

        _gl.uniform1i(loc, id);

        if (texture.dynamic || texture.needsUpdate) updateDynamic(texture);
        texture.needsUpdate = false;
    }

    this.upload = function(texture) {
        if (texture._gl && !texture.needsReupload && !texture.needsUpdate) return;
        let format = getFormat(texture);

        if (Utils.query('debugUpload')) {
            console.log('?debugUpload – upload texture', texture);
        }

        if (!!texture.cube) {
            if (texture.compressed) {
                if (texture.cube.length !== 1) throw 'Compressed cube texture requires 1 file with 6 faces';
            } else {
                if (texture.cube.length !== 6) throw 'Cube texture requires 6 images';
            }
            return uploadCube(texture);
        }

        if(!!texture.isTexture3D) {
            return uploadTexture3D(texture);
        }

        let texType = texture.EXT_OES ? _gl.TEXTURE_EXTERNAL_OES : _gl.TEXTURE_2D;
        if (typeof texture._gl === 'undefined') {
            texture._gl = _gl.createTexture();
            RenderCount.add('texture');
            _gl.bindTexture(texType, texture._gl);
            setTextureParams(texture, texType);
        } else {
            _gl.bindTexture(texType, texture._gl);
        }

        if (texture.isDataTexture || (texture.type && texture.type.includes('float'))) {
            if (texture.flipY === true) {
                if (!_state.flipY) {
                    _gl.pixelStorei(_gl.UNPACK_FLIP_Y_WEBGL, true);
                    _state.flipY = true;
                }
            } else {
                if (_state.flipY) {
                    _gl.pixelStorei(_gl.UNPACK_FLIP_Y_WEBGL, false);
                    _state.flipY = false;
                }
            }

            _gl.pixelStorei(_gl.UNPACK_ALIGNMENT, 1);
            let {internalformat, format, type} = getFloatParams(texture);

            if (Device.system.browser === 'ie') {
                try { _gl.texImage2D(_gl.TEXTURE_2D, 0, internalformat, texture.width, texture.height, 0, format, type, texture.distributeTextureData ? null : texture.data); }
                catch (e) { console.log(e) }
            } else {
                _gl.texImage2D(_gl.TEXTURE_2D, 0, internalformat, texture.width, texture.height, 0, format, type, texture.distributeTextureData ? null : texture.data);
            }

            if (texture.destroyDataAfterUpload) {
                texture.data = null;
                delete texture.data;
            }

        } else {

            if (!_state.flipY) {
                _gl.pixelStorei(_gl.UNPACK_FLIP_Y_WEBGL, true);
                _state.flipY = true;
            }

            if (texture.image && texture.compressed) {
                let data = texture.image.compressedData;
                for (let i = 0; i < data.length; i++) {
                    let size = texture.image.sizes[i];
                    if (texture.image.uncompressed) {
                        _gl.texImage2D(_gl.TEXTURE_2D, i, _gl.RGBA, size.width, size.height, 0, _gl.RGBA, _gl.UNSIGNED_BYTE, data[i]);
                    } else {
                        _gl.compressedTexImage2D(_gl.TEXTURE_2D, i, texture.image.gliFormat, size.width || size, size.height || size, 0, data[i]);
                    }
                }
                data.length = 0;
            } else if (texture.image) {

                if (!(texture.image instanceof HTMLVideoElement)) {
                    try {
                        _gl.texImage2D(_gl.TEXTURE_2D, 0, format, format, getType(texture), texture.image);
                    } catch(e) {
                        console.log('error loading texture', e, texture.image);
                    }
                }
            }

            if (!texture.distributeTextureData) RenderCount.add('tex_upload', texture);

        }

        if ((texture.image || texture.data)
            && texture.generateMipmaps && !texture.compressed) _gl.generateMipmap(_gl.TEXTURE_2D);

        texture.needsUpdate = texture.needsReupload = false;
        if (texture.onUpdate) texture.onUpdate();
    }

    this.manualUpdateDynamic = function(texture) {
        if (texture._gl === undefined || texture.needsReupload) this.upload(texture);
        _gl.bindTexture(_gl.TEXTURE_2D, texture._gl);
        updateDynamic(texture);
    }

    this.uploadAsync = function(texture) {
        let {format, type} = getFloatParams(texture);

        if (texture._uploadAsyncPromise) return texture._uploadAsyncPromise;
        texture._uploadAsyncPromise = Promise.create();

        RenderCount.add('tex_uploadAsync', texture);

        if (!texture._gl) {
            texture.distributeTextureData = true;
            _this.upload(texture);
        }

        let chunks = 4;
        let pixelsPerChunk = texture.height / chunks;
        let dataPerChunk = texture.data.length / chunks;
        let i = 0;

        let worker = new Render.Worker(function workerUploadAsync() {
            let pixelOffset = pixelsPerChunk * i;
            let dataOffset = dataPerChunk * i;
            let subarray = texture.data.subarray(dataOffset, dataOffset + dataPerChunk);

            if (texture.flipY === true) {
                if (!_state.flipY) {
                    _gl.pixelStorei(_gl.UNPACK_FLIP_Y_WEBGL, true);
                    _state.flipY = true;
                }
            } else {
                if (_state.flipY) {
                    _gl.pixelStorei(_gl.UNPACK_FLIP_Y_WEBGL, false);
                    _state.flipY = false;
                }
            }

            _gl.bindTexture(_gl.TEXTURE_2D, texture._gl);
            _gl.texSubImage2D(_gl.TEXTURE_2D, 0, 0, pixelOffset, texture.width, pixelsPerChunk, format, type, subarray);
            _gl.bindTexture(_gl.TEXTURE_2D, null);

            if (++i == chunks) {
                worker.stop();
                texture._uploadAsyncPromise.resolve();
            }
        });

        return texture._uploadAsyncPromise;
    }

    this.destroy = function(texture) {
        if (texture._gl) {
            _gl.deleteTexture(texture._gl);
            RenderCount.remove('texture');
            RenderCount.add('tex_destroy', texture);
        }

        if (texture.data) {
            texture.data = null;
            delete texture.data;
        }

        delete texture._gl;
    }
});

/**
 * @name RenderTarget
 * @param {Number} width
 * @param {Number} height
 * @param {Object} options
 */

class RenderTarget {
    constructor(width, height, options = {}) {
        this.width = width;
        this.height = height;
        this.options = options;

        this.viewport = new Vector2( 0, 0 );

        if (options.minFilter === undefined) options.minFilter = Texture.LINEAR;

        this.stencil = typeof options.stencil === 'boolean' ? options.stencil : false;

        if(options.sharedRenderbuffer) {
            this.sharedRenderbuffer = true;
            this.clearDepth = typeof options.clearDepth === 'boolean' ? options.clearDepth : true;
            this._depthBuffer = options.sharedRenderbuffer.rt._depthBuffer;
        }

        this.texture = new Texture(null);
        this.texture.generateMipmaps = options.generateMipmaps;
        this.texture.rt = this;

        this.texture.width = width;
        this.texture.height = height;

        this.texture.minFilter = options.minFilter || Texture.LINEAR;
        this.texture.magFilter = options.magFilter || Texture.LINEAR;
        this.texture.wrapS = options.wrapS || Texture.CLAMP_TO_EDGE;
        this.texture.wrapT = options.wrapT || Texture.CLAMP_TO_EDGE;

        this.texture.format = options.format || Texture.RGBFormat;

        if (options.type) this.texture.type = options.type;

        if(options.multisample && (Renderer.type ? (Renderer.type == Renderer.WEBGL2) : Device.graphics.webgl.webgl2)) {
            options.multisample = false;
            this.multisample = true;
            this._rtMultisample = new RenderTarget(width, height, options);
            this._rtMultisample.internalMultisample = true;
            this._rtMultisample.parent = this;
            this._rtMultisample._samplesAmount = options.samplesAmount === undefined ? 100 : options.samplesAmount;

        }

        this.isRT = true;
    }

    /**
     * @name setSize()
     * @memberof RenderTarget
     *
     * @function
     * @param {Number} width
     * @param {Number} height
     */
    setSize(width, height) {
        this.width = width;
        this.height = height;

        this.texture.width = width;
        this.texture.height = height;

        this.viewport.set(0, 0);

        RenderTarget.renderer.resize(this);

        if (this.multisample && (this._rtMultisample.width !== width || this._rtMultisample.height !== height)) {
            this._rtMultisample.destroy();
            this._rtMultisample = new RenderTarget(width, height, this.options);
            this._rtMultisample.internalMultisample = true;
            this._rtMultisample.parent = this;
            this._rtMultisample._samplesAmount = this.options.samplesAmount === undefined ? 100 : this.options.samplesAmount;
        }
    }

    /**
     * @name clone()
     * @memberof RenderTarget
     * @function
     */
    clone() {
        return new RenderTarget(this.width, this.height, { ...this.options }).copy(this);
    }

    copy(source) {
        this.width = source.width;
        this.height = source.height;
        let options = { ...this.options };
        this.options = options;
        this.viewport.copy(source.viewport);
        this.stencil = source.stencil;
        if (source.sharedRenderbuffer) {
            this.sharedRenderbuffer = true;
            this.clearDepth = source.clearDepth;
            this._depthBuffer = source._depthBuffer;
        }
        this.texture = source.texture.clone();
        if (source.multisample) {
            options.multisample = false;
            this.multisample = true;
            this._rtMultisample = new RenderTarget(this.width, this.height, options);
            this._rtMultisample.internalMultisample = true;
            this._rtMultisample.parent = this;
            this._rtMultisample._samplesAmount = source._rtMultisample._samplesAmount;
        }
        return this;
    }

    createDepthTexture() {
        this.depth = new Texture(null);
        this.depth.generateMipmaps = false;
        this.depth.minFilter = Texture.NEAREST;
        this.depth.magFilter = Texture.NEAREST;
        this.depth.wrapS = Texture.CLAMP_TO_EDGE;
        this.depth.wrapT = Texture.CLAMP_TO_EDGE;
        return this.depth;
    }

    destroy() {
        RenderTarget.renderer.destroy(this);
    }

    upload() {
        if (!this._gl) RenderTarget.renderer.upload(this);

        if (this._rtMultisample) {
            this._rtMultisample.upload();
        }
    }
}

/**
 * @name MultiRenderTarget
 * @param {Number} width
 * @param {Number} height
 * @param {Object} options
 */
class MultiRenderTarget extends RenderTarget {
    constructor(width, height, options = {}) {
        super(width, height, options);
        this.multi = true;
        this.attachments = [this.texture];
    }
}

/**
 * @name CubeRenderTarget
 * @param {Number} width
 * @param {Number} height
 * @param {Object} options
 */
class CubeRenderTarget extends RenderTarget {
    constructor(width, height, options = {}) {
        super(width, height, options);
        this.activeFace = 0;
        this.cube = true;
    }
}

/**
 * @name Shader
 * @param {String} vertexShader
 * @param {String} fragmentShader
 * @param {Object} params
 */
Class(function Shader(_vertexShader, _fragmentShader, _params, _onBeforeBuild, _postfix) {
    if (typeof _vertexShader === 'object') {
        _fragmentShader = _vertexShader.uniforms;
        _vertexShader = _vertexShader.name;
    }

    const _this = this;

    this.uniforms = Shader.createUniforms(this);
    this.side = Shader.FRONT_SIDE;
    this.blending = Shader.NORMAL_BLENDING;
    this.colorMask = Shader.COLOR_MASK_NONE;
    this.polygonOffset = false;
    this.polygonOffsetFactor = 0;
    this.polygonOffsetUnits = 1;
    this.depthTest = true;
    this.depthWrite = true;
    this.globalIllumination = _params?.globalIllumination || false;
    this.depthFunc = Shader.DEPTH_FUNC_LESS;
    this.stencilTest = false;
    this.stencilMask = false;
    this.wireframe = false;
    this.transparent = false;
    this.visible = true;
    this.persists = false;
    this.precision = 'high';
    this.customCompile = _params?.customCompile || '';
    this.onBeforePrecompilePromise = Promise.create();

    if (typeof _fragmentShader !== 'string') {
        _params = _fragmentShader;
        _fragmentShader = _vertexShader;
    }

    _params = _params || {};

    _this.vsParam = _vertexShader;
    _this.fsParam = _fragmentShader;
    _this.params = _params;
    _this.onBeforeBuild = _onBeforeBuild;

    _this.vsName = _vertexShader;
    _this.fsName = (_fragmentShader || _vertexShader) + (_postfix || '');
    if (_params.vsName) {
        _this.vsName = _params.vsName;
        delete _params.vsName;
    }

    if (_params.precision) _this.precision = _params.precision;
    if (_params.receiveShadow) {
        _this.receiveLight = true;
        if (!!World.RENDERER.shadows) _this.precision = 'high';
    }

    let vs = _vertexShader;
    let fs = _fragmentShader;

    if (_params.uilFrom) {
        vs = _params.uilFrom;
        fs = _params.uilFrom;
        delete _params.uilFrom;
    }

    _this.UILPrefix = _params.UILPrefix || `${vs}/${fs}/${(_params.unique ? _params.unique + '/' : '')}`;
    Shader.parseParams(_params, _this);

    let cachedProgram = Shader.renderer.findCachedProgram(_this);

    if (!cachedProgram && !Shader.hasAlreadyPreProcessed(_this)) {
        Shader.runPreProcess(_this);
    }

}, _ => {
    Shader.FRONT_SIDE = 'shader_front_side';
    Shader.BACK_SIDE = 'shader_back_side';
    Shader.DOUBLE_SIDE = 'shader_double_side';
    Shader.DOUBLE_SIDE_TRANSPARENCY = 'shader_double_side_trasparency';
    Shader.ADDITIVE_BLENDING = 'shader_additive_blending';
    Shader.NORMAL_BLENDING = 'shader_normal_blending';
    Shader.PREMULTIPLIED_ALPHA_BLENDING = 'shader_premultiplied_alpha_blending';
    Shader.ADDITIVE_COLOR_ALPHA = 'shader_additive_color_alpha';
    Shader.CUSTOM_DEPTH = 'shader_custom_depth';
    Shader.COLOR_MASK_RGB = 'shader_colormask_rgb';
    Shader.COLOR_MASK_RGBA = 'shader_colormask_rgba';
    Shader.COLOR_MASK_NONE = 'shader_colormask_none';
    Shader.DEPTH_FUNC_NEVER = 'shader_depth_func_never';
    Shader.DEPTH_FUNC_LESS = 'shader_depth_func_less';
    Shader.DEPTH_FUNC_EQUAL = 'shader_depth_func_equal';
    Shader.DEPTH_FUNC_LEQUAL = 'shader_depth_func_lequal';
    Shader.DEPTH_FUNC_GREATER = 'shader_depth_func_greater';
    Shader.DEPTH_FUNC_NOTEQUAL = 'shader_depth_func_notequal';
    Shader.DEPTH_FUNC_GEQUAL = 'shader_depth_func_gequal';
    Shader.DEPTH_FUNC_ALWAYS = 'shader_depth_func_always';

    Shader.parseParams = function(_params, _this) {
        for (let key in _params) {

            // Custom params
            if (key == 'receiveShadow') {
                _this.receiveShadow = _params[key];
            } else if (key == 'receiveLight') {
                _this.receiveLight = _params[key];
            } else if (_params[key] && _params[key].value !== undefined) {
                // Retrieve UIL overrides if exists
                if (window.UILStorage && UILStorage.hasData()) {
                    _this.uniforms[key] = UILStorage.parse(_this.UILPrefix + key, _params[key].value) || _params[key];
                    if (!!_params[key].ubo) _this.uniforms[key].ubo = true;
                } else {
                    _this.uniforms[key] = _params[key];
                }
            } else {
                if (key == 'unique') continue;
                _this[key] = _params[key];
            }
        }
    }

    Shader.runPreProcess = function(shader) {
        shader.vertexShader = Shader.process(Shaders.getShader(shader.vsParam + '.vs'), 'vs', shader, shader.onBeforeBuild);
        shader.fragmentShader = Shader.process(Shaders.getShader(shader.fsParam + '.fs'), 'fs', shader, shader.onBeforeBuild);

        if (shader.vertexShader.includes('//js') && !window[shader.vsName]) {
            let code = shader.vertexShader.split('\n');
            let adders = [];
            code.forEach(line => {
                if (line.includes('//js')) {
                    let name = line.split(' ')[2].replace(';', '');
                    let value = line.split('//js ')[1].replace(';', '');
                    adders.push(obj => {
                        obj[name] = { value: eval(value) };
                    });
                } else if (line.includes('sampler2D')) {
                    let name = line.split(' ')[2].replace(';', '');
                    adders.push(obj => {
                        obj[name] = {value: null}
                    });
                }
            });
            window[shader.vsName] = function(_mesh, _shader) {
                let uniforms = {};
                adders.forEach(addTo => addTo(uniforms));
                _shader.addUniforms(uniforms);
            };
        }
    }

    Shader.process = function(code, type, _this, _onBeforeBuild) {
        const WEBGL2 = Renderer.type == Renderer.WEBGL2;

        if (!code) throw 'No shader found! ' + _this.vsName + ' | ' + _this.fsName;
        const externalOES = code.includes('samplerExternalOES') && window.AURA && Device.system.os == 'android';
        const standardDeriv = !WEBGL2 && code.includes(['fwidth', 'dFdx', 'dFdy']);
        const drawBuffers = !WEBGL2 && code.includes(['gl_FragData', '#drawbuffer']) && (window.World && World.NUKE.useDrawBuffers);
        let levelOfDetail = !WEBGL2 && code.includes(['textureGrad', 'textureProjGrad', 'texture2DGrad', 'textureCubeGrad', 'texture2DProjGrad']);
        if (!levelOfDetail && !WEBGL2 && type === 'fs') levelOfDetail = code.includes(['textureLod', 'texture2DLod', 'textureCubeLod', 'texture2DProjLod']);
        const layoutsDefined = code.includes('layout') || _this.globalIllumination;


        let header;
        if (type == 'vs') {
            header = [
                '#version 300 es',
                externalOES ? '#extension GL_OES_EGL_image_external_essl3 : require' : '',
                levelOfDetail ? '#extension GL_EXT_shader_texture_lod : enable' : '',

                `precision ${_this.precision}p float;`,
                `precision ${_this.precision}p int;`,
                WEBGL2 ? `precision ${_this.precision}p sampler3D;`  :'',

                'attribute vec2 uv;',
                'attribute vec3 position;',
                'attribute vec3 normal;',

                'uniform mat3 normalMatrix;',
                'uniform mat4 modelMatrix;',
                'uniform mat4 modelViewMatrix;',

                'uniform global {',
                'mat4 projectionMatrix;',
                'mat4 viewMatrix;',
                'vec3 cameraPosition;',
                'vec4 cameraQuaternion;',
                'vec2 resolution;',
                'float time;',
                'float timeScale;',
                '};',

            ].join('\n');
        } else {

            header = [
                '#version 300 es',
                externalOES ? '#extension GL_OES_EGL_image_external_essl3 : require' : '',
                standardDeriv ? '#extension GL_OES_standard_derivatives : enable' : '',
                drawBuffers ? '#extension GL_EXT_draw_buffers : require' : '',
                levelOfDetail ? '#extension GL_EXT_shader_texture_lod : enable' : '',

                `precision ${_this.precision}p float;`,
                `precision ${_this.precision}p int;`,
                WEBGL2 ? `precision ${_this.precision}p sampler3D;`  :'',

                'uniform mat3 normalMatrix;',
                'uniform mat4 modelMatrix;',
                'uniform mat4 modelViewMatrix;',

                'uniform global {',
                'mat4 projectionMatrix;',
                'mat4 viewMatrix;',
                'vec3 cameraPosition;',
                'vec4 cameraQuaternion;',
                'vec2 resolution;',
                'float time;',
                'float timeScale;',
                '};',

                layoutsDefined ? '' : 'out vec4 FragColor;'


            ].join('\n');
        }

        header += '\n__ACTIVE_THEORY_LIGHTS__\n\n';
        if (window.AURA) header += '#define AURA\n';
        if (_this.defines) _this.defines.forEach(d => header += `#define ${d.toUpperCase()}\n`);

        if (_onBeforeBuild) code = _onBeforeBuild(code, type);

        if(_this.globalIllumination) {
            let GIVaryings = [
                `varying vec4 vPosDeferred;`,
                `varying vec3 vNormalDeferred;`,
            ].join('\n');
            header += GIVaryings;
        }

        let split = code.split('\n');
        for (let i = split.length-1; i > -1; i--) {
            let line = split[i];
            if (line.includes('uniform sampler2D')) {
                let name = line.split('sampler2D ')[1].replace(';', '').trim();
                if (!_this.uniforms[name]) _this.uniforms[name] = {value: null};
            }
        }

        //Deferred buffers for the global illumination
        if(_this.globalIllumination && type == "fs") {

            let buffersDeferred = `
            #drawbuffer PositionLayer gl_FragColor = vPosDeferred;
            #drawbuffer NormalsLayer gl_FragColor = vec4(vNormalDeferred, 1.);
            `;

            let main = code.split('main() {');
            main[1] = '\n' + buffersDeferred + main[1];
            code = main.join('main() {');

        }

        code = header + code;

        return code;
    }

    function getLightingCode(_this) {
        if (!_this.receiveShadow && Shader.shouldReceiveShadow(_this)) _this.receiveShadow = true;
        if (!_this.receiveLight || _this.isShadow) return '';

        let lighting = Lighting.getLighting(_this);
        let numLights = lighting.position.length/4;

        if (numLights == 0) return Lighting.getShadowUniforms(_this);

        let lights = [
            `#define NUM_LIGHTS ${numLights}`,
            `uniform lights {`,
            `vec4 lightPos[${numLights}];`,
            `vec4 lightColor[${numLights}];`,
            `vec4 lightData[${numLights}];`,
            `vec4 lightData2[${numLights}];`,
            `vec4 lightData3[${numLights}];`,
            `vec4 lightProperties[${numLights}];`,
            `};`,
        ].join('\n');

        return lights + Lighting.getShadowUniforms(_this);
    }

    function setupGlobalIllumination(code, type, _this) {

        //for the vertex shader
        if(type == "vs") {

            //Checks if the position is defined
            //this is to ba able to define custom vertex animations
            //the final position should be defined based on the pos variable.
            if(!code.includes('vec3 pos = position;')) {
                throw `Shader ${_this.vsName} needs to have "vec3 pos = position;" in order for dynamic merging to work`;
            }

            //Sets the varying for the deferred rendering.
            let vsDeferred = `
            vPosDeferred = modelViewMatrix * vec4(pos, 1.);
            vNormalDeferred = normalMatrix * normal;
            `;

            let main = code.split('vec3 pos = position;');
            main[1] = '\n' + vsDeferred + main[1];
            code = main.join('vec3 pos = position;');

        }

        return code;

    }

    const prototype = Shader.prototype;

    /**
     * If linked, any changes to one uniform will update both. Non-linked it just a snapshot copy.
     * @name copyUniformsTo
     * @memberof Shader
     *
     * @function
     * @param {Shader} shader
     * @param {Boolean} linked
     */
    prototype.copyUniformsTo = function(shader, linked, ignore) {
        for (let key in this.uniforms) {
            if (this.uniforms[key] === undefined) continue;
            if (ignore && ignore.includes?.(key)) continue;
            shader.uniforms[key] = linked ? this.uniforms[key] : {type: this.uniforms[key].type, value: this.uniforms[key].value};
        }
    }

    prototype.addUniforms = function(uniforms) {
        if (uniforms.UILPrefix) {
            this.UILPrefix = uniforms.UILPrefix;
            delete uniforms.UILPrefix;
        }

        for (let key in uniforms) {
            if (!this.hotReloading || !this.uniforms[key]) this.uniforms[key] = uniforms[key];
        }
    }

    prototype.draw = function(mesh, geom) {
        if (this.receiveLight && !this.__lighting) Lighting.getLighting(this);
        Shader.renderer.draw(this, mesh, geom);
    }

    prototype.upload = function(mesh, geom) {
        if (!this.receiveShadow && Shader.shouldReceiveShadow(this)) this.receiveShadow = true;
        Shader.renderer.upload(this, mesh, geom);
        if (this.receiveShadow && !this.shadow) Lighting.initShadowShader(this, mesh);
    }

    prototype.destroy = function() {
        if (!this.persists) {
            Shader.renderer.destroy(this);
            if (this.shadow) this.shadow.destroy();
        }
        if (this.receiveLight) Lighting.destroyShader(this);
    }

    prototype.onBeforeCompile = function(code, type) {
        const WEBGL2 = Renderer.type == Renderer.WEBGL2;

        code = code.trim();
        if (code[code.length-1] != '}') code += '\n}';

        let p = this.mesh;
        let scene = World.SCENE;
        while (p) {
            if (p instanceof Scene) scene = p;
            p = p._parent;
        }
        if (scene.nuke && scene.nuke.onBeforeShaderCompile) {
            scene.nuke.onBeforeShaderCompile(this.mesh);
        } else {
            this.onBeforePrecompilePromise.resolve();
        }

        if (this.receiveShadow) this.receiveLight = true;

        let varyings = [];
        let uniforms = [];

        if(this.globalIllumination) code = setupGlobalIllumination(code, type, this);

        code = code.split('\n');
        code.forEach((line, index) => {
            if (type == 'fs') {
                if (line.includes('#drawbuffer')) {
                    if (line.includes('#drawbuffer Color')) code[index] = line.replace('#drawbuffer Color', '');
                    else code[index] = '';
                }
            }

            if (line.includes('varying')) varyings.push(line.trim());
            if (line.includes('uniform')) uniforms.push(line.trim());
        });
        code = code.join('\n');

        const process = function(array) {
            let counts = [];
            let replace;
            array.forEach(value => {
                let count = 0;
                array.forEach(v2 => {
                    if (value == v2) count++;
                });
                if (count > 1) {
                    if (!replace) replace = [];
                    if (!replace.includes(value)) {
                        replace.push(value);
                        counts.push(count);
                    }
                }
            });

            if (replace) {
                replace.forEach((value, i) => {
                    let count = counts[i];
                    for (let j = 0; j < count-1; j++) {
                        let index = code.lastIndexOf(value);
                        code = code.substring(0, index) + code.substring(index + value.length);
                    }
                });
            }
        };

        process(varyings);
        process(uniforms);

        if (type == 'fs') {
            if (WEBGL2) {
                if (code.includes('gl_FragColor')) code = code.replace(/gl_FragColor/g, 'FragColor');
            } else {
                if (code.includes('#applyShadow')) code = code.replace('#applyShadow', '');
            }
        }

        code = code.replace('__ACTIVE_THEORY_LIGHTS__', getLightingCode(this));

        if (type == 'fs' && code.includes('SHADOW_MAPS')) code = require('GLSLOptimizer')(code.replace('SHADOW_COUNT', Lighting.getShadowCount(this)));

        if (this.preCompile) code = this.preCompile(code, type);

        let converter = require('ShaderCode');
        if (!WEBGL2) {
            code = converter.convertWebGL1(code, type);
        } else {
            code = converter.convertWebGL2(code, type);
        }

        return code;
    }

    /**
     * @name set
     * @memberof Shader
     *
     * @function
     * @param {String} key
     * @param {*} [value]
     * @returns {*} value of uniform
     */
    prototype.set = function(key, value, ref) {
        let _this = ref || this;
        if (!_this.uniforms[key]) return console.warn(`No key ${key} found on shader`, _this);
        if (typeof value !== 'undefined') {
            TweenManager.clearTween(_this.uniforms[key]);
            _this.uniforms[key].value = value;
            if (_this.ubo) _this.ubo.needsUpdate = true;
        }
        return _this.uniforms[key].value;
    };

    /**
     * @name get
     * @memberof Shader
     *
     * @function
     * @param {String} key
     * @returns {*} value of uniform
     */
    prototype.get = function(key, ref) {
        let _this = ref || this;
        return _this.uniforms[key] && _this.uniforms[key].value;
    };

    /**
     * @name tween
     * @memberof Shader
     *
     * @function
     * @param {String} key
     * @param {*} value
     * @param {Number} time
     * @param {String} ease
     * @param {Number} [delay]
     * @returns {Tween}
     */
    prototype.tween = function(key, value, time, ease, delay, callback, update, scaledTime) {
        if (typeof value === 'number') {
            return tween(this.uniforms[key], {value: value}, time, ease, delay, callback, update, null, scaledTime);
        } else {
            return tween(this.uniforms[key].value, value, time, ease, delay, callback, update, null, scaledTime);
        }
    }

    /**
     * @name clone
     * @memberof Shader
     *
     * @function
     */
    prototype.clone = function(noShadows, postfix) {
        const _this = this;

        if (noShadows) _this.params.receiveShadow = false;
        let shader = new Shader(_this.vsParam, _this.fsParam, _this.params, null, postfix);

        for (let key in _this) {
            if (key.includes(['vsName', 'fsName', 'uniforms', '_uniform', '_gl']) || typeof _this[key] === 'function') continue;
            shader[key] = _this[key];
        }

        for (let key in _this.uniforms) {
            shader.uniforms[key] = {type: _this.uniforms[key].type, value: _this.uniforms[key].value};
        }
        return shader;
    }

    prototype.resetProgram = function() {
        this.destroy();
        this.vertexShader = this.restoreVS || Shader.process(Shaders.getShader(this.vsName + '.vs'), 'vs', this, this.onBeforeBuild);
        this.fragmentShader = this.restoreFS || Shader.process(Shaders.getShader(this.fsName + '.fs'), 'fs', this, this.onBeforeBuild);
    }


    var _shaderShadowMap = {};
    var _emptyShadowMap;
    Object.defineProperty(prototype, 'receiveShadow', {
        set: function(v) {
            _shaderShadowMap[this.vsName+'_'+this.fsName] = v;
            this._receiveShadow = v;
            if (v && !this.uniforms.shadowMap) {
                if (!_emptyShadowMap) _emptyShadowMap = [Utils3D.getEmptyTexture()];
                this.uniforms.shadowMap = {value: _emptyShadowMap};
            }
        },

        get: function() {
            return this._receiveShadow;
        }
    });

    let shaders = {};
    Shader.hasAlreadyPreProcessed = function(shader) {
        let key = shader.vsName+'_'+shader.vsName+'_'+shader.customCompile;
        return shaders[key];
    }

    Shader.registerPreProcess = function(shader) {
        let key = shader.vsName+'_'+shader.vsName+'_'+shader.customCompile;
        shaders[key] = true;
    }

    Shader.shouldReceiveShadow = function(shader) {
        return _shaderShadowMap[shader.vsName+'_'+shader.fsName];
    }
});

Shader.createUniforms = function(shader) {
    let uniforms = {};
    let handler = {
        set (target, property, value) {
            target[property] = value;
            shader._uniformKeys.length = 0;
            shader._uniformValues.length = 0;
            for (let key in uniforms) {
                shader._uniformKeys.push(key);
                shader._uniformValues.push(uniforms[key]);
            }
            return true;
        }
    };

    shader._uniformValues = [];
    shader._uniformKeys = [];

    return new Proxy(uniforms, handler);
};

/**
 * @name Shader.FRONT_SIDE
 * @memberof Shader
 * @property
 */

/**
 * @name Shader.BACK_SIDE
 * @memberof Shader
 * @property
 */

/**
 * @name Shader.DOUBLE_SIDE
 * @memberof Shader
 * @property
 */

/**
 * @name Shader.DOUBLE_SIDE_TRANSPARENCY
 * @memberof Shader
 * @property
 */

/**
 * @name Shader.ADDITIVE_BLENDING
 * @memberof Shader
 * @property
 */

/**
 * @name Shader.NORMAL_BLENDING
 * @memberof Shader
 * @property
 */

/**
 * @name Shader.PREMULTIPLIED_ALPHA_BLENDING
 * @memberof Shader
 * @property
 */

 /**
 * @name Shader.ADDITIVE_COLOR_ALPHA
 * @memberof Shader
 * @property
 */

/**
 * @name Shader.CUSTOM_DEPTH
 * @memberof Shader
 * @property
 */

/**
 * @name Texture
 * @param {Image} img
 */

class Texture {
    constructor(img) {
        this.magFilter = Texture.LINEAR;
        this.minFilter = Texture.LINEAR_MIPMAP;
        this.format = Texture.RGBAFormat;
        this.wrapS = this.wrapT = Texture.CLAMP_TO_EDGE;
        this._image = img;
        this.needsUpdate = true;
        this.generateMipmaps = true;
        this.anisotropy = 1;
        this.type = Texture.UNSIGNED_BYTE;
        this.isTexture = true;

        if (img && img.onCreateTexture) img.onCreateTexture(this);

        /**
         * @name magFilter
         * @memberof Texture
         * @property
         */

        /**
         * @name minFilter
         * @memberof Texture
         * @property
         */

        /**
         * @name format
         * @memberof Texture
         * @property
         */

        /**
         * @name wrapS
         * @memberof Texture
         * @property
         */

        /**
         * @name wrapT
         * @memberof Texture
         * @property
         */

        /**
         * @name image
         * @memberof Texture
         * @property
         */

        /**
         * @name needsUpdate
         * @memberof Texture
         * @property
         */

        /**
         * @name generateMipmaps
         * @memberof Texture
         * @property
         */

        /**
         * @name anisotropy
         * @memberof Texture
         * @property
         */

        /**
         * @name type
         * @memberof Texture
         * @property
         */
    }

    set image(img) {
        this._image = img;
        if (img && img.onCreateTexture) img.onCreateTexture(this);
    }

    get image() {
        return this._image;
    }

    upload() {
        if (!this._gl) Texture.renderer.upload(this);
    }

    destroy() {
        Texture.renderer.destroy(this);
        this._image = null;
    }

    clone() {
        let texture = new Texture(this.img);
        texture.format = this.format;
        texture.type = this.type;
        texture.anisotropy = this.anisotropy;
        texture.wrapS = this.wrapS;
        texture.wrapT = this.wrapT;
        texture.generateMipmaps = this.generateMipmaps;
        texture.minFilter = this.minFilter;
        texture.magFilter = this.magFilter;
        return texture;
    }
}

/**
 * @name DataTexture
 * @param {Float32Array} data
 * @param {Number} width
 * @param {Number} height
 * @param {String} format
 * @param {String} type
 */
class DataTexture extends Texture {
    constructor(data, width, height, format, type) {
        super();
        if (format) this.format = format;

        this.width = width;
        this.height = height;
        this.data = data;
        this.minFilter = this.magFilter = Texture.NEAREST;
        this.generateMipmaps = false;
        this.type = type || Texture.FLOAT;
        this.isDataTexture = true;
        this.destroyDataAfterUpload = false;
    }

    uploadAsync() {
        return Texture.renderer.uploadAsync(this);
    }
}

/**
 * @name Texture3D
 * @param {Float32Array} image
 * @param {Number} width
 * @param {Number} height
 * @param {String} format
 */
class Texture3D extends Texture {

    constructor(image, width, height, depth) {
        super();
        this.format = Texture.RGBAFormat;
        this.width = width;
        this.height = height;
        this.depth = depth;
        this.image = image;
        this.minFilter = this.magFilter = Texture.LINEAR;
        this.wrapS = this.wrapT =  this.wrapR = Texture.CLAMP_TO_EDGE;
        this.generateMipmaps = false;
        this.type = Texture.FLOAT;
        this.isTexture3D = true;
    }

}

Texture.NEAREST = 'texture_nearest';
Texture.CLAMP_TO_EDGE = 'texture_clamp';
Texture.REPEAT = 'texture_repeat';
Texture.MIRROR_REPEAT = 'texture_mirror_repeat';
Texture.LINEAR = 'texture_linear';
Texture.LINEAR_MIPMAP = 'texture_linear_mip';
Texture.LINEAR_MIPMAP_NEAREST = 'texture_linear_mip_nearest';
Texture.NEAREST_MIPMAP = 'texture_nearest_mip';
Texture.RGBFormat = 'texture_rgbFormat';
Texture.RGBAFormat = 'texture_rgbaFormat';
Texture.UNSIGNED_BYTE = 'texture_unsigned_byte';
Texture.DEPTH = 'texture_depth';
Texture.FLOAT = 'texture_float';
Texture.HALF_FLOAT = 'texture_half_float';

/**
 * @name Texture.NEAREST
 * @memberof Texture
 * @property
 */

/**
 * @name Texture.CLAMP_TO_EDGE
 * @memberof Texture
 * @property
 */

/**
 * @name Texture.REPEAT
 * @memberof Texture
 * @property
 */

/**
 * @name Texture.LINEAR
 * @memberof Texture
 * @property
 */

/**
 * @name Texture.LINEAR_MIPMAP
 * @memberof Texture
 * @property
 */

/**
 * @name Texture.LINEAR_MIPMAP_NEAREST
 * @memberof Texture
 * @property
 */

/**
 * @name Texture.NEAREST_MIPMAP
 * @memberof Texture
 * @property
 */

/**
 * @name Texture.RGBFormat
 * @memberof Texture
 * @property
 */

/**
 * @name Texture.RGBAFormat
 * @memberof Texture
 * @property
 */

/**
 * @name Texture.UNSIGNED_BYTE
 * @memberof Texture
 * @property
 */

/**
 * @name Texture.DEPTH
 * @memberof Texture
 * @property
 */

/**
 * @name Texture.FLOAT
 * @memberof Texture
 * @property
 */

/**
 * @name Texture.HALF_FLOAT
 * @memberof Texture
 * @property
 */
Module(function GLSLOptimizer() {

    function unrollLoops( string ) {
        let pattern = /#pragma unroll_loop[\s]+?for \(int i \= (\d+)\; i < (\d+)\; i\+\+\) \{([\s\S]+?)(?=\})\}/g;
        function replace( match, start, end, snippet ) {
            let unroll = '';
            for ( let i = parseInt( start ); i < parseInt( end ); i ++ ) {
                unroll += snippet.replace( /\[i\]/g, '['+ i +']' );
            }

            return unroll;
        }

        return string.replace(pattern, replace);
    }

    this.exports = function(code) {
        return unrollLoops(code);
    }
});
Module(function GLTypes() {
    function getFormat(texture) {
        let _gl = Renderer.context;
        return texture.format == Texture.RGBAFormat ? _gl.RGBA : _gl.RGB;
    }
    
    function getInternalFormat(texture) {
        let _gl = Renderer.context;
        return texture.format == Texture.RGBAFormat ? _gl.RGBA8 : _gl.RGB8;
    }

    function getProperty(property) {
        let _gl = Renderer.context;
        switch (property) {
            case Texture.NEAREST: return _gl.NEAREST; break;
            case Texture.LINEAR: return _gl.LINEAR; break;
            case Texture.LINEAR_MIPMAP: return _gl.LINEAR_MIPMAP_LINEAR; break;
            case Texture.NEAREST_MIPMAP: return _gl.NEAREST_MIPMAP_LINEAR; break;
            case Texture.LINEAR_MIPMAP_NEAREST: return _gl.LINEAR_MIPMAP_NEAREST; break;
            case Texture.CLAMP_TO_EDGE: return _gl.CLAMP_TO_EDGE; break;
            case Texture.REPEAT: return _gl.REPEAT; break;
            case Texture.MIRROR_REPEAT: return _gl.MIRRORED_REPEAT; break;
        }
    }

    function getType(texture) {
        let _gl = Renderer.context;
        switch (texture.type) {
            case Texture.FLOAT:
                return _gl.FLOAT;
                break;

            case Texture.HALF_FLOAT:
                if (Renderer.type == Renderer.WEBGL2) return _gl.HALF_FLOAT;
                else return Renderer.extensions.halfFloat.HALF_FLOAT_OES;
                break;

            default:
                return _gl.UNSIGNED_BYTE;
                break;
        }
    }

    function getFloatParams(texture) {
        let _gl = Renderer.context;
        let internalformat = (function() {
            if (Renderer.type == Renderer.WEBGL2) {
                switch (texture.type) {
                    case Texture.HALF_FLOAT:
                        return texture.format == Texture.RGBAFormat ? _gl.RGBA16F : _gl.RGB16F;

                    case Texture.FLOAT:
                        return texture.format == Texture.RGBAFormat ? _gl.RGBA32F : _gl.RGB32F;
                        break;
                }

                return texture.format == Texture.RGBAFormat ? _gl.RGBA : _gl.RGB;
            } else {
                return texture.format == Texture.RGBAFormat ? _gl.RGBA : _gl.RGB;
            }
        })();

        let format = texture.format == Texture.RGBAFormat ? _gl.RGBA : _gl.RGB;

        let type = getType(texture);

        return {internalformat, format, type};
    }

    this.exports = {
        getFormat,
        getInternalFormat,
        getProperty,
        getType,
        getFloatParams
    };
});
Module(function ShaderCode() {
    // Match texture, textureLod, textureGrad, textureProjLod, textureProjGrad
    // as well as the texture2D/textureCube versions of those.
    let textureExpression = /texture(2D|Cube)?(\w+)?\s*\(/g;

    function removeUBO(code, name) {
        let uniforms = code.split(`uniform ${name} {`)[1];
        uniforms = uniforms.split('};')[0];

        uniforms = uniforms.split('\n');
        uniforms.forEach(u => {
            u = u.trim();
            if (!u.length) return;
            code = code.replace(u, 'uniform '+u);
        });

        let split = code.split(`uniform ${name} {`);
        split[1] = split[1].replace('};', '');
        code = split.join('');
        code = code.replace(`uniform ${name} {`, '');
        return code;
    }

    function convertWebGL1(code, type) {
        code = code.replace('#version 300 es', '');

        code = code.replace('out vec4 FragColor;', '');
        if (code.includes('samplerExternalOES')) code = code.replace('samplerExternalOES', 'sampler2D');

        code = code.replace(textureExpression, function(match, samplerType, suffix = '', offset, origCode) {
            if (!samplerType) {
                // Need to figure out the sampler type from the code
                let name = origCode.substring(offset + match.length)
                    .split(',', 1)[0]?.trim();
                if (name) {
                    samplerType = new RegExp(`sampler(\\w+)\\s+${name}`).exec(origCode)?.[1];
                }
                if (!samplerType) {
                    // Guess the most likely type
                    samplerType = '2D';
                }
            }
            if (suffix.endsWith('EXT')) suffix = suffix.slice(0, -3);
            if (type === 'vs') {
                // Lod supported in vertex shader without extension
                if (['Lod', 'ProjLod'].includes(suffix)) return `texture${samplerType}${suffix}(`;
            }
            if (['Lod', 'Grad', 'ProjLod', 'ProjGrad'].includes(suffix)) {
                if (!Renderer.extensions.lod) {
                    // Fall back to bias where possible: textureLod, textureProjLod
                    if (suffix.endsWith('Lod')) {
                        suffix = suffix.slice(0, -3);
                    }
                    // TODO maybe support Grad, ProjGrad by stripping off dPdx and dPdy params.
                    //   But that would require actual parsing.
                } else {
                    return `texture${samplerType}${suffix}EXT(`;
                }
            }
            return `texture${samplerType}${suffix}(`;
        });

        if (code.includes('uniform global {')) code = removeUBO(code, 'global');
        if (code.includes('uniform ubo {')) code = removeUBO(code, 'ubo');
        if (code.includes('uniform lights {')) code = removeUBO(code, 'lights');
        return code;
    }

    function convertWebGL2(code, type) {
        if (type == 'vs') {
            code = code.replace(/attribute/g, 'in');
            code = code.replace(/varying/g, 'out');
        } else {
            code = code.replace(/varying/g, 'in');
        }

        code = code.replace(textureExpression, function(match, samplerType, suffix = '') {
            if (suffix.endsWith('EXT')) suffix = suffix.slice(0, -3);
            return `texture${suffix}(`;
        });

        if (code.includes('samplerExternalOES') && !(Device.system.os == 'android' && window.AURA)) code = code.replace('samplerExternalOES', 'sampler2D');

        if (!Renderer.UBO) {
            if (code.includes('uniform global {')) code = removeUBO(code, 'global');
            if (code.includes('uniform ubo {')) code = removeUBO(code, 'ubo');
            if (code.includes('uniform lights {')) code = removeUBO(code, 'lights');
        } else {
            if (code.includes('uniform global {')) code = code.replace('uniform global', 'layout(std140) uniform global');
            if (code.includes('uniform ubo {')) code = code.replace('uniform ubo', 'layout(std140) uniform ubo');
            if (Lighting.UBO) {
                if (code.includes('uniform lights {')) code = code.replace('uniform lights', 'layout(std140) uniform lights');
            } else {
                if (code.includes('uniform lights {')) code = removeUBO(code, 'lights');
            }
        }

        return code;
    }

    this.exports = {convertWebGL1, convertWebGL2};
});

class UBO {
    constructor(location, gl = Renderer.context) {
        this.gl = gl;

        this.arrays = [];
        for (let i = 0; i < 30; i++) this.arrays.push([]);
        this.arrayIndex = 0;

        this.objects = [];
        this.location = location;
        this.data = null;
        this.lastUpdate = 0;
    }

    _getSize(uniform) {
        let obj = uniform.value;
        if (Array.isArray(obj)) {
            if (uniform.components) return (obj.length/uniform.components) * 16;
            return obj.length * 16;
        }
        if (obj instanceof Vector2) return 8;
        if (obj instanceof Vector3) return 16;
        if (obj instanceof Vector4) return 16;
        if (obj instanceof Color) return 16;
        if (obj instanceof Matrix4) return 16*4;
        if (obj instanceof Matrix3) return 16*3;
        if (obj instanceof Quaternion) return 16;
        return 4;
    }

    _getValues(uniform) {
        let obj = uniform.value;
        if (Array.isArray(obj)) return obj;
        if (obj instanceof Vector2) return this._array(obj.x, obj.y);
        if (obj instanceof Vector3) return this._array(obj.x, obj.y, obj.z);
        if (obj instanceof Matrix4) return obj.elements;
        if (obj instanceof Matrix3) return obj.elements;
        if (obj instanceof Color) return this._array(obj.r, obj.g, obj.b);
        if (obj instanceof Quaternion) return this._array(obj.x, obj.y, obj.z, obj.w);
        return this._array(obj);
    }

    _array() {
        if (this.arrayIndex++ >= this.arrays.length-1) this.arrayIndex = 0;
        let array = this.arrays[this.arrayIndex];
        array.length = 0;
        array.push.apply(array, arguments);
        return array;
    }

    clear() {
        for (let i = 0; i < this.arrays.length; i++) this.arrays[i].length = 0;
    }

    calculate() {
        let len = this.objects.length;

        let chunk = 16;
        let tsize = 0;
        let offset = 0;
        let size = 0;

        for (let i = 0; i < len; i++) {
            let obj = this.objects[i];
            size = this._getSize(obj);

            tsize = chunk - size;

            if (tsize < 0 && chunk < 16) {
                offset += chunk;
                if (i > 0) this.objects[i-1].chunkLen += chunk;
                chunk = 16;
            } else if (tsize < 0 && chunk == 16) {

            } else if (tsize == 0) {
                chunk = 16;
            } else {
                chunk -= size;
            }

            obj.offset = offset / 4;
            obj.chunkLen = size / 4;
            obj.dataLen = size / 4;

            offset += size;
        }

        if (offset % 16 != 0) {
            this.objects[this.objects.length-1].chunkLen += chunk / 4;
            offset += chunk;
        }

        return offset / 4;
    }

    compileData() {
        let array = this._array();
        let len = this.calculate();

        let i;

        for (i = 0; i < len; i++) array[i] = 0;

        for (i = 0; i < this.objects.length; i++) {
            let obj = this.objects[i];
            let values = this._getValues(obj);

            for (let j = 0; j < values.length; j++) {
                array[obj.offset + j] = values[j];
            }
        }

        return array;
    }

    upload() {
        if (this.data) return;
        let gl = Renderer.context;

        let array = this.compileData();
        if (!array.length) return;

        this.data = new Float32Array(array);

        this.buffer = gl.createBuffer();
        gl.bindBuffer(gl.UNIFORM_BUFFER, this.buffer);
        gl.bufferData(gl.UNIFORM_BUFFER, this.data, gl.DYNAMIC_DRAW);
        gl.bindBuffer(gl.UNIFORM_BUFFER, null);
        gl.bindBufferBase(gl.UNIFORM_BUFFER, this.location, this.buffer);
    }

    bind(program, name) {
        if (!this.data) this.upload();
        if (this.needsUpdate) this.update();
        let gl = Renderer.context;

        let location;
        if (program == this.lastProgram && name == this.lastName && this.lastLocation !== undefined) {
            location = this.lastLocation;
        } else {
            location = gl.getUniformBlockIndex(program, name);
        }

        if (location > 99999 || location == -1) return;
        gl.uniformBlockBinding(program, location, this.location);
        gl.bindBufferBase(gl.UNIFORM_BUFFER, this.location, this.buffer);

        this.lastProgram = program;
        this.lastName = name;
        this.lastLocation = location;
    }

    update() {
        if (!this.data) this.upload();
        if (!this.data) return;

        let gl = Renderer.context;
        let array = this.compileData();

        if (array.length != this.data.length) {
            this.data = new Float32Array(array);
            this.upload();
        }
        this.data.set(array);
        gl.bindBuffer(gl.UNIFORM_BUFFER, this.buffer);
        gl.bufferSubData(gl.UNIFORM_BUFFER, 0, this.data);
        gl.bindBuffer(gl.UNIFORM_BUFFER, null);

        this.needsUpdate = false;
    }

    unbind() {
        // let gl = this.gl;
        // gl.bindBufferBase(gl.UNIFORM_BUFFER, null);
    }

    push() {
        if (this.data) throw `Can't modify UBO after initial upload!`;
        for (let i = 0; i < arguments.length; i++) this.objects.push(arguments[i]);
    }

    destroy() {
        let gl = this.gl;
        gl.deleteBuffer(this.buffer);
    }
}
class VAO {
    constructor(gl) {
        this.gl = gl;
        this.WEBGL2 = Renderer.type == Renderer.WEBGL2;

        if (this.WEBGL2) {
            this.vao = gl.createVertexArray();
        } else {
            this.vao = Renderer.extensions.VAO.createVertexArrayOES();
        }
    }

    bind() {
        const gl = this.gl;

        if (this.WEBGL2) {
            gl.bindVertexArray(this.vao);
        } else {
            Renderer.extensions.VAO.bindVertexArrayOES(this.vao);
        }
    }

    unbind() {
        const gl = this.gl;

        if (this.WEBGL2) {
            gl.bindVertexArray(null);
        } else {
            Renderer.extensions.VAO.bindVertexArrayOES(null);
        }
    }

    destroy() {
        const gl = this.gl;

        if (this.WEBGL2) {
            gl.deleteVertexArray(this.vao)
        } else {
            Renderer.extensions.VAO.deleteVertexArrayOES(this.vao);
        }

        this.vao = null;
    }
}
class BoxGeometry extends Geometry {
    constructor(width = 1, height = 1, depth = 1, widthSegments = 1, heightSegments = 1, depthSegments = 1) {
        super();

        widthSegments = Math.floor(widthSegments);
        heightSegments = Math.floor(heightSegments);
        depthSegments = Math.floor(depthSegments);

        let indices = [];
        let vertices = [];
        let normals = [];
        let uvs = [];
        let numberOfVertices = 0;

        buildPlane('z', 'y', 'x', - 1, - 1, depth, height, width, depthSegments, heightSegments, 0);
        buildPlane('z', 'y', 'x', 1, - 1, depth, height, - width, depthSegments, heightSegments, 1);
        buildPlane('x', 'z', 'y', 1, 1, width, depth, height, widthSegments, depthSegments, 2);
        buildPlane('x', 'z', 'y', 1, - 1, width, depth, - height, widthSegments, depthSegments, 3);
        buildPlane('x', 'y', 'z', 1, - 1, width, height, depth, widthSegments, heightSegments, 4);
        buildPlane('x', 'y', 'z', - 1, - 1, width, height, - depth, widthSegments, heightSegments, 5);

        this.index = new (Geometry.arrayNeedsUint32(indices) ? Uint32Array : Uint16Array)(indices);
        this.addAttribute('position', new GeometryAttribute(new Float32Array(vertices), 3));
        this.addAttribute('normal', new GeometryAttribute(new Float32Array(normals), 3));
        this.addAttribute('uv', new GeometryAttribute(new Float32Array(uvs), 2));

        function buildPlane(u, v, w, udir, vdir, width, height, depth, gridX, gridY, materialIndex) {
            let segmentWidth = width / gridX;
            let segmentHeight = height / gridY;
            let widthHalf = width / 2;
            let heightHalf = height / 2;
            let depthHalf = depth / 2;
            let gridX1 = gridX + 1;
            let gridY1 = gridY + 1;
            let vertexCounter = 0;
            let ix, iy;
            let vector = new Vector3();

            for (iy = 0; iy < gridY1; iy ++) {
                let y = iy * segmentHeight - heightHalf;
                for (ix = 0; ix < gridX1; ix ++) {
                    let x = ix * segmentWidth - widthHalf;

                    vector[u] = x * udir;
                    vector[v] = y * vdir;
                    vector[w] = depthHalf;
                    vertices.push(vector.x, vector.y, vector.z);

                    vector[u] = 0;
                    vector[v] = 0;
                    vector[w] = depth > 0 ? 1 : - 1;
                    normals.push(vector.x, vector.y, vector.z);

                    uvs.push(ix / gridX);
                    uvs.push(1 - (iy / gridY));

                    vertexCounter += 1;
                }
            }

            for (iy = 0; iy < gridY; iy ++) {
                for (ix = 0; ix < gridX; ix ++) {
                    let a = numberOfVertices + ix + gridX1 * iy;
                    let b = numberOfVertices + ix + gridX1 * (iy + 1);
                    let c = numberOfVertices + (ix + 1) + gridX1 * (iy + 1);
                    let d = numberOfVertices + (ix + 1) + gridX1 * iy;

                    indices.push( a, b, d );
                    indices.push( b, c, d );
                }
            }
            numberOfVertices += vertexCounter;
        }
    };
}
class CircleGeometry extends Geometry {
    constructor(radius = 1, segments = 8, thetaStart = 0, thetaLength = Math.PI * 2) {
        super();

        var indices = [];
        var vertices = [];
        var normals = [];
        var uvs = [];

        var i, s;
        var vertex = new Vector3();
        var uv = new Vector2();

        vertices.push( 0, 0, 0 );
        normals.push( 0, 0, 1 );
        uvs.push( 0.5, 0.5 );

        for (s = 0, i = 3; s <= segments; s ++, i += 3) {
            var segment = thetaStart + s / segments * thetaLength;

            vertex.x = radius * Math.cos( segment );
            vertex.y = radius * Math.sin( segment );

            vertices.push( vertex.x, vertex.y, vertex.z );

            normals.push( 0, 0, 1 );

            uv.x = ( vertices[ i ] / radius + 1 ) / 2;
            uv.y = ( vertices[ i + 1 ] / radius + 1 ) / 2;
            uvs.push( uv.x, uv.y );
        }

        for ( i = 1; i <= segments; i ++ ) {
            indices.push( i, i + 1, 0 );
        }

        this.index = new (Geometry.arrayNeedsUint32(indices) ? Uint32Array : Uint16Array)(indices);
        this.addAttribute( 'position', new GeometryAttribute(new Float32Array(vertices), 3));
        this.addAttribute( 'normal', new GeometryAttribute(new Float32Array(normals), 3));
        this.addAttribute( 'uv', new GeometryAttribute(new Float32Array(uvs), 2));
    }
}
class CylinderGeometry extends Geometry {
    constructor(radiusTop = 1, radiusBottom = 1, height = 1, radialSegments = 8, heightSegments = 1, openEnded = false, thetaStart = 0, thetaLength = Math.PI*2, planarMapping = false) {
        super();

        radialSegments = Math.floor(radialSegments);
        heightSegments = Math.floor(heightSegments);

        let indices = [];
        let vertices = [];
        let normals = [];
        let uvs = [];

        let index = 0;
        let indexArray = [];
        let halfHeight = height / 2;

        generateTorso();

        if (openEnded === false) {
            if (radiusTop > 0) generateCap(true);
            if (radiusBottom > 0) generateCap(false);
        }

        this.index = new (Geometry.arrayNeedsUint32(indices) ? Uint32Array : Uint16Array)(indices);
        this.addAttribute('position', new GeometryAttribute(new Float32Array(vertices), 3));
        this.addAttribute('normal', new GeometryAttribute(new Float32Array(normals), 3));
        this.addAttribute('uv', new GeometryAttribute(new Float32Array(uvs), 2));

        function generateTorso() {
            let x, y;
            let uv = new Vector2();
            let normal = new Vector3();
            let vertex = new Vector3();
            let slope = (radiusBottom - radiusTop) / height;

            for (y = 0; y <= heightSegments; y++) {
                let indexRow = [];
                let v = y / heightSegments;
                let radius = v * (radiusBottom - radiusTop) + radiusTop;

                for (x = 0; x <= radialSegments; x++) {
                    let u = x / radialSegments;
                    let theta = u * thetaLength + thetaStart;
                    let sinTheta = Math.sin(theta);
                    let cosTheta = Math.cos(theta);

                    vertex.x = radius * sinTheta;
                    vertex.y = - v * height + halfHeight;
                    vertex.z = radius * cosTheta;
                    vertices.push(vertex.x, vertex.y, vertex.z);

                    normal.set(sinTheta, slope, cosTheta).normalize();
                    normals.push(normal.x, normal.y, normal.z);

                    if (planarMapping) {
                        uv.x = (cosTheta * 0.5) + 0.5;
                        uv.y = (sinTheta * 0.5) + 0.5;
                        uvs.push(uv.x, uv.y);
                    } else {
                        uvs.push(u, 1 - v);
                    }

                    indexRow.push(index++);
                }

                indexArray.push(indexRow);
            }

            for (x = 0; x < radialSegments; x++) {
                for (y = 0; y < heightSegments; y++) {
                    let a = indexArray[y][x];
                    let b = indexArray[y + 1][x];
                    let c = indexArray[y + 1][x + 1];
                    let d = indexArray[y][x + 1];

                    indices.push(a, b, d);
                    indices.push(b, c, d);
                }
            }
        }

        function generateCap(top) {
            let x, centerIndexStart, centerIndexEnd;
            let uv = new Vector2();
            let vertex = new Vector3();
            let radius = (top === true) ? radiusTop : radiusBottom;
            let sign = (top === true) ? 1 : - 1;
            let signV = planarMapping ? 1 : sign;

            centerIndexStart = index;

            for (x = 1; x <= radialSegments; x++) {
                vertices.push(0, halfHeight * sign, 0);
                normals.push(0, sign, 0);
                uvs.push(0.5, 0.5);
                index++;
            }

            centerIndexEnd = index;

            for (x = 0; x <= radialSegments; x++) {
                let u = x / radialSegments;
                let theta = u * thetaLength + thetaStart;
                let cosTheta = Math.cos(theta);
                let sinTheta = Math.sin(theta);

                vertex.x = radius * sinTheta;
                vertex.y = halfHeight * sign;
                vertex.z = radius * cosTheta;
                vertices.push(vertex.x, vertex.y, vertex.z);

                normals.push(0, sign, 0);

                uv.x = (cosTheta * 0.5) + 0.5;
                uv.y = (sinTheta * 0.5 * signV) + 0.5;
                uvs.push(uv.x, uv.y);

                index++;
            }

            for (x = 0; x < radialSegments; x++) {
                let c = centerIndexStart + x;
                let i = centerIndexEnd + x;

                if (top === true) {
                    indices.push(i, i + 1, c);
                } else {
                    indices.push(i + 1, i, c);
                }
            }
        }
    }
}

class ConeGeometry extends CylinderGeometry {
    constructor(radius, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength) {
        super(0, radius, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength);
    }
}
class PlaneGeometry extends Geometry {
    constructor(width = 1, height = 1, widthSegments = 1, heightSegments = 1) {
        super();
        let width_half = width / 2;
        let height_half = height / 2;

        let gridX = Math.floor( widthSegments ) || 1;
        let gridY = Math.floor( heightSegments ) || 1;

        let gridX1 = gridX + 1;
        let gridY1 = gridY + 1;

        let segment_width = width / gridX;
        let segment_height = height / gridY;

        let ix, iy;

        // buffers

        let indices = [];
        let vertices = [];
        let normals = [];
        let uvs = [];

        for ( iy = 0; iy < gridY1; iy ++ ) {
            let y = iy * segment_height - height_half;
            for ( ix = 0; ix < gridX1; ix ++ ) {
                let x = ix * segment_width - width_half;
                vertices.push( x, - y, 0 );
                normals.push( 0, 0, 1 );

                uvs.push( ix / gridX );
                uvs.push( 1 - ( iy / gridY ) );
            }
        }

        // indices

        for ( iy = 0; iy < gridY; iy ++ ) {
            for ( ix = 0; ix < gridX; ix ++ ) {
                let a = ix + gridX1 * iy;
                let b = ix + gridX1 * ( iy + 1 );
                let c = ( ix + 1 ) + gridX1 * ( iy + 1 );
                let d = ( ix + 1 ) + gridX1 * iy;

                // faces

                indices.push( a, b, d );
                indices.push( b, c, d );

            }
        }

        this.index = new (Geometry.arrayNeedsUint32(indices) ? Uint32Array : Uint16Array)(indices);
        this.addAttribute('position', new GeometryAttribute(new Float32Array(vertices), 3));
        this.addAttribute('normal', new GeometryAttribute(new Float32Array(normals), 3));
        this.addAttribute('uv', new GeometryAttribute(new Float32Array(uvs), 2));
    }
}
class PolyhedronGeometry extends Geometry {
    constructor(vertices, indices = [], radius = 1, detail = 0) {
        super();

        let vertexBuffer = [];
        let uvBuffer = [];

        subdivide(detail);
        appplyRadius(radius);
        generateUVs();

        this.addAttribute('position', new GeometryAttribute(new Float32Array(vertexBuffer), 3));
        this.addAttribute('normal', new GeometryAttribute(new Float32Array(vertexBuffer.slice()), 3));
        this.addAttribute('uv', new GeometryAttribute(new Float32Array(uvBuffer), 2));

        // this.index = new Uint16Array(indices);

        if (detail === 0) {
            this.computeVertexNormals(); // flat normals
        } else {
            this.normalizeNormals(); // smooth normals
        }

        function subdivide( detail ) {
            let a = new Vector3();
            let b = new Vector3();
            let c = new Vector3();
            for (let i = 0; i < indices.length; i += 3) {
                getVertexByIndex(indices[i + 0], a);
                getVertexByIndex(indices[i + 1], b);
                getVertexByIndex(indices[i + 2], c);
                subdivideFace(a, b, c, detail);
            }
        }

        function subdivideFace(a, b, c, detail) {
            var cols = Math.pow(2, detail);
            var v = [];
            var i, j;
    
            for (i = 0; i <= cols; i++) {
                v[ i ] = [];
                var aj = a.clone().lerp(c, i / cols);
                var bj = b.clone().lerp(c, i / cols);
                var rows = cols - i;
                for (j = 0; j <= rows; j++) {
                    if (j === 0 && i === cols) {
                        v[i][j] = aj;
                    } else {
                        v[i][j] = aj.clone().lerp(bj, j / rows);
                    }
                }
            }
    
            for (i = 0; i < cols; i++) {
                for (j = 0; j < 2 * (cols - i) - 1; j++) {
                    var k = Math.floor(j / 2);
                    if (j % 2 === 0) {
                        pushVertex(v[i][k+1]);
                        pushVertex(v[i+1][k]);
                        pushVertex(v[i][k]);
                    } else {
                        pushVertex(v[i][k+1]);
                        pushVertex(v[i+1][k+1]);
                        pushVertex(v[i+1][k]);
                    }
                }
            }
        }

        function appplyRadius(radius ) {
            var vertex = new Vector3();
            for ( var i = 0; i < vertexBuffer.length; i += 3 ) {
                vertex.x = vertexBuffer[i + 0];
                vertex.y = vertexBuffer[i + 1];
                vertex.z = vertexBuffer[i + 2];
    
                vertex.normalize().multiplyScalar(radius);
    
                vertexBuffer[i + 0] = vertex.x;
                vertexBuffer[i + 1] = vertex.y;
                vertexBuffer[i + 2] = vertex.z;
            }
        }


        function generateUVs() {
            let vertex = new Vector3();
            for (let i = 0; i < vertexBuffer.length; i += 3) {
                vertex.x = vertexBuffer[i + 0];
                vertex.y = vertexBuffer[i + 1];
                vertex.z = vertexBuffer[i + 2];

                let u = azimuth(vertex) / 2 / Math.PI + 0.5;
                let v = inclination(vertex) / Math.PI + 0.5;
                uvBuffer.push(u, 1 - v);
            }
            correctUVs();
            correctSeam();
        }

        function correctSeam() {
            for (let i = 0; i < uvBuffer.length; i += 6) {
                let x0 = uvBuffer[i + 0];
                let x1 = uvBuffer[i + 2];
                let x2 = uvBuffer[i + 4];
                let max = Math.max(x0, x1, x2);
                let min = Math.min(x0, x1, x2);
                if (max > 0.9 && min < 0.1) {
                    if (x0 < 0.2) uvBuffer[i + 0] += 1;
                    if (x1 < 0.2) uvBuffer[i + 2] += 1;
                    if (x2 < 0.2) uvBuffer[i + 4] += 1;
                }
            }
        }
    
        function pushVertex(vertex) {
            vertexBuffer.push(vertex.x, vertex.y, vertex.z);
        }

        function getVertexByIndex( index, vertex ) {
            let stride = index * 3;
            vertex.x = vertices[stride + 0];
            vertex.y = vertices[stride + 1];
            vertex.z = vertices[stride + 2];
        }

        function correctUVs() {
            let a = new Vector3();
            let b = new Vector3();
            let c = new Vector3();
    
            let centroid = new Vector3();
    
            let uvA = new Vector2();
            let uvB = new Vector2();
            let uvC = new Vector2();
    
            for (let i = 0, j = 0; i < vertexBuffer.length; i += 9, j += 6) {
                a.set(vertexBuffer[i + 0], vertexBuffer[i + 1], vertexBuffer[i + 2]);
                b.set(vertexBuffer[i + 3], vertexBuffer[i + 4], vertexBuffer[i + 5]);
                c.set(vertexBuffer[i + 6], vertexBuffer[i + 7], vertexBuffer[i + 8]);
    
                uvA.set(uvBuffer[j + 0], uvBuffer[j + 1]);
                uvB.set(uvBuffer[j + 2], uvBuffer[j + 3]);
                uvC.set(uvBuffer[j + 4], uvBuffer[j + 5]);
    
                centroid.copy(a).add(b).add(c).divideScalar(3);
    
                let azi = azimuth(centroid);
    
                correctUV(uvA, j + 0, a, azi);
                correctUV(uvB, j + 2, b, azi);
                correctUV(uvC, j + 4, c, azi);
            }
        }

        function correctUV(uv, stride, vector, azimuth) {
            if ((azimuth < 0) && (uv.x === 1)) {
                uvBuffer[stride] = uv.x - 1;
            }
    
            if ((vector.x === 0) && (vector.z === 0)) {
                uvBuffer[stride] = azimuth / 2 / Math.PI + 0.5;
            }
        }

        function azimuth(vector) {
            return Math.atan2(vector.z, - vector.x);
        }

        function inclination(vector) {
            return Math.atan2(- vector.y, Math.sqrt((vector.x * vector.x) + (vector.z * vector.z)));
        }
    }
}

class IcosahedronGeometry extends PolyhedronGeometry {
    constructor(radius, detail) {
        let t = ( 1 + Math.sqrt( 5 ) ) / 2;
        let vertices = [
            - 1, t, 0, 	1, t, 0, 	- 1, - t, 0, 	1, - t, 0,
            0, - 1, t, 	0, 1, t,	0, - 1, - t, 	0, 1, - t,
            t, 0, - 1, 	t, 0, 1, 	- t, 0, - 1, 	- t, 0, 1
        ];
    
        let indices = [
            0, 11, 5, 	0, 5, 1, 	0, 1, 7, 	0, 7, 10, 	0, 10, 11,
            1, 5, 9, 	5, 11, 4,	11, 10, 2,	10, 7, 6,	7, 1, 8,
            3, 9, 4, 	3, 4, 2,	3, 2, 6,	3, 6, 8,	3, 8, 9,
            4, 9, 5, 	2, 4, 11,	6, 2, 10,	8, 6, 7,	9, 8, 1
        ];

        super(vertices, indices, radius, detail);
    }
}

class OctahedronGeometry extends PolyhedronGeometry {

    constructor( radius = 1, detail = 0 ) {

        const vertices = [
            1, 0, 0, 	- 1, 0, 0,	0, 1, 0,
            0, - 1, 0, 	0, 0, 1,	0, 0, - 1
        ];

        const indices = [
            0, 2, 4,	0, 4, 3,	0, 3, 5,
            0, 5, 2,	1, 2, 5,	1, 5, 3,
            1, 3, 4,	1, 4, 2
        ];

        super( vertices, indices, radius, detail );

        this.type = 'OctahedronGeometry';

        this.parameters = {
            radius: radius,
            detail: detail
        };

    }

}

OctahedronGeometry.fromJSON = function(data) {
    return new OctahedronGeometry( data.radius, data.detail );
}
class RingGeometry extends Geometry {
    constructor(innerRadius = 0.5, outerRadius = 1, thetaSegments = 8, phiSegments = 1, thetaStart = 0, thetaLength = Math.PI * 2) {
        super();

        var indices = [];
        var vertices = [];
        var normals = [];
        var uvs = [];

        var segment;
        var radius = innerRadius;
        var radiusStep = ( ( outerRadius - innerRadius ) / phiSegments );
        var vertex = new Vector3();
        var uv = new Vector2();
        var j, i;

        for ( j = 0; j <= phiSegments; j ++ ) {
            for ( i = 0; i <= thetaSegments; i ++ ) {
                segment = thetaStart + i / thetaSegments * thetaLength;

                vertex.x = radius * Math.cos( segment );
                vertex.y = radius * Math.sin( segment );

                vertices.push( vertex.x, vertex.y, vertex.z );

                normals.push( 0, 0, 1 );

                uv.x = ( vertex.x / outerRadius + 1 ) / 2;
                uv.y = ( vertex.y / outerRadius + 1 ) / 2;
                uvs.push( uv.x, uv.y );
            }
            radius += radiusStep;
        }

        for ( j = 0; j < phiSegments; j ++ ) {
            var thetaSegmentLevel = j * ( thetaSegments + 1 );
            for ( i = 0; i < thetaSegments; i ++ ) {
                segment = i + thetaSegmentLevel;
                var a = segment;
                var b = segment + thetaSegments + 1;
                var c = segment + thetaSegments + 2;
                var d = segment + 1;

                indices.push( a, b, d );
                indices.push( b, c, d );
            }
        }

        this.index = new (Geometry.arrayNeedsUint32(indices) ? Uint32Array : Uint16Array)(indices);
        this.addAttribute('position', new GeometryAttribute(new Float32Array(vertices), 3));
        this.addAttribute( 'normal', new GeometryAttribute(new Float32Array(normals), 3));
        this.addAttribute( 'uv', new GeometryAttribute(new Float32Array(uvs), 2));
    }
}
class SphereGeometry extends Geometry {
    constructor(radius = 1, widthSegments = 8, heightSegments = 6, phiStart = 0, phiLength = Math.PI * 2, thetaStart = 0, thetaLength = Math.PI) {
        super();

        widthSegments = Math.max(3, Math.floor(widthSegments));
        heightSegments = Math.max(2, Math.floor(heightSegments));

        let thetaEnd = thetaStart + thetaLength;
        let ix, iy;
        let index = 0;
        let grid = [];

        let vertex = new Vector3();
        let normal = new Vector3();

        let indices = [];
        let vertices = [];
        let normals = [];
        let uvs = [];

        for (iy = 0; iy <= heightSegments; iy ++) {
            let verticesRow = [];
            let v = iy / heightSegments;

            for (ix = 0; ix <= widthSegments; ix ++) {
                let u = ix / widthSegments;

                vertex.x = - radius * Math.cos(phiStart + u * phiLength) * Math.sin( thetaStart + v * thetaLength);
                vertex.y = radius * Math.cos(thetaStart + v * thetaLength);
                vertex.z = radius * Math.sin(phiStart + u * phiLength) * Math.sin( thetaStart + v * thetaLength);
                vertices.push(vertex.x, vertex.y, vertex.z);

                normal.set(vertex.x, vertex.y, vertex.z).normalize();
                normals.push(normal.x, normal.y, normal.z);

                uvs.push(u, 1 - v);
                verticesRow.push(index++);
            }

            grid.push(verticesRow);
        }

        for (iy = 0; iy < heightSegments; iy++) {
            for (ix = 0; ix < widthSegments; ix++) {
                let a = grid[ iy ][ ix + 1 ];
                let b = grid[ iy ][ ix ];
                let c = grid[ iy + 1 ][ ix ];
                let d = grid[ iy + 1 ][ ix + 1 ];

                if (iy !== 0 || thetaStart > 0) indices.push(a, b, d);
                if (iy !== heightSegments - 1 || thetaEnd < Math.PI) indices.push(b, c, d);
            }
        }

        this.index = new (Geometry.arrayNeedsUint32(indices) ? Uint32Array : Uint16Array)(indices);
        this.addAttribute('position', new GeometryAttribute(new Float32Array(vertices), 3));
        this.addAttribute('normal', new GeometryAttribute(new Float32Array(normals), 3));
        this.addAttribute('uv', new GeometryAttribute(new Float32Array(uvs), 2));
    }
}
class TorusKnotGeometry extends Geometry {
    constructor(radius = 1, tube = 0.4, tubularSegments = 64, radialSegments = 8, p = 2, q = 3) {
        super();

        let indices = [];
        let vertices = [];
        let normals = [];
        let uvs = [];

        let i, j;

        let vertex = new Vector3();
        let normal = new Vector3();

        let P1 = new Vector3();
        let P2 = new Vector3();

        let B = new Vector3();
        let T = new Vector3();
        let N = new Vector3();

        for (i = 0; i <= tubularSegments; ++i) {
            let u = i / tubularSegments * p * Math.PI * 2;
            calculatePositionOnCurve(u, p, q, radius, P1);
            calculatePositionOnCurve(u + 0.01, p, q, radius, P2);

            T.subVectors(P2, P1);
            N.addVectors(P2, P1);
            B.crossVectors(T, N);
            N.crossVectors(B, T);

            B.normalize();
            N.normalize();

            for (j = 0; j <= radialSegments; ++j) {
                let v = j / radialSegments * Math.PI * 2;
                let cx = -tube * Math.cos(v);
                let cy = tube * Math.sin(v);

                vertex.x = P1.x + (cx * N.x + cy * B.x);
                vertex.y = P1.y + (cx * N.y + cy * B.y);
                vertex.z = P1.z + (cx * N.z + cy * B.z);

                vertices.push(vertex.x, vertex.y, vertex.z);

                normal.subVectors(vertex, P1).normalize();

                normals.push(normal.x, normal.y, normal.z);

                uvs.push(i / tubularSegments);
                uvs.push(j / radialSegments);

            }

        }

        for (j = 1; j <= tubularSegments; j++) {

            for (i = 1; i <= radialSegments; i++) {

                let a = (radialSegments + 1) * (j - 1) + (i - 1);
                let b = (radialSegments + 1) * j + (i - 1);
                let c = (radialSegments + 1) * j + i;
                let d = (radialSegments + 1) * (j - 1) + i;

                indices.push(a, b, d);
                indices.push(b, c, d);

            }

        }

        this.index = new (Geometry.arrayNeedsUint32(indices) ? Uint32Array : Uint16Array)(indices);
        this.addAttribute('position', new GeometryAttribute(new Float32Array(vertices), 3));
        this.addAttribute('normal', new GeometryAttribute(new Float32Array(normals), 3));
        this.addAttribute('uv', new GeometryAttribute(new Float32Array(uvs), 2));

        function calculatePositionOnCurve(u, p, q, radius, position) {

            let cu = Math.cos(u);
            let su = Math.sin(u);
            let quOverP = q / p * u;
            let cs = Math.cos(quOverP);

            position.x = radius * (2 + cs) * 0.5 * cu;
            position.y = radius * (2 + cs) * su * 0.5;
            position.z = radius * Math.sin(quOverP) * 0.5;

        }
    }
}
/**
 * @name Interaction3D
 */

Class(function Interaction3D(_camera) {
    Inherit(this, Component);
    const _this = this;
    let _hover, _click;
    var _hold, _calc, _lastOnUpdate;
    var _v3 = new Vector3();
    var _plane = new Plane();
    var _input = {};
    var _cacheHits = [];
    var _maximumVRHitDistance;

    var _enabled = true;

    _this.ID = Utils.timestamp();

    _camera = _camera || World.CAMERA;
    var _ray = _this.initClass(Raycaster, _camera);

    var _meshes = [];
    var _test = [];
    var _event = {};

    const PROHIBITED_ELEMENTS = ['hit', 'prevent_interaction3d'];

    this.cursor = 'auto';

    (function() {
        _ray.testVisibility = true;
    })();

    function checkIfProhibited(element) {
        let el = element;
        while (el) {
            if (el.classList) {
                for (let i = 0; i < PROHIBITED_ELEMENTS.length; i++) {
                    if (el.classList.contains(PROHIBITED_ELEMENTS[i])) return true;
                }
            }
            el = el.parentNode;
        }
        return false;
    }

    function parseMeshes(meshes) {
        if (!Array.isArray(meshes)) meshes = [meshes];
        let output = [];
        meshes.forEach(checkMesh);
        function checkMesh(obj) {
            if ( obj.hitArea || obj.hitMesh ) obj = initHitMesh( obj );
            if (typeof obj.isHitMesh === 'boolean') {
                obj.mouseEnabled = function(visible) {
                    if (visible) {
                        if (!~_meshes.indexOf(obj)) _meshes.push(obj);
                    } else {
                        _meshes.remove(obj);
                    }
                };
                output.push(obj);
            } else {
                output.push(obj);
            }
            if (obj.children.length) obj.children.forEach(checkMesh);
        }
        return output;
    }

    function initHitMesh( obj ) {
        if ( !obj.hitMesh ) {
            obj.hitMesh = new Mesh( obj.hitArea );
        }
        obj.add( obj.hitMesh );
        obj = obj.hitMesh;
        obj.isHitMesh = true;
        obj.shader.neverRender = true;
        return obj;
    }

    function testObjects() {
        _test.length = 0;
        for (let i = _meshes.length-1; i > -1; i--) {
            let obj = _meshes[i];
            if (obj.determineVisible()) _test.push(obj);
        }
        return _test;
    }

    //*** Event handlers
    function addHandlers() {
        _this.events.sub(Mouse.input, Interaction.START, start);
        if (Device.mobile) _this.events.sub(Mouse.input, Interaction.END, end);
        _this.events.sub(Mouse.input, Interaction.MOVE, move);
        _this.events.sub(Mouse.input, Interaction.CLICK, click);
    }

    function removeHandlers() {
        _this.events.unsub(Mouse.input, Interaction.START, start);
        if (Device.mobile) _this.events.unsub(Mouse.input, Interaction.END, end);
        _this.events.unsub(Mouse.input, Interaction.MOVE, move);
        _this.events.unsub(Mouse.input, Interaction.CLICK, click);
    }

    function start(e) {
        if (_input.type == '2d') {
            let element = document.elementFromPoint(Math.clamp(e.x || 0, 0, Stage.width), Math.clamp(e.y || 0, 0, Stage.height));
            if ((element && checkIfProhibited(element)) || GLUI.HIT) return;
        }

        if (!_enabled) return;
        let hit = move(e);

        if (_input.type == '3d') _this.events.fire(Interaction3D.EXTERNAL_PRESS);

        if (hit) {
            _click = hit.object;
            _click.time = Render.TIME;
        } else {
            _click = null;
        }
    }

    function moveHand(e) {
        if (!_enabled) return;

        _cacheHits.length = 0;

        for (let i = 0; i < _input.obj.length; i++) {
            let obj = _input.obj[i];
            _v3.set(0, 0, -1).applyQuaternion(obj.quaternion);
            let hit = _ray.checkFromValues(testObjects(), obj.position, _v3)[0];
            if (hit) _cacheHits.push(hit);
        }

        _cacheHits.sort((a, b) => a.distance - b.distance);
        let hit = _cacheHits[0];

        if (!hit || hit.object != _lastOnUpdate) {
            _lastOnUpdate && _lastOnUpdate.onMissUpdate && _lastOnUpdate.onMissUpdate();
            _lastOnUpdate = null;
        }

        if (hit) {
            let mesh = hit.object;
            if (mesh.onHitUpdate) {
                hit.usingFinger = true;
                _lastOnUpdate = mesh;
                mesh.onHitUpdate(hit);
                return false;
            }

            let timeGate = mesh._debounceFingerClick ? Render.TIME - mesh._debounceFingerClick > 1000 : true;
            if (timeGate) {
                if (hit.distance < 0.01) {
                    _click = mesh;
                    triggerClick(mesh, hit);
                    mesh._debounceFingerClick = Render.TIME;
                } else {
                    if (!_hover) {
                        _hover = mesh;
                        triggerHover('over', mesh, hit);
                    }
                }
            } else {
                if (_hover) {
                    triggerHover('out', _hover);
                    _hover = null;
                }
            }
        } else {
            if (_hover) {
                triggerHover('out', _hover);
                _hover = null;
            }
        }
    }

    function move(e) {
        if (_input.type == '2d') {
            let element = document.elementFromPoint(Math.clamp(e.x || 0, 0, Stage.width), Math.clamp(e.y || 0, 0, Stage.height));
            if ((element && checkIfProhibited(element))) return;
        }

        if (!_enabled) {
            Interaction3D.requestCursor('auto', _this);
            return;
        }

        let hit;
        if (_input.type == '2d') {
            hit = _ray.checkHit(testObjects(), _input.position, _input.rect || Stage)[0];
        } else {
            _input.obj.hideBeam();
            _v3.set(0, 0, -1).applyQuaternion(_input.obj.group.getWorldQuaternion());
            hit = _ray.checkFromValues(testObjects(), _input.obj.group.getWorldPosition(), _v3)[0];
        }

        if (!hit || hit.object != _lastOnUpdate) {
            _lastOnUpdate && _lastOnUpdate.onMissUpdate && _lastOnUpdate.onMissUpdate();
            _lastOnUpdate = null;
        }


        if (hit) {
            _this.intersecting = true;
            let mesh = hit.object;

            if (_input.type == '3d') {
                let max = _maximumVRHitDistance || Interaction3D.maximumVRHitDistance;
                if (typeof mesh.maximumVRHitDistance === 'number' && mesh.maximumVRHitDistance > 0) {
                    max = mesh.maximumVRHitDistance;
                }
                if (mesh.onHitUpdate && hit.distance > max) return false;
                _input.obj.showBeam();
                _input.obj.setHitPosition && _input.obj.setHitPosition( hit );
            }

            if (mesh.onHitUpdate) {
                mesh.onHitUpdate(hit);
                _lastOnUpdate = mesh;
                return false;
            }

            if (_hover !== mesh) {
                if (_hover) triggerHover('out', _hover, hit);

                _hover = mesh;
                triggerHover('over', _hover, hit);

                if (_hover.__clickCallback) {
                    Interaction3D.requestCursor('pointer', _this);
                } else {
                    Interaction3D.requestCursor('auto', _this);
                }
            } else {
                triggerMove(_hover, hit);
            }

            return hit;
        } else {
            _this.intersecting = false;
            end();
            _input.obj && _input.obj.setHitPosition && _input.obj.setHitPosition(false);
            return false;
        }
    }

    function end() {
        if (!_hover) return;
        triggerHover('out', _hover, null);
        _hover = null;
        Interaction3D.requestCursor(_this.cursor, _this);
    }

    function click(e) {
        if (_input.type == '3d') {
            _this.events.fire(Interaction3D.EXTERNAL_RELEASE);
        }

        if (!_this.enabled) return;
        if (!_click) return;

        let element = document.elementFromPoint(Math.clamp(e.x || 0, 0, Stage.width), Math.clamp(e.y || 0, 0, Stage.height));
        if ((element && checkIfProhibited(element))) return;

        let hit;
        if (_input.type == '2d') {
            if (GLUI.HIT) return;
            hit = _ray.checkHit(testObjects(), _input.position, _input.rect)[0];
        } else {
            _v3.set(0, 0, -1).applyQuaternion(_input.obj.group.getWorldQuaternion());
            hit = _ray.checkFromValues(testObjects(), _input.obj.group.getWorldPosition(), _v3)[0];
        }

        if (hit && hit.object === _click) {
            triggerClick(_click, hit);
        }
        _click = null;
    }

    function triggerHover(action, mesh, hit) {
        _event.action = action;
        _event.mesh = mesh;
        _event.hit = hit;
        _this.events.fire(Interaction3D.HOVER, _event, true);
        _hover.__hoverCallback && _hover.__hoverCallback(_event);
    }

    function triggerClick(mesh, hit) {
        _event.action = 'click';
        _event.mesh = mesh;
        _event.hit = hit;
        _this.events.fire(Interaction3D.CLICK, _event, true);
        _click.__clickCallback && _click.__clickCallback(_event);
    }

    function triggerMove(mesh, hit) {
        _event.action = 'move';
        _event.mesh = mesh;
        _event.hit = hit;
        _this.events.fire(Interaction3D.MOVE, _event, true);
        // mesh.__moveCallback && mesh.__moveCallback(_event);
        mesh['__moveCallback' + _this.ID] && mesh['__moveCallback' + _this.ID](_event);
    }

    function vrInputButton(e) {
        if (e.label == 'trigger') {
            if (e.pressed) start(e);
            else click(e);
        }
    }

    //*** Public methods
    this.set('camera', c => {
        _ray.camera = c;
    });

    /**
     * @name this.add
     * @memberof Interaction3D
     *
     * @function
     * @param meshes
     * @param hover
     * @param click
     * @param move
     * @param seo
    */
    this.add = function(meshes, hover, click, move, seo) {
        if (!Array.isArray(meshes)) meshes = parseMeshes(meshes);

        if (move && typeof move != 'function') {
            seo = move;
            move = null;
        }

        let seoRoot;
        if (seo && seo.root) {
            seoRoot = seo.root;
            seo = seo.seo;
        }

        meshes.forEach((mesh, i) => {
            if (seo) {
                try {
                    mesh._divFocus = _ => hover({action: 'over', seo: true, mesh});
                    mesh._divBlur = _ => hover({action: 'out', seo: true, mesh});
                    mesh._divSelect = _ => click({action: 'click', seo: true, mesh});
                    let {url, label, ...options} = Array.isArray(seo) ? seo[i] : seo;

                    GLSEO.objectNode(mesh, seoRoot);
                    mesh.seo.aLink(url, label, options);
                } catch(e) {
                    if (Hydra.LOCAL) console.warn(`Could not add SEO to Interaction3D meshes`, e);
                }
            }

            mesh.hitDestroy = _ => _meshes.remove( mesh );
            if (hover) mesh.__hoverCallback = hover;
            if (click) mesh.__clickCallback = click;
            if (move) mesh['__moveCallback' + _this.ID] = move;
            _meshes.push(mesh);
        });
    };

    /**
     * @name this.remove
     * @memberof Interaction3D
     *
     * @function
     * @param meshes
    */
    this.remove = function(meshes) {
        if (!Array.isArray(meshes)) meshes = parseMeshes(meshes);
        meshes.forEach(mesh => {
            if ( mesh === _hover ) {
                _hover = null;
                Interaction3D.requestCursor(_this.cursor, _this);
            }

            if (mesh.seo) mesh.seo.unlink();

            for (let i = _meshes.length - 1; i >= 0; i--) {
                if (mesh === _meshes[i]) _meshes.splice(i, 1);
            }
        });
    };

    this.set('testVisibility', v => _ray.testVisibility = v);

    this.set('input', obj => {
        if (_input && _input.obj) {
            if (_input.obj.isVrController) _this.events.unsub(_input.obj, VRInput.BUTTON, vrInputButton);
            if (_input.obj.setHitPosition) _input.obj.setHitPosition(false);
            if (_input.obj.hideBeam) _input.obj.hideBeam();
        }

        _input = {};
        _input.obj = obj;
        _input.position = obj.group ? obj.group.position : obj;
        _input.quaternion = obj.group ? obj.group.quaternion : null;
        _input.type = typeof _input.position.z === 'number' || Array.isArray(obj) ? '3d' : '2d';
        _input.rect = obj.rect;
        if (_input.type == '3d') {
            _hold = new Vector3();
            _calc = new Vector3();
        } else {
            _hold = new Vector2();
            _calc = new Vector2();
        }

        if (obj == Mouse) {
            addHandlers();
        } else {
            removeHandlers();
            if (Array.isArray(obj)) {
                _this.startRender(moveHand);
                _this.stopRender(move);
            } else {
                _this.events.sub(obj, VRInput.BUTTON, vrInputButton);
                _this.startRender(move);
                _this.stopRender(moveHand);
            }
        }
    });

    this.get('input', _ => _input);

    this.get('enabled', _ => _enabled);
    this.set('enabled', v => {
        _enabled = v;
        if (!_enabled ) {
            if (_hover) triggerHover('out', _hover, null);
            _hover = null;
            if (_input && _input.obj) {
                if (_input.obj.setHitPosition) _input.obj.setHitPosition(false);
                if (_input.obj.hideBeam) _input.obj.hideBeam();
            }
        }
    });

    this.checkObjectHit = function(object, mouse, rect = Stage) {
        return _ray.checkHit(object, mouse, rect)[0];
    };

    this.checkObjectFromValues = function(object, origin, direction) {
        return _ray.checkFromValues(object, origin, direction)[0];
    };

    this.getObjectHitLocalCoords = function(v, object, mouse, rect = Stage) {
        let hit = _this.checkObjectHit(object, mouse, rect);
        if (hit) {
            v.copy(hit.point);
            return hit.object.worldToLocal(v);
        } else {
            // intersect with the infinite plane
            _plane.normal.set(0, 0, 1).applyQuaternion(object.getWorldQuaternion());
            _plane.constant = -object.getWorldPosition().dot(_plane.normal);
            _ray.ray.intersectPlane(_plane, v);
            return object.worldToLocal(v);
        }
    }

    this.get('maximumVRHitDistance', () => _maximumVRHitDistance);
    this.set('maximumVRHitDistance', (value) => {
        if (!value) {
            _maximumVRHitDistance = undefined;
        } else if (typeof value === 'number' && value > 0) {
            _maximumVRHitDistance = value;
        }
    });
}, () => {
    Interaction3D.HOVER = 'interaction3d_hover';
    Interaction3D.CLICK = 'interaction3d_click';
    Interaction3D.MOVE = 'interaction3d_move';
    Interaction3D.EXTERNAL_PRESS = 'interaction3d_ext_press';
    Interaction3D.EXTERNAL_RELEASE = 'interaction3d_ext_release';

    var _map = new Map();
    var _input = Mouse;
    var _cursorObj;
    var _maximumVRHitDistance = 5;

    Interaction3D.find = function(camera) {
        camera = camera.camera || camera;
        if (!_map.has(camera)) {
            let interaction = new Interaction3D(camera);
            interaction.input = _input;
            _map.set(camera, interaction);
        }
        return _map.get(camera);
    }

    Interaction3D.useInput = function(obj) {
        if (_input == obj) return;
        for ( let [ camera, interaction ] of _map ) interaction.input = obj;
        _input = obj;
    }

    Interaction3D.requestCursor = function(cursor, obj) {
        if (obj.forceCursor) {
            cursor = obj.forceCursor;
        }

        if (cursor == 'pointer') {
            _cursorObj = obj;
            Stage.cursor(cursor);
        }

        if (cursor == 'auto') {
            if (_cursorObj == obj) {
                Stage.cursor(cursor);
                _cursorObj = null;
            }
        }
    }

    Object.defineProperty(Interaction3D, 'maximumVRHitDistance', {
        get() {
            return _maximumVRHitDistance;
        },
        set(value) {
            if (!value) {
                _maximumVRHitDistance = 5;
            } else if (typeof value === 'number' && value > 0) {
                _maximumVRHitDistance = value;
            }
        }
    });
});

/**
/**
 * @name Lighting
 */

Class(function Lighting() {
    Inherit(this, Component);
    const _this = this;

    var _scenes = {};
    var _activeScene;

   /**
    * @name fallbackAreaToPoint
    * @memberof Lighting
    * @property
    */
    this.fallbackAreaToPoint = false;
   /**
    * @name scenes
    * @memberof Lighting
    * @property
    */
    this.scenes = _scenes;

    //*** Constructor
    (async function () {
        await Hydra.ready();
        _this.createScene('default');
        _this.useScene('default');
    })();

    function loop() {
        decomposeLights(_activeScene.lights);

        if (!_this.UBO) {
            let shader = _activeScene.shaders.start();
            while (shader) {
                updateArrays(shader);
                shader = _activeScene.shaders.next();
            }
        } else {
            let shader = _activeScene.shaders.start();
            if (shader) {
                updateArrays(shader);
                if (!_activeScene.ubo.created) {
                    createUBO(shader.uniforms);
                } else {
                    _activeScene.ubo.update();
                }
            }
        }
    }

    function createUBO(uniforms) {
        if (!uniforms.lightPos) return;
        _activeScene.ubo.created = true;
        _activeScene.ubo.push(uniforms.lightPos);
        _activeScene.ubo.push(uniforms.lightColor);
        _activeScene.ubo.push(uniforms.lightData);
        _activeScene.ubo.push(uniforms.lightData2);
        _activeScene.ubo.push(uniforms.lightData3);
        _activeScene.ubo.push(uniforms.lightProperties);
        _activeScene.ubo.upload();
    }

    function decomposeLights(lights) {
        for (let i = lights.length-1; i > -1; i--) {
            let light = lights[i];
            if (light._decomposedTime && Render.TIME - light._decomposedTime < 8) continue;
            light._decomposedTime = Render.TIME;

            if (!light._parent) light.updateMatrixWorld();
            if (!light._world) light._world = new Vector3();
            if (!light.lockToLocal) light.getWorldPosition(light._world);
            else light._world.copy(light.position);
        }
    }

    function updateArrays(shader) {
        let lighting = shader.__lighting;

        lighting.position.length = 0;
        lighting.color.length = 0;
        lighting.data.length = 0;
        lighting.data2.length = 0;
        lighting.data3.length = 0;
        lighting.properties.length = 0;

        for (let i = 0; i < _activeScene.lights.length; i++) {
            let light = _activeScene.lights[i];
            if (!light._world) decomposeLights(_activeScene.lights);

            lighting.position.push(light._world.x, light._world.y, light._world.z, 0);
            lighting.color.push(light.color.r, light.color.g, light.color.b, 0);
            lighting.data.push(light.data.x, light.data.y, light.data.z, light.data.w);
            lighting.data2.push(light.data2.x, light.data2.y, light.data2.z, light.data2.w);
            lighting.data3.push(light.data3.x, light.data3.y, light.data3.z, light.data3.w);
            lighting.properties.push(light.properties.x, light.properties.y, light.properties.z, light.properties.w);
        }
    }

    function findParentScene(obj3d) {
        if (!obj3d) return _activeScene;
        if (obj3d._lightingData) return obj3d._lightingData;
        let scene;
        let p = obj3d._parent;
        while (p) {
            if (p instanceof Scene) {
                if (p._lightingData) scene = p._lightingData;
            }
            p = p._parent;
        }
        if (!scene) scene = _activeScene;
        return scene;
    }

    //*** Event handlers

    //*** Public methods
    /**
     * @name Lighting.createScene
     * @memberof Lighting
     *
     * @function
     * @param name
     * @param scene
    */
    this.createScene = function(name, scene) {
        if (_scenes[name]) return this;

        let UBOClass = window.Metal ? MetalUBO : UBO;
        let obj = {
            lights: [],
            renderShadows: [],
            ubo: new UBOClass(2),
            shaders: new LinkedList(),
            name
        };

        if (scene) scene._lightingData = obj;

        _scenes[name] = obj;
        return this;
    }

    /**
     * @name Lighting.useScene
     * @memberof Lighting
     *
     * @function
     * @param name
    */
    this.useScene = function(name) {
        _activeScene = _scenes[name];
        if (!_activeScene) throw `Scene ${name} not found`;
        loop();
        return this;
    }

    /**
     * @name Lighting.destroyScene
     * @memberof Lighting
     *
     * @function
     * @param name
    */
    this.destroyScene = function(name) {
        delete _scenes[name];
    }

    /**
     * @name Lighting.push
     * @memberof Lighting
     *
     * @function
     * @param light
    */
    this.push = this.add = function(light) {
        _this.UBO = Renderer.UBO && !(window.AURA || RenderManager.type == RenderManager.WEBVR);
        if (window.Metal) _this.UBO = true;

        let scene = findParentScene(light);
        scene.lights.push(light);

        if (light.isAreaLight) scene.hasAreaLight = true;

        if (!_this.startedLoop) {
            _this.startedLoop = true;

            if (RenderManager.type == RenderManager.WEBVR) {
                _this.startRender(loop, World.NUKE);
            } else {
                Render.onDrawFrame(loop);
            }
        }
    }

    /**
     * @name Lighting.remove
     * @memberof Lighting
     *
     * @function
     * @param light
    */
    this.remove = function(light) {
        _activeScene.lights.remove(light);
    }

    /**
     * @name Lighting.getLighting
     * @memberof Lighting
     *
     * @function
     * @param shader
     * @param force
    */
    this.getLighting = function(shader, force) {
        if (shader.__lighting && !force) return shader.__lighting;

        let scene = findParentScene(shader.mesh);
        scene.shaders.push(shader);
        if (window.AreaLightUtil && scene.hasAreaLight) AreaLightUtil.append(shader);

        let lighting = shader.__lighting = {
            position: [],
            color: [],
            data: [],
            data2: [],
            data3: [],
            properties: [],
        };

        if (!scene.lights.length) return shader.__lighting;

        let lightUBO = _this.UBO;
        shader.uniforms.lightPos = {type: 'v4v', value: lighting.position, ignoreUIL: true, lightUBO, components: 4, metalIgnore: true};
        shader.uniforms.lightColor = {type: 'v4v', value: lighting.color, ignoreUIL: true, lightUBO, components: 4, metalIgnore: true};
        shader.uniforms.lightData = {type: 'v4v', value: lighting.data, ignoreUIL: true, lightUBO, components: 4, metalIgnore: true};
        shader.uniforms.lightData2 = {type: 'v4v', value: lighting.data2, ignoreUIL: true, lightUBO, components: 4, metalIgnore: true};
        shader.uniforms.lightData3 = {type: 'v4v', value: lighting.data3, ignoreUIL: true, lightUBO, components: 4, metalIgnore: true};
        shader.uniforms.lightProperties = {type: 'v4v', value: lighting.properties, ignoreUIL: true, lightUBO, components: 4, metalIgnore: true};

        updateArrays(shader);
        if (_this.UBO && !_activeScene.ubo.created) createUBO(shader.uniforms);

        return shader.__lighting;
    }

    /**
     * @name Lighting.destroyShader
     * @memberof Lighting
     *
     * @function
     * @param shader
    */
    this.destroyShader = function(shader) {
        let scene = findParentScene(shader.mesh);
        _activeScene.shaders.remove(shader);
    }

    /**
     * @name Lighting.sort
     * @memberof Lighting
     *
     * @function
     * @param callback
    */
    this.sort = function(callback) {
        _activeScene.lights.sort(callback);
    }

    /**
     * @name Lighting.addToShadowGroup
     * @memberof Lighting
     *
     * @function
     * @param light
    */
    this.addToShadowGroup = function(light) {
        let scene = findParentScene(light);
        scene.renderShadows.push(light);
    }

    /**
     * @name Lighting.removeFromShadowGroup
     * @memberof Lighting
     *
     * @function
     * @param light
    */
    this.removeFromShadowGroup = function(light) {
        let scene = findParentScene(light);
        _activeScene.renderShadows.remove(light);
    }

    /**
     * @name Lighting.getShadowLights
     * @memberof Lighting
     *
     * @function
    */
    this.getShadowLights = function() {
        return _activeScene.renderShadows;
    }

    /**
     * @name Lighting.getShadowCount
     * @memberof Lighting
     *
     * @function
    */
    this.getShadowCount = function() {
        return _activeScene.renderShadows.length;
    }

    /**
     * @name Lighting.initShadowShader
     * @memberof Lighting
     *
     * @function
     * @param object
     * @param mesh
    */
    this.initShadowShader = function(object, mesh) {
        let shader = object.shader || object;

        let scene;
        if (shader.mesh) {
            let p = shader.mesh._parent;
            while (p) {
                if (p instanceof Scene) {
                    if (p._lightingData) scene = p._lightingData;
                }
                p = p._parent;
            }
        }
        if (!scene) scene = _activeScene;

        if (!World.RENDERER.shadows || scene.renderShadows.length == 0) return '';
        if (!shader._gl) shader.upload();

        let vsName = shader.vsName;
        let fsName = 'ShadowDepth';

        if (shader.customShadowShader) fsName = shader.customShadowShader;

        shader.shadow = new Shader(vsName, fsName, {receiveLight: shader.receiveLight, UILPrefix: shader.UILPrefix, precision: 'high'});
        if (shader.vertexShader) shader.shadow.vertexShader = shader.vertexShader;
        if (shader.restoreVS) shader.shadow.vertexShader = shader.restoreVS;
        if (shader.customCompile) shader.shadow.customCompile = shader.customCompile + '_shadow';
        if (shader.defines) {
            shader.shadow.defines = shader.defines;
            shader.shadow.resetProgram();
        }
        shader.shadow.lights = shader.lights;
        shader.shadow.isShadow = true;
        shader.copyUniformsTo(shader.shadow, true);
        shader.shadow.upload();
    }

    /**
     * @name Lighting.getShadowUniforms
     * @memberof Lighting
     *
     * @function
     * @param shader
    */
    this.getShadowUniforms = function(shader) {
        let scene;
        if (shader.mesh) {
            let p = shader.mesh._parent;
            while (p) {
                if (p instanceof Scene) {
                    if (p._lightingData) scene = p._lightingData;
                }
                p = p._parent;
            }
        }
        if (!scene) scene = _activeScene;

        if (!World.RENDERER.shadows || scene.renderShadows.length == 0) return '';

        return [
            `\n#define SHADOW_MAPS ${scene.renderShadows.length}`,
            World.RENDERER.shadows == Renderer.SHADOWS_LOW ? '#define SHADOWS_LOW' : '',
            World.RENDERER.shadows == Renderer.SHADOWS_MED ? '#define SHADOWS_MED' : '',
            World.RENDERER.shadows == Renderer.SHADOWS_HIGH ? '#define SHADOWS_HIGH' : '',
            `uniform sampler2D shadowMap[${scene.renderShadows.length}];`,
            `uniform mat4 shadowMatrix[${scene.renderShadows.length}];`,
            `uniform vec3 shadowLightPos[${scene.renderShadows.length}];`,
            `uniform float shadowSize[${scene.renderShadows.length}];`,
        ].join('\n');
    }

    /**
     * @name Lighting.bindUBO
     * @memberof Lighting
     *
     * @function
     * @param shader
    */
    this.bindUBO = function(shader) {
        if (_activeScene.ubo.created) _activeScene.ubo.bind(shader, 'lights');
    }

      /**
     * @name Lighting.fallbackAreaToPointTest
     * @memberof Lighting
     *
     * @function
    */
    this.fallbackAreaToPointTest = function() {
        return _this.fallbackAreaToPoint;
    }

    this.get('activeScene', _ => _activeScene);

    /**
     * When using multiple shadow maps, it may be necessary
     * to render only a subset of objects into each shadow
     * map. By default, all objects with castShadow will
     * render into all shadow maps; this function limits the
     * given mesh to being rendered into only the given light’s
     * shadow map. Acts like an allow list - can be called
     * again to add another light to the list.
     *
     * @param object
     * @param light
     */
    this.renderShadowsAllowLight = function(object, light) {
        if (!object._renderShadowsAllowLights) {
            let allowed = new WeakMap();
            object._renderShadowsAllowLights = allowed;
            let prevOnBeforeRenderShadow = object.onBeforeRenderShadow;
            object.onBeforeRenderShadow = function(renderLight) {
                let result = prevOnBeforeRenderShadow && prevOnBeforeRenderShadow.apply(this, arguments);
                if (!allowed.has(renderLight)) return true; // do not render
                return result;
            };
        }
        object._renderShadowsAllowLights.set(light.light || light, true);
    };

}, 'static');

class Shadow {
    constructor(light) {
        this.light = light;
        this.camera = new PerspectiveCamera(60, 1, 0.1, 50);
        this.target = new Vector3();
        this.rt = new RenderTarget(1024, 1024);
        this.rt.createDepthTexture();
        this.enabled = true;
        this._size = 1024;
        this._fov = 60;
        this._far = 50;
        this._near = 0.1;

        light.add(this.camera);
    }

    destroy() {
        this.rt.destroy();
    }

    set fov(value) {
        this._fov = value;
        this.camera.fov = value;
        this.camera.updateProjectionMatrix();

        if (value == -1) {
            this.camera = new OrthographicCamera(-5, 5, 5, -5, 0.1, 50);
        }
    }

    get fov() {
        return this._fov;
    }

    set area(value) {
        this._area = value;
        this.camera.left = -value;
        this.camera.right = value;
        this.camera.top = value;
        this.camera.bottom = -value;
        this.camera.updateProjectionMatrix();
    }

    get area() {
        return this._area;
    }

    set far(value) {
        this._far = value;
        this.camera.far = value;
        this.camera.updateProjectionMatrix();
    }

    get far() {
        return this._far;
    }

    set near(value) {
        this._near = value;
        this.camera.near = value;
        this.camera.updateProjectionMatrix();
    }

    get near() {
        return this._near;
    }

    set size(value) {
        this._size = value;
        this.rt.setSize(value, value);
    }

    get size() {
        return this._size;
    }
}
/**
 * @name Box2
 */
class Box2 {
    constructor(min, max) {
        this.min = ( min !== undefined ) ? min : new Vector2( + Infinity, + Infinity );
        this.max = ( max !== undefined ) ? max : new Vector2( - Infinity, - Infinity );
    }

    /**
     * @name this.set
     * @memberof Box2
     *
     * @function
     * @param min
     * @param max
    */
    set(min, max) {
        this.min.copy( min );
        this.max.copy( max );

        return this;
    }

    /**
     * @name this.setFromPoints
     * @memberof Box2
     *
     * @function
     * @param points
    */
    setFromPoints(points) {
        this.makeEmpty();
        for ( let i = 0, il = points.length; i < il; i ++ ) {
            this.expandByPoint( points[ i ] );
        }

        return this;
    }

    /**
     * @name this.setFromCenterAndSize
     * @memberof Box2
     *
     * @function
     * @param center
     * @param size
    */
    setFromCenterAndSize(center, size) {
        let v1 = this.V1 || new Vector2();
        this.V1 = v1;

        let halfSize = v1.copy( size ).multiplyScalar( 0.5 );
        this.min.copy( center ).sub( halfSize );
        this.max.copy( center ).add( halfSize );

        return this;
    }

    /**
     * @name this.clone
     * @memberof Box2
     *
     * @function
    */
    clone() {
        return new Box2().copy(this);
    }

    /**
     * @name this.copy
     * @memberof Box2
     *
     * @function
     * @param box
    */
    copy(box) {
        this.min.copy( box.min );
        this.max.copy( box.max );

        return this;
    }

    /**
     * @name this.makeEmpty
     * @memberof Box2
     *
     * @function
    */
    makeEmpty() {
        this.min.x = this.min.y = + Infinity;
        this.max.x = this.max.y = - Infinity;

        return this;
    }

    /**
     * @name this.isEmpty
     * @memberof Box2
     *
     * @function
    */
    isEmpty() {
        return ( this.max.x < this.min.x ) || ( this.max.y < this.min.y );
    }

    /**
     * @name this.getCenter
     * @memberof Box2
     *
     * @function
     * @param target
    */
    getCenter(target) {
        return this.isEmpty() ? target.set( 0, 0 ) : target.addVectors( this.min, this.max ).multiplyScalar( 0.5 );
    }

    /**
     * @name this.getSize
     * @memberof Box2
     *
     * @function
     * @param target
    */
    getSize(target) {
        return this.isEmpty() ? target.set( 0, 0 ) : target.subVectors( this.max, this.min );
    }

    /**
     * @name this.expandByPoint
     * @memberof Box2
     *
     * @function
     * @param point
    */
    expandByPoint(point) {
        this.min.min( point );
        this.max.max( point );

        return this;
    }

    /**
     * @name this.expandByVector
     * @memberof Box2
     *
     * @function
     * @param vector
    */
    expandByVector(vector) {
        this.min.sub( vector );
        this.max.add( vector );

        return this;
    }

    /**
     * @name this.expandByScalar
     * @memberof Box2
     *
     * @function
     * @param scalar
    */
    expandByScalar(scalar) {
        this.min.addScalar( - scalar );
        this.max.addScalar( scalar );

        return this;
    }

    /**
     * @name this.containsPoint
     * @memberof Box2
     *
     * @function
     * @param point
    */
    containsPoint(point) {
        return point.x < this.min.x || point.x > this.max.x || point.y < this.min.y || point.y > this.max.y ? false : true;
    }

    /**
     * @name this.containsBox
     * @memberof Box2
     *
     * @function
     * @param box
    */
    containsBox(box) {
        return this.min.x <= box.min.x && box.max.x <= this.max.x &&
            this.min.y <= box.min.y && box.max.y <= this.max.y;
    }

    /**
     * @name this.getParameter
     * @memberof Box2
     *
     * @function
     * @param point
     * @param target
    */
    getParameter(point, target) {
        return target.set(
            ( point.x - this.min.x ) / ( this.max.x - this.min.x ),
            ( point.y - this.min.y ) / ( this.max.y - this.min.y )
        );
    }

    /**
     * @name this.intersectsBox
     * @memberof Box2
     *
     * @function
     * @param box
    */
    intersectsBox(box) {
        return box.max.x < this.min.x || box.min.x > this.max.x ||
        box.max.y < this.min.y || box.min.y > this.max.y ? false : true;
    }

    /**
     * @name this.clampPoint
     * @memberof Box2
     *
     * @function
     * @param point
     * @param target
    */
    clampPoint(point, target) {
        return target.copy( point ).clamp( this.min, this.max );
    }

    /**
     * @name this.distanceToPoint
     * @memberof Box2
     *
     * @function
     * @param point
    */
    distanceToPoint(point) {
        let v1 = this.V1 || new Vector2();
        this.V1 = v1;

        let clampedPoint = v1.copy( point ).clamp( this.min, this.max );
        return clampedPoint.sub( point ).length();
    }

    /**
     * @name this.intersect
     * @memberof Box2
     *
     * @function
     * @param box
    */
    intersect(box) {
        this.min.max( box.min );
        this.max.min( box.max );

        return this;
    }

    /**
     * @name this.union
     * @memberof Box2
     *
     * @function
     * @param box
    */
    union(box) {
        this.min.min( box.min );
        this.max.max( box.max );

        return this;
    }

    /**
     * @name this.translate
     * @memberof Box2
     *
     * @function
     * @param offset
    */
    translate(offset) {
        this.min.add( offset );
        this.max.add( offset );

        return this;
    }

    /**
     * @name this.equals
     * @memberof Box2
     *
     * @function
     * @param box
    */
    equals(box) {
        return box.min.equals( this.min ) && box.max.equals( this.max );
    }
}
/**
 * @name Box3
 */
class Box3 {
    constructor(min, max) {
        this.min = ( min !== undefined ) ? min : new Vector3( + Infinity, + Infinity, + Infinity );
        this.max = ( max !== undefined ) ? max : new Vector3( - Infinity, - Infinity, - Infinity );
    }

    /**
     * @name this.set
     * @memberof Box3
     *
     * @function
     * @param min
     * @param max
    */
    set(min, max) {
        this.min.copy( min );
        this.max.copy( max );

        return this;
    }

    /**
     * @name this.setFromArray
     * @memberof Box3
     *
     * @function
     * @param array
    */
    setFromArray(array) {
        let minX = + Infinity;
        let minY = + Infinity;
        let minZ = + Infinity;

        let maxX = - Infinity;
        let maxY = - Infinity;
        let maxZ = - Infinity;

        for ( let i = 0, l = array.length; i < l; i += 3 ) {

            let x = array[ i ];
            let y = array[ i + 1 ];
            let z = array[ i + 2 ];

            if ( x < minX ) minX = x;
            if ( y < minY ) minY = y;
            if ( z < minZ ) minZ = z;

            if ( x > maxX ) maxX = x;
            if ( y > maxY ) maxY = y;
            if ( z > maxZ ) maxZ = z;

        }

        this.min.set( minX, minY, minZ );
        this.max.set( maxX, maxY, maxZ );

        return this;
    }

    /**
     * @name this.setFromBufferAttribute
     * @memberof Box3
     *
     * @function
     * @param attribute
    */
    setFromBufferAttribute(attribute) {
        let minX = +Infinity;
        let minY = +Infinity;
        let minZ = +Infinity;

        let maxX = -Infinity;
        let maxY = -Infinity;
        let maxZ = -Infinity;

        for (let i = 0, l = attribute.count; i < l; i++) {

            let x = attribute.array[i * 3 + 0];
            let y = attribute.array[i * 3 + 1];
            let z = attribute.array[i * 3 + 2];

            if ( x < minX ) minX = x;
            if ( y < minY ) minY = y;
            if ( z < minZ ) minZ = z;

            if ( x > maxX ) maxX = x;
            if ( y > maxY ) maxY = y;
            if ( z > maxZ ) maxZ = z;

        }

        this.min.set( minX, minY, minZ );
        this.max.set( maxX, maxY, maxZ );

        return this;

    }

    /**
     * @name this.setFromPoints
     * @memberof Box3
     *
     * @function
     * @param points
    */
    setFromPoints(points) {
        this.makeEmpty();

        for ( let i = 0, il = points.length; i < il; i ++ ) {

            this.expandByPoint( points[ i ] );

        }

        return this;
    }

    /**
     * @name this.setFromCenterAndSize
     * @memberof Box3
     *
     * @function
     * @param center
     * @param size
    */
    setFromCenterAndSize(center, size) {
        let v1 = this.V1 || new Vector3();
        this.V1 = v1;

        let halfSize = v1.copy( size ).multiplyScalar( 0.5 );

        this.min.copy( center ).sub( halfSize );
        this.max.copy( center ).add( halfSize );

        return this;
    }

    /**
     * @name this.setFromObject
     * @memberof Box3
     *
     * @function
     * @param object
    */
    setFromObject(object) {
        this.makeEmpty();

        return this.expandByObject( object );
    }

    /**
     * @name this.clone
     * @memberof Box3
     *
     * @function
    */
    clone() {
        return new Box3().copy(this);
    }

    /**
     * @name this.copy
     * @memberof Box3
     *
     * @function
     * @param box
    */
    copy(box) {
        this.min.copy( box.min );
        this.max.copy( box.max );

        return this;
    }

    /**
     * @name this.makeEmpty
     * @memberof Box3
     *
     * @function
    */
    makeEmpty() {
        this.min.x = this.min.y = this.min.z = + Infinity;
        this.max.x = this.max.y = this.max.z = - Infinity;

        return this;
    }

    /**
     * @name this.isEmpty
     * @memberof Box3
     *
     * @function
    */
    isEmpty() {
        return ( this.max.x < this.min.x ) || ( this.max.y < this.min.y ) || ( this.max.z < this.min.z );
    }

    /**
     * @name this.getCenter
     * @memberof Box3
     *
     * @function
     * @param target
    */
    getCenter(target) {
        return this.isEmpty() ? target.set( 0, 0, 0 ) : target.addVectors( this.min, this.max ).multiplyScalar( 0.5 );
    }

    /**
     * @name this.getSize
     * @memberof Box3
     *
     * @function
     * @param target
    */
    getSize(target) {
        return this.isEmpty() ? target.set( 0, 0, 0 ) : target.subVectors( this.max, this.min );
    }

    /**
     * @name this.expandByPoint
     * @memberof Box3
     *
     * @function
     * @param point
    */
    expandByPoint(point) {
        this.min.min( point );
        this.max.max( point );

        return this;
    }

    /**
     * @name this.expandByVector
     * @memberof Box3
     *
     * @function
     * @param vector
    */
    expandByVector(vector) {
        this.min.sub( vector );
        this.max.add( vector );

        return this;
    }

    /**
     * @name this.expandByScalar
     * @memberof Box3
     *
     * @function
     * @param scalar
    */
    expandByScalar(scalar) {
        this.min.addScalar( - scalar );
        this.max.addScalar( scalar );

        return this;
    }

    /**
     * @name this.expandByObject
     * @memberof Box3
     *
     * @function
     * @param object
     * @param local
     * @param onlyvisible
    */
    expandByObject(object, local, onlyvisible) {
        let v1 = this.V1 || new Vector3();
        this.V1 = v1;

        let scope, i, l;

        scope = this;
        object.updateMatrixWorld(true);
        object.traverse(node => {
            if (onlyvisible && !node.visible) return;
            if (node.isGizmo) return;

            let geometry = node.geometry;
            if (!geometry) return;
            let attribute = geometry.attributes.position;
            if ( attribute !== undefined ) {
                for ( i = 0, l = attribute.count; i < l; i ++ ) {
                    v1.fromBufferAttribute( attribute, i ).applyMatrix4( local ? node.matrix : node.matrixWorld );
                    scope.expandByPoint( v1 );
                }
            }
        });

        return this;
    }

    /**
     * @name this.containsPoint
     * @memberof Box3
     *
     * @function
     * @param point
    */
    containsPoint(point) {
        return point.x < this.min.x || point.x > this.max.x ||
        point.y < this.min.y || point.y > this.max.y ||
        point.z < this.min.z || point.z > this.max.z ? false : true;
    }

    /**
     * @name this.containsBox
     * @memberof Box3
     *
     * @function
     * @param box
    */
    containsBox(box) {
        return this.min.x <= box.min.x && box.max.x <= this.max.x &&
            this.min.y <= box.min.y && box.max.y <= this.max.y &&
            this.min.z <= box.min.z && box.max.z <= this.max.z;
    }

    /**
     * @name this.getParameter
     * @memberof Box3
     *
     * @function
     * @param point
     * @param target
    */
    getParameter(point, target) {
        return target.set(
            ( point.x - this.min.x ) / ( this.max.x - this.min.x ),
            ( point.y - this.min.y ) / ( this.max.y - this.min.y ),
            ( point.z - this.min.z ) / ( this.max.z - this.min.z )
        );
    }

    /**
     * @name this.intersectsBox
     * @memberof Box3
     *
     * @function
     * @param box
    */
    intersectsBox(box) {
        return box.max.x < this.min.x || box.min.x > this.max.x ||
        box.max.y < this.min.y || box.min.y > this.max.y ||
        box.max.z < this.min.z || box.min.z > this.max.z ? false : true;
    }

    /**
     * @name this.intersectsSphere
     * @memberof Box3
     *
     * @function
     * @param sphere
    */
    intersectsSphere(sphere) {
        let closestPoint = this.V1 || new Vector3();
        this.V1 = closestPoint;

        this.clampPoint( sphere.center, closestPoint );
        return closestPoint.distanceToSquared( sphere.center ) <= ( sphere.radius * sphere.radius );
    }

    /**
     * @name this.intersectsPlane
     * @memberof Box3
     *
     * @function
     * @param plane
    */
    intersectsPlane(plane) {
        let min, max;

        if ( plane.normal.x > 0 ) {
            min = plane.normal.x * this.min.x;
            max = plane.normal.x * this.max.x;
        } else {
            min = plane.normal.x * this.max.x;
            max = plane.normal.x * this.min.x;
        }

        if ( plane.normal.y > 0 ) {
            min += plane.normal.y * this.min.y;
            max += plane.normal.y * this.max.y;
        } else {
            min += plane.normal.y * this.max.y;
            max += plane.normal.y * this.min.y;
        }

        if ( plane.normal.z > 0 ) {
            min += plane.normal.z * this.min.z;
            max += plane.normal.z * this.max.z;
        } else {
            min += plane.normal.z * this.max.z;
            max += plane.normal.z * this.min.z;
        }

        return ( min <= plane.constant && max >= plane.constant );
    }

    /**
     * @name this.intersectsTriangle
     * @memberof Box3
     *
     * @function
     * @param triangle
    */
    intersectsTriangle(triangle) {
        let v0 = this.V0 || new Vector3();
        this.V0 = v0;

        let v1 = this.V1 || new Vector3();
        this.V1 = v1;

        let v2 = this.V2 || new Vector3();
        this.V2 = v2;

        let f0 = this.F0 || new Vector3();
        this.F0 = f0;

        let f1 = this.F1 || new Vector3();
        this.F1 = f1;

        let f2 = this.F2 || new Vector3();
        this.F2 = f2;

        let testAxis = this.V3 || new Vector3();
        this.V3 = testAxis;

        let center = this.V4 || new Vector3();
        this.V4 = center;

        let extents = this.V5 || new Vector3();
        this.V5 = extents;

        let triangleNormal = this.V6 || new Vector3();
        this.V6 = triangleNormal;

        function satForAxes( axes ) {

            let i, j;

            for ( i = 0, j = axes.length - 3; i <= j; i += 3 ) {

                testAxis.fromArray( axes, i );
                // project the aabb onto the seperating axis
                let r = extents.x * Math.abs( testAxis.x ) + extents.y * Math.abs( testAxis.y ) + extents.z * Math.abs( testAxis.z );
                // project all 3 vertices of the triangle onto the seperating axis
                let p0 = v0.dot( testAxis );
                let p1 = v1.dot( testAxis );
                let p2 = v2.dot( testAxis );
                // actual test, basically see if either of the most extreme of the triangle points intersects r
                if ( Math.max( - Math.max( p0, p1, p2 ), Math.min( p0, p1, p2 ) ) > r ) {

                    // points of the projected triangle are outside the projected half-length of the aabb
                    // the axis is seperating and we can exit
                    return false;

                }

            }

            return true;

        }


        if ( this.isEmpty() ) {

            return false;

        }

        // compute box center and extents
        this.getCenter( center );
        extents.subVectors( this.max, center );

        // translate triangle to aabb origin
        v0.subVectors( triangle.a, center );
        v1.subVectors( triangle.b, center );
        v2.subVectors( triangle.c, center );

        // compute edge vectors for triangle
        f0.subVectors( v1, v0 );
        f1.subVectors( v2, v1 );
        f2.subVectors( v0, v2 );

        // test against axes that are given by cross product combinations of the edges of the triangle and the edges of the aabb
        // make an axis testing of each of the 3 sides of the aabb against each of the 3 sides of the triangle = 9 axis of separation
        // axis_ij = u_i x f_j (u0, u1, u2 = face normals of aabb = x,y,z axes vectors since aabb is axis aligned)
        let axes = [
            0, - f0.z, f0.y, 0, - f1.z, f1.y, 0, - f2.z, f2.y,
            f0.z, 0, - f0.x, f1.z, 0, - f1.x, f2.z, 0, - f2.x,
            - f0.y, f0.x, 0, - f1.y, f1.x, 0, - f2.y, f2.x, 0
        ];
        if ( ! satForAxes( axes ) ) {

            return false;

        }

        // test 3 face normals from the aabb
        axes = [ 1, 0, 0, 0, 1, 0, 0, 0, 1 ];
        if ( ! satForAxes( axes ) ) {

            return false;

        }

        // finally testing the face normal of the triangle
        // use already existing triangle edge vectors here
        triangleNormal.crossVectors( f0, f1 );
        axes = [ triangleNormal.x, triangleNormal.y, triangleNormal.z ];
        return satForAxes( axes );
    }

    /**
     * @name this.clampPoint
     * @memberof Box3
     *
     * @function
     * @param point
     * @param target
    */
    clampPoint(point, target) {
        return target.copy( point ).clamp( this.min, this.max );
    }

    /**
     * @name this.distanceToPoint
     * @memberof Box3
     *
     * @function
     * @param point
    */
    distanceToPoint(point) {
        let v1 = this.V1 || new Vector3();
        this.V1 = v1;

        let clampedPoint = v1.copy( point ).clamp( this.min, this.max );
        return clampedPoint.sub( point ).length();
    }

    /**
     * @name this.getBoundingSphere
     * @memberof Box3
     *
     * @function
     * @param target
    */
    getBoundingSphere(target = new Sphere()) {
        let v1 = this.V1 || new Vector3();
        this.V1 = v1;

        this.getCenter( target.center );
        target.radius = this.getSize( v1 ).length() * 0.5;
        return target;
    }

    /**
     * @name this.intersect
     * @memberof Box3
     *
     * @function
     * @param box
    */
    intersect(box) {
        this.min.max( box.min );
        this.max.min( box.max );
        // ensure that if there is no overlap, the result is fully empty, not slightly empty with non-inf/+inf values that will cause subsequence intersects to erroneously return valid values.
        if ( this.isEmpty() ) this.makeEmpty();
        return this;
    }

    /**
     * @name this.union
     * @memberof Box3
     *
     * @function
     * @param box
    */
    union(box) {
        this.min.min( box.min );
        this.max.max( box.max );
        return this;
    }

    /**
     * @name this.applyMatrix4
     * @memberof Box3
     *
     * @function
     * @param matrix
    */
    applyMatrix4(matrix) {
        if ( this.isEmpty() ) return this;

        let m = matrix.elements;

        let xax = m[ 0 ] * this.min.x, xay = m[ 1 ] * this.min.x, xaz = m[ 2 ] * this.min.x;
        let xbx = m[ 0 ] * this.max.x, xby = m[ 1 ] * this.max.x, xbz = m[ 2 ] * this.max.x;
        let yax = m[ 4 ] * this.min.y, yay = m[ 5 ] * this.min.y, yaz = m[ 6 ] * this.min.y;
        let ybx = m[ 4 ] * this.max.y, yby = m[ 5 ] * this.max.y, ybz = m[ 6 ] * this.max.y;
        let zax = m[ 8 ] * this.min.z, zay = m[ 9 ] * this.min.z, zaz = m[ 10 ] * this.min.z;
        let zbx = m[ 8 ] * this.max.z, zby = m[ 9 ] * this.max.z, zbz = m[ 10 ] * this.max.z;

        this.min.x = Math.min( xax, xbx ) + Math.min( yax, ybx ) + Math.min( zax, zbx ) + m[ 12 ];
        this.min.y = Math.min( xay, xby ) + Math.min( yay, yby ) + Math.min( zay, zby ) + m[ 13 ];
        this.min.z = Math.min( xaz, xbz ) + Math.min( yaz, ybz ) + Math.min( zaz, zbz ) + m[ 14 ];
        this.max.x = Math.max( xax, xbx ) + Math.max( yax, ybx ) + Math.max( zax, zbx ) + m[ 12 ];
        this.max.y = Math.max( xay, xby ) + Math.max( yay, yby ) + Math.max( zay, zby ) + m[ 13 ];
        this.max.z = Math.max( xaz, xbz ) + Math.max( yaz, ybz ) + Math.max( zaz, zbz ) + m[ 14 ];

        return this;
    }

    /**
     * @name this.translate
     * @memberof Box3
     *
     * @function
     * @param offset
    */
    translate(offset) {
        this.min.add( offset );
        this.max.add( offset );

        return this;
    }

    /**
     * @name this.equals
     * @memberof Box3
     *
     * @function
     * @param box
    */
    equals(box) {
        return box.min.equals( this.min ) && box.max.equals( this.max );
    }

    setFromBufferAttribute(attribute) {
        let minX = +Infinity;
        let minY = +Infinity;
        let minZ = +Infinity;

        let maxX = -Infinity;
        let maxY = -Infinity;
        let maxZ = -Infinity;

        for ( let i = 0, l = attribute.count; i < l; i ++ ) {
            let x = attribute.array[i * 3 + 0];
            let y = attribute.array[i * 3 + 1];
            let z = attribute.array[i * 3 + 2];

            if ( x < minX ) minX = x;
            if ( y < minY ) minY = y;
            if ( z < minZ ) minZ = z;

            if ( x > maxX ) maxX = x;
            if ( y > maxY ) maxY = y;
            if ( z > maxZ ) maxZ = z;
        }

        this.min.set( minX, minY, minZ );
        this.max.set( maxX, maxY, maxZ );

        return this;
    }
}

/**
 * @name Color
 */

class Color {
    constructor(r, g, b) {
        if (r == undefined && g == undefined && b == undefined) return this.setRGB(1, 1, 1);

        if ( g === undefined && b === undefined ) {
            return this.set( r );
        }

        this.setRGB( r, g, b );
    }

    /**
     * @name set
     * @memberof Color
     *
     * @function
     * @param {*} value
     * @return {Color}
     */
    set(value) {
        if ( value && value instanceof Color ) {
            this.copy( value );
        } else if ( typeof value === 'number' ) {
            this.setHex( value );
        } else if ( typeof value === 'string' ) {
            this.setStyle( value );
        }

        return this;
    }

    /**
     * @name setScalar
     * @memberof Color
     *
     * @function
     * @param {Number} value
     * @return {Color}
     */
    setScalar(scalar) {
        this.r = scalar;
        this.g = scalar;
        this.b = scalar;

        return this;
    }

    /**
     * @name setHex
     * @memberof Color
     *
     * @function
     * @param {Number} hex
     * @return {Color}
     */
    setHex(hex) {
        hex = Math.floor( hex );

        this.r = ( hex >> 16 & 255 ) / 255;
        this.g = ( hex >> 8 & 255 ) / 255;
        this.b = ( hex & 255 ) / 255;

        return this;
    }

    /**
     * @name setStyle
     * @memberof Color
     *
     * @function
     * @param {String} value
     * @return {Color}
     */
    setStyle(string) {
        return this.setHex(Number(string.replace('#', '0x')));
    }

    /**
     * @name setRGB
     * @memberof Color
     *
     * @function
     * @param {Number} r
     * @param {Number} g
     * @param {Number} b
     * @return {Color}
     */
    setRGB(r, g, b) {
        this.r = r;
        this.g = g;
        this.b = b;

        return this;
    }

    /**
     * @name setHSL
     * @memberof Color
     *
     * @function
     * @param {Number} h
     * @param {Number} s
     * @param {Number} l
     * @return {Color}
     */
    setHSL(h, s, l) {
        function hue2rgb( p, q, t ) {
            if ( t < 0 ) t += 1;
            if ( t > 1 ) t -= 1;
            if ( t < 1 / 6 ) return p + ( q - p ) * 6 * t;
            if ( t < 1 / 2 ) return q;
            if ( t < 2 / 3 ) return p + ( q - p ) * 6 * ( 2 / 3 - t );
            return p;
        }

        h = Math.euclideanModulo( h, 1 );
        s = Math.clamp( s, 0, 1 );
        l = Math.clamp( l, 0, 1 );

        if ( s === 0 ) {

            this.r = this.g = this.b = l;

        } else {

            let p = l <= 0.5 ? l * ( 1 + s ) : l + s - ( l * s );
            let q = ( 2 * l ) - p;

            this.r = hue2rgb( q, p, h + 1 / 3 );
            this.g = hue2rgb( q, p, h );
            this.b = hue2rgb( q, p, h - 1 / 3 );

        }

        return this;
    }

    /**
     * @name clone
     * @memberof Color
     *
     * @function
     * @return {Color}
     */
    clone() {
        return new Color(this.r, this.g, this.b);
    }

    /**
     * @name this.copy
     * @memberof Color
     *
     * @function
     * @param color
    */
    copy(color) {
        this.r = color.r;
        this.g = color.g;
        this.b = color.b;

        return this;
    }

    /**
     * @name this.copyGammaToLinear
     * @memberof Color
     *
     * @function
     * @param color
     * @param gammaFactor
    */
    copyGammaToLinear(color, gammaFactor) {
        if ( gammaFactor === undefined ) gammaFactor = 2.0;

        this.r = Math.pow( color.r, gammaFactor );
        this.g = Math.pow( color.g, gammaFactor );
        this.b = Math.pow( color.b, gammaFactor );

        return this;
    }

    /**
     * @name this.copyLinearToGamma
     * @memberof Color
     *
     * @function
     * @param color
     * @param gammaFactor
    */
    copyLinearToGamma(color, gammaFactor) {
        if ( gammaFactor === undefined ) gammaFactor = 2.0;

        let safeInverse = ( gammaFactor > 0 ) ? ( 1.0 / gammaFactor ) : 1.0;

        this.r = Math.pow( color.r, safeInverse );
        this.g = Math.pow( color.g, safeInverse );
        this.b = Math.pow( color.b, safeInverse );

        return this;
    }

    /**
     * @name this.convertGammaToLinear
     * @memberof Color
     *
     * @function
     * @param gammaFactor
    */
    convertGammaToLinear(gammaFactor) {
        this.copyGammaToLinear( this, gammaFactor );
        return this;
    }

    /**
     * @name this.convertLinearToGamma
     * @memberof Color
     *
     * @function
     * @param gammaFactor
    */
    convertLinearToGamma(gammaFactor) {
        this.copyLinearToGamma( this, gammaFactor );
        return this;
    }

    /**
     * @name getHex
     * @memberof Color
     *
     * @function
     * @return {Number}
     */
    getHex() {
        return ( this.r * 255 ) << 16 ^ ( this.g * 255 ) << 8 ^ ( this.b * 255 ) << 0;
    }

    /**
     * @name getHexString
     * @memberof Color
     *
     * @function
     * @return {String}
     */
    getHexString() {
        return '#' + ( '000000' + this.getHex().toString( 16 ) ).slice( - 6 );
    }

    /**
     * @name getHSL
     * @memberof Color
     *
     * @function
     * @return {Object}
     */
    getHSL() {
        let target = this.target || {};
        this.target = target;

        let r = this.r, g = this.g, b = this.b;

        let max = Math.max( r, g, b );
        let min = Math.min( r, g, b );

        let hue, saturation;
        let lightness = ( min + max ) / 2.0;

        if ( min === max ) {

            hue = 0;
            saturation = 0;

        } else {

            let delta = max - min;

            saturation = lightness <= 0.5 ? delta / ( max + min ) : delta / ( 2 - max - min );

            switch ( max ) {

                case r: hue = ( g - b ) / delta + ( g < b ? 6 : 0 ); break;
                case g: hue = ( b - r ) / delta + 2; break;
                case b: hue = ( r - g ) / delta + 4; break;

            }

            hue /= 6;

        }

        target.h = hue;
        target.s = saturation;
        target.l = lightness;

        return target;
    }

    /**
     * @name this.tween
     * @memberof Color
     *
     * @function
     * @param color
     * @param time
     * @param ease
     * @param delay
    */
    tween(color, time, ease, delay) {
        const _this = this;
        if (!_this.tweenObj) _this.tweenObj = {v: 0};
        _this.tweenObj.v = 0;
        let clone = this.clone();
    /**
     * @name this.return TweenManager.tween
     * @memberof Color
     *
     * @function
     * @param _this.tweenObj
     * @param {v: 1}
     * @param time
     * @param ease
     * @param delay
    */
        return TweenManager.tween(_this.tweenObj, {v: 1}, time, ease, delay).onUpdate(_ => {
            _this.copy(clone).lerp(color, _this.tweenObj.v);
        });
    }

    /**
     * @name offsetHSL
     * @memberof Color
     *
     * @function
     * @param {Number} h
     * @param {Number} s
     * @param {Number} l
     * @return {Color}
     */
    offsetHSL(h, s, l) {
        let hsl = this.getHSL();
        hsl.h += h; hsl.s += s; hsl.l += l;
        this.setHSL( hsl.h, hsl.s, hsl.l );
        return this;
    }

    /**
     * @name add
     * @memberof Color
     *
     * @function
     * @param {Color} color
     * @return {Color}
     */
    add(color) {
        this.r += color.r;
        this.g += color.g;
        this.b += color.b;

        return this;
    }

    /**
     * @name addColors
     * @memberof Color
     *
     * @function
     * @param {Color} color
     * @param {Color} color2
     * @return {Color}
     */
    addColors(color1, color2) {
        this.r = color1.r + color2.r;
        this.g = color1.g + color2.g;
        this.b = color1.b + color2.b;

        return this;
    }

    /**
     * @name addScalar
     * @memberof Color
     *
     * @function
     * @param {Number} scalar
     * @return {Color}
     */
    addScalar(s) {
        this.r += s;
        this.g += s;
        this.b += s;

        return this;
    }

    /**
     * @name this.sub
     * @memberof Color
     *
     * @function
     * @param color
    */
    sub(color) {
        this.r = Math.max( 0, this.r - color.r );
        this.g = Math.max( 0, this.g - color.g );
        this.b = Math.max( 0, this.b - color.b );

        return this;
    }

    /**
     * @name this.multiply
     * @memberof Color
     *
     * @function
     * @param color
    */
    multiply(color) {
        this.r *= color.r;
        this.g *= color.g;
        this.b *= color.b;

        return this;
    }

    /**
     * @name this.multiplyScalar
     * @memberof Color
     *
     * @function
     * @param s
    */
    multiplyScalar(s) {
        this.r *= s;
        this.g *= s;
        this.b *= s;

        return this;
    }

    /**
     * @name this.invert
     * @memberof Color
     *
     * @function
    */
    invert() {
        this.r = 1.0 - this.r;
        this.g = 1.0 - this.g;
        this.b = 1.0 - this.b;

        return this;
    }

    /**
     * @name lerp
     * @memberof Color
     *
     * @function
     * @param {Color} color
     * @param {Number} alpha
     * @param {Boolean} hz
     * @return {Color}
     */
     lerp(color, alpha, hz) {
        this.r = Math.lerp(color.r, this.r, alpha, hz);
        this.g = Math.lerp(color.g, this.g, alpha, hz);
        this.b = Math.lerp(color.b, this.b, alpha, hz);

        return this;
    }

    /**
     * @name this.equals
     * @memberof Color
     *
     * @function
     * @param c
    */
    equals(c) {
        return ( c.r === this.r ) && ( c.g === this.g ) && ( c.b === this.b );
    }

    /**
     * @name fromArray
     * @memberof Color
     *
     * @function
     * @param {Array} array
     * @param {Number} offset
     * @return {Color}
     */
    fromArray(array, offset) {
        if ( offset === undefined ) offset = 0;

        this.r = array[ offset ];
        this.g = array[ offset + 1 ];
        this.b = array[ offset + 2 ];

        return this;
    }

    /**
     * @name toArray
     * @memberof Color
     *
     * @function
     * @param {Array} array
     * @param {Number} offset
     * @return {Array}
     */
    toArray(array, offset) {
        if ( array === undefined ) array = [];
        if ( offset === undefined ) offset = 0;

        array[ offset ] = this.r;
        array[ offset + 1 ] = this.g;
        array[ offset + 2 ] = this.b;

        return array;
    }

    /**
     * @name toRGBA
     * @memberof Color
     *
     * @function
     * @param {Number} alpha
     * @return {String}
     */
    toRGBA(alpha = 1) {
        return `rgba(${Math.floor(this.r * 255)}, ${Math.floor(this.g * 255)}, ${Math.floor(this.b * 255)}, ${alpha})`;
    }
}
/**
 * @name Cylindrical
 */
class Cylindrical {
    constructor(radius = 1.0, theta = 0, y = 0) {
        this.radius = radius;
        this.theta = theta;
        this.y = y;
    }

    /**
     * @name this.set
     * @memberof Cylindrical
     *
     * @function
     * @param radius
     * @param theta
     * @param y
    */
    set(radius, theta, y) {
		this.radius = radius;
		this.theta = theta;
		this.y = y;
		return this;
	}

    /**
     * @name this.clone
     * @memberof Cylindrical
     *
     * @function
    */
	clone() {
		return new this.constructor().copy(this);
	}

    /**
     * @name this.copy
     * @memberof Cylindrical
     *
     * @function
     * @param other
    */
	copy(other) {
		this.radius = other.radius;
		this.theta = other.theta;
		this.y = other.y;
		return this;
	}

    /**
     * @name this.setFromVector3
     * @memberof Cylindrical
     *
     * @function
     * @param vec3
    */
	setFromVector3(vec3) {
		this.radius = Math.sqrt(vec3.x * vec3.x + vec3.z * vec3.z);
		this.theta = Math.atan2(vec3.x, vec3.z);
		this.y = vec3.y;
		return this;
	}
}
/**
 * @name Euler
 * @param {Number} x
 * @param {Number} y
 * @param {Number} z
 * @param {String} order
 */
class Euler {
    constructor(x, y, z, order) {
        this._x = x || 0;
        this._y = y || 0;
        this._z = z || 0;
        this._order = order || 'XYZ';
        this.isEuler = true;
    }

    get x() {
        return this._x;
    }

    set x(v) {
        if (zUtils3D.LOCAL && isNaN(v)) return console.trace('Euler::NaN');
        let dirty = Math.abs(this._x - v) > Base3D.DIRTY_EPSILON;
        this._x = v;
        if (dirty) this.onChangeCallback();
    }

    get y() {
        return this._y;
    }

    set y(v) {
        if (zUtils3D.LOCAL && isNaN(v)) return console.trace('Euler::NaN');
        let dirty = Math.abs(this._y - v) > Base3D.DIRTY_EPSILON;
        this._y = v;
        if (dirty) this.onChangeCallback();
    }

    get z() {
        return this._z;
    }

    set z(v) {
        if (zUtils3D.LOCAL && isNaN(v)) return console.trace('Euler::NaN');
        let dirty = Math.abs(this._z - v) > Base3D.DIRTY_EPSILON;
        this._z = v;
        if (dirty) this.onChangeCallback();
    }

    /**
     * @name this.set order
     * @memberof Euler
     *
     * @function
     * @param value
    */
    set order(value) {
        this._order = value;
        this.onChangeCallback();
    }

    /**
     * @name this.get order
     * @memberof Euler
     *
     * @function
    */
    get order() {
        return this._order;
    }

    /**
     * @name set
     * @memberof Euler
     *
     * @function
     * @param {Number} x
     * @param {Number} y
     * @param {Number} z
     * @param {String} order
     * @return {Euler}
     */
    set(x, y, z, order) {
        this._x = x;
        this._y = y;
        this._z = z;
        this._order = order || this._order;

        this.onChangeCallback();

        return this;
    }

    /**
     * @name clone
     * @memberof Euler
     *
     * @return {Euler}
     */
    clone() {
        return new Euler(this._x, this._y, this._z, this._order);
    }

    /**
     * @name this.copy
     * @memberof Euler
     *
     * @function
     * @param euler
    */
    copy(euler) {
        this._x = euler.x;
        this._y = euler.y;
        this._z = euler.z;
        if (euler._order) this._order = euler._order;

        this.onChangeCallback();

        return this;
    }

    /**
     * @name setFromRotationMatrix
     * @memberof Euler
     *
     * @function
     * @param {Matrix4} m
     * @param {String} order
     */
    setFromRotationMatrix(m, order, update) {
        let clamp = Math.clamp;

        let te = m.elements;
        let m11 = te[ 0 ], m12 = te[ 4 ], m13 = te[ 8 ];
        let m21 = te[ 1 ], m22 = te[ 5 ], m23 = te[ 9 ];
        let m31 = te[ 2 ], m32 = te[ 6 ], m33 = te[ 10 ];

        order = order || this._order;

        if ( order === 'XYZ' ) {

            this._y = Math.asin( clamp( m13, - 1, 1 ) );

            if ( Math.abs( m13 ) < (1.0 - Base3D.DIRTY_EPSILON) ) {

                this._x = Math.atan2( - m23, m33 );
                this._z = Math.atan2( - m12, m11 );

            } else {

                this._x = Math.atan2( m32, m22 );
                this._z = 0;

            }

        } else if ( order === 'YXZ' ) {

            this._x = Math.asin( - clamp( m23, - 1, 1 ) );

            if ( Math.abs( m23 ) < (1.0 - Base3D.DIRTY_EPSILON) ) {

                this._y = Math.atan2( m13, m33 );
                this._z = Math.atan2( m21, m22 );

            } else {

                this._y = Math.atan2( - m31, m11 );
                this._z = 0;

            }

        } else if ( order === 'ZXY' ) {

            this._x = Math.asin( clamp( m32, - 1, 1 ) );

            if ( Math.abs( m32 ) < (1.0 - Base3D.DIRTY_EPSILON) ) {

                this._y = Math.atan2( - m31, m33 );
                this._z = Math.atan2( - m12, m22 );

            } else {

                this._y = 0;
                this._z = Math.atan2( m21, m11 );

            }

        } else if ( order === 'ZYX' ) {

            this._y = Math.asin( - clamp( m31, - 1, 1 ) );

            if ( Math.abs( m31 ) < (1.0 - Base3D.DIRTY_EPSILON) ) {

                this._x = Math.atan2( m32, m33 );
                this._z = Math.atan2( m21, m11 );

            } else {

                this._x = 0;
                this._z = Math.atan2( - m12, m22 );

            }

        } else if ( order === 'YZX' ) {

            this._z = Math.asin( clamp( m21, - 1, 1 ) );

            if ( Math.abs( m21 ) < (1.0 - Base3D.DIRTY_EPSILON) ) {

                this._x = Math.atan2( - m23, m22 );
                this._y = Math.atan2( - m31, m11 );

            } else {

                this._x = 0;
                this._y = Math.atan2( m13, m33 );

            }

        } else if ( order === 'XZY' ) {

            this._z = Math.asin( - clamp( m12, - 1, 1 ) );

            if ( Math.abs( m12 ) < (1.0 - Base3D.DIRTY_EPSILON) ) {

                this._x = Math.atan2( m32, m22 );
                this._y = Math.atan2( m13, m11 );

            } else {

                this._x = Math.atan2( - m23, m33 );
                this._y = 0;

            }

        }

        this._order = order;

        if ( update !== false ) this.onChangeCallback();

        return this;
    }

    /**
     * @name setFromQuaternion
     * @memberof Euler
     *
     * @function
     * @param {Quaternion} q
     * @param {String} order
     */
    setFromQuaternion(q, order, update) {
        let matrix = this.M1 || new Matrix4();
        this.M1 = matrix;

        matrix.makeRotationFromQuaternion( q );
        return this.setFromRotationMatrix( matrix, order, update );
    }

    /**
     * @name setFromVector3
     * @memberof Euler
     *
     * @function
     * @param {Vector3} v
     * @param {String} order
     */
    setFromVector3(v, order) {
        return this.set( v.x, v.y, v.z, order || this._order );
    }

    /**
     * @name reorder
     * @memberof Euler
     *
     * @function
     * @param {String} order
     */
    reorder(newOrder) {
        let q = this.Q1 || new Quaternion();
        this.Q1 = q;

        q.setFromEuler( this );
        return this.setFromQuaternion( q, newOrder );
    }

    /**
     * @name lerp
     * @memberof Euler
     *
     * @function
     * @param {Euler} euler
     * @param {Number} alpha
     */
    lerp(euler, alpha) {
        this._x += (euler._x - this._x) * alpha;
        this._y += (euler._y - this._y) * alpha;
        this._z += (euler._z - this._z) * alpha;
        this.onChangeCallback();
    }

    /**
     * @name this.equals
     * @memberof Euler
     *
     * @function
     * @param euler
    */
    equals(euler) {
        return ( euler._x === this._x ) && ( euler._y === this._y ) && ( euler._z === this._z ) && ( euler._order === this._order );
    }

    /**
     * @name this.fromArray
     * @memberof Euler
     *
     * @function
     * @param array
    */
    fromArray(array) {
        this._x = array[ 0 ];
        this._y = array[ 1 ];
        this._z = array[ 2 ];
        if ( array[ 3 ] !== undefined ) this._order = array[ 3 ];

        this.onChangeCallback();

        return this;
    }

    /**
     * @name this.toArray
     * @memberof Euler
     *
     * @function
     * @param array
     * @param offset
    */
    toArray(array, offset) {
        if ( array === undefined ) array = [];
        if ( offset === undefined ) offset = 0;

        array[ offset ] = this._x;
        array[ offset + 1 ] = this._y;
        array[ offset + 2 ] = this._z;
        array[ offset + 3 ] = this._order;

        return array;
    }

    /**
     * @name this.toVector3
     * @memberof Euler
     *
     * @function
     * @param optionalResult
    */
    toVector3(optionalResult) {
        if ( optionalResult ) {
            return optionalResult.set( this._x, this._y, this._z );

        } else {
            return new Vector3( this._x, this._y, this._z );
        }
    }

    /**
     * @name this.onChange
     * @memberof Euler
     *
     * @function
     * @param callback
    */
    onChange(callback) {
        this.onChangeCallback = callback;
    }

    /**
     * @name this.onChangeCallback
     * @memberof Euler
     *
     * @function
    */
    onChangeCallback() {

    }
}


Euler.DefaultOrder = 'XYZ';
Euler.RotationOrders = [ 'XYZ', 'YZX', 'ZXY', 'XZY', 'YXZ', 'ZYX' ];

/**
 * @name Frustum
 */
class Frustum {
    constructor(p0, p1, p2, p3, p4, p5) {
        this.planes = [
            ( p0 !== undefined ) ? p0 : new Plane(),
            ( p1 !== undefined ) ? p1 : new Plane(),
            ( p2 !== undefined ) ? p2 : new Plane(),
            ( p3 !== undefined ) ? p3 : new Plane(),
            ( p4 !== undefined ) ? p4 : new Plane(),
            ( p5 !== undefined ) ? p5 : new Plane()
        ];
    }

    /**
     * @name this.set
     * @memberof Frustum
     *
     * @function
     * @param p0
     * @param p1
     * @param p2
     * @param p3
     * @param p4
     * @param p5
    */
    set(p0, p1, p2, p3, p4, p5) {
        let planes = this.planes;

        planes[ 0 ].copy( p0 );
        planes[ 1 ].copy( p1 );
        planes[ 2 ].copy( p2 );
        planes[ 3 ].copy( p3 );
        planes[ 4 ].copy( p4 );
        planes[ 5 ].copy( p5 );

        return this;
    }

    /**
     * @name this.clone
     * @memberof Frustum
     *
     * @function
    */
    clone() {
        return new Frustum().copy(this);
    }

    /**
     * @name this.copy
     * @memberof Frustum
     *
     * @function
     * @param frustum
    */
    copy(frustum) {
        let planes = this.planes;
        for ( let i = 0; i < 6; i ++ ) {
            planes[ i ].copy( frustum.planes[ i ] );
        }

        return this;
    }

    /**
     * @name setFromMatrix
     * @memberof Frustum
     *
     * @function
     * @param {Matrix4} m
     * @return {Frustum}
     */
    setFromMatrix(m) {
        let planes = this.planes;
        let me = m.elements;
        let me0 = me[ 0 ], me1 = me[ 1 ], me2 = me[ 2 ], me3 = me[ 3 ];
        let me4 = me[ 4 ], me5 = me[ 5 ], me6 = me[ 6 ], me7 = me[ 7 ];
        let me8 = me[ 8 ], me9 = me[ 9 ], me10 = me[ 10 ], me11 = me[ 11 ];
        let me12 = me[ 12 ], me13 = me[ 13 ], me14 = me[ 14 ], me15 = me[ 15 ];

        planes[ 0 ].setComponents( me3 - me0, me7 - me4, me11 - me8, me15 - me12 ).normalize();
        planes[ 1 ].setComponents( me3 + me0, me7 + me4, me11 + me8, me15 + me12 ).normalize();
        planes[ 2 ].setComponents( me3 + me1, me7 + me5, me11 + me9, me15 + me13 ).normalize();
        planes[ 3 ].setComponents( me3 - me1, me7 - me5, me11 - me9, me15 - me13 ).normalize();
        planes[ 4 ].setComponents( me3 - me2, me7 - me6, me11 - me10, me15 - me14 ).normalize();
        planes[ 5 ].setComponents( me3 + me2, me7 + me6, me11 + me10, me15 + me14 ).normalize();

        return this;
    }

    /**
     * @name setFromCamera
     * @memberof Frustum
     *
     * @function
     * @param {CameraBase3D} camera
     * @return {Frustum}
     */
    setFromCamera(camera) {
        let matrix = this.M1 || new Matrix4();
        this.M1 = matrix;

        matrix.multiplyMatrices(camera.projectionMatrix, camera.matrixWorldInverse);
        return this.setFromMatrix(matrix);
    }

    /**
     * @name intersectsObject
     * @memberof Frustum
     *
     * @function
     * @param {Base3D} object
     * @return {Boolean}
     */
    intersectsObject(object) {
        let sphere = this.S1 || new Sphere();
        this.S1 = sphere;

        let geometry = object.geometry;
        if (!geometry) return false;

        if (geometry.boundingSphere === null) geometry.computeBoundingSphere();

        sphere.copy(geometry.boundingSphere).applyMatrix4(object.matrixWorld);

        return this.intersectsSphere(sphere);
    }

    /**
     * @name intersectsSphere
     * @memberof Frustum
     *
     * @function
     * @param {Sphere} sphere
     * @return {Boolean}
     */
    intersectsSphere(sphere) {
        let planes = this.planes;
        let center = sphere.center;
        let negRadius = - sphere.radius;

        for ( let i = 0; i < 6; i ++ ) {
            let distance = planes[ i ].distanceToPoint( center );
            if ( distance < negRadius ) {
                return false;
            }
        }

        return true;
    }

    /**
     * @name intersectsBox
     * @memberof Frustum
     *
     * @function
     * @param {Box3} box
     * @return {Boolean}
     */
    intersectsBox(box) {
        let p1 = this.V1 || new Vector3();
        let p2 = this.V2 || new Vector3();
        this.V1 = p1;
        this.V2 = p2;

        let planes = this.planes;

        for ( let i = 0; i < 6; i ++ ) {
            let plane = planes[i];

            p1.x = plane.normal.x > 0 ? box.min.x : box.max.x;
            p2.x = plane.normal.x > 0 ? box.max.x : box.min.x;
            p1.y = plane.normal.y > 0 ? box.min.y : box.max.y;
            p2.y = plane.normal.y > 0 ? box.max.y : box.min.y;
            p1.z = plane.normal.z > 0 ? box.min.z : box.max.z;
            p2.z = plane.normal.z > 0 ? box.max.z : box.min.z;

            let d1 = plane.distanceToPoint(p1);
            let d2 = plane.distanceToPoint(p2);


            if (d1 < 0 && d2 < 0) {
                return false;
            }
        }

        return true;
    }

    /**
     * @name this.containsPoint
     * @memberof Frustum
     *
     * @function
     * @param point
    */
    containsPoint(point) {
        let planes = this.planes;

        for ( let i = 0; i < 6; i ++ ) {
            if ( planes[ i ].distanceToPoint( point ) < 0 ) {
                return false;
            }
        }

        return true;
    }
}
/**
 * @name Line3
 */
class Line3 {
    constructor(start = new Vector3(), end = new Vector3()) {
        this.start = start;
        this.end = end;
    }

    /**
     * @name this.set
     * @memberof Line3
     *
     * @function
     * @param start
     * @param end
    */
    set(start, end) {
		this.start.copy(start);
		this.end.copy(end);
		return this;
	}

    /**
     * @name this.clone
     * @memberof Line3
     *
     * @function
    */
	clone() {
		return new this.constructor().copy(this);
	}

    /**
     * @name this.copy
     * @memberof Line3
     *
     * @function
     * @param line
    */
	copy(line) {
		this.start.copy(line.start);
		this.end.copy(line.end);
		return this;
	}

    /**
     * @name this.getCenter
     * @memberof Line3
     *
     * @function
     * @param target
    */
	getCenter(target = new Vector3()) {
		return target.addVectors(this.start, this.end).multiplyScalar(0.5);
	}

    /**
     * @name this.delta
     * @memberof Line3
     *
     * @function
     * @param target
    */
	delta(target = new Vector3()) {
		return target.subVectors(this.end, this.start);
	}

    /**
     * @name this.distanceSq
     * @memberof Line3
     *
     * @function
    */
	distanceSq() {
		return this.start.distanceToSquared(this.end);
	}

    /**
     * @name this.distance
     * @memberof Line3
     *
     * @function
    */
	distance() {
		return this.start.distanceTo(this.end);
	}

    /**
     * @name this.at
     * @memberof Line3
     *
     * @function
     * @param t
     * @param target
    */
	at(t, target = new Vector3()) {
		return this.delta(target).multiplyScalar(t).add(this.start);
	}

    /**
     * @name this.closestPointToPointParameter
     * @memberof Line3
     *
     * @function
     * @param point
     * @param clampToLine
    */
	closestPointToPointParameter(point, clampToLine) {
		let startP = this.V1 || new Vector3();
        let startEnd = this.V2 || new Vector3();
        this.V1 = startP;
        this.V2 = startEnd;

        startP.subVectors(point, this.start);
        startEnd.subVectors(this.end, this.start);

        let startEnd2 = startEnd.dot(startEnd);
        let startEnd_startP = startEnd.dot(startP);
        let t = startEnd_startP / startEnd2;

        if (clampToLine) {
            t = Math.clamp(t, 0, 1);
        }

        return t;
	}

    /**
     * @name this.closestPointToPoint
     * @memberof Line3
     *
     * @function
     * @param point
     * @param clampToLine
     * @param target
    */
	closestPointToPoint(point, clampToLine, target = new Vector3()) {
		let t = this.closestPointToPointParameter(point, clampToLine);
		return this.delta( target ).multiplyScalar( t ).add(this.start);
	}

    /**
     * @name this.applyMatrix4
     * @memberof Line3
     *
     * @function
     * @param matrix
    */
	applyMatrix4(matrix) {
		this.start.applyMatrix4(matrix);
		this.end.applyMatrix4(matrix);
		return this;
	}

    /**
     * @name this.equals
     * @memberof Line3
     *
     * @function
     * @param line
    */
	equals(line) {
		return line.start.equals(this.start) && line.end.equals(this.end);
	}
}
/**
 * @name Matrix3
 */
class Matrix3 {
    constructor() {
        this.elements = new Float32Array([
            1, 0, 0,
            0, 1, 0,
            0, 0, 1
        ]);
    }

    /**
     * @name elements
     * @memberof Matrix3
     * @property
     */

    /**
     * @name set
     * @memberof Matrix3
     *
     * @function
     * @return {Matrix3}
     */
    set(n11, n12, n13, n21, n22, n23, n31, n32, n33) {
        let te = this.elements;

        te[ 0 ] = n11; te[ 1 ] = n21; te[ 2 ] = n31;
        te[ 3 ] = n12; te[ 4 ] = n22; te[ 5 ] = n32;
        te[ 6 ] = n13; te[ 7 ] = n23; te[ 8 ] = n33;

        return this;
    }

    /**
     * @name identity
     * @memberof Matrix3
     *
     * @function
     * @return {Matrix3}
     */
    identity() {
        this.set(
            1, 0, 0,
            0, 1, 0,
            0, 0, 1
        );

        return this;
    }

    /**
     * @name clone
     * @memberof Matrix3
     *
     * @function
     * @return {Matrix3}
     */
    clone() {
        return new Matrix3().fromArray(this.elements);
    }

    /**
     * @name this.copy
     * @memberof Matrix3
     *
     * @function
     * @param m
    */
    copy(m) {
        let te = this.elements;
        let me = m.elements;

        te[ 0 ] = me[ 0 ]; te[ 1 ] = me[ 1 ]; te[ 2 ] = me[ 2 ];
        te[ 3 ] = me[ 3 ]; te[ 4 ] = me[ 4 ]; te[ 5 ] = me[ 5 ];
        te[ 6 ] = me[ 6 ]; te[ 7 ] = me[ 7 ]; te[ 8 ] = me[ 8 ];

        return this;
    }

    /**
     * @name setFromMatrix4
     * @memberof Matrix3
     *
     * @function
     * @param {Matrix4} m
     * @return {Matrix3}
     */
    setFromMatrix4(m) {
        let me = m.elements;
        this.set(
            me[ 0 ], me[ 4 ], me[ 8 ],
            me[ 1 ], me[ 5 ], me[ 9 ],
            me[ 2 ], me[ 6 ], me[ 10 ]
        );

        return this;
    }

    /**
     * @name multiply
     * @memberof Matrix3
     *
     * @function
     * @param {Matrix3} m
     * @return {Matrix3}
     */
    multiply(m) {
        return this.multiplyMatrices(this, m);
    }

    /**
     * @name premultiply
     * @memberof Matrix3
     *
     * @function
     * @param {Matrix3} m
     * @return {Matrix3}
     */
    premultiply(m) {
        return this.multiplyMatrices(m, this);
    }

    /**
     * @name multiplyMatrices
     * @memberof Matrix3
     *
     * @function
     * @param {Matrix3} a
     * @param {Matrix3} b
     * @return {Matrix3}
     */
    multiplyMatrices(a, b) {
        let ae = a.elements;
        let be = b.elements;
        let te = this.elements;

        let a11 = ae[ 0 ], a12 = ae[ 3 ], a13 = ae[ 6 ];
        let a21 = ae[ 1 ], a22 = ae[ 4 ], a23 = ae[ 7 ];
        let a31 = ae[ 2 ], a32 = ae[ 5 ], a33 = ae[ 8 ];

        let b11 = be[ 0 ], b12 = be[ 3 ], b13 = be[ 6 ];
        let b21 = be[ 1 ], b22 = be[ 4 ], b23 = be[ 7 ];
        let b31 = be[ 2 ], b32 = be[ 5 ], b33 = be[ 8 ];

        te[ 0 ] = a11 * b11 + a12 * b21 + a13 * b31;
        te[ 3 ] = a11 * b12 + a12 * b22 + a13 * b32;
        te[ 6 ] = a11 * b13 + a12 * b23 + a13 * b33;

        te[ 1 ] = a21 * b11 + a22 * b21 + a23 * b31;
        te[ 4 ] = a21 * b12 + a22 * b22 + a23 * b32;
        te[ 7 ] = a21 * b13 + a22 * b23 + a23 * b33;

        te[ 2 ] = a31 * b11 + a32 * b21 + a33 * b31;
        te[ 5 ] = a31 * b12 + a32 * b22 + a33 * b32;
        te[ 8 ] = a31 * b13 + a32 * b23 + a33 * b33;

        return this;
    }

    /**
     * @name multiplyScalar
     * @memberof Matrix3
     *
     * @function
     * @param {Number} s
     * @return {Matrix3}
     */
    multiplyScalar(s) {
        let te = this.elements;

        te[ 0 ] *= s; te[ 3 ] *= s; te[ 6 ] *= s;
        te[ 1 ] *= s; te[ 4 ] *= s; te[ 7 ] *= s;
        te[ 2 ] *= s; te[ 5 ] *= s; te[ 8 ] *= s;

        return this;
    }

    /**
     * @name determinant
     * @memberof Matrix3
     *
     * @function
     * @return {Number}
     */
    determinant() {
        let te = this.elements;

        let a = te[ 0 ], b = te[ 1 ], c = te[ 2 ],
            d = te[ 3 ], e = te[ 4 ], f = te[ 5 ],
            g = te[ 6 ], h = te[ 7 ], i = te[ 8 ];

        return a * e * i - a * f * h - b * d * i + b * f * g + c * d * h - c * e * g;
    }

    /**
     * @name getInverse
     * @memberof Matrix3
     *
     * @function
     * @param {Matrix3} m
     * @return {Matrix3}
     */
    getInverse(matrix, throwOnDegenerate) {
        let me = matrix.elements,
            te = this.elements,

            n11 = me[ 0 ], n21 = me[ 1 ], n31 = me[ 2 ],
            n12 = me[ 3 ], n22 = me[ 4 ], n32 = me[ 5 ],
            n13 = me[ 6 ], n23 = me[ 7 ], n33 = me[ 8 ],

            t11 = n33 * n22 - n32 * n23,
            t12 = n32 * n13 - n33 * n12,
            t13 = n23 * n12 - n22 * n13,

            det = n11 * t11 + n21 * t12 + n31 * t13;

        if ( det === 0 ) {

            let msg = ".getInverse() can't invert matrix, determinant is 0";

            if ( throwOnDegenerate === true ) {

                throw new Error( msg );

            } else {

                // console.warn( msg );

            }

            return this.identity();

        }

        let detInv = 1 / det;

        te[ 0 ] = t11 * detInv;
        te[ 1 ] = ( n31 * n23 - n33 * n21 ) * detInv;
        te[ 2 ] = ( n32 * n21 - n31 * n22 ) * detInv;

        te[ 3 ] = t12 * detInv;
        te[ 4 ] = ( n33 * n11 - n31 * n13 ) * detInv;
        te[ 5 ] = ( n31 * n12 - n32 * n11 ) * detInv;

        te[ 6 ] = t13 * detInv;
        te[ 7 ] = ( n21 * n13 - n23 * n11 ) * detInv;
        te[ 8 ] = ( n22 * n11 - n21 * n12 ) * detInv;

        return this;

    }

    /**
     * @name transpose
     * @memberof Matrix3
     *
     * @function
     * @return {Matrix3}
     */
    transpose() {
        let tmp, m = this.elements;

        tmp = m[ 1 ]; m[ 1 ] = m[ 3 ]; m[ 3 ] = tmp;
        tmp = m[ 2 ]; m[ 2 ] = m[ 6 ]; m[ 6 ] = tmp;
        tmp = m[ 5 ]; m[ 5 ] = m[ 7 ]; m[ 7 ] = tmp;

        return this;
    }

    /**
     * @name getNormalMatrix
     * @memberof Matrix3
     *
     * @function
     * @param {Matrix4} m
     * @return {Matrix3}
     */
    getNormalMatrix(matrix4) {
        return this.setFromMatrix4( matrix4 ).getInverse( this ).transpose();
    }

    /**
     * @name this.setUvTransform
     * @memberof Matrix3
     *
     * @function
     * @param tx
     * @param ty
     * @param sx
     * @param sy
     * @param rotation
     * @param cx
     * @param cy
    */
    setUvTransform(tx, ty, sx, sy, rotation, cx, cy) {
        let c = Math.cos( rotation );
        let s = Math.sin( rotation );

        this.set(
            sx * c, sx * s, - sx * ( c * cx + s * cy ) + cx + tx,
            - sy * s, sy * c, - sy * ( - s * cx + c * cy ) + cy + ty,
            0, 0, 1
        );
    }

    /**
     * @name scale
     * @memberof Matrix3
     *
     * @function
     * @param {Number} sx
     * @param {Number} sy
     * @return {Matrix3}
     */
    scale(sx, sy) {
        let te = this.elements;

        te[ 0 ] *= sx; te[ 3 ] *= sx; te[ 6 ] *= sx;
        te[ 1 ] *= sy; te[ 4 ] *= sy; te[ 7 ] *= sy;

        return this;
    }

    /**
     * @name rotate
     * @memberof Matrix3
     *
     * @function
     * @param {Number} theta
     * @return {Matrix3}
     */
    rotate(theta) {
        let c = Math.cos( theta );
        let s = Math.sin( theta );

        let te = this.elements;

        let a11 = te[ 0 ], a12 = te[ 3 ], a13 = te[ 6 ];
        let a21 = te[ 1 ], a22 = te[ 4 ], a23 = te[ 7 ];

        te[ 0 ] = c * a11 + s * a21;
        te[ 3 ] = c * a12 + s * a22;
        te[ 6 ] = c * a13 + s * a23;

        te[ 1 ] = - s * a11 + c * a21;
        te[ 4 ] = - s * a12 + c * a22;
        te[ 7 ] = - s * a13 + c * a23;

        return this;
    }

    /**
     * @name translate
     * @memberof Matrix3
     *
     * @function
     * @param {Number} tx
     * @param {Number} ty
     * @return {Matrix3}
     */
    translate(tx, ty) {
        let te = this.elements;

        te[ 0 ] += tx * te[ 2 ]; te[ 3 ] += tx * te[ 5 ]; te[ 6 ] += tx * te[ 8 ];
        te[ 1 ] += ty * te[ 2 ]; te[ 4 ] += ty * te[ 5 ]; te[ 7 ] += ty * te[ 8 ];

        return this;
    }

    /**
     * @name this.equals
     * @memberof Matrix3
     *
     * @function
     * @param matrix
    */
    equals(matrix) {
        let te = this.elements;
        let me = matrix.elements;

        for ( let i = 0; i < 9; i ++ ) {
            if ( te[ i ] !== me[ i ] ) return false;
        }

        return true;
    }

    /**
     * @name this.fromArray
     * @memberof Matrix3
     *
     * @function
     * @param array
     * @param offset
    */
    fromArray(array, offset) {
        if ( offset === undefined ) offset = 0;
        for ( let i = 0; i < 9; i ++ ) {
            this.elements[ i ] = array[ i + offset ];
        }

        return this;
    }

    /**
     * @name this.toArray
     * @memberof Matrix3
     *
     * @function
     * @param array
     * @param offset
    */
    toArray(array, offset) {
        if ( array === undefined ) array = [];
        if ( offset === undefined ) offset = 0;

        let te = this.elements;

        array[ offset ] = te[ 0 ];
        array[ offset + 1 ] = te[ 1 ];
        array[ offset + 2 ] = te[ 2 ];

        array[ offset + 3 ] = te[ 3 ];
        array[ offset + 4 ] = te[ 4 ];
        array[ offset + 5 ] = te[ 5 ];

        array[ offset + 6 ] = te[ 6 ];
        array[ offset + 7 ] = te[ 7 ];
        array[ offset + 8 ] = te[ 8 ];

        return array;
    }

    /**
     * @name this.applyToBufferAttribute
     * @memberof Matrix3
     *
     * @function
     * @param attribute
    */
    applyToBufferAttribute(attribute) {
        let v1 = this.V1 || new Vector3();
        this.V1 = v1;

        for (let i = 0, l = attribute.count; i < l; i ++) {
            v1.x = attribute.array[i * 3 + 0]
            v1.y = attribute.array[i * 3 + 1];
            v1.z = attribute.array[i * 3 + 2];
            v1.applyMatrix3(this);

            attribute.array[i * 3 + 0] = v1.x;
            attribute.array[i * 3 + 1] = v1.y;
            attribute.array[i * 3 + 2] = v1.z;
        }

        return attribute;
    }
}
/**
 * @name Matrix4
 */
class Matrix4 {
    constructor() {
        this.elements = new Float32Array([
            1, 0, 0, 0,
            0, 1, 0, 0,
            0, 0, 1, 0,
            0, 0, 0, 1
        ]);
    }

    /**
     * @name elements
     * @memberof Matrix3
     * @property
     */

    /**
     * @name set
     * @memberof Matrix3
     *
     * @function
     * @return {Matrix3}
     */
    set(n11, n12, n13, n14, n21, n22, n23, n24, n31, n32, n33, n34, n41, n42, n43, n44) {
        let te = this.elements;

        te[ 0 ] = n11; te[ 4 ] = n12; te[ 8 ] = n13; te[ 12 ] = n14;
        te[ 1 ] = n21; te[ 5 ] = n22; te[ 9 ] = n23; te[ 13 ] = n24;
        te[ 2 ] = n31; te[ 6 ] = n32; te[ 10 ] = n33; te[ 14 ] = n34;
        te[ 3 ] = n41; te[ 7 ] = n42; te[ 11 ] = n43; te[ 15 ] = n44;

        return this;
    }

    /**
     * @name identity
     * @memberof Matrix3
     *
     * @function
     * @return {Matrix3}
     */
    identity() {
        this.set(
            1, 0, 0, 0,
            0, 1, 0, 0,
            0, 0, 1, 0,
            0, 0, 0, 1
        );

        return this;
    }

    /**
     * @name clone
     * @memberof Matrix3
     *
     * @function
     * @return {Matrix3}
     */
    clone() {
        return new Matrix4().fromArray( this.elements );
    }

    /**
     * @name this.copy
     * @memberof Matrix4
     *
     * @function
     * @param m
    */
    copy(m) {
        let te = this.elements;
        let me = m.elements;

        te[ 0 ] = me[ 0 ]; te[ 1 ] = me[ 1 ]; te[ 2 ] = me[ 2 ]; te[ 3 ] = me[ 3 ];
        te[ 4 ] = me[ 4 ]; te[ 5 ] = me[ 5 ]; te[ 6 ] = me[ 6 ]; te[ 7 ] = me[ 7 ];
        te[ 8 ] = me[ 8 ]; te[ 9 ] = me[ 9 ]; te[ 10 ] = me[ 10 ]; te[ 11 ] = me[ 11 ];
        te[ 12 ] = me[ 12 ]; te[ 13 ] = me[ 13 ]; te[ 14 ] = me[ 14 ]; te[ 15 ] = me[ 15 ];

        return this;
    }

    /**
     * @name copyPosition
     * @memberof Matrix4
     *
     * @function
     * @param {Matrix4} m
     * @return {Matrix4}
     */
    copyPosition(m) {
        let te = this.elements, me = m.elements;
        te[ 12 ] = me[ 12 ];
        te[ 13 ] = me[ 13 ];
        te[ 14 ] = me[ 14 ];

        return this;
    }

    /**
     * @name extractBasis
     * @memberof Matrix4
     *
     * @function
     * @param {Number} xAxis
     * @param {Number} yAxis
     * @param {Number} zAxis
     * @return {Matrix4}
     */
    extractBasis(xAxis, yAxis, zAxis) {
        xAxis.setFromMatrixColumn( this, 0 );
        yAxis.setFromMatrixColumn( this, 1 );
        zAxis.setFromMatrixColumn( this, 2 );

        return this;
    }

    /**
     * @name makeBasis
     * @memberof Matrix4
     *
     * @function
     * @param {Number} xAxis
     * @param {Number} yAxis
     * @param {Number} zAxis
     * @return {Matrix4}
     */
    makeBasis(xAxis, yAxis, zAxis) {
        this.set(
            xAxis.x, yAxis.x, zAxis.x, 0,
            xAxis.y, yAxis.y, zAxis.y, 0,
            xAxis.z, yAxis.z, zAxis.z, 0,
            0, 0, 0, 1
        );

        return this;
    }

    /**
     * @name extractRotation
     * @memberof Matrix4
     *
     * @function
     * @param {Matrix4} m
     * @return {Matrix4}
     */
    extractRotation(m) {
        let v1 = this.V1 || new Vector3();
        this.V1 = v1;

        let te = this.elements;
        let me = m.elements;

        let scaleX = 1 / v1.setFromMatrixColumn( m, 0 ).length();
        let scaleY = 1 / v1.setFromMatrixColumn( m, 1 ).length();
        let scaleZ = 1 / v1.setFromMatrixColumn( m, 2 ).length();

        te[ 0 ] = me[ 0 ] * scaleX;
        te[ 1 ] = me[ 1 ] * scaleX;
        te[ 2 ] = me[ 2 ] * scaleX;

        te[ 4 ] = me[ 4 ] * scaleY;
        te[ 5 ] = me[ 5 ] * scaleY;
        te[ 6 ] = me[ 6 ] * scaleY;

        te[ 8 ] = me[ 8 ] * scaleZ;
        te[ 9 ] = me[ 9 ] * scaleZ;
        te[ 10 ] = me[ 10 ] * scaleZ;

        return this;
    }

    /**
     * @name makeRotationFromEuler
     * @memberof Matrix4
     *
     * @function
     * @param {Euler} euler
     * @return {Matrix4}
     */
    makeRotationFromEuler(euler) {
        let te = this.elements;

        let x = euler.x, y = euler.y, z = euler.z;
        let a = Math.cos( x ), b = Math.sin( x );
        let c = Math.cos( y ), d = Math.sin( y );
        let e = Math.cos( z ), f = Math.sin( z );

        if ( euler.order === 'XYZ' ) {

            let ae = a * e, af = a * f, be = b * e, bf = b * f;

            te[ 0 ] = c * e;
            te[ 4 ] = - c * f;
            te[ 8 ] = d;

            te[ 1 ] = af + be * d;
            te[ 5 ] = ae - bf * d;
            te[ 9 ] = - b * c;

            te[ 2 ] = bf - ae * d;
            te[ 6 ] = be + af * d;
            te[ 10 ] = a * c;

        } else if ( euler.order === 'YXZ' ) {

            let ce = c * e, cf = c * f, de = d * e, df = d * f;

            te[ 0 ] = ce + df * b;
            te[ 4 ] = de * b - cf;
            te[ 8 ] = a * d;

            te[ 1 ] = a * f;
            te[ 5 ] = a * e;
            te[ 9 ] = - b;

            te[ 2 ] = cf * b - de;
            te[ 6 ] = df + ce * b;
            te[ 10 ] = a * c;

        } else if ( euler.order === 'ZXY' ) {

            let ce = c * e, cf = c * f, de = d * e, df = d * f;

            te[ 0 ] = ce - df * b;
            te[ 4 ] = - a * f;
            te[ 8 ] = de + cf * b;

            te[ 1 ] = cf + de * b;
            te[ 5 ] = a * e;
            te[ 9 ] = df - ce * b;

            te[ 2 ] = - a * d;
            te[ 6 ] = b;
            te[ 10 ] = a * c;

        } else if ( euler.order === 'ZYX' ) {

            let ae = a * e, af = a * f, be = b * e, bf = b * f;

            te[ 0 ] = c * e;
            te[ 4 ] = be * d - af;
            te[ 8 ] = ae * d + bf;

            te[ 1 ] = c * f;
            te[ 5 ] = bf * d + ae;
            te[ 9 ] = af * d - be;

            te[ 2 ] = - d;
            te[ 6 ] = b * c;
            te[ 10 ] = a * c;

        } else if ( euler.order === 'YZX' ) {

            let ac = a * c, ad = a * d, bc = b * c, bd = b * d;

            te[ 0 ] = c * e;
            te[ 4 ] = bd - ac * f;
            te[ 8 ] = bc * f + ad;

            te[ 1 ] = f;
            te[ 5 ] = a * e;
            te[ 9 ] = - b * e;

            te[ 2 ] = - d * e;
            te[ 6 ] = ad * f + bc;
            te[ 10 ] = ac - bd * f;

        } else if ( euler.order === 'XZY' ) {

            let ac = a * c, ad = a * d, bc = b * c, bd = b * d;

            te[ 0 ] = c * e;
            te[ 4 ] = - f;
            te[ 8 ] = d * e;

            te[ 1 ] = ac * f + bd;
            te[ 5 ] = a * e;
            te[ 9 ] = ad * f - bc;

            te[ 2 ] = bc * f - ad;
            te[ 6 ] = b * e;
            te[ 10 ] = bd * f + ac;

        }

        // last column
        te[ 3 ] = 0;
        te[ 7 ] = 0;
        te[ 11 ] = 0;

        // bottom row
        te[ 12 ] = 0;
        te[ 13 ] = 0;
        te[ 14 ] = 0;
        te[ 15 ] = 1;

        return this;
    }

    /**
     * @name makeRotationFromQuaternion
     * @memberof Matrix4
     *
     * @function
     * @param {Euler} euler
     * @return {Matrix4}
     */
    makeRotationFromQuaternion(q) {
        let te = this.elements;

        let x = q._x, y = q._y, z = q._z, w = q._w;
        // if (!!window.NativeUtils) {
        //     NativeUtils.makeRotationFromQuaternion(te, x, y, z, w);
        // } else {
            let x2 = x + x, y2 = y + y, z2 = z + z;
            let xx = x * x2, xy = x * y2, xz = x * z2;
            let yy = y * y2, yz = y * z2, zz = z * z2;
            let wx = w * x2, wy = w * y2, wz = w * z2;

            te[ 0 ] = 1 - ( yy + zz );
            te[ 4 ] = xy - wz;
            te[ 8 ] = xz + wy;

            te[ 1 ] = xy + wz;
            te[ 5 ] = 1 - ( xx + zz );
            te[ 9 ] = yz - wx;

            te[ 2 ] = xz - wy;
            te[ 6 ] = yz + wx;
            te[ 10 ] = 1 - ( xx + yy );

            // last column
            te[ 3 ] = 0;
            te[ 7 ] = 0;
            te[ 11 ] = 0;

            // bottom row
            te[ 12 ] = 0;
            te[ 13 ] = 0;
            te[ 14 ] = 0;
            te[ 15 ] = 1;
        // }

        return this;
    }

    /**
     * @name lookAt
     * @memberof Matrix4
     *
     * @function
     * @param {Vector3} eye
     * @param {Vector3} target
     * @param {Vector3} up
     * @return {Matrix4}
     */
    lookAt(eye, target, up) {
        let x = this.V1 || new Vector3();
        let y = this.V2 || new Vector3();
        let z = this.V3 || new Vector3();

        this.V1 = x;
        this.V2 = y;
        this.V3 = z;

        let te = this.elements;

        z.subVectors( eye, target );

        if ( z.lengthSq() === 0 ) {

            // eye and target are in the same position

            z.z = 1;

        }

        z.normalize();
        x.crossVectors( up, z );

        if ( x.lengthSq() === 0 ) {

            // up and z are parallel

            if ( Math.abs( up.z ) === 1 ) {

                z.x += 0.0001;

            } else {

                z.z += 0.0001;

            }

            z.normalize();
            x.crossVectors( up, z );

        }

        x.normalize();
        y.crossVectors( z, x );

        te[ 0 ] = x.x; te[ 4 ] = y.x; te[ 8 ] = z.x;
        te[ 1 ] = x.y; te[ 5 ] = y.y; te[ 9 ] = z.y;
        te[ 2 ] = x.z; te[ 6 ] = y.z; te[ 10 ] = z.z;

        return this;
    }

    /**
     * @name multiply
     * @memberof Matrix4
     *
     * @function
     * @param {Matrix} m
     * @return {Matrix4}
     */
    multiply(m) {
        return this.multiplyMatrices( this, m );
    }

    /**
     * @name premultiply
     * @memberof Matrix4
     *
     * @function
     * @param {Matrix} m
     * @return {Matrix4}
     */
    premultiply(m) {
        return this.multiplyMatrices( m, this );
    }

    /**
     * @name multiplyMatrices
     * @memberof Matrix4
     *
     * @function
     * @param {Matrix} a
     * @param {Matrix} b
     * @return {Matrix4}
     */
    multiplyMatrices(ae, be) {
        let a = ae.elements;
        let b = be.elements;
        let out = this.elements;

        let a00 = a[0],
            a01 = a[1],
            a02 = a[2],
            a03 = a[3];
        let a10 = a[4],
            a11 = a[5],
            a12 = a[6],
            a13 = a[7];
        let a20 = a[8],
            a21 = a[9],
            a22 = a[10],
            a23 = a[11];
        let a30 = a[12],
            a31 = a[13],
            a32 = a[14],
            a33 = a[15];

        // Cache only the current line of the second matrix
        let b0 = b[0],
            b1 = b[1],
            b2 = b[2],
            b3 = b[3];
        out[0] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
        out[1] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
        out[2] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
        out[3] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;

        b0 = b[4];
        b1 = b[5];
        b2 = b[6];
        b3 = b[7];
        out[4] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
        out[5] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
        out[6] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
        out[7] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;

        b0 = b[8];
        b1 = b[9];
        b2 = b[10];
        b3 = b[11];
        out[8] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
        out[9] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
        out[10] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
        out[11] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;

        b0 = b[12];
        b1 = b[13];
        b2 = b[14];
        b3 = b[15];
        out[12] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
        out[13] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
        out[14] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
        out[15] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;

        return this;
    }

    /**
     * @name multiplyScalar
     * @memberof Matrix4
     *
     * @function
     * @param {Number} s
     * @return {Matrix4}
     */
    multiplyScalar(s) {
        let te = this.elements;

        te[ 0 ] *= s; te[ 4 ] *= s; te[ 8 ] *= s; te[ 12 ] *= s;
        te[ 1 ] *= s; te[ 5 ] *= s; te[ 9 ] *= s; te[ 13 ] *= s;
        te[ 2 ] *= s; te[ 6 ] *= s; te[ 10 ] *= s; te[ 14 ] *= s;
        te[ 3 ] *= s; te[ 7 ] *= s; te[ 11 ] *= s; te[ 15 ] *= s;

        return this;
    }

    /**
     * @name determinant
     * @memberof Matrix4
     *
     * @function
     * @return {Matrix4}
     */
    determinant() {
        let te = this.elements;

        let n11 = te[ 0 ], n12 = te[ 4 ], n13 = te[ 8 ], n14 = te[ 12 ];
        let n21 = te[ 1 ], n22 = te[ 5 ], n23 = te[ 9 ], n24 = te[ 13 ];
        let n31 = te[ 2 ], n32 = te[ 6 ], n33 = te[ 10 ], n34 = te[ 14 ];
        let n41 = te[ 3 ], n42 = te[ 7 ], n43 = te[ 11 ], n44 = te[ 15 ];

        return (
            n41 * (
                + n14 * n23 * n32
                - n13 * n24 * n32
                - n14 * n22 * n33
                + n12 * n24 * n33
                + n13 * n22 * n34
                - n12 * n23 * n34
            ) +
            n42 * (
                + n11 * n23 * n34
                - n11 * n24 * n33
                + n14 * n21 * n33
                - n13 * n21 * n34
                + n13 * n24 * n31
                - n14 * n23 * n31
            ) +
            n43 * (
                + n11 * n24 * n32
                - n11 * n22 * n34
                - n14 * n21 * n32
                + n12 * n21 * n34
                + n14 * n22 * n31
                - n12 * n24 * n31
            ) +
            n44 * (
                - n13 * n22 * n31
                - n11 * n23 * n32
                + n11 * n22 * n33
                + n13 * n21 * n32
                - n12 * n21 * n33
                + n12 * n23 * n31
            )

        );

    }

    /**
     * @name transpose
     * @memberof Matrix4
     *
     * @function
     * @return {Matrix4}
     */
    transpose() {
        let te = this.elements;
        let tmp;

        tmp = te[ 1 ]; te[ 1 ] = te[ 4 ]; te[ 4 ] = tmp;
        tmp = te[ 2 ]; te[ 2 ] = te[ 8 ]; te[ 8 ] = tmp;
        tmp = te[ 6 ]; te[ 6 ] = te[ 9 ]; te[ 9 ] = tmp;

        tmp = te[ 3 ]; te[ 3 ] = te[ 12 ]; te[ 12 ] = tmp;
        tmp = te[ 7 ]; te[ 7 ] = te[ 13 ]; te[ 13 ] = tmp;
        tmp = te[ 11 ]; te[ 11 ] = te[ 14 ]; te[ 14 ] = tmp;

        return this;
    }

    /**
     * @name setPosition
     * @memberof Matrix4
     *
     * @function
     * @param {Vector3} v
     * @return {Matrix4}
     */
    setPosition(v) {
        let te = this.elements;

        te[ 12 ] = v.x;
        te[ 13 ] = v.y;
        te[ 14 ] = v.z;

        return this;
    }

    /**
     * @name getInverse
     * @memberof Matrix4
     *
     * @function
     * @param {Matrix4} m
     * @return {Matrix4}
     */
    getInverse(m, throwOnDegenerate) {
        let te = this.elements,
            me = m.elements,

            n11 = me[ 0 ], n21 = me[ 1 ], n31 = me[ 2 ], n41 = me[ 3 ],
            n12 = me[ 4 ], n22 = me[ 5 ], n32 = me[ 6 ], n42 = me[ 7 ],
            n13 = me[ 8 ], n23 = me[ 9 ], n33 = me[ 10 ], n43 = me[ 11 ],
            n14 = me[ 12 ], n24 = me[ 13 ], n34 = me[ 14 ], n44 = me[ 15 ],

            t11 = n23 * n34 * n42 - n24 * n33 * n42 + n24 * n32 * n43 - n22 * n34 * n43 - n23 * n32 * n44 + n22 * n33 * n44,
            t12 = n14 * n33 * n42 - n13 * n34 * n42 - n14 * n32 * n43 + n12 * n34 * n43 + n13 * n32 * n44 - n12 * n33 * n44,
            t13 = n13 * n24 * n42 - n14 * n23 * n42 + n14 * n22 * n43 - n12 * n24 * n43 - n13 * n22 * n44 + n12 * n23 * n44,
            t14 = n14 * n23 * n32 - n13 * n24 * n32 - n14 * n22 * n33 + n12 * n24 * n33 + n13 * n22 * n34 - n12 * n23 * n34;

        let det = n11 * t11 + n21 * t12 + n31 * t13 + n41 * t14;

        if ( det === 0 ) {

            let msg = ".getInverse() can't invert matrix, determinant is 0";

            if ( throwOnDegenerate === true ) {

                throw new Error( msg );

            } else {

                // console.warn( msg );

            }

            return this.identity();

        }

        let detInv = 1 / det;

        te[ 0 ] = t11 * detInv;
        te[ 1 ] = ( n24 * n33 * n41 - n23 * n34 * n41 - n24 * n31 * n43 + n21 * n34 * n43 + n23 * n31 * n44 - n21 * n33 * n44 ) * detInv;
        te[ 2 ] = ( n22 * n34 * n41 - n24 * n32 * n41 + n24 * n31 * n42 - n21 * n34 * n42 - n22 * n31 * n44 + n21 * n32 * n44 ) * detInv;
        te[ 3 ] = ( n23 * n32 * n41 - n22 * n33 * n41 - n23 * n31 * n42 + n21 * n33 * n42 + n22 * n31 * n43 - n21 * n32 * n43 ) * detInv;

        te[ 4 ] = t12 * detInv;
        te[ 5 ] = ( n13 * n34 * n41 - n14 * n33 * n41 + n14 * n31 * n43 - n11 * n34 * n43 - n13 * n31 * n44 + n11 * n33 * n44 ) * detInv;
        te[ 6 ] = ( n14 * n32 * n41 - n12 * n34 * n41 - n14 * n31 * n42 + n11 * n34 * n42 + n12 * n31 * n44 - n11 * n32 * n44 ) * detInv;
        te[ 7 ] = ( n12 * n33 * n41 - n13 * n32 * n41 + n13 * n31 * n42 - n11 * n33 * n42 - n12 * n31 * n43 + n11 * n32 * n43 ) * detInv;

        te[ 8 ] = t13 * detInv;
        te[ 9 ] = ( n14 * n23 * n41 - n13 * n24 * n41 - n14 * n21 * n43 + n11 * n24 * n43 + n13 * n21 * n44 - n11 * n23 * n44 ) * detInv;
        te[ 10 ] = ( n12 * n24 * n41 - n14 * n22 * n41 + n14 * n21 * n42 - n11 * n24 * n42 - n12 * n21 * n44 + n11 * n22 * n44 ) * detInv;
        te[ 11 ] = ( n13 * n22 * n41 - n12 * n23 * n41 - n13 * n21 * n42 + n11 * n23 * n42 + n12 * n21 * n43 - n11 * n22 * n43 ) * detInv;

        te[ 12 ] = t14 * detInv;
        te[ 13 ] = ( n13 * n24 * n31 - n14 * n23 * n31 + n14 * n21 * n33 - n11 * n24 * n33 - n13 * n21 * n34 + n11 * n23 * n34 ) * detInv;
        te[ 14 ] = ( n14 * n22 * n31 - n12 * n24 * n31 - n14 * n21 * n32 + n11 * n24 * n32 + n12 * n21 * n34 - n11 * n22 * n34 ) * detInv;
        te[ 15 ] = ( n12 * n23 * n31 - n13 * n22 * n31 + n13 * n21 * n32 - n11 * n23 * n32 - n12 * n21 * n33 + n11 * n22 * n33 ) * detInv;

        return this;
    }

    /**
     * @name invert
     * @memberof Matrix4
     *
     * @function
     */
    invert() {
		const te = this.elements,

			n11 = te[ 0 ], n21 = te[ 1 ], n31 = te[ 2 ], n41 = te[ 3 ],
			n12 = te[ 4 ], n22 = te[ 5 ], n32 = te[ 6 ], n42 = te[ 7 ],
			n13 = te[ 8 ], n23 = te[ 9 ], n33 = te[ 10 ], n43 = te[ 11 ],
			n14 = te[ 12 ], n24 = te[ 13 ], n34 = te[ 14 ], n44 = te[ 15 ],

			t11 = n23 * n34 * n42 - n24 * n33 * n42 + n24 * n32 * n43 - n22 * n34 * n43 - n23 * n32 * n44 + n22 * n33 * n44,
			t12 = n14 * n33 * n42 - n13 * n34 * n42 - n14 * n32 * n43 + n12 * n34 * n43 + n13 * n32 * n44 - n12 * n33 * n44,
			t13 = n13 * n24 * n42 - n14 * n23 * n42 + n14 * n22 * n43 - n12 * n24 * n43 - n13 * n22 * n44 + n12 * n23 * n44,
			t14 = n14 * n23 * n32 - n13 * n24 * n32 - n14 * n22 * n33 + n12 * n24 * n33 + n13 * n22 * n34 - n12 * n23 * n34;

		const det = n11 * t11 + n21 * t12 + n31 * t13 + n41 * t14;

		if ( det === 0 ) return this.set( 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 );

		const detInv = 1 / det;

		te[ 0 ] = t11 * detInv;
		te[ 1 ] = ( n24 * n33 * n41 - n23 * n34 * n41 - n24 * n31 * n43 + n21 * n34 * n43 + n23 * n31 * n44 - n21 * n33 * n44 ) * detInv;
		te[ 2 ] = ( n22 * n34 * n41 - n24 * n32 * n41 + n24 * n31 * n42 - n21 * n34 * n42 - n22 * n31 * n44 + n21 * n32 * n44 ) * detInv;
		te[ 3 ] = ( n23 * n32 * n41 - n22 * n33 * n41 - n23 * n31 * n42 + n21 * n33 * n42 + n22 * n31 * n43 - n21 * n32 * n43 ) * detInv;

		te[ 4 ] = t12 * detInv;
		te[ 5 ] = ( n13 * n34 * n41 - n14 * n33 * n41 + n14 * n31 * n43 - n11 * n34 * n43 - n13 * n31 * n44 + n11 * n33 * n44 ) * detInv;
		te[ 6 ] = ( n14 * n32 * n41 - n12 * n34 * n41 - n14 * n31 * n42 + n11 * n34 * n42 + n12 * n31 * n44 - n11 * n32 * n44 ) * detInv;
		te[ 7 ] = ( n12 * n33 * n41 - n13 * n32 * n41 + n13 * n31 * n42 - n11 * n33 * n42 - n12 * n31 * n43 + n11 * n32 * n43 ) * detInv;

		te[ 8 ] = t13 * detInv;
		te[ 9 ] = ( n14 * n23 * n41 - n13 * n24 * n41 - n14 * n21 * n43 + n11 * n24 * n43 + n13 * n21 * n44 - n11 * n23 * n44 ) * detInv;
		te[ 10 ] = ( n12 * n24 * n41 - n14 * n22 * n41 + n14 * n21 * n42 - n11 * n24 * n42 - n12 * n21 * n44 + n11 * n22 * n44 ) * detInv;
		te[ 11 ] = ( n13 * n22 * n41 - n12 * n23 * n41 - n13 * n21 * n42 + n11 * n23 * n42 + n12 * n21 * n43 - n11 * n22 * n43 ) * detInv;

		te[ 12 ] = t14 * detInv;
		te[ 13 ] = ( n13 * n24 * n31 - n14 * n23 * n31 + n14 * n21 * n33 - n11 * n24 * n33 - n13 * n21 * n34 + n11 * n23 * n34 ) * detInv;
		te[ 14 ] = ( n14 * n22 * n31 - n12 * n24 * n31 - n14 * n21 * n32 + n11 * n24 * n32 + n12 * n21 * n34 - n11 * n22 * n34 ) * detInv;
		te[ 15 ] = ( n12 * n23 * n31 - n13 * n22 * n31 + n13 * n21 * n32 - n11 * n23 * n32 - n12 * n21 * n33 + n11 * n22 * n33 ) * detInv;

		return this;

	}

    /**
     * @name scale
     * @memberof Matrix4
     *
     * @function
     * @param {Vector3} v
     * @return {Matrix4}
     */
    scale(v) {
        let te = this.elements;
        let x = v.x, y = v.y, z = v.z;

        // if (!!window.NativeUtils) {
        //     NativeUtils.scaleMatrix(te, x, y, z);
        // } else {
            te[ 0 ] *= x; te[ 4 ] *= y; te[ 8 ] *= z;
            te[ 1 ] *= x; te[ 5 ] *= y; te[ 9 ] *= z;
            te[ 2 ] *= x; te[ 6 ] *= y; te[ 10 ] *= z;
            te[ 3 ] *= x; te[ 7 ] *= y; te[ 11 ] *= z;
        // }

        return this;
    }

    /**
     * @name this.getMaxScaleOnAxis
     * @memberof Matrix4
     *
     * @function
    */
    getMaxScaleOnAxis() {
        let te = this.elements;

        // if (!!window.NativeUtils) {
        //     return NativeUtils.getMaxScaleOnAxis(te);
        // } else {
            let scaleXSq = te[0] * te[0] + te[1] * te[1] + te[2] * te[2];
            let scaleYSq = te[4] * te[4] + te[5] * te[5] + te[6] * te[6];
            let scaleZSq = te[8] * te[8] + te[9] * te[9] + te[10] * te[10];
            return Math.sqrt(Math.max(scaleXSq, scaleYSq, scaleZSq));
        // }
    }

    /**
     * @name makeTranslation
     * @memberof Matrix4
     *
     * @function
     * @param {Number} x
     * @param {Number} y
     * @param {Number} z
     * @return {Matrix4}
     */
    makeTranslation(x, y, z) {
        this.set(
            1, 0, 0, x,
            0, 1, 0, y,
            0, 0, 1, z,
            0, 0, 0, 1
        );

        return this;
    }

    /**
     * @name makeRotationX
     * @memberof Matrix4
     *
     * @function
     * @param {Number} theta
     * @return {Matrix4}
     */
    makeRotationX(theta) {
        let c = Math.cos( theta ), s = Math.sin( theta );
        this.set(
            1, 0, 0, 0,
            0, c, - s, 0,
            0, s, c, 0,
            0, 0, 0, 1
        );

        return this;
    }

    /**
     * @name makeRotationY
     * @memberof Matrix4
     *
     * @function
     * @param {Number} theta
     * @return {Matrix4}
     */
    makeRotationY(theta) {
        let c = Math.cos( theta ), s = Math.sin( theta );

        this.set(
            c, 0, s, 0,
            0, 1, 0, 0,
            - s, 0, c, 0,
            0, 0, 0, 1
        );

        return this;
    }

    /**
     * @name makeRotationZ
     * @memberof Matrix4
     *
     * @function
     * @param {Number} theta
     * @return {Matrix4}
     */
    makeRotationZ(theta) {
        let c = Math.cos( theta ), s = Math.sin( theta );
        this.set(
            c, - s, 0, 0,
            s, c, 0, 0,
            0, 0, 1, 0,
            0, 0, 0, 1

        );
        return this;
    }

    /**
     * @name makeRotationAxis
     * @memberof Matrix4
     *
     * @function
     * @param {Vector3} axis
     * @param {Number} angle
     * @return {Matrix4}
     */
    makeRotationAxis(axis, angle) {
        let c = Math.cos( angle );
        let s = Math.sin( angle );
        let t = 1 - c;
        let x = axis.x, y = axis.y, z = axis.z;
        let tx = t * x, ty = t * y;

        this.set(
            tx * x + c, tx * y - s * z, tx * z + s * y, 0,
            tx * y + s * z, ty * y + c, ty * z - s * x, 0,
            tx * z - s * y, ty * z + s * x, t * z * z + c, 0,
            0, 0, 0, 1
        );

        return this;
    }

    /**
     * @name makeScale
     * @memberof Matrix4
     *
     * @function
     * @param {Number} x
     * @param {Number} y
     * @param {Number} z
     * @return {Matrix4}
     */
    makeScale(x, y, z) {
        this.set(
            x, 0, 0, 0,
            0, y, 0, 0,
            0, 0, z, 0,
            0, 0, 0, 1
        );

        return this;
    }

    /**
     * @name makeShear
     * @memberof Matrix4
     *
     * @function
     * @param {Number} x
     * @param {Number} y
     * @param {Number} z
     * @return {Matrix4}
     */
    makeShear(x, y, z) {
        this.set(
            1, y, z, 0,
            x, 1, z, 0,
            x, y, 1, 0,
            0, 0, 0, 1
        );

        return this;
    }

    /**
     * @name compose
     * @memberof Matrix4
     *
     * @function
     * @param {Vector3} position
     * @param {Quaternion} quaternion
     * @param {Vector3} scale
     * @return {Matrix4}
     */
    compose(position, quaternion, scale) {
        this.makeRotationFromQuaternion( quaternion );
        this.scale( scale );
        this.setPosition( position );
        return this;
    }

    /**
     * @name decompose
     * @memberof Matrix4
     *
     * @function
     * @param {Vector3} position
     * @param {Quaternion} quaternion
     * @param {Vector3} scale
     * @return {Matrix4}
     */
    decompose(position, quaternion, scale) {
        let vector = this.V1 || new Vector3();
        this.V1 = vector;

        let matrix = this.M1 || new Matrix4();
        this.M1 = matrix;

        let te = this.elements;

        let sx = vector.set( te[ 0 ], te[ 1 ], te[ 2 ] ).length();
        let sy = vector.set( te[ 4 ], te[ 5 ], te[ 6 ] ).length();
        let sz = vector.set( te[ 8 ], te[ 9 ], te[ 10 ] ).length();

        // if determine is negative, we need to invert one scale
        let det = this.determinant();
        if ( det < 0 ) sx = - sx;

        position.x = te[ 12 ];
        position.y = te[ 13 ];
        position.z = te[ 14 ];

        // scale the rotation part
        matrix.copy( this );

        let invSX = 1 / sx;
        let invSY = 1 / sy;
        let invSZ = 1 / sz;

        matrix.elements[ 0 ] *= invSX;
        matrix.elements[ 1 ] *= invSX;
        matrix.elements[ 2 ] *= invSX;

        matrix.elements[ 4 ] *= invSY;
        matrix.elements[ 5 ] *= invSY;
        matrix.elements[ 6 ] *= invSY;

        matrix.elements[ 8 ] *= invSZ;
        matrix.elements[ 9 ] *= invSZ;
        matrix.elements[ 10 ] *= invSZ;

        quaternion.setFromRotationMatrix( matrix );

        scale.x = sx;
        scale.y = sy;
        scale.z = sz;

        return this;
    }

    /**
     * @name makePerspective
     * @memberof Matrix4
     *
     * @function
     * @return {Matrix4}
     */
    makePerspective(left, right, top, bottom, near, far) {
        let te = this.elements;
        let x = 2 * near / ( right - left );
        let y = 2 * near / ( top - bottom );

        let a = ( right + left ) / ( right - left );
        let b = ( top + bottom ) / ( top - bottom );
        let c = - ( far + near ) / ( far - near );
        let d = - 2 * far * near / ( far - near );

        te[ 0 ] = x;	te[ 4 ] = 0;	te[ 8 ] = a;	te[ 12 ] = 0;
        te[ 1 ] = 0;	te[ 5 ] = y;	te[ 9 ] = b;	te[ 13 ] = 0;
        te[ 2 ] = 0;	te[ 6 ] = 0;	te[ 10 ] = c;	te[ 14 ] = d;
        te[ 3 ] = 0;	te[ 7 ] = 0;	te[ 11 ] = - 1;	te[ 15 ] = 0;

        return this;
    }

    /**
     * @name makeOrthographic
     * @memberof Matrix4
     *
     * @function
     * @return {Matrix4}
     */
    makeOrthographic(left, right, top, bottom, near, far) {
        let te = this.elements;
        let w = 1.0 / ( right - left );
        let h = 1.0 / ( top - bottom );
        let p = 1.0 / ( far - near );

        let x = ( right + left ) * w;
        let y = ( top + bottom ) * h;
        let z = ( far + near ) * p;

        te[ 0 ] = 2 * w;	te[ 4 ] = 0;	te[ 8 ] = 0;	te[ 12 ] = - x;
        te[ 1 ] = 0;	te[ 5 ] = 2 * h;	te[ 9 ] = 0;	te[ 13 ] = - y;
        te[ 2 ] = 0;	te[ 6 ] = 0;	te[ 10 ] = - 2 * p;	te[ 14 ] = - z;
        te[ 3 ] = 0;	te[ 7 ] = 0;	te[ 11 ] = 0;	te[ 15 ] = 1;

        return this;
    }

    /**
     * @name this.equals
     * @memberof Matrix4
     *
     * @function
     * @param matrix
    */
    equals(matrix) {
        let te = this.elements;
        let me = matrix.elements;

        if (te[0] != me[0]) return false;
        if (te[1] != me[1]) return false;
        if (te[2] != me[2]) return false;
        if (te[3] != me[3]) return false;
        if (te[4] != me[4]) return false;
        if (te[5] != me[5]) return false;
        if (te[6] != me[6]) return false;
        if (te[7] != me[7]) return false;
        if (te[8] != me[8]) return false;
        if (te[9] != me[9]) return false;
        if (te[10] != me[10]) return false;
        if (te[11] != me[11]) return false;
        if (te[12] != me[12]) return false;
        if (te[13] != me[13]) return false;
        if (te[14] != me[14]) return false;
        if (te[15] != me[15]) return false;

        return true;
    }

    /**
     * @name this.fromArray
     * @memberof Matrix4
     *
     * @function
     * @param array
     * @param offset
    */
    fromArray(array, offset = 0) {
        let te = this.elements;

        te[0] = array[0 + offset];
        te[1] = array[1 + offset];
        te[2] = array[2 + offset];
        te[3] = array[3 + offset];
        te[4] = array[4 + offset];
        te[5] = array[5 + offset];
        te[6] = array[6 + offset];
        te[7] = array[7 + offset];
        te[8] = array[8 + offset];
        te[9] = array[9 + offset];
        te[10] = array[10 + offset];
        te[11] = array[11 + offset];
        te[12] = array[12 + offset];
        te[13] = array[13 + offset];
        te[14] = array[14 + offset];
        te[15] = array[15 + offset];

        return this;
    }

    /**
     * @name this.toArray
     * @memberof Matrix4
     *
     * @function
     * @param array
     * @param offset
    */
    toArray(array, offset) {
        if ( array === undefined ) array = [];
        if ( offset === undefined ) offset = 0;

        let te = this.elements;

        array[ offset ] = te[ 0 ];
        array[ offset + 1 ] = te[ 1 ];
        array[ offset + 2 ] = te[ 2 ];
        array[ offset + 3 ] = te[ 3 ];

        array[ offset + 4 ] = te[ 4 ];
        array[ offset + 5 ] = te[ 5 ];
        array[ offset + 6 ] = te[ 6 ];
        array[ offset + 7 ] = te[ 7 ];

        array[ offset + 8 ] = te[ 8 ];
        array[ offset + 9 ] = te[ 9 ];
        array[ offset + 10 ] = te[ 10 ];
        array[ offset + 11 ] = te[ 11 ];

        array[ offset + 12 ] = te[ 12 ];
        array[ offset + 13 ] = te[ 13 ];
        array[ offset + 14 ] = te[ 14 ];
        array[ offset + 15 ] = te[ 15 ];

        return array;
    }

    /**
     * @name this.applyToBufferAttribute
     * @memberof Matrix4
     *
     * @function
     * @param attribute
    */
    applyToBufferAttribute(attribute) {
        let v1 = this.V1 || new Vector3();
        this.V1 = v1;

        for (let i = 0, l = attribute.count; i < l; i ++) {
            v1.x = attribute.array[i * 3 + 0]
            v1.y = attribute.array[i * 3 + 1];
            v1.z = attribute.array[i * 3 + 2];
            v1.applyMatrix4(this);

            attribute.array[i * 3 + 0] = v1.x;
            attribute.array[i * 3 + 1] = v1.y;
            attribute.array[i * 3 + 2] = v1.z;
        }

        return attribute;
    }

    /**
     * @name this.isIdentity
     * @memberof Matrix4
     *
     * @function
    */
    isIdentity() {
        let te = this.elements;

        if (te[0] != 1) return false;
        if (te[1] != 0) return false;
        if (te[2] != 0) return false;
        if (te[3] != 0) return false;
        if (te[4] != 0) return false;
        if (te[5] != 1) return false;
        if (te[6] != 0) return false;
        if (te[7] != 0) return false;
        if (te[8] != 0) return false;
        if (te[9] != 0) return false;
        if (te[10] != 1) return false;
        if (te[11] != 0) return false;
        if (te[12] != 0) return false;
        if (te[13] != 0) return false;
        if (te[14] != 0) return false;
        if (te[15] != 1) return false;

        return true;
    }
}

Matrix4.__IDENTITY__ = new Matrix4();

/**
 * @name Plane
 */
class Plane {
    constructor(normal, constant) {
        this.normal = ( normal !== undefined ) ? normal : new Vector3( 1, 0, 0 );
        this.constant = ( constant !== undefined ) ? constant : 0;
    }

    /**
     * @name this.set
     * @memberof Plane
     *
     * @function
     * @param normal
     * @param constant
    */
    set(normal, constant) {
        this.normal.copy( normal );
        this.constant = constant;

        return this;
    }

    /**
     * @name this.setComponents
     * @memberof Plane
     *
     * @function
     * @param x
     * @param y
     * @param z
     * @param w
    */
    setComponents(x, y, z, w) {
        this.normal.set( x, y, z );
        this.constant = w;

        return this;
    }

    /**
     * @name this.setFromNormalAndCoplanarPoint
     * @memberof Plane
     *
     * @function
     * @param normal
     * @param point
    */
    setFromNormalAndCoplanarPoint(normal, point) {
        this.normal.copy( normal );
        this.constant = - point.dot( this.normal );

        return this;
    }

    /**
     * @name this.setFromCoplanarPoints
     * @memberof Plane
     *
     * @function
     * @param a
     * @param b
     * @param c
    */
    setFromCoplanarPoints(a, b, c) {
        let v1 = this.V1 || new Vector3();
        let v2 = this.V2 || new Vector3();
        this.V1 = v1;
        this.V2 = v2;

        var normal = v1.subVectors( c, b ).cross( v2.subVectors( a, b ) ).normalize();
        this.setFromNormalAndCoplanarPoint( normal, a );

        return this;
    }

    /**
     * @name this.clone
     * @memberof Plane
     *
     * @function
    */
    clone() {
        return new Plane().copy(this);
    }

    /**
     * @name this.copy
     * @memberof Plane
     *
     * @function
     * @param plane
    */
    copy(plane) {
        this.normal.copy( plane.normal );
        this.constant = plane.constant;

        return this;
    }

    /**
     * @name this.normalize
     * @memberof Plane
     *
     * @function
    */
    normalize() {
        var inverseNormalLength = 1.0 / this.normal.length();
        this.normal.multiplyScalar( inverseNormalLength );
        this.constant *= inverseNormalLength;

        return this;
    }

    /**
     * @name this.negate
     * @memberof Plane
     *
     * @function
    */
    negate() {
        this.constant *= - 1;
        this.normal.negate();

        return this;
    }

    /**
     * @name this.distanceToPoint
     * @memberof Plane
     *
     * @function
     * @param point
    */
    distanceToPoint(point) {
        return this.normal.dot( point ) + this.constant;
    }

    /**
     * @name this.distanceToSphere
     * @memberof Plane
     *
     * @function
     * @param sphere
    */
    distanceToSphere(sphere) {
        return this.distanceToPoint( sphere.center ) - sphere.radius;
    }

    /**
     * @name this.projectPoint
     * @memberof Plane
     *
     * @function
     * @param point
     * @param target
    */
    projectPoint(point, target) {
        return target.copy( this.normal ).multiplyScalar( - this.distanceToPoint( point ) ).add( point );
    }

    /**
     * @name this.intersectLine
     * @memberof Plane
     *
     * @function
     * @param line
     * @param target
    */
    intersectLine(line, target) {
        let v1 = this.V1 || new Vector3();
        this.V1 = v1;
        var direction = line.delta( v1 );

        var denominator = this.normal.dot( direction );

        if ( denominator === 0 ) {

            // line is coplanar, return origin
            if ( this.distanceToPoint( line.start ) === 0 ) {

                return target.copy( line.start );

            }

            // Unsure if this is the correct method to handle this case.
            return undefined;

        }

        var t = - ( line.start.dot( this.normal ) + this.constant ) / denominator;

        if ( t < 0 || t > 1 ) {

            return undefined;

        }

        return target.copy( direction ).multiplyScalar( t ).add( line.start );
    }

    /**
     * @name this.intersectsLine
     * @memberof Plane
     *
     * @function
     * @param line
    */
    intersectsLine(line) {
        var startSign = this.distanceToPoint( line.start );
        var endSign = this.distanceToPoint( line.end );

        return ( startSign < 0 && endSign > 0 ) || ( endSign < 0 && startSign > 0 );
    }

    /**
     * @name this.intersectsBox
     * @memberof Plane
     *
     * @function
     * @param box
    */
    intersectsBox(box) {
        return box.intersectsPlane( this );
    }

    /**
     * @name this.intersectsSphere
     * @memberof Plane
     *
     * @function
     * @param sphere
    */
    intersectsSphere(sphere) {
        return sphere.intersectsPlane( this );
    }

    /**
     * @name this.coplanarPoint
     * @memberof Plane
     *
     * @function
     * @param target
    */
    coplanarPoint(target) {
        return target.copy( this.normal ).multiplyScalar( - this.constant );
    }

    /**
     * @name this.applyMatrix4
     * @memberof Plane
     *
     * @function
     * @param matrix
     * @param optionalNormalMatrix
    */
    applyMatrix4(matrix, optionalNormalMatrix) {
        let v1 = this.V1 || new Vector3();
        this.V1 = v1;

        let m1 = this.M1 || new Matrix3();
        this.M1 = m1;

        var normalMatrix = optionalNormalMatrix || m1.getNormalMatrix( matrix );
        var referencePoint = this.coplanarPoint( v1 ).applyMatrix4( matrix );
        var normal = this.normal.applyMatrix3( normalMatrix ).normalize();
        this.constant = - referencePoint.dot( normal );

        return this;
    }

    /**
     * @name this.translate
     * @memberof Plane
     *
     * @function
     * @param offset
    */
    translate(offset) {
        this.constant -= offset.dot( this.normal );
        return this;
    }

    /**
     * @name this.equals
     * @memberof Plane
     *
     * @function
     * @param plane
    */
    equals(plane) {
        return plane.normal.equals( this.normal ) && ( plane.constant === this.constant );
    }
}
/**
 * @name Quaternion
 * @param {Number} x
 * @param {Number} y
 * @param {Number} z
 * @param {Number} w
 */
class Quaternion {
    constructor(x, y, z, w) {
        this._x = x || 0;
        this._y = y || 0;
        this._z = z || 0;
        this._w = ( w !== undefined ) ? w : 1;
        this.isQuaternion = true;
    }

    get x() {
        return this._x;
    }

    set x(v) {
        if (zUtils3D.LOCAL && isNaN(v)) return console.trace('Quaternion::NaN');
        let dirty = Math.abs(this._x - v) > Base3D.DIRTY_EPSILON;
        this._x = v;
        if (dirty) this.onChangeCallback();
    }

    get y() {
        return this._y;
    }

    set y(v) {
        if (zUtils3D.LOCAL && isNaN(v)) return console.trace('Quaternion::NaN');
        let dirty = Math.abs(this._y - v) > Base3D.DIRTY_EPSILON;
        this._y = v;
        if (dirty) this.onChangeCallback();
    }

    get z() {
        return this._z;
    }

    set z(v) {
        if (zUtils3D.LOCAL && isNaN(v)) return console.trace('Quaternion::NaN');
        let dirty = Math.abs(this._z - v) > Base3D.DIRTY_EPSILON;
        this._z = v;
        if (dirty) this.onChangeCallback();
    }

    get w() {
        return this._w;
    }

    set w(v) {
        if (zUtils3D.LOCAL && isNaN(v)) return console.trace('Quaternion::NaN');
        let dirty = Math.abs(this._w - v) > Base3D.DIRTY_EPSILON;
        this._w = v;
        if (dirty) this.onChangeCallback();
    }

    /**
     * @name clone
     * @memberof Quaternion
     *
     * @return {Quaternion}
     */
    clone() {
        return new Quaternion(this._x, this._y, this._z, this._w);
    }

    /**
     * @name this.copy
     * @memberof Quaternion
     *
     * @function
     * @param quaternion
    */
    copy(quaternion) {
        const abs = Math.abs;
        let dirty = abs(this._x - quaternion.x) > Base3D.DIRTY_EPSILON || abs(this._y - quaternion.y) > Base3D.DIRTY_EPSILON || abs(this._z - quaternion.z) > Base3D.DIRTY_EPSILON || abs(this._w - quaternion.w) > Base3D.DIRTY_EPSILON;

        this._x = quaternion.x;
        this._y = quaternion.y;
        this._z = quaternion.z;
        this._w = quaternion.w;

        if (dirty) this.onChangeCallback();

        return this;
    }

    /**
     * @name set
     * @memberof Quaternion
     *
     * @function
     * @param {Number} x
     * @param {Number} y
     * @param {Number} z
     * @param {Number} w
     * @return {Quaternion}
     */
    set(x, y, z, w) {
        const abs = Math.abs;
        let dirty = abs(this._x - x) > Base3D.DIRTY_EPSILON || abs(this._y - y) > Base3D.DIRTY_EPSILON || abs(this._z - z) > Base3D.DIRTY_EPSILON || abs(this._w - w) > Base3D.DIRTY_EPSILON;

        this._x = x;
        this._y = y;
        this._z = z;
        this._w = w;
        if (dirty) this.onChangeCallback();
    }

    /**
     * @name setFromEuler
     * @memberof Quaternion
     *
     * @function
     * @param {Euler} euler
     * @return {Quaternion}
     */
    setFromEuler(euler, update) {
        let x = euler._x, y = euler._y, z = euler._z, order = euler.order;

        let cos = Math.cos;
        let sin = Math.sin;

        let c1 = cos( x / 2 );
        let c2 = cos( y / 2 );
        let c3 = cos( z / 2 );

        let s1 = sin( x / 2 );
        let s2 = sin( y / 2 );
        let s3 = sin( z / 2 );

        if ( order === 'XYZ' ) {

            this._x = s1 * c2 * c3 + c1 * s2 * s3;
            this._y = c1 * s2 * c3 - s1 * c2 * s3;
            this._z = c1 * c2 * s3 + s1 * s2 * c3;
            this._w = c1 * c2 * c3 - s1 * s2 * s3;

        } else if ( order === 'YXZ' ) {

            this._x = s1 * c2 * c3 + c1 * s2 * s3;
            this._y = c1 * s2 * c3 - s1 * c2 * s3;
            this._z = c1 * c2 * s3 - s1 * s2 * c3;
            this._w = c1 * c2 * c3 + s1 * s2 * s3;

        } else if ( order === 'ZXY' ) {

            this._x = s1 * c2 * c3 - c1 * s2 * s3;
            this._y = c1 * s2 * c3 + s1 * c2 * s3;
            this._z = c1 * c2 * s3 + s1 * s2 * c3;
            this._w = c1 * c2 * c3 - s1 * s2 * s3;

        } else if ( order === 'ZYX' ) {

            this._x = s1 * c2 * c3 - c1 * s2 * s3;
            this._y = c1 * s2 * c3 + s1 * c2 * s3;
            this._z = c1 * c2 * s3 - s1 * s2 * c3;
            this._w = c1 * c2 * c3 + s1 * s2 * s3;

        } else if ( order === 'YZX' ) {

            this._x = s1 * c2 * c3 + c1 * s2 * s3;
            this._y = c1 * s2 * c3 + s1 * c2 * s3;
            this._z = c1 * c2 * s3 - s1 * s2 * c3;
            this._w = c1 * c2 * c3 - s1 * s2 * s3;

        } else if ( order === 'XZY' ) {

            this._x = s1 * c2 * c3 - c1 * s2 * s3;
            this._y = c1 * s2 * c3 - s1 * c2 * s3;
            this._z = c1 * c2 * s3 + s1 * s2 * c3;
            this._w = c1 * c2 * c3 + s1 * s2 * s3;

        }

        if ( update !== false ) this.onChangeCallback();

        return this;
    }

    /**
     * @name setFromAxisAngle
     * @memberof Quaternion
     *
     * @function
     * @param {Number} axis
     * @param {Number} angle
     * @return {Quaternion}
     */
    setFromAxisAngle(axis, angle) {
        let halfAngle = angle / 2, s = Math.sin( halfAngle );

        this._x = axis.x * s;
        this._y = axis.y * s;
        this._z = axis.z * s;
        this._w = Math.cos( halfAngle );

        this.onChangeCallback();

        return this;
    }

    /**
     * @name setFromRotationMatrix
     * @memberof Quaternion
     *
     * @function
     * @param {Matrix4} m
     * @return {Quaternion}
     */
    setFromRotationMatrix(m) {
        let te = m.elements,

            m11 = te[ 0 ], m12 = te[ 4 ], m13 = te[ 8 ],
            m21 = te[ 1 ], m22 = te[ 5 ], m23 = te[ 9 ],
            m31 = te[ 2 ], m32 = te[ 6 ], m33 = te[ 10 ],

            trace = m11 + m22 + m33,
            s;

        if ( trace > 0 ) {

            s = 0.5 / Math.sqrt( trace + 1.0 );

            this._w = 0.25 / s;
            this._x = ( m32 - m23 ) * s;
            this._y = ( m13 - m31 ) * s;
            this._z = ( m21 - m12 ) * s;

        } else if ( m11 > m22 && m11 > m33 ) {

            s = 2.0 * Math.sqrt( 1.0 + m11 - m22 - m33 );

            this._w = ( m32 - m23 ) / s;
            this._x = 0.25 * s;
            this._y = ( m12 + m21 ) / s;
            this._z = ( m13 + m31 ) / s;

        } else if ( m22 > m33 ) {

            s = 2.0 * Math.sqrt( 1.0 + m22 - m11 - m33 );

            this._w = ( m13 - m31 ) / s;
            this._x = ( m12 + m21 ) / s;
            this._y = 0.25 * s;
            this._z = ( m23 + m32 ) / s;

        } else {

            s = 2.0 * Math.sqrt( 1.0 + m33 - m11 - m22 );

            this._w = ( m21 - m12 ) / s;
            this._x = ( m13 + m31 ) / s;
            this._y = ( m23 + m32 ) / s;
            this._z = 0.25 * s;

        }

        this.onChangeCallback();

        return this;
    }

    /**
     * @name setFromUnitVectors
     * @memberof Quaternion
     *
     * @function
     * @param {Vector3} from
     * @param {Vector3} to
     * @return {Quaternion}
     */
    setFromUnitVectors(vFrom, vTo) {
        let v1 = this.V1 || new Vector3();
        this.V1 = v1;

        let EPS = 0.000001;

        let r = vFrom.dot( vTo ) + 1;

        if ( r < EPS ) {
            r = 0;
            if ( Math.abs( vFrom.x ) > Math.abs( vFrom.z ) ) {
                v1.set( - vFrom.y, vFrom.x, 0 );
            } else {
                v1.set( 0, - vFrom.z, vFrom.y );
            }
        } else {
            v1.crossVectors( vFrom, vTo );
        }

        this._x = v1.x;
        this._y = v1.y;
        this._z = v1.z;
        this._w = r;

        return this.normalize();
    }

    /**
     * @name inverse
     * @memberof Quaternion
     * @function
     * @return {Quaternion}
     */
    inverse() {
        return this.conjugate();
    }

    /**
     * @name conjugate
     * @memberof Quaternion
     * @function
     * @return {Quaternion}
     */
    conjugate() {
        this._x *= - 1;
        this._y *= - 1;
        this._z *= - 1;

        this.onChangeCallback();

        return this;
    }

    /**
     * @name dot
     * @memberof Quaternion
     *
     * @function
     * @param {Vector3} v
     * @return {Number}
     */
    dot(v) {
        const w = v._w === undefined ? 1 : v._w;
        return this._x * v._x + this._y * v._y + this._z * v._z + this._w * w;
    }

    /**
     * @name lengthSq
     * @memberof Quaternion
     * @function
     * @return {Number}
     */
    lengthSq() {
        return this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w;
    }

    /**
     * @name length
     * @memberof Quaternion
     * @function
     * @return {Number}
     */
    length() {
        return Math.sqrt( this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w );
    }

    /**
     * @name normalize
     * @memberof Quaternion
     * @function
     * @return {Quaternion}
     */
    normalize() {
        let l = this.length();

        if ( l === 0 ) {

            this._x = 0;
            this._y = 0;
            this._z = 0;
            this._w = 1;

        } else {

            l = 1 / l;

            this._x = this._x * l;
            this._y = this._y * l;
            this._z = this._z * l;
            this._w = this._w * l;

        }

        this.onChangeCallback();

        return this;
    }

    /**
     * @name multiply
     * @memberof Quaternion
     * @function
     * @param {Quaternion} q;
     * @return {Quaternion}
     */
    multiply(q) {
        return this.multiplyQuaternions( this, q );
    }

    /**
     * @name premultiply
     * @memberof Quaternion
     * @function
     * @param {Quaternion} q;
     * @return {Quaternion}
     */
    premultiply(q) {
        return this.multiplyQuaternions( q, this );
    }

    /**
     * @name multiplyQuaternions
     * @memberof Quaternion
     * @function
     * @param {Quaternion} a;
     * @param {Quaternion} b;
     * @return {Quaternion}
     */
    multiplyQuaternions(a, b) {
        let qax = a._x, qay = a._y, qaz = a._z, qaw = a._w;
        let qbx = b._x, qby = b._y, qbz = b._z, qbw = b._w;

        this._x = qax * qbw + qaw * qbx + qay * qbz - qaz * qby;
        this._y = qay * qbw + qaw * qby + qaz * qbx - qax * qbz;
        this._z = qaz * qbw + qaw * qbz + qax * qby - qay * qbx;
        this._w = qaw * qbw - qax * qbx - qay * qby - qaz * qbz;

        this.onChangeCallback();

        return this;
    }

    /**
     * @name slerp
     * @memberof Quaternion
     * @function
     * @param {Quaternion} qb;
     * @param {Number} t;
     * @return {Quaternion}
     */
    slerp(qb, t, hz = true) {
        if (hz) {
            t = Math.framerateNormalizeLerpAlpha(t);
        } else {
            t = Math.clamp(t);
        }
        if ( t === 0 ) return this;
        if ( t === 1 ) return this.copy( qb );

        let x = this._x, y = this._y, z = this._z, w = this._w;

        let cosHalfTheta = w * qb._w + x * qb._x + y * qb._y + z * qb._z;

        if ( cosHalfTheta < 0 ) {

            this._w = - qb._w;
            this._x = - qb._x;
            this._y = - qb._y;
            this._z = - qb._z;

            cosHalfTheta = - cosHalfTheta;

        } else {

            this.copy( qb );

        }

        if ( cosHalfTheta >= 1.0 ) {

            this._w = w;
            this._x = x;
            this._y = y;
            this._z = z;

            return this;

        }

        let sinHalfTheta = Math.sqrt( 1.0 - cosHalfTheta * cosHalfTheta );

        if ( Math.abs( sinHalfTheta ) < 0.001 ) {

            this._w = 0.5 * ( w + this._w );
            this._x = 0.5 * ( x + this._x );
            this._y = 0.5 * ( y + this._y );
            this._z = 0.5 * ( z + this._z );

            return this;

        }

        let halfTheta = Math.atan2( sinHalfTheta, cosHalfTheta );
        let ratioA = Math.sin( ( 1 - t ) * halfTheta ) / sinHalfTheta,
            ratioB = Math.sin( t * halfTheta ) / sinHalfTheta;

        this._w = ( w * ratioA + this._w * ratioB );
        this._x = ( x * ratioA + this._x * ratioB );
        this._y = ( y * ratioA + this._y * ratioB );
        this._z = ( z * ratioA + this._z * ratioB );

        this.onChangeCallback();

        return this;
    }

    /**
     * @name this.equals
     * @memberof Quaternion
     *
     * @function
     * @param quaternion
    */
    equals(quaternion) {
        return ( quaternion._x === this._x ) && ( quaternion._y === this._y ) && ( quaternion._z === this._z ) && ( quaternion._w === this._w );
    }

    /**
     * @name this.fromArray
     * @memberof Quaternion
     *
     * @function
     * @param array
     * @param offset
    */
    fromArray(array, offset) {
        if ( offset === undefined ) offset = 0;

        this._x = array[ offset ];
        this._y = array[ offset + 1 ];
        this._z = array[ offset + 2 ];
        this._w = array[ offset + 3 ];

        this.onChangeCallback();

        return this;
    }

    /**
     * @name this.toArray
     * @memberof Quaternion
     *
     * @function
     * @param array
     * @param offset
    */
    toArray(array, offset) {
        if ( array === undefined ) array = [];
        if ( offset === undefined ) offset = 0;

        array[ offset ] = this._x;
        array[ offset + 1 ] = this._y;
        array[ offset + 2 ] = this._z;
        array[ offset + 3 ] = this._w;

        return array;
    }

    /**
     * @name this.onChange
     * @memberof Quaternion
     *
     * @function
     * @param callback
    */
    onChange(callback) {
        this.onChangeCallback = callback;
    }

    /**
     * @name this.onChangeCallback
     * @memberof Quaternion
     *
     * @function
    */
    onChangeCallback() {

    }
}

/**
 * @name RayManager
 */
class RayManager {
    constructor(origin, direction, near = 0, far = Infinity) {
        this.ray = new Ray(origin, direction);
        this.near = near;
        this.far = far;

        this.params = {
            Mesh: {},
            Points: {threshold: 1}
        };
    }

    /**
     * @name this.set
     * @memberof RayManager
     *
     * @function
     * @param origin
     * @param direction
    */
    set(origin, direction) {
        this.ray.set(origin, direction);
        return this;
    }

    /**
     * @name this.setFromCamera
     * @memberof RayManager
     *
     * @function
     * @param coords
     * @param camera
    */
    setFromCamera(coords, camera) {
        if (camera.isPerspective) {
            this.ray.origin.setFromMatrixPosition( camera.matrixWorld );
            this.ray.direction.set( coords.x, coords.y, 0.5 ).unproject( camera ).sub( this.ray.origin ).normalize();
        } else {
            this.ray.origin.set( coords.x, coords.y, ( camera.near + camera.far ) / ( camera.near - camera.far ) ).unproject( camera ); // set origin in plane of camera
            this.ray.direction.set( 0, 0, - 1 ).transformDirection( camera.matrixWorld );
        }
    }

    /**
     * @name this._ascSort
     * @memberof RayManager
     *
     * @function
     * @param a
     * @param b
    */
    _ascSort(a, b) {
        return a.distance - b.distance;
    }

    /**
     * @name this._intersectObject
     * @memberof RayManager
     *
     * @function
     * @param object
     * @param raycaster
     * @param intersects
     * @param recursive
    */
    _intersectObject(object, raycaster, intersects, recursive, forceAllVisible) {
        if (object.visible === false && !forceAllVisible) return;
        if (object.raycast) object.raycast(raycaster, intersects);
        if (recursive === true) {
            let children = object.children;
            for ( let i = 0, l = children.length; i < l; i ++ ) {
                this._intersectObject(children[ i ], raycaster, intersects, true);
            }
        }
    }

    /**
     * @name this.intersectObject
     * @memberof RayManager
     *
     * @function
     * @param object
     * @param recursive
     * @param optionalTarget
    */
    intersectObject(object, recursive, optionalTarget, forceAllVisible) {
        let intersects = optionalTarget || [];
        this._intersectObject( object, this, intersects, recursive, forceAllVisible );
        intersects.sort(this._ascSort);
        return intersects;
    }

    /**
     * @name this.intersectObjects
     * @memberof RayManager
     *
     * @function
     * @param objects
     * @param recursive
     * @param optionalTarget
    */
    intersectObjects(objects, recursive, optionalTarget) {
        let intersects = optionalTarget || [];
        for ( let i = 0, l = objects.length; i < l; i ++ ) {
            this._intersectObject( objects[ i ], this, intersects, recursive );
        }

        intersects.sort(this._ascSort);
        return intersects;
    }
}

class Ray {
    constructor(origin = new Vector3(), direction = new Vector3()) {
        this.origin = origin;
        this.direction = direction;
    }

    set(origin, direction) {
        this.origin.copy(origin);
        this.direction.copy(direction);
        return this;
    }

    /**
     * @name this.clone
     * @memberof RayManager
     *
     * @function
    */
    clone() {
        return new Ray().copy(this);
    }

    /**
     * @name this.copy
     * @memberof RayManager
     *
     * @function
     * @param ray
    */
    copy(ray) {
        this.origin.copy(ray.origin);
        this.direction.copy(ray.direction);
        return this;
    }

    /**
     * @name this.at
     * @memberof RayManager
     *
     * @function
     * @param t
     * @param target
    */
    at(t, target = new Vector3()) {
        return target.copy(this.direction).multiplyScalar(t).add(this.origin);
    }

    /**
     * @name this.lookAt
     * @memberof RayManager
     *
     * @function
     * @param v
    */
    lookAt(v) {
        this.direction.copy(v).sub(this.origin).normalize();
        return this;
    }

    /**
     * @name this.recast
     * @memberof RayManager
     *
     * @function
     * @param t
    */
    recast(t) {
        let v1 = this.V1 || new Vector3();
        this.V1 = v1;

        this.origin.copy( this.at( t, v1 ) );
    }

    /**
     * @name this.closestPointToPoint
     * @memberof RayManager
     *
     * @function
     * @param point
     * @param target
    */
    closestPointToPoint(point, target = new Vector3()) {
        target.subVectors(point, this.origin);

        let directionDistance = target.dot(this.direction);
        if (directionDistance < 0) return target.copy(this.origin);

        return target.copy(this.direction).multiplyScalar(directionDistance).add(this.origin);
    }

    /**
     * @name this.distanceToPoint
     * @memberof RayManager
     *
     * @function
     * @param point
    */
    distanceToPoint(point) {
        return Math.sqrt(this.distanceSqToPoint(point));
    }

    /**
     * @name this.distanceSqToPoint
     * @memberof RayManager
     *
     * @function
     * @param point
    */
    distanceSqToPoint(point) {
        let v1 = this.V1 || new Vector3();
        this.V1 = v1;

        let directionDistance = v1.subVectors( point, this.origin ).dot( this.direction );
        if ( directionDistance < 0 ) return this.origin.distanceToSquared( point );

        v1.copy( this.direction ).multiplyScalar( directionDistance ).add( this.origin );
        return v1.distanceToSquared( point );
    }

    /**
     * @name this.distanceSqToSegment
     * @memberof RayManager
     *
     * @function
     * @param v0
     * @param v1
     * @param optionalPointOnRay
     * @param optionalPointOnSegment
    */
    distanceSqToSegment(v0, v1, optionalPointOnRay, optionalPointOnSegment) {
        let segCenter = this.V1 || new Vector3();
        let segDir = this.V2 || new Vector3();
        let diff = this.V3 || new Vector3();
        this.V1 = segCenter;
        this.V2 = segDir;
        this.V3 = diff;

        segCenter.copy( v0 ).add( v1 ).multiplyScalar( 0.5 );
        segDir.copy( v1 ).sub( v0 ).normalize();
        diff.copy( this.origin ).sub( segCenter );

        let segExtent = v0.distanceTo( v1 ) * 0.5;
        let a01 = - this.direction.dot( segDir );
        let b0 = diff.dot( this.direction );
        let b1 = - diff.dot( segDir );
        let c = diff.lengthSq();
        let det = Math.abs( 1 - a01 * a01 );
        let s0, s1, sqrDist, extDet;

        if ( det > 0 ) {

            // The ray and segment are not parallel.

            s0 = a01 * b1 - b0;
            s1 = a01 * b0 - b1;
            extDet = segExtent * det;

            if ( s0 >= 0 ) {

                if ( s1 >= - extDet ) {

                    if ( s1 <= extDet ) {

                        // region 0
                        // Minimum at interior points of ray and segment.

                        let invDet = 1 / det;
                        s0 *= invDet;
                        s1 *= invDet;
                        sqrDist = s0 * ( s0 + a01 * s1 + 2 * b0 ) + s1 * ( a01 * s0 + s1 + 2 * b1 ) + c;

                    } else {

                        // region 1

                        s1 = segExtent;
                        s0 = Math.max( 0, - ( a01 * s1 + b0 ) );
                        sqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;

                    }

                } else {

                    // region 5

                    s1 = - segExtent;
                    s0 = Math.max( 0, - ( a01 * s1 + b0 ) );
                    sqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;

                }

            } else {

                if ( s1 <= - extDet ) {

                    // region 4

                    s0 = Math.max( 0, - ( - a01 * segExtent + b0 ) );
                    s1 = ( s0 > 0 ) ? - segExtent : Math.min( Math.max( - segExtent, - b1 ), segExtent );
                    sqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;

                } else if ( s1 <= extDet ) {

                    // region 3

                    s0 = 0;
                    s1 = Math.min( Math.max( - segExtent, - b1 ), segExtent );
                    sqrDist = s1 * ( s1 + 2 * b1 ) + c;

                } else {

                    // region 2

                    s0 = Math.max( 0, - ( a01 * segExtent + b0 ) );
                    s1 = ( s0 > 0 ) ? segExtent : Math.min( Math.max( - segExtent, - b1 ), segExtent );
                    sqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;

                }

            }

        } else {

            // Ray and segment are parallel.

            s1 = ( a01 > 0 ) ? - segExtent : segExtent;
            s0 = Math.max( 0, - ( a01 * s1 + b0 ) );
            sqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;

        }

        if ( optionalPointOnRay ) {

            optionalPointOnRay.copy( this.direction ).multiplyScalar( s0 ).add( this.origin );

        }

        if ( optionalPointOnSegment ) {

            optionalPointOnSegment.copy( segDir ).multiplyScalar( s1 ).add( segCenter );

        }

        return sqrDist;
    }

    /**
     * @name this.intersectSphere
     * @memberof RayManager
     *
     * @function
     * @param sphere
     * @param target
    */
    intersectSphere(sphere, target) {
        let v1 = this.V1 || new Vector3();
        this.V1 = v1;

        v1.subVectors( sphere.center, this.origin );
        let tca = v1.dot( this.direction );
        let d2 = v1.dot( v1 ) - tca * tca;
        let radius2 = sphere.radius * sphere.radius;

        if ( d2 > radius2 ) return null;

        let thc = Math.sqrt( radius2 - d2 );

        // t0 = first intersect point - entrance on front of sphere
        let t0 = tca - thc;

        // t1 = second intersect point - exit point on back of sphere
        let t1 = tca + thc;

        // test to see if both t0 and t1 are behind the ray - if so, return null
        if ( t0 < 0 && t1 < 0 ) return null;

        // test to see if t0 is behind the ray:
        // if it is, the ray is inside the sphere, so return the second exit point scaled by t1,
        // in order to always return an intersect point that is in front of the ray.
        if ( t0 < 0 ) return this.at( t1, target );

        // else t0 is in front of the ray, so return the first collision point scaled by t0
        return this.at( t0, target );
    }

    /**
     * @name this.intersectsSphere
     * @memberof RayManager
     *
     * @function
     * @param sphere
    */
    intersectsSphere(sphere) {
        return this.distanceSqToPoint( sphere.center ) <= sphere.radius * sphere.radius;
    }

    /**
     * @name this.distanceToPlane
     * @memberof RayManager
     *
     * @function
     * @param plane
    */
    distanceToPlane(plane) {
        let denominator = plane.normal.dot( this.direction );

        if ( denominator === 0 ) {
            if ( plane.distanceToPoint( this.origin ) === 0 ) {
                return 0;
            }

            return null;
        }

        let t = - ( this.origin.dot( plane.normal ) + plane.constant ) / denominator;
        return t >= 0 ? t : null;
    }

    /**
     * @name this.intersectPlane
     * @memberof RayManager
     *
     * @function
     * @param plane
     * @param target
    */
    intersectPlane(plane, target) {
        let t = this.distanceToPlane( plane );
        if (t === null) {
            return null;
        }
        return this.at( t, target );
    }

    /**
     * @name this.intersectsPlane
     * @memberof RayManager
     *
     * @function
     * @param plane
    */
    intersectsPlane(plane) {
        let distToPoint = plane.distanceToPoint( this.origin );
        if ( distToPoint === 0 ) return true;
        let denominator = plane.normal.dot( this.direction );
        if ( denominator * distToPoint < 0 ) return true;
        return false;
    }

    /**
     * @name this.intersectBox
     * @memberof RayManager
     *
     * @function
     * @param box
     * @param target
    */
    intersectBox(box, target) {
        let tmin, tmax, tymin, tymax, tzmin, tzmax;

        let invdirx = 1 / this.direction.x,
            invdiry = 1 / this.direction.y,
            invdirz = 1 / this.direction.z;

        let origin = this.origin;

        if ( invdirx >= 0 ) {

            tmin = ( box.min.x - origin.x ) * invdirx;
            tmax = ( box.max.x - origin.x ) * invdirx;

        } else {

            tmin = ( box.max.x - origin.x ) * invdirx;
            tmax = ( box.min.x - origin.x ) * invdirx;

        }

        if ( invdiry >= 0 ) {

            tymin = ( box.min.y - origin.y ) * invdiry;
            tymax = ( box.max.y - origin.y ) * invdiry;

        } else {

            tymin = ( box.max.y - origin.y ) * invdiry;
            tymax = ( box.min.y - origin.y ) * invdiry;

        }

        if ( ( tmin > tymax ) || ( tymin > tmax ) ) return null;

        // These lines also handle the case where tmin or tmax is NaN
        // (result of 0 * Infinity). x !== x returns true if x is NaN

        if ( tymin > tmin || tmin !== tmin ) tmin = tymin;

        if ( tymax < tmax || tmax !== tmax ) tmax = tymax;

        if ( invdirz >= 0 ) {

            tzmin = ( box.min.z - origin.z ) * invdirz;
            tzmax = ( box.max.z - origin.z ) * invdirz;

        } else {

            tzmin = ( box.max.z - origin.z ) * invdirz;
            tzmax = ( box.min.z - origin.z ) * invdirz;

        }

        if ( ( tmin > tzmax ) || ( tzmin > tmax ) ) return null;

        if ( tzmin > tmin || tmin !== tmin ) tmin = tzmin;

        if ( tzmax < tmax || tmax !== tmax ) tmax = tzmax;

        //return point closest to the ray (positive side)

        if ( tmax < 0 ) return null;

        return this.at( tmin >= 0 ? tmin : tmax, target );
    }

    /**
     * @name this.intersectsBox
     * @memberof RayManager
     *
     * @function
     * @param box
    */
    intersectsBox(box) {
        let v = this.V1 || new Vector3();
        this.V1 = v;
        return this.intersectBox( box, v ) !== null;
    }

    /**
     * @name this.intersectsTriangle
     * @memberof RayManager
     *
     * @function
     * @param a
     * @param b
     * @param c
     * @param backfaceCulling
     * @param target
    */
    intersectsTriangle(a, b, c, backfaceCulling, target) {
        let diff = this.V1 || new Vector3();
        let edge1 = this.V2 || new Vector3();
        let edge2 = this.V3 || new Vector3();
        let normal = this.V4 || new Vector3();
        this.V1 = diff;
        this.V2 = edge1;
        this.V3 = edge2;
        this.V4 = normal;

        edge1.subVectors( b, a );
        edge2.subVectors( c, a );
        normal.crossVectors( edge1, edge2 );

        // Solve Q + t*D = b1*E1 + b2*E2 (Q = kDiff, D = ray direction,
        // E1 = kEdge1, E2 = kEdge2, N = Cross(E1,E2)) by
        //   |Dot(D,N)|*b1 = sign(Dot(D,N))*Dot(D,Cross(Q,E2))
        //   |Dot(D,N)|*b2 = sign(Dot(D,N))*Dot(D,Cross(E1,Q))
        //   |Dot(D,N)|*t = -sign(Dot(D,N))*Dot(Q,N)
        let DdN = this.direction.dot( normal );
        let sign;

        if ( DdN > 0 ) {

            if ( backfaceCulling ) return null;
            sign = 1;

        } else if ( DdN < 0 ) {

            sign = - 1;
            DdN = - DdN;

        } else {

            return null;

        }

        diff.subVectors( this.origin, a );
        let DdQxE2 = sign * this.direction.dot( edge2.crossVectors( diff, edge2 ) );

        // b1 < 0, no intersection
        if ( DdQxE2 < 0 ) {

            return null;

        }

        let DdE1xQ = sign * this.direction.dot( edge1.cross( diff ) );

        // b2 < 0, no intersection
        if ( DdE1xQ < 0 ) {

            return null;

        }

        // b1+b2 > 1, no intersection
        if ( DdQxE2 + DdE1xQ > DdN ) {

            return null;

        }

        // Line intersects triangle, check if ray does.
        let QdN = - sign * diff.dot( normal );

        // t < 0, no intersection
        if ( QdN < 0 ) {

            return null;

        }

        // Ray intersects triangle.
        return this.at( QdN / DdN, target );
    }

    /**
     * @name this.applyMatrix4
     * @memberof RayManager
     *
     * @function
     * @param matrix4
    */
    applyMatrix4(matrix4) {
        this.origin.applyMatrix4( matrix4 );
        this.direction.transformDirection( matrix4 );
        return this;
    }

    /**
     * @name this.equals
     * @memberof RayManager
     *
     * @function
     * @param ray
    */
    equals(ray) {
        return ray.origin.equals( this.origin ) && ray.direction.equals( this.direction );
    }

}

/**
 * @name Sphere
 */
class Sphere {
    constructor(center = new Vector3(), radius = 0) {
        this.center = center;
        this.radius = radius;
    }

    /**
     * @name this.set
     * @memberof Sphere
     *
     * @function
     * @param center
     * @param radius
    */
    set(center, radius) {
		this.center.copy( center );
		this.radius = radius;
		return this;
	}

    /**
     * @name this.setFromPoints
     * @memberof Sphere
     *
     * @function
     * @param points
     * @param optionalCenter
    */
    setFromPoints(points, optionalCenter) {
        let box = this.V1 || new Box3();
        this.V1 = box;

        let center = this.center;
        if (optionalCenter !== undefined) {
            center.copy(optionalCenter);
        } else {
            box.setFromPoints(points).getCenter(center);
        }

        let maxRadiusSq = 0;
        for (let i = 0, il = points.length; i < il; i++) {
            maxRadiusSq = Math.max(maxRadiusSq, center.distanceToSquared(points[i]));
        }
        this.radius = Math.sqrt(maxRadiusSq);

        return this;
	}

    /**
     * @name this.clone
     * @memberof Sphere
     *
     * @function
    */
	clone() {
		return new this.constructor().copy(this);
	}

    /**
     * @name this.copy
     * @memberof Sphere
     *
     * @function
     * @param sphere
    */
	copy(sphere) {
		this.center.copy(sphere.center);
		this.radius = sphere.radius;
		return this;
	}

    /**
     * @name this.empty
     * @memberof Sphere
     *
     * @function
    */
	empty() {
		return (this.radius <= 0);
	}

    /**
     * @name this.containsPoint
     * @memberof Sphere
     *
     * @function
     * @param point
    */
	containsPoint(point) {
		return (point.distanceToSquared(this.center) <= (this.radius * this.radius));
	}

    /**
     * @name this.distanceToPoint
     * @memberof Sphere
     *
     * @function
     * @param point
    */
	distanceToPoint(point) {
       return (point.distanceTo(this.center) - this.radius);
	}

    /**
     * @name this.intersectsSphere
     * @memberof Sphere
     *
     * @function
     * @param sphere
    */
	intersectsSphere(sphere) {
		let radiusSum = this.radius + sphere.radius;
		return sphere.center.distanceToSquared(this.center) <= (radiusSum * radiusSum);
	}

    /**
     * @name this.intersectsBox
     * @memberof Sphere
     *
     * @function
     * @param box
    */
	intersectsBox(box) {
		return box.intersectsSphere(this);
	}

    /**
     * @name this.intersectsPlane
     * @memberof Sphere
     *
     * @function
     * @param plane
    */
	intersectsPlane(plane) {
		return Math.abs(plane.distanceToPoint(this.center)) <= this.radius;
	}

    /**
     * @name this.clampPoint
     * @memberof Sphere
     *
     * @function
     * @param point
     * @param target
    */
	clampPoint(point, target = new Vector3()) {
		let deltaLengthSq = this.center.distanceToSquared( point );
		target.copy(point);
		if (deltaLengthSq > (this.radius * this.radius)) {
			target.sub( this.center ).normalize();
			target.multiplyScalar( this.radius ).add( this.center );
		}
		return target;
	}

    /**
     * @name this.getBoundingBox
     * @memberof Sphere
     *
     * @function
     * @param target
    */
	getBoundingBox(target = new Box3()) {
		target.set(this.center, this.center);
		target.expandByScalar(this.radius);
		return target;
	}

    /**
     * @name this.applyMatrix4
     * @memberof Sphere
     *
     * @function
     * @param matrix
    */
	applyMatrix4(matrix) {
		this.center.applyMatrix4(matrix);
		this.radius = this.radius * matrix.getMaxScaleOnAxis();
		return this;
	}

    /**
     * @name this.translate
     * @memberof Sphere
     *
     * @function
     * @param offset
    */
	translate(offset) {
		this.center.add(offset);
		return this;
	}

    /**
     * @name this.equals
     * @memberof Sphere
     *
     * @function
     * @param sphere
    */
	equals(sphere) {
		return sphere.center.equals(this.center) && (sphere.radius === this.radius);
	}
}
/**
 * @name Spherical
 */
class Spherical {
    constructor(radius = 1, phi = 0, theta = 0) {
        this.radius = radius;
        this.phi = phi;
        this.theta = theta;
    }

    /**
     * @name this.set
     * @memberof Spherical
     *
     * @function
     * @param radius
     * @param phi
     * @param theta
    */
    set(radius, phi, theta) {
        this.radius = radius;
        this.phi = phi;
        this.theta = theta;
        return this;
    }

    /**
     * @name this.clone
     * @memberof Spherical
     *
     * @function
    */
    clone() {
        return new Spherical().copy(this);
    }

    /**
     * @name this.copy
     * @memberof Spherical
     *
     * @function
     * @param other
    */
    copy(other) {
        this.radius = other.radius;
        this.phi = other.phi;
        this.theta = other.theta;
        return this;
    }

    /**
     * @name this.makeSafe
     * @memberof Spherical
     *
     * @function
    */
    makeSafe() {
        var EPS = 0.000001;
        this.phi = Math.max( EPS, Math.min( Math.PI - EPS, this.phi ) );
        return this;
    }

    /**
     * @name this.setFromVector3
     * @memberof Spherical
     *
     * @function
     * @param vec3
    */
    setFromVector3(vec3) {
        this.radius = vec3.length();
        if ( this.radius === 0 ) {
            this.theta = 0;
            this.phi = 0;
        } else {
            this.theta = Math.atan2( vec3.x, vec3.z ); // equator angle around y-up axis
            this.phi = Math.acos( Math.clamp( vec3.y / this.radius, - 1, 1 ) ); // polar angle
        }
        return this;
    }
}
/**
 * @name Triangle
 */
class Triangle {
    constructor(a = new Vector3(), b = new Vector3(), c = new Vector3()) {
        this.a = a;
        this.b = b;
        this.c = c;
    }

    /**
     * @name this.set
     * @memberof Triangle
     *
     * @function
     * @param a
     * @param b
     * @param c
    */
    set(a, b, c) {
        this.a.copy( a );
        this.b.copy( b );
        this.c.copy( c );
        return this;
    }

    /**
     * @name this.setFromPointsAndIndices
     * @memberof Triangle
     *
     * @function
     * @param points
     * @param i0
     * @param i1
     * @param i2
    */
    setFromPointsAndIndices(points, i0, i1, i2) {
        this.a.copy( points[ i0 ] );
        this.b.copy( points[ i1 ] );
        this.c.copy( points[ i2 ] );
        return this;
    }

    /**
     * @name this.clone
     * @memberof Triangle
     *
     * @function
    */
    clone() {
        return new Triangle().copy(this);
    }

    /**
     * @name this.copy
     * @memberof Triangle
     *
     * @function
     * @param triangle
    */
    copy(triangle) {
        this.a.copy( triangle.a );
        this.b.copy( triangle.b );
        this.c.copy( triangle.c );
        return this;
    }

    /**
     * @name this.getArea
     * @memberof Triangle
     *
     * @function
    */
    getArea() {
        let v0 = this.V0 || new Vector3();
        let v1 = this.V1 || new Vector3();
        this.V0 = v0;
        this.V1 = v1;

        v0.subVectors( this.c, this.b );
        v1.subVectors( this.a, this.b );

        return v0.cross( v1 ).length() * 0.5;
    }

    /**
     * @name this.getMidpoint
     * @memberof Triangle
     *
     * @function
     * @param target
    */
    getMidpoint(target = new Vector3()) {
        return target.addVectors( this.a, this.b ).add( this.c ).multiplyScalar( 1 / 3 );
    }

    /**
     * @name this.getNormal
     * @memberof Triangle
     *
     * @function
     * @param target
    */
    getNormal(target) {
        return Triangle.getNormal( this.a, this.b, this.c, target );
    }

    /**
     * @name this.getPlane
     * @memberof Triangle
     *
     * @function
     * @param target
    */
    getPlane(target = new Vector3()) {
        return target.setFromCoplanarPoints( this.a, this.b, this.c );
    }

    /**
     * @name this.getBarycoord
     * @memberof Triangle
     *
     * @function
     * @param point
     * @param target
    */
    getBarycoord(point, target) {
        return Triangle.getBarycoord( point, this.a, this.b, this.c, target );
    }

    /**
     * @name this.containsPoint
     * @memberof Triangle
     *
     * @function
     * @param point
    */
    containsPoint(point) {
        return Triangle.containsPoint( point, this.a, this.b, this.c );
    }

    /**
     * @name this.intersectsBox
     * @memberof Triangle
     *
     * @function
     * @param box
    */
    intersectsBox(box) {
        return box.intersectsTriangle( this );
    }

    /**
     * @name this.equals
     * @memberof Triangle
     *
     * @function
     * @param triangle
    */
    equals(triangle) {
        return triangle.a.equals( this.a ) && triangle.b.equals( this.b ) && triangle.c.equals( this.c );
    }
}
/**
 * @name Vector2
 * @param {Number} x
 * @param {Number} y
 */
class Vector2 {
    constructor(x = 0, y = 0) {
        this.x = x;
        this.y = y;
    }

    /**
     * @name set
     * @memberof Vector2
     *
     * @function
     * @param {Number} x
     * @param {Number} y
     * @return {Vector2}
     */
    set(x, y) {
        this.x = x;
        this.y = y;

        return this;
    }

    /**
     * @name x
     * @memberof Vector2
     * @property
     */

    /**
     * @name y
     * @memberof Vector2
     * @property
     */

    /**
     * @name width
     * @memberof Vector2
     * @property
     */
    get width() {
        return this.x;
    }

    /**
     * @name this.get height
     * @memberof Vector2
     *
     * @function
    */
    get height() {
        return this.y;
    }

    /**
     * @name setScalar
     * @memberof Vector2
     *
     * @function
     * @param {Number} s
     * @return {Vector2}
     */
    setScalar(s) {
        this.x = this.y = s;

        return this;
    }

    /**
     * @name clone
     * @memberof Vector2
     *
     * @function
     * @return {Vector2}
     */
    clone() {
        return new Vector2(this.x, this.y);
    }

    /**
     * @name this.copy
     * @memberof Vector2
     *
     * @function
     * @param v
    */
    copy(v) {
        this.x = v.x;
        this.y = v.y;

        return this;
    }

    /**
     * @name add
     * @memberof Vector2
     *
     * @function
     * @param {Vector2} v
     * @return {Vector2}
     */
    add(v) {
        this.x += v.x;
        this.y += v.y;

        return this;
    }

    /**
     * @name addScalar
     * @memberof Vector2
     *
     * @function
     * @param {Number} s
     * @return {Vector2}
     */
    addScalar(s) {
        this.x += s;
        this.y += s;

        return this;
    }

    /**
     * @name addVectors
     * @memberof Vector2
     *
     * @function
     * @param {Vector2} a
     * @param {Vector2} b
     * @return {Vector2}
     */
    addVectors(a, b) {
        this.x = a.x + b.x;
        this.y = a.y + b.y;

        return this;
    }

    /**
     * @name addScaledVector
     * @memberof Vector2
     *
     * @function
     * @param {Vector2} v
     * @param {Number} s
     * @return {Vector2}
     */
    addScaledVector(v, s) {
        this.x += v.x * s;
        this.y += v.y * s;

        return this;
    }

    /**
     * @name sub
     * @memberof Vector2
     *
     * @function
     * @param {Vector2} v
     * @return {Vector2}
     */
    sub(v) {
        this.x -= v.x;
        this.y -= v.y;

        return this;
    }

    /**
     * @name subScalar
     * @memberof Vector2
     *
     * @function
     * @param {Number} s
     * @return {Vector2}
     */
    subScalar(s) {
        this.x -= s;
        this.y -= s;

        return this;
    }

    /**
     * @name subVectors
     * @memberof Vector2
     *
     * @function
     * @param {Vector2} a
     * @param {Vector2} b
     * @return {Vector2}
     */
    subVectors(a, b) {
        this.x = a.x - b.x;
        this.y = a.y - b.y;

        return this;
    }

    /**
     * @name multiply
     * @memberof Vector2
     *
     * @function
     * @param {Vector2} v
     * @return {Vector2}
     */
    multiply(v) {
        this.x *= v.x;
        this.y *= v.y;

        return this;
    }

    /**
     * @name multiplyScalar
     * @memberof Vector2
     *
     * @function
     * @param {Number} s
     * @return {Vector2}
     */
    multiplyScalar(scalar) {
        this.x *= scalar;
        this.y *= scalar;

        return this;
    }

    /**
     * @name divide
     * @memberof Vector2
     *
     * @function
     * @param {Vector2} v
     * @return {Vector2}
     */
    divide(v) {
        this.x /= v.x;
        this.y /= v.y;

        return this;
    }

    /**
     * @name divideScalar
     * @memberof Vector2
     *
     * @function
     * @param {Number} s
     * @return {Vector2}
     */
    divideScalar(scalar) {
        return this.multiplyScalar( 1 / scalar );
    }

    /**
     * @name applyMatrix3
     * @memberof Vector2
     *
     * @function
     * @param {Matrix3} m
     * @return {Vector2}
     */
    applyMatrix3(m) {
        let x = this.x, y = this.y;
        let e = m.elements;

        this.x = e[ 0 ] * x + e[ 3 ] * y + e[ 6 ];
        this.y = e[ 1 ] * x + e[ 4 ] * y + e[ 7 ];

        return this;
    }

    /**
     * @name this.min
     * @memberof Vector2
     *
     * @function
     * @param v
    */
    min(v) {
        this.x = Math.min( this.x, v.x );
        this.y = Math.min( this.y, v.y );

        return this;
    }

    /**
     * @name this.max
     * @memberof Vector2
     *
     * @function
     * @param v
    */
    max(v) {
        this.x = Math.max( this.x, v.x );
        this.y = Math.max( this.y, v.y );

        return this;
    }

    /**
     * @name this.clamp
     * @memberof Vector2
     *
     * @function
     * @param min
     * @param max
    */
    clamp(min, max) {
        this.x = Math.max( min.x, Math.min( max.x, this.x ) );
        this.y = Math.max( min.y, Math.min( max.y, this.y ) );

        return this;
    }

    /**
     * @name this.clampScalar
     * @memberof Vector2
     *
     * @function
     * @param minVal
     * @param maxVal
    */
    clampScalar(minVal, maxVal) {
        let min = new Vector2();
        let max = new Vector2();

        min.set( minVal, minVal );
        max.set( maxVal, maxVal );

        return this.clamp( min, max );
    }

    /**
     * @name this.clampLength
     * @memberof Vector2
     *
     * @function
     * @param min
     * @param max
    */
    clampLength(min, max) {
        let length = this.length();
        return this.divideScalar( length || 1 ).multiplyScalar( Math.max( min, Math.min( max, length ) ) );
    }

    /**
     * @name this.floor
     * @memberof Vector2
     *
     * @function
    */
    floor() {
        this.x = Math.floor( this.x );
        this.y = Math.floor( this.y );

        return this;
    }

    /**
     * @name this.ceil
     * @memberof Vector2
     *
     * @function
    */
    ceil() {
        this.x = Math.ceil( this.x );
        this.y = Math.ceil( this.y );

        return this;
    }

    /**
     * @name this.round
     * @memberof Vector2
     *
     * @function
    */
    round() {
        this.x = Math.round( this.x );
        this.y = Math.round( this.y );

        return this;
    }

    /**
     * @name this.roundToZero
     * @memberof Vector2
     *
     * @function
    */
    roundToZero() {
        this.x = ( this.x < 0 ) ? Math.ceil( this.x ) : Math.floor( this.x );
        this.y = ( this.y < 0 ) ? Math.ceil( this.y ) : Math.floor( this.y );

        return this;
    }

    /**
     * @name this.negate
     * @memberof Vector2
     *
     * @function
    */
    negate() {
        this.x = - this.x;
        this.y = - this.y;

        return this;
    }

    /**
     * @name dot
     * @memberof Vector2
     *
     * @function
     * @param {Vector2} v
     * @return {Number}
     */
    dot(v) {
        return this.x * v.x + this.y * v.y;
    }

    /**
     * @name lengthSq
     * @memberof Vector2
     *
     * @function
     * @return {Number}
     */
    lengthSq() {
        return this.x * this.x + this.y * this.y;
    }

    /**
     * @name length
     * @memberof Vector2
     *
     * @function
     * @return {Number}
     */
    length() {
        return Math.sqrt( this.x * this.x + this.y * this.y );
    }

    /**
     * @name this.manhattanLength
     * @memberof Vector2
     *
     * @function
    */
    manhattanLength() {
        return Math.abs( this.x ) + Math.abs( this.y );
    }

    /**
     * @name normalize
     * @memberof Vector2
     *
     * @function
     * @return {Vector2}
     */
    normalize() {
        return this.divideScalar( this.length() || 1 );
    }

    /**
     * @name angle
     * @memberof Vector2
     *
     * @function
     * @return {Number}
     */
    angle() {
        let angle = Math.atan2( this.y, this.x );
        if ( angle < 0 ) angle += 2 * Math.PI;
        return angle;
    }

    /**
     * @name this.angleTo
     * @memberof Vector2
     *
     * @function
     * @param a
     * @param b
    */
    angleTo(a, b) {
        if (!b) b = this;
        return Math.atan2(a.y - b.y, a.x - b.x);
    }

    /**
     * @name distanceTo
     * @memberof Vector2
     *
     * @function
     * @param {Vector2} v
     * @return {Number}
     */
    distanceTo(v) {
        return Math.sqrt( this.distanceToSquared( v ) );
    }

    /**
     * @name distanceToSquared
     * @memberof Vector2
     *
     * @function
     * @param {Vector2} v
     * @return {Number}
     */
    distanceToSquared(v) {
        let dx = this.x - v.x, dy = this.y - v.y;
        return dx * dx + dy * dy;
    }

    /**
     * @name this.manhattanDistanceTo
     * @memberof Vector2
     *
     * @function
     * @param v
    */
    manhattanDistanceTo(v) {
        return Math.abs( this.x - v.x ) + Math.abs( this.y - v.y );
    }

    /**
     * @name setLength
     * @memberof Vector2
     *
     * @function
     * @param {Number} length
     * @return {Number}
     */
    setLength(length) {
        return this.normalize().multiplyScalar( length );
    }

    /**
     * @name lerp
     * @memberof Vector2
     *
     * @function
     * @param {Vector2} v
     * @param {Number} alpha
     * @return {Vector2}
     */
    lerp(v, alpha, hz) {
        this.x = Math.lerp(v.x, this.x, alpha, hz);
        this.y = Math.lerp(v.y, this.y, alpha, hz);
        return this;
    }

    /**
     * @name this.lerpVectors
     * @memberof Vector2
     *
     * @function
     * @param v1
     * @param v2
     * @param alpha
    */
    lerpVectors(v1, v2, alpha) {
        return this.subVectors( v2, v1 ).multiplyScalar( alpha ).add( v1 );
    }

    /**
     * @name this.equals
     * @memberof Vector2
     *
     * @function
     * @param v
    */
    equals(v) {
        return ( ( v.x === this.x ) && ( v.y === this.y ) );
    }

    /**
     * @name this.setAngleRadius
     * @memberof Vector2
     *
     * @function
     * @param a
     * @param r
    */
    setAngleRadius(a, r) {
        this.x = Math.cos(a) * r;
        this.y = Math.sin(a) * r;
        return this;
    }

    /**
     * @name this.addAngleRadius
     * @memberof Vector2
     *
     * @function
     * @param a
     * @param r
    */
    addAngleRadius(a, r) {
        this.x += Math.cos(a) * r;
        this.y += Math.sin(a) * r;
        return this;
    }

    /**
     * @name this.fromArray
     * @memberof Vector2
     *
     * @function
     * @param array
     * @param offset
    */
    fromArray(array, offset) {
        if ( offset === undefined ) offset = 0;

        this.x = array[ offset ];
        this.y = array[ offset + 1 ];

        return this;
    }

    /**
     * @name this.toArray
     * @memberof Vector2
     *
     * @function
     * @param array
     * @param offset
    */
    toArray(array, offset) {
        if ( array === undefined ) array = [];
        if ( offset === undefined ) offset = 0;

        array[ offset ] = this.x;
        array[ offset + 1 ] = this.y;

        return array;
    }

    /**
     * @name this.rotateAround
     * @memberof Vector2
     *
     * @function
     * @param center
     * @param angle
    */
    rotateAround(center, angle) {
        let c = Math.cos( angle ), s = Math.sin( angle );

        let x = this.x - center.x;
        let y = this.y - center.y;

        this.x = x * c - y * s + center.x;
        this.y = x * s + y * c + center.y;

        return this;
    }

    /**
     * @name this.fromBufferAttribute
     * @memberof Vector2
     *
     * @function
     * @param attribute
     * @param index
    */
    fromBufferAttribute(attribute, index) {
        this.x = attribute.array[index * 2 + 0];
        this.y = attribute.array[index * 2 + 1];
    }

}
/**
 * @name Vector3
 * @param {Number} x
 * @param {Number} y
 * @param {Number} z
 */

class Vector3 {
    constructor(x, y, z) {
        this.x = x || 0;
        this.y = y || 0;
        this.z = z || 0;
    }

    /**
     * @name x
     * @memberof Vector3
     * @property
     */

    /**
     * @name y
     * @memberof Vector3
     * @property
     */

    /**
     * @name z
     * @memberof Vector3
     * @property
     */

    /**
     * @name set
     * @memberof Vector3
     *
     * @function
     * @param {Number} x
     * @param {Number} y
     * @param {Number} z
     * @return {Vector3}
     */
    set(x, y, z) {
        this.x = x || 0;
        this.y = y || 0;
        this.z = z || 0;

        return this;
    }

    /**
     * @name setScalar
     * @memberof Vector3
     *
     * @function
     * @param {Number} s
     * @return {Vector3}
     */
    setScalar(scalar) {
        this.x = scalar;
        this.y = scalar;
        this.z = scalar;

        return this;
    }

    /**
     * @name clone
     * @memberof Vector3
     *
     * @function
     * @return {Vector3}
     */
    clone() {
        return new Vector3(this.x, this.y, this.z);
    }

    /**
     * @name this.copy
     * @memberof Vector3
     *
     * @function
     * @param v
    */
    copy(v) {
        this.x = v.x;
        this.y = v.y;
        this.z = v.z;

        return this;
    }

    /**
     * @name add
     * @memberof Vector3
     *
     * @function
     * @param {Vector3} v
     * @return {Vector3}
     */
    add(v) {
        this.x += v.x;
        this.y += v.y;
        this.z += v.z;

        return this;
    }

    /**
     * @name addScalar
     * @memberof Vector3
     *
     * @function
     * @param {Number} s
     * @return {Vector3}
     */
    addScalar(s) {
        this.x += s;
        this.y += s;
        this.z += s;

        return this;
    }

    /**
     * @name addVectors
     * @memberof Vector3
     *
     * @function
     * @param {Vector3} a
     * @param {Vector3} b
     * @return {Vector3}
     */
    addVectors(a, b) {
        this.x = a.x + b.x;
        this.y = a.y + b.y;
        this.z = a.z + b.z;

        return this;
    }

    /**
     * @name addScaledVector
     * @memberof Vector3
     *
     * @function
     * @param {Vector3} v
     * @param {Number} s
     * @return {Vector3}
     */
    addScaledVector(v, s) {
        this.x += v.x * s;
        this.y += v.y * s;
        this.z += v.z * s;

        return this;
    }

    /**
     * @name sub
     * @memberof Vector3
     *
     * @function
     * @param {Vector3} v
     * @return {Vector3}
     */
    sub(v) {
        this.x -= v.x;
        this.y -= v.y;
        this.z -= v.z;

        return this;
    }

    /**
     * @name subScalar
     * @memberof Vector3
     *
     * @function
     * @param {Number} s
     * @return {Vector3}
     */
    subScalar(s) {
        this.x -= s;
        this.y -= s;
        this.z -= s;

        return this;
    }

    /**
     * @name subVectors
     * @memberof Vector3
     *
     * @function
     * @param {Vector3} a
     * @param {Vector3} b
     * @return {Vector3}
     */
    subVectors(a, b) {
        this.x = a.x - b.x;
        this.y = a.y - b.y;
        this.z = a.z - b.z;

        return this;
    }

    /**
     * @name multiply
     * @memberof Vector3
     *
     * @function
     * @param {Vector3} v
     * @return {Vector3}
     */
    multiply(v) {
        this.x *= v.x;
        this.y *= v.y;
        this.z *= v.z;

        return this;
    }

    /**
     * @name multiplyScalar
     * @memberof Vector3
     *
     * @function
     * @param {Number} s
     * @return {Vector3}
     */
    multiplyScalar(scalar) {
        this.x *= scalar;
        this.y *= scalar;
        this.z *= scalar;

        return this;
    }

    /**
     * @name multiplyVectors
     * @memberof Vector3
     *
     * @function
     * @param {Vector3} a
     * @param {Vector3} b
     * @return {Vector3}
     */
    multiplyVectors(a, b) {
        this.x = a.x * b.x;
        this.y = a.y * b.y;
        this.z = a.z * b.z;

        return this;
    }

    /**
     * @name applyEuler
     * @memberof Vector3
     *
     * @function
     * @param {Euler} euler
     * @return {Vector3}
     */
    applyEuler(euler) {
        let quaternion = this.Q1 || new Quaternion();
        this.Q1 = quaternion;

        return this.applyQuaternion( quaternion.setFromEuler( euler ) );
    }

    /**
     * @name applyAxisAngle
     * @memberof Vector3
     *
     * @function
     * @param {Number} axis
     * @param {Number} angle
     * @return {Vector3}
     */
    applyAxisAngle(axis, angle) {
        let quaternion = this.Q1 || new Quaternion();
        this.Q1 = quaternion;

        return this.applyQuaternion( quaternion.setFromAxisAngle( axis, angle ) );
    }

    /**
     * @name applyMatrix3
     * @memberof Vector3
     *
     * @function
     * @param {Matrix3} matrix
     * @return {Vector3}
     */
    applyMatrix3(m) {
        let x = this.x, y = this.y, z = this.z;
        let e = m.elements;

        this.x = e[ 0 ] * x + e[ 3 ] * y + e[ 6 ] * z;
        this.y = e[ 1 ] * x + e[ 4 ] * y + e[ 7 ] * z;
        this.z = e[ 2 ] * x + e[ 5 ] * y + e[ 8 ] * z;

        return this;
    }

    /**
     * @name applyMatrix4
     * @memberof Vector3
     *
     * @function
     * @param {Matrix4} matrix
     * @return {Vector3}
     */
    applyMatrix4(m) {
        let x = this.x, y = this.y, z = this.z;
        let e = m.elements;

        let w = 1 / ( e[ 3 ] * x + e[ 7 ] * y + e[ 11 ] * z + e[ 15 ] );

        this.x = ( e[ 0 ] * x + e[ 4 ] * y + e[ 8 ] * z + e[ 12 ] ) * w;
        this.y = ( e[ 1 ] * x + e[ 5 ] * y + e[ 9 ] * z + e[ 13 ] ) * w;
        this.z = ( e[ 2 ] * x + e[ 6 ] * y + e[ 10 ] * z + e[ 14 ] ) * w;

        return this;
    }

    /**
     * @name applyQuaternion
     * @memberof Vector3
     *
     * @function
     * @param {Quaternion} q
     * @return {Vector3}
     */
    applyQuaternion(q) {
        let x = this.x, y = this.y, z = this.z;
        let qx = q.x, qy = q.y, qz = q.z, qw = q.w;

        if (qx == 0 && qy == 0 && qz == 0 && qw == 1) return this;

        // calculate quat * vector

        let ix = qw * x + qy * z - qz * y;
        let iy = qw * y + qz * x - qx * z;
        let iz = qw * z + qx * y - qy * x;
        let iw = - qx * x - qy * y - qz * z;

        // calculate result * inverse quat

        this.x = ix * qw + iw * - qx + iy * - qz - iz * - qy;
        this.y = iy * qw + iw * - qy + iz * - qx - ix * - qz;
        this.z = iz * qw + iw * - qz + ix * - qy - iy * - qx;

        return this;
    }

    /**
     * @name this.project
     * @memberof Vector3
     *
     * @function
     * @param camera
    */
    project(camera) {
        let matrix = this.M1 || new Matrix4();
        this.M1 = matrix;

        matrix.multiplyMatrices( camera.projectionMatrix, matrix.getInverse( camera.matrixWorld ) );
        return this.applyMatrix4( matrix );
    }

    /**
     * @name this.unproject
     * @memberof Vector3
     *
     * @function
     * @param camera
    */
    unproject(camera) {
        let matrix = this.M1 || new Matrix4();
        this.M1 = matrix;

        matrix.multiplyMatrices( camera.matrixWorld, matrix.getInverse( camera.projectionMatrix ) );
        return this.applyMatrix4( matrix );
    }

    /**
     * @name this.transformDirection
     * @memberof Vector3
     *
     * @function
     * @param m
    */
    transformDirection(m) {
        let x = this.x, y = this.y, z = this.z;
        let e = m.elements;

        this.x = e[ 0 ] * x + e[ 4 ] * y + e[ 8 ] * z;
        this.y = e[ 1 ] * x + e[ 5 ] * y + e[ 9 ] * z;
        this.z = e[ 2 ] * x + e[ 6 ] * y + e[ 10 ] * z;

        return this.normalize();
    }

    /**
     * @name divide
     * @memberof Vector3
     *
     * @function
     * @param {Vector3} v
     * @return {Vector3}
     */
    divide(v) {
        this.x /= v.x;
        this.y /= v.y;
        this.z /= v.z;

        return this;
    }

    /**
     * @name divideScalar
     * @memberof Vector3
     *
     * @function
     * @param {Number} s
     * @return {Vector3}
     */
    divideScalar(scalar) {
        return this.multiplyScalar( 1 / scalar );
    }

    /**
     * @name this.min
     * @memberof Vector3
     *
     * @function
     * @param v
    */
    min(v) {
        this.x = Math.min( this.x, v.x );
        this.y = Math.min( this.y, v.y );
        this.z = Math.min( this.z, v.z );

        return this;
    }

    /**
     * @name this.max
     * @memberof Vector3
     *
     * @function
     * @param v
    */
    max(v) {
        this.x = Math.max( this.x, v.x );
        this.y = Math.max( this.y, v.y );
        this.z = Math.max( this.z, v.z );

        return this;
    }

    /**
     * @name this.clamp
     * @memberof Vector3
     *
     * @function
     * @param min
     * @param max
    */
    clamp(min, max) {
        this.x = Math.max( min.x, Math.min( max.x, this.x ) );
        this.y = Math.max( min.y, Math.min( max.y, this.y ) );
        this.z = Math.max( min.z, Math.min( max.z, this.z ) );

        return this;
    }

    /**
     * @name this.clampScalar
     * @memberof Vector3
     *
     * @function
     * @param minVal
     * @param maxVal
    */
    clampScalar(minVal, maxVal) {
        let min = new Vector3();
        let max = new Vector3();

        min.set( minVal, minVal, minVal );
        max.set( maxVal, maxVal, maxVal );

        return this.clamp( min, max );
    }

    /**
     * @name this.clampLength
     * @memberof Vector3
     *
     * @function
     * @param min
     * @param max
    */
    clampLength(min, max) {
        let length = this.length();
        return this.divideScalar( length || 1 ).multiplyScalar( Math.max( min, Math.min( max, length ) ) );
    }

    /**
     * @name this.floor
     * @memberof Vector3
     *
     * @function
    */
    floor() {
        this.x = Math.floor( this.x );
        this.y = Math.floor( this.y );
        this.z = Math.floor( this.z );

        return this;
    }

    /**
     * @name this.ceil
     * @memberof Vector3
     *
     * @function
    */
    ceil() {
        this.x = Math.ceil( this.x );
        this.y = Math.ceil( this.y );
        this.z = Math.ceil( this.z );

        return this;
    }

    /**
     * @name this.round
     * @memberof Vector3
     *
     * @function
    */
    round() {
        this.x = Math.round( this.x );
        this.y = Math.round( this.y );
        this.z = Math.round( this.z );

        return this;
    }

    /**
     * @name this.roundToZero
     * @memberof Vector3
     *
     * @function
    */
    roundToZero() {
        this.x = ( this.x < 0 ) ? Math.ceil( this.x ) : Math.floor( this.x );
        this.y = ( this.y < 0 ) ? Math.ceil( this.y ) : Math.floor( this.y );
        this.z = ( this.z < 0 ) ? Math.ceil( this.z ) : Math.floor( this.z );

        return this;
    }

    /**
     * @name this.negate
     * @memberof Vector3
     *
     * @function
    */
    negate() {
        this.x = - this.x;
        this.y = - this.y;
        this.z = - this.z;

        return this;
    }

    /**
     * @name dot
     * @memberof Vector3
     *
     * @function
     * @param {Vector3} v
     * @return {Number}
     */
    dot(v) {
        return this.x * v.x + this.y * v.y + this.z * v.z;
    }

    /**
     * @name lengthSq
     * @memberof Vector3
     *
     * @function
     * @return {Number}
     */
    lengthSq() {
        return this.x * this.x + this.y * this.y + this.z * this.z;
    }

    /**
     * @name length
     * @memberof Vector3
     *
     * @function
     * @return {Number}
     */
    length() {
        return Math.sqrt( this.x * this.x + this.y * this.y + this.z * this.z );
    }

    /**
     * @name this.manhattanLength
     * @memberof Vector3
     *
     * @function
    */
    manhattanLength() {
        return Math.abs( this.x ) + Math.abs( this.y ) + Math.abs( this.z );
    }

    /**
     * @name normalize
     * @memberof Vector3
     *
     * @function
     * @return {Vector3}
     */
    normalize() {
        return this.divideScalar( this.length() || 1 );
    }

    /**
     * @name this.setLength
     * @memberof Vector3
     *
     * @function
     * @param length
    */
    setLength(length) {
        return this.normalize().multiplyScalar( length );
    }

    /**
     * @name length
     * @memberof Vector3
     *
     * @function
     * @return {Number}
     */
    lerp(v, alpha, hz) {
        this.x = Math.lerp(v.x, this.x, alpha, hz);
        this.y = Math.lerp(v.y, this.y, alpha, hz);
        this.z = Math.lerp(v.z, this.z, alpha, hz);

        return this;
    }

    /**
     * @name this.lerpVectors
     * @memberof Vector3
     *
     * @function
     * @param v1
     * @param v2
     * @param alpha
    */
    lerpVectors(v1, v2, alpha) {
        return this.subVectors( v2, v1 ).multiplyScalar( alpha ).add( v1 );
    }

    /**
     * @name cross
     * @memberof Vector3
     *
     * @function
     * @param {Vector3} v
     * @return {Vector3}
     */
    cross(v) {
        return this.crossVectors( this, v );
    }

    /**
     * @name crossVectors
     * @memberof Vector3
     *
     * @function
     * @param {Vector3} a
     * @param {Vector3} b
     * @return {Vector3}
     */
    crossVectors(a, b) {
        let ax = a.x, ay = a.y, az = a.z;
        let bx = b.x, by = b.y, bz = b.z;

        this.x = ay * bz - az * by;
        this.y = az * bx - ax * bz;
        this.z = ax * by - ay * bx;

        return this;
    }

    /**
     * @name this.projectOnVector
     * @memberof Vector3
     *
     * @function
     * @param vector
    */
    projectOnVector(vector) {
        let scalar = vector.dot( this ) / vector.lengthSq();
        return this.copy( vector ).multiplyScalar( scalar );
    }

    /**
     * @name this.projectOnPlane
     * @memberof Vector3
     *
     * @function
     * @param planeNormal
    */
    projectOnPlane(planeNormal) {
        let v1 = this.V1 || new Vector3();
        this.V1 = v1;

        v1.copy( this ).projectOnVector( planeNormal );
        return this.sub( v1 );
    }

    /**
     * @name this.reflect
     * @memberof Vector3
     *
     * @function
     * @param normal
    */
    reflect(normal) {
        let v1 = this.V1 || new Vector3();
        this.V1 = v1;

        return this.sub( v1.copy( normal ).multiplyScalar( 2 * this.dot( normal ) ) );
    }

    /**
     * @name angleTo
     * @memberof Vector3
     *
     * @function
     * @param {Vector3} v
     * @return {Number}
     */
    angleTo(v) {
        let theta = this.dot( v ) / ( Math.sqrt( this.lengthSq() * v.lengthSq() ) );
        return Math.acos( Math.clamp( theta, - 1, 1 ) );
    }

    /**
     * @name distanceTo
     * @memberof Vector3
     *
     * @function
     * @param {Vector3} v
     * @return {Number}
     */
    distanceTo(v) {
        return Math.sqrt( this.distanceToSquared( v ) );
    }

    /**
     * @name distanceToSquared
     * @memberof Vector3
     *
     * @function
     * @param {Vector3} v
     * @return {Number}
     */
    distanceToSquared(v) {
        let dx = this.x - v.x, dy = this.y - v.y, dz = this.z - v.z;
        return dx * dx + dy * dy + dz * dz;
    }

    /**
     * @name this.manhattanDistanceTo
     * @memberof Vector3
     *
     * @function
     * @param v
    */
    manhattanDistanceTo(v) {
        return Math.abs( this.x - v.x ) + Math.abs( this.y - v.y ) + Math.abs( this.z - v.z );
    }

    /**
     * @name this.setFromCylindrical
     * @memberof Vector3
     *
     * @function
     * @param c
    */
    setFromCylindrical(c) {
        this.x = c.radius * Math.sin( c.theta );
        this.y = c.y;
        this.z = c.radius * Math.cos( c.theta );

        return this;
    }

    /**
     * @name setFromMatrixPosition
     * @memberof Vector3
     *
     * @function
     * @param {Matrix4} m
     * @return {Vector3}
     */
    setFromMatrixPosition(m) {
        let e = m.elements;

        this.x = e[ 12 ];
        this.y = e[ 13 ];
        this.z = e[ 14 ];

        return this;
    }

    /**
     * @name setFromMatrixScale
     * @memberof Vector3
     *
     * @function
     * @param {Matrix4} m
     * @return {Vector3}
     */
    setFromMatrixScale(m) {
        let sx = this.setFromMatrixColumn( m, 0 ).length();
        let sy = this.setFromMatrixColumn( m, 1 ).length();
        let sz = this.setFromMatrixColumn( m, 2 ).length();

        this.x = sx;
        this.y = sy;
        this.z = sz;

        return this;
    }

    /**
     * @name this.setFromMatrixColumn
     * @memberof Vector3
     *
     * @function
     * @param m
     * @param index
    */
    setFromMatrixColumn(m, index) {
        return this.fromArray( m.elements, index * 4 );
    }

    /**
     * @name this.setAngleRadius
     * @memberof Vector3
     *
     * @function
     * @param a
     * @param r
     * @param dir
    */
    setAngleRadius(a, r, dir = 'xy') {
        this[dir[0]] = Math.cos(a) * r;
        this[dir[1]] = Math.sin(a) * r;
        return this;
    }

    /**
     * @name this.addAngleRadius
     * @memberof Vector3
     *
     * @function
     * @param a
     * @param r
     * @param dir
    */
    addAngleRadius(a, r, dir = 'xy') {
        this[dir[0]] += Math.cos(a) * r;
        this[dir[1]] += Math.sin(a) * r;
        return this;
    }

    /**
     * @name this.equals
     * @memberof Vector3
     *
     * @function
     * @param v
    */
    equals(v) {
        return ( ( v.x === this.x ) && ( v.y === this.y ) && ( v.z === this.z ) );
    }

    /**
     * @name this.fromArray
     * @memberof Vector3
     *
     * @function
     * @param array
     * @param offset
    */
    fromArray(array, offset) {
        if ( offset === undefined ) offset = 0;

        this.x = array[ offset ];
        this.y = array[ offset + 1 ];
        this.z = array[ offset + 2 ];

        return this;
    }

    /**
     * @name this.setFromSpherical
     * @memberof Vector3
     *
     * @function
     * @param s
    */
    setFromSpherical(s) {
        this.setFromSphericalCoords(s.radius, s.phi, s.theta);
    }

    /**
     * @name this.setFromSphericalCoords
     * @memberof Vector3
     *
     * @function
     * @param radius
     * @param phi
     * @param theta
    */
    setFromSphericalCoords(radius, phi, theta) {
        let sinPhiRadius = Math.sin( phi ) * radius;

        this.x = sinPhiRadius * Math.sin( theta );
        this.y = Math.cos( phi ) * radius;
        this.z = sinPhiRadius * Math.cos( theta );

        return this;
    }

    /**
     * @name this.toArray
     * @memberof Vector3
     *
     * @function
     * @param array
     * @param offset
    */
    toArray(array, offset) {
        if ( array === undefined ) array = [];
        if ( offset === undefined ) offset = 0;

        array[ offset ] = this.x;
        array[ offset + 1 ] = this.y;
        array[ offset + 2 ] = this.z;

        return array;
    }

    /**
     * @name this.fromBufferAttribute
     * @memberof Vector3
     *
     * @function
     * @param attribute
     * @param index
    */
    fromBufferAttribute(attribute, index) {
        this.x = attribute.array[index * 3 + 0];
        this.y = attribute.array[index * 3 + 1];
        this.z = attribute.array[index * 3 + 2];

        return this;
    }
}
class Vector3D {
    constructor(x, y, z) {
        this._x = x || 0;
        this._y = y || 0;
        this._z = z || 0;
    }

    get x() {
        return this._x;
    }

    set x(v) {
        if (zUtils3D.LOCAL && isNaN(v)) return console.trace('Vector3D::NaN');
        let dirty = Math.abs(this._x - v) > Base3D.DIRTY_EPSILON;
        this._x = v;
        if (dirty) this.onChangeCallback();
    }

    get y() {
        return this._y;
    }

    set y(v) {
        if (zUtils3D.LOCAL && isNaN(v)) return console.trace('Vector3D::NaN');
        let dirty = Math.abs(this._y - v) > Base3D.DIRTY_EPSILON;
        this._y = v;
        if (dirty) this.onChangeCallback();
    }

    get z() {
        return this._z;
    }

    set z(v) {
        if (zUtils3D.LOCAL && isNaN(v)) return console.trace('Vector3D::NaN');
        let dirty = Math.abs(this._z - v) > Base3D.DIRTY_EPSILON;
        this._z = v;
        if (dirty) this.onChangeCallback();
    }

    onChangeCallback() {

    }

    set(x = 0, y = 0, z = 0) {
        const abs = Math.abs;
        let dirty = abs(this._x - x) > Base3D.DIRTY_EPSILON || abs(this._y - y) > Base3D.DIRTY_EPSILON || abs(this._z - z) > Base3D.DIRTY_EPSILON;

        this._x = x;
        this._y = y;
        this._z = z;

        if (dirty) this.onChangeCallback();

        return this;
    }

    setScalar(scalar) {
        const abs = Math.abs;
        let dirty = abs(this._x - scalar) > Base3D.DIRTY_EPSILON || abs(this._y - scalar) > Base3D.DIRTY_EPSILON || abs(this._z - scalar) > Base3D.DIRTY_EPSILON;

        this._x = scalar;
        this._y = scalar;
        this._z = scalar;

        if (dirty) this.onChangeCallback();

        return this;
    }

    clone() {
        return new Vector3(this._x, this._y, this._z);
    }

    copy(v) {
        const abs = Math.abs;
        let dirty = abs(this._x - v.x) > Base3D.DIRTY_EPSILON || abs(this._y - v.y) > Base3D.DIRTY_EPSILON || abs(this._z - v.z) > Base3D.DIRTY_EPSILON;

        this._x = v.x;
        this._y = v.y;
        this._z = v.z;

        if (dirty) this.onChangeCallback();

        return this;
    }

    add(v) {
        let nx = this._x + v.x;
        let ny = this._y + v.y;
        let nz = this._z + v.z;

        const abs = Math.abs;
        let dirty = abs(this._x - nx) > Base3D.DIRTY_EPSILON || abs(this._y - ny) > Base3D.DIRTY_EPSILON || abs(this._z - nz) > Base3D.DIRTY_EPSILON;

        this._x = nx;
        this._y = ny;
        this._z = nz;

        if (dirty) this.onChangeCallback();

        return this;
    }

    addScalar(s) {
        let nx = this._x + s;
        let ny = this._y + s;
        let nz = this._z + s;

        const abs = Math.abs;
        let dirty = abs(this._x - nx) > Base3D.DIRTY_EPSILON || abs(this._y - ny) > Base3D.DIRTY_EPSILON || abs(this._z - nz) > Base3D.DIRTY_EPSILON;

        this._x = nx;
        this._y = ny;
        this._z = nz;

        if (dirty) this.onChangeCallback();

        return this;
    }

    addVectors(a, b) {
        this._x = a.x + b.x;
        this._y = a.y + b.y;
        this._z = a.z + b.z;

        this.onChangeCallback();

        return this;
    }

    addScaledVector(v) {
        this._x += v.x * s;
        this._y += v.y * s;
        this._z += v.z * s;

        this.onChangeCallback();

        return this;
    }

    sub(v) {
        let nx = this._x - v.x;
        let ny = this._y - v.y;
        let nz = this._z - v.z;

        const abs = Math.abs;
        let dirty = abs(this._x - nx) > Base3D.DIRTY_EPSILON || abs(this._y - ny) > Base3D.DIRTY_EPSILON || abs(this._z - nz) > Base3D.DIRTY_EPSILON;

        this._x = nx;
        this._y = ny;
        this._z = nz;

        if (dirty) this.onChangeCallback();

        return this;
    }

    subScalar(s) {
        let nx = this._x - s;
        let ny = this._y - s;
        let nz = this._z - s;

        const abs = Math.abs;
        let dirty = abs(this._x - nx) > Base3D.DIRTY_EPSILON || abs(this._y - ny) > Base3D.DIRTY_EPSILON || abs(this._z - nz) > Base3D.DIRTY_EPSILON;

        this._x = nx;
        this._y = ny;
        this._z = nz;

        if (dirty) this.onChangeCallback();

        return this;
    }

    subVectors(a, b) {
        this._x = a.x - b.x;
        this._y = a.y - b.y;
        this._z = a.z - b.z;

        this.onChangeCallback();

        return this;
    }

    multiply(v) {
        let nx = this._x * v.x;
        let ny = this._y * v.y;
        let nz = this._z * v.z;

        const abs = Math.abs;
        let dirty = abs(this._x - nx) > Base3D.DIRTY_EPSILON || abs(this._y - ny) > Base3D.DIRTY_EPSILON || abs(this._z - nz) > Base3D.DIRTY_EPSILON;

        this._x = nx;
        this._y = ny;
        this._z = nz;

        if (dirty) this.onChangeCallback();

        return this;
    }

    multiplyScalar(scalar) {
        let nx = this._x * scalar;
        let ny = this._y * scalar;
        let nz = this._z * scalar;

        const abs = Math.abs;
        let dirty = abs(this._x - nx) > Base3D.DIRTY_EPSILON || abs(this._y - ny) > Base3D.DIRTY_EPSILON || abs(this._z - nz) > Base3D.DIRTY_EPSILON;

        this._x = nx;
        this._y = ny;
        this._z = nz;

        if (dirty) this.onChangeCallback();

        return this;
    }

    multiplyVectors(a, b) {
        this._x = a.x * b.x;
        this._y = a.y * b.y;
        this._z = a.z * b.z;

        this.onChangeCallback();

        return this;
    }

    applyEuler(euler) {
        let quaternion = this.Q1 || new Quaternion();
        this.Q1 = quaternion;

        return this.applyQuaternion( quaternion.setFromEuler( euler ) );
    }

    applyAxisAngle(axis, angle) {
        let quaternion = this.Q1 || new Quaternion();
        this.Q1 = quaternion;

        return this.applyQuaternion( quaternion.setFromAxisAngle( axis, angle ) );
    }

    applyMatrix3(m) {
        let x = this._x, y = this._y, z = this._z;
        let e = m.elements;

        this._x = e[ 0 ] * x + e[ 3 ] * y + e[ 6 ] * z;
        this._y = e[ 1 ] * x + e[ 4 ] * y + e[ 7 ] * z;
        this._z = e[ 2 ] * x + e[ 5 ] * y + e[ 8 ] * z;

        this.onChangeCallback();

        return this;
    }

    applyMatrix4(m) {
        let x = this._x, y = this._y, z = this._z;
        let e = m.elements;

        let w = 1 / ( e[ 3 ] * x + e[ 7 ] * y + e[ 11 ] * z + e[ 15 ] );

        this._x = ( e[ 0 ] * x + e[ 4 ] * y + e[ 8 ] * z + e[ 12 ] ) * w;
        this._y = ( e[ 1 ] * x + e[ 5 ] * y + e[ 9 ] * z + e[ 13 ] ) * w;
        this._z = ( e[ 2 ] * x + e[ 6 ] * y + e[ 10 ] * z + e[ 14 ] ) * w;

        this.onChangeCallback();

        return this;
    }

    applyQuaternion(q) {
        let x = this._x, y = this._y, z = this._z;
        let qx = q.x, qy = q.y, qz = q.z, qw = q.w;

        // calculate quat * vector

        let ix = qw * x + qy * z - qz * y;
        let iy = qw * y + qz * x - qx * z;
        let iz = qw * z + qx * y - qy * x;
        let iw = - qx * x - qy * y - qz * z;

        // calculate result * inverse quat

        this._x = ix * qw + iw * - qx + iy * - qz - iz * - qy;
        this._y = iy * qw + iw * - qy + iz * - qx - ix * - qz;
        this._z = iz * qw + iw * - qz + ix * - qy - iy * - qx;

        this.onChangeCallback();

        return this;
    }

    project(camera) {
        let matrix = this.M1 || new Matrix4();
        this.M1 = matrix;

        matrix.multiplyMatrices( camera.projectionMatrix, matrix.getInverse( camera.matrixWorld ) );
        return this.applyMatrix4( matrix );
    }

    unproject(camera) {
        let matrix = this.M1 || new Matrix4();
        this.M1 = matrix;

        matrix.multiplyMatrices( camera.matrixWorld, matrix.getInverse( camera.projectionMatrix ) );
        return this.applyMatrix4( matrix );
    }

    transformDirection(m) {
        let x = this._x, y = this._y, z = this._z;
        let e = m.elements;

        this._x = e[ 0 ] * x + e[ 4 ] * y + e[ 8 ] * z;
        this._y = e[ 1 ] * x + e[ 5 ] * y + e[ 9 ] * z;
        this._z = e[ 2 ] * x + e[ 6 ] * y + e[ 10 ] * z;

        this.onChangeCallback();

        return this.normalize();
    }

    divide(v) {
        this._x /= v.x;
        this._y /= v.y;
        this._z /= v.z;

        this.onChangeCallback();

        return this;
    }

    divideScalar(scalar) {
        return this.multiplyScalar( 1 / scalar );
    }

    min(v) {
        this._x = Math.min( this._x, v.x );
        this._y = Math.min( this._y, v.y );
        this._z = Math.min( this._z, v.z );

        this.onChangeCallback();

        return this;
    }

    max(v) {
        this._x = Math.max( this._x, v.x );
        this._y = Math.max( this._y, v.y );
        this._z = Math.max( this._z, v.z );

        return this;
    }

    clamp(min, max) {
        this._x = Math.max( min.x, Math.min( max.x, this._x ) );
        this._y = Math.max( min.y, Math.min( max.y, this._y ) );
        this._z = Math.max( min.z, Math.min( max.z, this._z ) );

        return this;
    }

    clampScalar(minVal, maxVal) {
        let min = new Vector3();
        let max = new Vector3();

        min.set( minVal, minVal, minVal );
        max.set( maxVal, maxVal, maxVal );

        return this.clamp( min, max );
    }

    clampLength(min, max) {
        let length = this.length();
        return this.divideScalar( length || 1 ).multiplyScalar( Math.max( min, Math.min( max, length ) ) );
    }

    floor() {
        this._x = Math.floor( this._x );
        this._y = Math.floor( this._y );
        this._z = Math.floor( this._z );

        this.onChangeCallback();

        return this;
    }

    ceil() {
        this._x = Math.ceil( this._x );
        this._y = Math.ceil( this._y );
        this._z = Math.ceil( this._z );

        this.onChangeCallback();

        return this;
    }

    round() {
        this._x = Math.round( this._x );
        this._y = Math.round( this._y );
        this._z = Math.round( this._z );

        this.onChangeCallback();

        return this;
    }

    roundToZero() {
        this._x = ( this._x < 0 ) ? Math.ceil( this._x ) : Math.floor( this._x );
        this._y = ( this._y < 0 ) ? Math.ceil( this._y ) : Math.floor( this._y );
        this._z = ( this._z < 0 ) ? Math.ceil( this._z ) : Math.floor( this._z );

        this.onChangeCallback();

        return this;
    }

    negate() {
        this._x = - this._x;
        this._y = - this._y;
        this._z = - this._z;

        this.onChangeCallback();

        return this;
    }

    dot(v) {
        return this._x * v.x + this._y * v.y + this._z * v.z;
    }

    lengthSq() {
        return this._x * this._x + this._y * this._y + this._z * this._z;
    }

    length() {
        return Math.sqrt( this._x * this._x + this._y * this._y + this._z * this._z );
    }

    manhattanLength() {
        return Math.abs( this._x ) + Math.abs( this._y ) + Math.abs( this._z );
    }

    normalize() {
        this.onChangeCallback();
        return this.divideScalar( this.length() || 1 );
    }

    setLength(length) {
        this.onChangeCallback();
        return this.normalize().multiplyScalar( length );
    }

    lerp(v, alpha, hz) {
        this._x = Math.lerp(v.x, this._x, alpha, hz);
        this._y = Math.lerp(v.y, this._y, alpha, hz);
        this._z = Math.lerp(v.z, this._z, alpha, hz);

        this.onChangeCallback();

        return this;
    }

    lerpVectors(v1, v2, alpha) {
        this.onChangeCallback();
        return this.subVectors( v2, v1 ).multiplyScalar( alpha ).add( v1 );
    }

    cross(v) {
        return this.crossVectors( this, v );
    }

    crossVectors(a, b) {
        let ax = a.x, ay = a.y, az = a.z;
        let bx = b.x, by = b.y, bz = b.z;

        this._x = ay * bz - az * by;
        this._y = az * bx - ax * bz;
        this._z = ax * by - ay * bx;

        this.onChangeCallback();

        return this;
    }

    projectOnVector(vector) {
        let scalar = vector.dot( this ) / vector.lengthSq();
        return this.copy( vector ).multiplyScalar( scalar );
    }

    projectOnPlane(planeNormal) {
        let v1 = this.V1 || new Vector3();
        this.V1 = v1;

        this.onChangeCallback();

        v1.copy( this ).projectOnVector( planeNormal );
        return this.sub( v1 );
    }

    reflect(normal) {
        let v1 = this.V1 || new Vector3();
        this.V1 = v1;

        this.onChangeCallback();

        return this.sub( v1.copy( normal ).multiplyScalar( 2 * this.dot( normal ) ) );
    }

    angleTo(v) {
        let theta = this.dot( v ) / ( Math.sqrt( this.lengthSq() * v.lengthSq() ) );
        return Math.acos( Math.clamp( theta, - 1, 1 ) );
    }

    distanceTo(v) {
        return Math.sqrt( this.distanceToSquared( v ) );
    }

    distanceToSquared(v) {
        let dx = this._x - v.x, dy = this._y - v.y, dz = this._z - v.z;
        return dx * dx + dy * dy + dz * dz;
    }

    manhattanDistanceTo(v) {
        return Math.abs( this._x - v.x ) + Math.abs( this._y - v.y ) + Math.abs( this._z - v.z );
    }

    setFromSpherical(s) {
        let sinPhiRadius = Math.sin( s.phi ) * s.radius;

        this._x = sinPhiRadius * Math.sin( s.theta );
        this._y = Math.cos( s.phi ) * s.radius;
        this._z = sinPhiRadius * Math.cos( s.theta );

        this.onChangeCallback();

        return this;
    }

    setFromCylindrical(c) {
        this._x = c.radius * Math.sin( c.theta );
        this._y = c.y;
        this._z = c.radius * Math.cos( c.theta );

        this.onChangeCallback();

        return this;
    }

    setFromMatrixPosition(m) {
        let e = m.elements;

        this._x = e[ 12 ];
        this._y = e[ 13 ];
        this._z = e[ 14 ];

        this.onChangeCallback();

        return this;
    }

    setFromMatrixScale(m) {
        let sx = this.setFromMatrixColumn( m, 0 ).length();
        let sy = this.setFromMatrixColumn( m, 1 ).length();
        let sz = this.setFromMatrixColumn( m, 2 ).length();

        this.onChangeCallback();

        this._x = sx;
        this._y = sy;
        this._z = sz;

        return this;
    }

    setFromMatrixColumn(m, index) {
        this.onChangeCallback();
        return this.fromArray( m.elements, index * 4 );
    }

    equals(v) {
        return ( ( v.x === this._x ) && ( v.y === this._y ) && ( v.z === this._z ) );
    }

    fromArray(array, offset) {
        if ( offset === undefined ) offset = 0;

        this._x = array[ offset ];
        this._y = array[ offset + 1 ];
        this._z = array[ offset + 2 ];

        this.onChangeCallback();

        return this;
    }

    toArray(array, offset) {
        if ( array === undefined ) array = [];
        if ( offset === undefined ) offset = 0;

        array[ offset ] = this._x;
        array[ offset + 1 ] = this._y;
        array[ offset + 2 ] = this._z;

        return array;
    }

    fromBufferAttribute(attribute, index) {
        this._x = attribute.array[index * 3 + 0];
        this._y = attribute.array[index * 3 + 1];
        this._z = attribute.array[index * 3 + 2];

        this.onChangeCallback();
    }

    onChange(callback) {
        this.onChangeCallback = callback;
    }

    onChangeCallback() {

    }
}

/**
 * @name Vector4
 */
class Vector4 {
    constructor(x = 0, y = 0, z = 0, w = 0) {
        this.x = x;
        this.y = y;
        this.z = z;
        this.w = w;
    }

    /**
     * @name this.multiplyScalar
     * @memberof Vector4
     *
     * @function
     * @param s
    */
    multiplyScalar(s) {
        this.x *= s;
        this.y *= s;
        this.z *= s;
        this.w *= s;

        return this;
    }

    /**
     * @name this.set
     * @memberof Vector4
     *
     * @function
     * @param x
     * @param y
     * @param z
     * @param w
    */
    set(x, y, z, w) {
        this.x = x;
        this.y = y;
        this.z = z;
        this.w = w;

        return this;
    }

    /**
     * @name this.copy
     * @memberof Vector4
     *
     * @function
     * @param v
    */
    copy(v) {
        this.x = v.x;
        this.y = v.y;
        this.z = v.z;
        this.w = v.w;
        return this;
    }

    /**
     * @name this.dot
     * @memberof Vector4
     *
     * @function
     * @param v
    */
    dot(v) {
        return this.x * v.x + this.y * v.y + this.z * v.z + this.w * v.w;
    }

    /**
     * @name this.length
     * @memberof Vector4
     *
     * @function
    */
    length() {
        return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w);
    }

    /**
     * @name this.lengthSq
     * @memberof Vector4
     *
     * @function
    */
    lengthSq() {
        return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w;
    }

    /**
     * @name this.equals
     * @memberof Vector4
     *
     * @function
     * @param v
    */
    equals(v) {
        return ( ( v.x === this.x ) && ( v.y === this.y ) && ( v.z === this.z ) && ( v.w === this.w ));
    }

    /**
     * @name this.lerp
     * @memberof Vector4
     *
     * @function
     * @param v
     * @param alpha
     * @param hz
    */
    lerp(v, alpha, hz) {
        this.x = Math.lerp(v.x, this.x, alpha, hz);
        this.y = Math.lerp(v.y, this.y, alpha, hz);
        this.z = Math.lerp(v.z, this.z, alpha, hz);
        this.w = Math.lerp(v.w, this.w, alpha, hz);

        return this;
    }

    /**
     * @name this.applyMatrix4
     * @memberof Vector4
     *
     * @function
     * @param m
    */
    applyMatrix4(m) {
        let x = this.x, y = this.y, z = this.z, w = this.w;
        let e = m.elements;

        this.x = e[ 0 ] * x + e[ 4 ] * y + e[ 8 ] * z + e[ 12 ] * w;
        this.y = e[ 1 ] * x + e[ 5 ] * y + e[ 9 ] * z + e[ 13 ] * w;
        this.z = e[ 2 ] * x + e[ 6 ] * y + e[ 10 ] * z + e[ 14 ] * w;
        this.w = e[ 3 ] * x + e[ 7 ] * y + e[ 11 ] * z + e[ 15 ] * w;

        return this;
    }

    /**
     * @name this.toArray
     * @memberof Vector4
     *
     * @function
     * @param array
     * @param offset
    */
    toArray(array, offset) {
        if ( array === undefined ) array = [];
        if ( offset === undefined ) offset = 0;

        array[ offset ] = this.x;
        array[ offset + 1 ] = this.y;
        array[ offset + 2 ] = this.z;
        array[ offset + 3 ] = this.w;

        return array;
    }

    /**
     * @name this.fromArray
     * @memberof Vector4
     *
     * @function
     * @param array
     * @param offset
    */
    fromArray(array, offset) {
        if ( offset === undefined ) offset = 0;

        this.x = array[ offset ];
        this.y = array[ offset + 1 ];
        this.z = array[ offset + 2 ];
        this.w = array[ offset + 3 ];

        return this;
    }

    /**
     * @name this.set width
     * @memberof Vector4
     *
     * @function
     * @param v
    */
    set width(v) {
        this.z = v;
    }

    /**
     * @name this.set height
     * @memberof Vector4
     *
     * @function
     * @param v
    */
    set height(v) {
        this.w = v;
    }

    /**
     * @name this.get width
     * @memberof Vector4
     *
     * @function
    */
    get width() {
        return this.z;
    }

    /**
     * @name this.get height
     * @memberof Vector4
     *
     * @function
    */
    get height() {
        return this.w;
    }

    /**
     * @name this.clone
     * @memberof Vector4
     *
     * @function
    */
    clone() {
        return new Vector4(this.x, this.y, this.z, this.w);
    }
}

class Face3 {
    constructor(a, b, c, normal = new Vector3()) {
        this.a = a;
        this.b = b;
        this.c = c;
        this.normal = normal;
    }
}

Class(function zUtils3D() {
    Math.euclideanModulo = function(n, m) {
        return ( ( n % m ) + m ) % m;
    }

    Math.isPowerOf2 = function(w, h) {
        let test = value => (value & (value - 1)) == 0;
        return test(w) && test(h);
    }

    Math.floorPowerOf2 = function(value) {
        return Math.pow(2, Math.floor(Math.log(value) / Math.LN2));
    }

    Math.ceilPowerOf2 = function(value) {
        return Math.pow(2, Math.ceil(Math.log(value) / Math.LN2));
    }

    this.LOCAL = window.Hydra && Hydra.LOCAL;

    Geometry.createAttributes = function(geom) {
        let attributes = {};
        let handler = {
            set (target, property, value) {
                target[property] = value;
                geom._attributeKeys.length = 0;
                geom._attributeValues.length = 0;
                for (let key in attributes) {
                    geom._attributeKeys.push(key);
                    geom._attributeValues.push(attributes[key]);
                }
                return true;
            }
        };

        geom._attributeKeys = [];
        geom._attributeValues = [];

        return new Proxy(attributes, handler);
    };

    Geometry.TYPED_ARRAYS = {
        Int8Array: Int8Array,
        Uint8Array: Uint8Array,
        Uint8ClampedArray: Uint8ClampedArray,
        Int16Array: Int16Array,
        Uint16Array: Uint16Array,
        Int32Array: Int32Array,
        Uint32Array: Uint32Array,
        Float32Array: Float32Array,
        Float64Array: Float64Array
    }

    Geometry.arrayNeedsUint32 = function(array) {
        // assumes larger values usually on last
        for (let i = array.length - 1; i >= 0; --i) {
            if (array[i] > 65535) return true;
        }
        return false;
    };

    Geometry.TYPES = {'SphereGeometry': SphereGeometry, 'IcosahedronGeometry': IcosahedronGeometry, 'BoxGeometry': BoxGeometry, 'PlaneGeometry': PlaneGeometry, 'CylinderGeometry': CylinderGeometry};

    Matrix4.prototype.isMatrix4 = true;
    Matrix3.prototype.isMatrix3 = true;
    Vector3.prototype.isVector3 = true;
    Vector3D.prototype.isVector3 = true;
    Vector2.prototype.isVector2 = true;
    CameraBase3D.prototype.isCamera = true;
    PerspectiveCamera.prototype.isPerspective = true;
    Scene.FRONT_TO_BACK = 'sort_front_to_back';
    Scene.FRONT_TO_BACK_BOUNDING = 'sort_front_to_back_bounding';

    if (window.THREAD) {
        Shader = {
            FRONT_SIDE: 'shader_front_side',
            BACK_SIDE: 'shader_back_side',
            DOUBLE_SIDE: 'shader_double_side',
        };
    }

    Ray.prototype.intersectTriangle = (function() {
        // Compute the offset origin, edges, and normal.
        var diff = new Vector3();
        var edge1 = new Vector3();
        var edge2 = new Vector3();
        var normal = new Vector3();

        return function intersectTriangle( a, b, c, backfaceCulling, target ) {

            // from http://www.geometrictools.com/GTEngine/Include/Mathematics/GteIntrRay3Triangle3.h

            edge1.subVectors( b, a );
            edge2.subVectors( c, a );
            normal.crossVectors( edge1, edge2 );

            // Solve Q + t*D = b1*E1 + b2*E2 (Q = kDiff, D = ray direction,
            // E1 = kEdge1, E2 = kEdge2, N = Cross(E1,E2)) by
            //   |Dot(D,N)|*b1 = sign(Dot(D,N))*Dot(D,Cross(Q,E2))
            //   |Dot(D,N)|*b2 = sign(Dot(D,N))*Dot(D,Cross(E1,Q))
            //   |Dot(D,N)|*t = -sign(Dot(D,N))*Dot(Q,N)
            var DdN = this.direction.dot( normal );
            var sign;

            if ( DdN > 0 ) {

                if ( backfaceCulling ) return null;
                sign = 1;

            } else if ( DdN < 0 ) {

                sign = - 1;
                DdN = - DdN;

            } else {

                return null;

            }

            diff.subVectors( this.origin, a );
            var DdQxE2 = sign * this.direction.dot( edge2.crossVectors( diff, edge2 ) );

            // b1 < 0, no intersection
            if ( DdQxE2 < 0 ) {

                return null;

            }

            var DdE1xQ = sign * this.direction.dot( edge1.cross( diff ) );

            // b2 < 0, no intersection
            if ( DdE1xQ < 0 ) {

                return null;

            }

            // b1+b2 > 1, no intersection
            if ( DdQxE2 + DdE1xQ > DdN ) {

                return null;

            }

            // Line intersects triangle, check if ray does.
            var QdN = - sign * diff.dot( normal );

            // t < 0, no intersection
            if ( QdN < 0 ) {

                return null;

            }

            // Ray intersects triangle.
            return this.at( QdN / DdN, target );

        };

    })();

    Mesh.prototype.raycast = (function() {
        let inverseMatrix = new Matrix4();
        let ray = new Ray();
        let sphere = new Sphere();

        let vA = new Vector3();
        let vB = new Vector3();
        let vC = new Vector3();

        let tempA = new Vector3();
        let tempB = new Vector3();
        let tempC = new Vector3();
        let tempD = new Vector3();

        let uvA = new Vector2();
        let uvB = new Vector2();
        let uvC = new Vector2();

        let barycoord = new Vector3();

        let intersectionPoint = new Vector3();
        let intersectionPointWorld = new Vector3();

        function uvIntersection( point, p1, p2, p3, uv1, uv2, uv3 ) {

            Triangle.getBarycoord( point, p1, p2, p3, barycoord );

            uv1.multiplyScalar( barycoord.x );
            uv2.multiplyScalar( barycoord.y );
            uv3.multiplyScalar( barycoord.z );

            uv1.add( uv2 ).add( uv3 );

            return uv1.clone();

        }

        function checkIntersection( object, shader, raycaster, ray, pA, pB, pC, point ) {

            let intersect;

            if ( shader.side === Shader.BACK_SIDE ) {

                intersect = ray.intersectTriangle( pC, pB, pA, true, point );

            } else {

                intersect = ray.intersectTriangle( pA, pB, pC, shader.side !== Shader.DOUBLE_SIDE, point );

            }

            if ( intersect === null ) return null;

            intersectionPointWorld.copy( point );
            intersectionPointWorld.applyMatrix4( object.matrixWorld );

            let distance = raycaster.ray.origin.distanceTo( intersectionPointWorld );

            if ( distance < raycaster.near || distance > raycaster.far ) return null;

            return {
                distance: distance,
                point: intersectionPointWorld.clone(),
                object: object
            };

        }

        function checkBufferGeometryIntersection( object, raycaster, ray, position, uv, a, b, c ) {

            vA.fromBufferAttribute( position, a );
            vB.fromBufferAttribute( position, b );
            vC.fromBufferAttribute( position, c );

            if (object.raycastLimit) {
                let {radiusSq, position} = object.raycastLimit;
                if (vA.distanceToSquared(position) > radiusSq) {
                    return;
                }
            }

            let intersection = checkIntersection( object, object.shader, raycaster, ray, vA, vB, vC, intersectionPoint );

            if ( intersection ) {

                if ( uv ) {

                    uvA.fromBufferAttribute( uv, a );
                    uvB.fromBufferAttribute( uv, b );
                    uvC.fromBufferAttribute( uv, c );

                    intersection.uv = uvIntersection( intersectionPoint, vA, vB, vC, uvA, uvB, uvC );

                }

                let face = new Face3( a, b, c );
                Triangle.getNormal( vA, vB, vC, face.normal );

                intersection.face = face;

            }

            return intersection;

        }

        return function raycast( raycaster, intersects ) {

            let geometry = this.geometry;
            let shader = this.shader;
            let matrixWorld = this.matrixWorld;

            if ( shader === undefined ) return;

            // Checking boundingSphere distance to ray

            if ( geometry.boundingSphere === null ) geometry.computeBoundingSphere();

            if (this.scale.x == 0) return;

            if (this.staticRaycast) {
                if (!this.raySphere) {
                    this.raySphere = new Sphere();
                    this.raySphere.copy( geometry.boundingSphere );
                    this.raySphere.applyMatrix4( matrixWorld );
                }

                if (this.raycastNeedsUpdate) {
                    this.raySphere.copy( geometry.boundingSphere );
                    this.raySphere.applyMatrix4( matrixWorld );
                    this.raycastNeedsUpdate = false;
                }

                if ( raycaster.ray.intersectsSphere( this.raySphere ) === false ) return;
            } else {
                sphere.copy( geometry.boundingSphere );
                sphere.applyMatrix4( matrixWorld );

                if ( raycaster.ray.intersectsSphere( sphere ) === false ) return;
            }


            //

            inverseMatrix.getInverse( matrixWorld );
            ray.copy( raycaster.ray ).applyMatrix4( inverseMatrix );

            // Check boundingBox before continuing

            if ( geometry.boundingBox !== null ) {

                if ( ray.intersectsBox( geometry.boundingBox ) === false ) return;

            }

            let intersection;


            let a, b, c;
            let index = geometry.index;
            let position = geometry.attributes.position;
            let uv = geometry.attributes.uv;
            let i, l;

            if ( index !== null ) {

                // indexed buffer geometry

                for ( i = 0, l = index.length; i < l; i += 3 ) {

                    a = index[i];
                    b = index[i+1];
                    c = index[i+2];

                    intersection = checkBufferGeometryIntersection( this, raycaster, ray, position, uv, a, b, c );

                    if ( intersection ) {

                        intersection.faceIndex = Math.floor( i / 3 ); // triangle number in indexed buffer semantics
                        intersects.push( intersection );

                    }

                }

            } else if ( position !== undefined ) {

                // non-indexed buffer geometry

                for ( i = 0, l = position.count; i < l; i += 3 ) {

                    a = i;
                    b = i + 1;
                    c = i + 2;

                    intersection = checkBufferGeometryIntersection( this, raycaster, ray, position, uv, a, b, c );

                    if ( intersection ) {

                        intersection.faceIndex = Math.floor( i / 3 ); // triangle number in non-indexed buffer semantics
                        intersects.push( intersection );

                    }

                }

            }

        };

    })();

    Triangle.prototype.closestPointToPoint = (function() {
        let plane = new Plane();
        let edgeList = [ new Line3(), new Line3(), new Line3() ];
        let projectedPoint = new Vector3();
        let closestPoint = new Vector3();

        return function closestPointToPoint( point, target = new Vector3() ) {

            let minDistance = Infinity;

            // project the point onto the plane of the triangle

            plane.setFromCoplanarPoints( this.a, this.b, this.c );
            plane.projectPoint( point, projectedPoint );

            // check if the projection lies within the triangle

            if ( this.containsPoint( projectedPoint ) === true ) {

                // if so, this is the closest point

                target.copy( projectedPoint );

            } else {

                // if not, the point falls outside the triangle. the target is the closest point to the triangle's edges or vertices

                edgeList[ 0 ].set( this.a, this.b );
                edgeList[ 1 ].set( this.b, this.c );
                edgeList[ 2 ].set( this.c, this.a );

                for ( let i = 0; i < edgeList.length; i ++ ) {

                    edgeList[ i ].closestPointToPoint( projectedPoint, true, closestPoint );

                    let distance = projectedPoint.distanceToSquared( closestPoint );

                    if ( distance < minDistance ) {

                        minDistance = distance;

                        target.copy( closestPoint );

                    }

                }

            }

            return target;

        };
    })();

    Points.prototype.raycast = (function() {

        let inverseMatrix = new Matrix4();
        let ray = new Ray();
        let sphere = new Sphere();

        return function raycast(raycaster, intersects) {
            let object = this;
            let geometry = this.geometry;
            let matrixWorld = this.matrixWorld;
            let threshold = raycaster.params.Points.threshold;

            // Checking boundingSphere distance to ray

            if (geometry.boundingSphere === null) geometry.computeBoundingSphere();

            sphere.copy( geometry.boundingSphere );
            sphere.applyMatrix4( matrixWorld );
            sphere.radius += threshold;

            if ( raycaster.ray.intersectsSphere( sphere ) === false ) return;

            //

            inverseMatrix.getInverse( matrixWorld );
            ray.copy( raycaster.ray ).applyMatrix4( inverseMatrix );

            let localThreshold = threshold / ( ( this.scale.x + this.scale.y + this.scale.z ) / 3 );
            let localThresholdSq = localThreshold * localThreshold;
            let position = new Vector3();
            let intersectPoint = new Vector3();

            function testPoint( point, index ) {

                let rayPointDistanceSq = ray.distanceSqToPoint( point );

                if ( rayPointDistanceSq < localThresholdSq ) {

                    ray.closestPointToPoint( point, intersectPoint );
                    intersectPoint.applyMatrix4( matrixWorld );

                    let distance = raycaster.ray.origin.distanceTo( intersectPoint );

                    if ( distance < raycaster.near || distance > raycaster.far ) return;

                    intersects.push( {

                        distance: distance,
                        distanceToRay: Math.sqrt( rayPointDistanceSq ),
                        point: intersectPoint.clone(),
                        index: index,
                        face: null,
                        object: object

                    } );

                }

            }

            let index = geometry.index;
            let attributes = geometry.attributes;
            let positions = attributes.position.array;

            if ( index !== null ) {

                let indices = index.array;

                for ( let i = 0, il = indices.length; i < il; i ++ ) {

                    let a = indices[ i ];

                    position.fromArray( positions, a * 3 );

                    testPoint( position, a );

                }

            } else {

                for ( let i = 0, l = positions.length / 3; i < l; i ++ ) {

                    position.fromArray( positions, i * 3 );

                    testPoint( position, i );

                }

            }
        };
    })();

    Object.assign(Triangle, {
        getNormal: function() {
            var v0 = new Vector3();

            return function getNormal( a, b, c, target = new Vector3() ) {
                target.subVectors( c, b );
                v0.subVectors( a, b );
                target.cross( v0 );

                var targetLengthSq = target.lengthSq();
                if ( targetLengthSq > 0 ) return target.multiplyScalar( 1 / Math.sqrt( targetLengthSq ) );

                return target.set( 0, 0, 0 );
            };

        }(),

        getBarycoord: function () {
            var v0 = new Vector3();
            var v1 = new Vector3();
            var v2 = new Vector3();

            return function getBarycoord(point, a, b, c, target = new Vector3()) {
                v0.subVectors( c, a );
                v1.subVectors( b, a );
                v2.subVectors( point, a );

                var dot00 = v0.dot( v0 );
                var dot01 = v0.dot( v1 );
                var dot02 = v0.dot( v2 );
                var dot11 = v1.dot( v1 );
                var dot12 = v1.dot( v2 );
                var denom = ( dot00 * dot11 - dot01 * dot01 );


                if (denom === 0) return target.set( - 2, - 1, - 1 );

                var invDenom = 1 / denom;
                var u = ( dot11 * dot02 - dot01 * dot12 ) * invDenom;
                var v = ( dot00 * dot12 - dot01 * dot02 ) * invDenom;

                return target.set( 1 - u - v, v, u );
            };

        }(),

        getUV: function() {
            let _v3 = new Vector3();
            return function getUV( point, p1, p2, p3, uv1, uv2, uv3, target ) {
                this.getBarycoord( point, p1, p2, p3, _v3 );

                target.set( 0, 0 );
                target.addScaledVector( uv1, _v3.x );
                target.addScaledVector( uv2, _v3.y );
                target.addScaledVector( uv3, _v3.z );

                return target;
            }
        }(),

        containsPoint: function () {
            var v1 = new Vector3();
            return function containsPoint( point, a, b, c ) {
                Triangle.getBarycoord( point, a, b, c, v1 );
                return ( v1.x >= 0 ) && ( v1.y >= 0 ) && ( ( v1.x + v1.y ) <= 1 );
            };
        }()
    });
}, 'static');

/**
 * @name FXLayer
 * @param {Nuke} parentNuke
 * @param {String} type
 */

Class(function FXLayer(_parentNuke, _type, _preventDrawBuffers = false) {
    Inherit(this, Component);
    var _this = this;
    var _nuke, _rt;

    var _scene = new Scene();
    var _objects = [];
    var _rts = {};
    var _textureIndex = -1;
    var _visible = true;

    var _id = Utils.timestamp();
    var _name = Utils.getConstructorName(_this);
    var _useDrawBuffers = !_preventDrawBuffers;

    this.resolution = 1;
    this.enabled = true;
    this.renderShadows = true;

    const CLEAR_COLOR = [0, 0, 0, 1];
    FXLayer.exists = true;

    function editShader(mesh) {
        let modifyShader = (shader, name) => {
            let fs = shader._fragmentShader;
            if (!fs) return;
            let marker = '#drawbuffer '+name;
            if (fs.includes(marker)) {
                let split = fs.split(marker+' ');
                fs = split.join('');
            }

            while (fs.includes('#drawbuffer')) {
                fs = fs.split('\n');
                for (let i = 0; i < fs.length; i++) {
                    if (fs[i].includes('#drawbuffer')) fs[i] = '';
                }
                fs = fs.join('\n');
            }

            shader.fragmentShader = fs;
        };

        let applyShadow = (shader, bool) => {
            let fs = shader.fragmentShader;
            if (!fs) return;
            while (fs.includes('#applyShadow')) {
                fs = fs.split('\n');
                for (let i = 0; i < fs.length; i++) {
                    if (bool) {
                        if (fs[i].includes('#applyShadow')) fs[i] = fs[i].replace('#applyShadow', '');
                    } else {
                        if (fs[i].includes('#applyShadow')) fs[i] = '';
                    }
                }
                fs = fs.join('\n');
            }

            shader.fragmentShader = fs;
        };

        if (!mesh.shader._fragmentShader) mesh.shader._fragmentShader = mesh.shader.fragmentShader;
        modifyShader(mesh.shader, 'Color');

        let shader = mesh.shader.clone(!_this.renderShadows, `-${_this.name || _name}`);
        modifyShader(shader, _this.name || _name);
        applyShadow(shader, _this.renderShadows);
        applyShadow(mesh.shader, true);

        mesh.shader.copyUniformsTo(shader, true);
        mesh.shader = shader;
    }

    function editDBShader(mesh) {
        const WEBGL2 = Renderer.type == Renderer.WEBGL2;
        let modifyMarker = (fs, name, index) => {
            if (WEBGL2) {
                if (!fs.includes(`layout(location=${index})`)) {
                    fs = fs.replace('out vec4 FragColor;', '');
                    let mainAt = fs.indexOf('void main()');
                    let before = fs.slice(0, mainAt);
                    let after = fs.slice(mainAt);
                    fs = before + `layout(location=${index}) out vec4 ${name};\n` + after;
                }
            }

            let marker = '#drawbuffer '+name;
            if (fs.includes(marker)) {
                let split = fs.split(marker+' ');
                let finalOut = WEBGL2 ? name : `gl_FragData[${index}]`;
                for (let i = 1; i < split.length; ++i) {
                    split[i] = split[i].replace('gl_FragColor', finalOut);
                }
                fs = split.join('');
            }

            while (fs.includes('#applyShadow')) {
                fs = fs.split('\n');
                for (let i = 0; i < fs.length; i++) {
                    if (fs[i].includes('#applyShadow')) fs[i] = fs[i].replace('#applyShadow', '');
                }
                fs = fs.join('\n');
            }

            return fs;
        };

        let shader = mesh.shader;
        let fs = shader.fragmentShader;
        let name = _this.name || _name;

        if (!WEBGL2 || !fs.includes('location=0')) fs = modifyMarker(fs, 'Color', 0);
        fs = modifyMarker(fs, name, _textureIndex);

        shader.fragmentShader = fs;
    }

    //*** Event handlers
    function addListeners() {
        _this.events.sub(Events.RESIZE, resizeHandler);
    }

    function resizeHandler() {
        _rt.setSize && _rt.setSize(_nuke.stage.width * _this.resolution * _nuke.dpr, _nuke.stage.height * _this.resolution * _nuke.dpr);
    }

    function initRT(rt) {
        if (_useDrawBuffers) {
            let texture = new Texture();
            texture.minFilter = Texture.LINEAR;
            texture.magFilter = Texture.LINEAR;
            texture.format = Texture.RGBAFormat;
            if (!!_this.rtType) texture.type = _this.rtType;
            if (!!_this.rtFormat) texture.format = _this.rtFormat;
            if (!!_this.rtMipmaps) {
                texture.generateMipmaps = true;
                texture.minFilter = texture.magFilter = Texture.LINEAR_MIPMAP;
            } else {
                texture.generateMipmaps = false;
            }
            if (texture.type == Texture.FLOAT) texture.format = Texture.RGBAFormat;
            texture.wrapS = texture.wrapT = Texture.CLAMP_TO_EDGE;
            texture.fxLayer = _this;
            _this.textureIndex = _textureIndex = _parentNuke.attachDrawBuffer(texture);
            _rt = {texture};
        } else {
            if (_this.rtType && _this.rtType == Texture.FLOAT) {
                if (Device.system.os == 'ios') _this.rtType = Texture.HALF_FLOAT;
            }
            _rt = rt || Utils3D.createRT(Math.round(_nuke.stage.width * _this.resolution * _nuke.dpr), Math.round(_nuke.stage.height * _this.resolution * _nuke.dpr), _this.rtType, _this.rtFormat);
            if (_this.rtMipmaps) {
                _rt.texture.minFilter = _rt.texture.magFilter = Texture.LINEAR_MIPMAP;
                _rt.texture.generateMipmaps = true;
            } else {
                _rt.texture.generateMipmaps = false;
            }
        }
        _this.rt = _rt;
        _this.nuke.setSize(_rt.width, _rt.height);
    }

    //*** Public methods

    this.set('visible', v => _this.scene.visible = _visible = v);
    this.get('visible', _ => _visible);

    /**
     * @name this.onInvisible
     * @memberof FXLayer
     *
     * @function
    */
    this.onInvisible = function() {
        _this.scene.visible = false;
    }

    /**
     * @name this.onVisible
     * @memberof FXLayer
     *
     * @function
    */
    this.onVisible = function() {
        _this.scene.visible = true;
    }

    /**
     * @name create()
     * @memberof FXLayer
     *
     * @function
     * @param {Nuke} nuke
     * @param {String} type
     * @param {RenderTarget} rt
     */
    this.create = function(nuke = World.NUKE, type, rt) {
        if (!nuke) return;

        _useDrawBuffers = nuke.useDrawBuffers;

        let format, manualRender, mipmaps;
        if (type && typeof type === 'object') {
            if (typeof type.useDrawBuffers === 'boolean') _useDrawBuffers = type.useDrawBuffers;
            format = type.format;
            manualRender = type.manualRender;
            mipmaps = type.mipmaps;
            if (!rt) rt = type.rt;
            type = type.type;
        }

        _this.rtType = type || Texture.UNSIGNED_BYTE;
        _this.rtFormat = format || Texture.RGBFormat;
        _this.rtMipmaps = mipmaps;
        _this = this;
        _this.scene = _scene;
        _nuke = _this.initClass(Nuke, nuke.stage, {renderer: nuke.renderer, camera: nuke.camera, scene: _scene, dpr: nuke.dpr, useDrawBuffers: false});
        _nuke.parentNuke = nuke;
        _parentNuke = nuke;
        _this.nuke = _nuke;
        initRT(rt);
        addListeners();

        if (!manualRender && !FXScene.manualRender) _this.startRender(_ => _this.draw(), nuke);
    }

    /**
     * @name addObject()
     * @name add()
     * @memberof FXLayer
     *
     * @function
     * @param {Base3D} object
     */
    /**
     * @name this.addObject
     * @memberof FXLayer
     *
     * @function
     * @param object
    */
    this.addObject = this.add = function(object) {
        if (!_nuke) return;
        if (!_useDrawBuffers) {
            let clone = object.clone();
            object['clone_' + _id] = clone;
            _scene.add(clone);
            _objects.push(object);
            if (object.shader) editShader(clone);
            while (clone.children.length) clone.remove(clone.children[0]);
            return clone;
        } else {
            if (object.shader && object.shader.fragmentShader) {
                editDBShader(object);
                object.shader._attachmentData = {format: _this.rtFormat, type: _this.rtType, attachments: _parentNuke.attachments};
            }
        }
    }

    /**
     * @name removeObject()
     * @memberof FXLayer
     *
     * @function
     * @param {Base3D} object
     */
    this.removeObject = function(object) {
        if (!_nuke) return;
        _scene.remove(object['clone_' + _id]);
        _objects.remove(object);
        delete object['clone_' + _id];
    }

    /**
     * @name render()
     * @name draw()
     * @memberof FXLayer
     *
     * @function
     * @param {Object} stage
     * @param {CameraBase3D} camera
     */
    /**
     * @name this.render
     * @memberof FXLayer
     *
     * @function
     * @param stage
     * @param camera
    */
    this.render = this.draw = function(stage, camera) {
        if (!_nuke || !_this.enabled || _useDrawBuffers) return;
        if (!_parentNuke.enabled || !_objects.length) return;

        const oldClear = Renderer.CLEAR;
        Renderer.CLEAR = CLEAR_COLOR;

        if (stage) {
            _nuke.stage = stage;
            _this.setSize(stage.width, stage.height);
        }

        if (camera) {
            _nuke.camera = camera;
        } else {
            _nuke.camera = _nuke.parentNuke.camera;
        }

        if (!_this.renderShadows) _nuke.renderer.overridePreventShadows = true;

        for (let i = _objects.length-1; i > -1; i--) {
            let obj = _objects[i];
            let clone = obj['clone_' + _id];

            if (_this.forceVisible) clone.visible = true;
            else clone.visible = obj.determineVisible();

            if (clone.visible) {
                obj.updateMatrixWorld();
                if (!obj.ignoreMatrix) Utils3D.decompose(obj, clone);
            }
        }

        _nuke.rtt = _rt;
        _nuke.render();
        RenderStats.update('FXLayer');

        _nuke.renderer.overridePreventShadows = false;
        Renderer.CLEAR = oldClear;
    }

    /**
     * @name addPass()
     * @memberof FXLayer
     *
     * @function
     * @param {NukePass} pass
     */
    this.addPass = function(pass) {
        if (!_nuke) return;
        _nuke.add(pass);
    }

    /**
     * @name removePass()
     * @memberof FXLayer
     *
     * @function
     * @param {NukePass} pass
     */
    this.removePass = function(pass) {
        if (!_nuke) return;
        _nuke.remove(pass);
    }

    /**
     * @name setSize()
     * @memberof FXLayer
     *
     * @function
     * @param {Number} width
     * @param {Number} height
     */
    this.setSize = function(width, height) {
        if (!_nuke) return;
        if (_rt.width == width && _rt.height == height) return;
        _this.events.unsub(Events.RESIZE, resizeHandler);
        _rt && _rt.setSize(width * _this.resolution * _nuke.dpr, height * _this.resolution * _nuke.dpr);
        _nuke.setSize(width * _this.resolution * _nuke.dpr, height * _this.resolution * _nuke.dpr);
    }

    /**
     * @name setDPR()
     * @memberof FXLayer
     *
     * @function
     * @param {Number} dpr
     */
    this.setDPR = function(dpr) {
        if (!_nuke) return;
        _nuke.dpr = dpr;
        resizeHandler();
    }

    /**
     * @name setResolution()
     * @memberof FXLayer
     *
     * @function
     * @param {Number} res
     */
    this.setResolution = function(res) {
        _this.resolution = res;
        resizeHandler();
    }

    /**
     * @name this.getObjects
     * @memberof FXLayer
     *
     * @function
    */
    this.getObjects = function() {
        return _objects;
    }

    /**
     * @name this.useRT
     * @memberof FXLayer
     *
     * @function
     * @param rt
    */
    this.useRT = function(rt) {
        _rt = _this.rt = rt;
    }

    /**
     * @name this.getName
     * @memberof FXLayer
     *
     * @function
    */
    this.getName = function() {
        return _this.name || _name;
    }

    if (_parentNuke instanceof Nuke) this.create(_parentNuke, _type);
});

Namespace('FX');

/**
 * @name FXScene
 * @param {Nuke} parentNuke
 * @param {String} type
 */

Class(function FXScene(_parentNuke, _type, ...rest) {
    Inherit(this, Component);
    var _this = this;
    var _nuke, _rt, _rtPool;

    var _scene = new Scene();
    var _id = Utils.timestamp();
    var _objects = [];
    var _renderTime = Render.TIME;

    var _visible = true;

    this.resolution = 1;
    this.autoVisible = true;
    this.enabled = true;
    this.scene = _scene;
    this.renderShadows = true;

    var _showManualRenderWarning;

    function initRT(rt, options = {}) {
        if (options.type == Texture.FLOAT) {
            options.format = Texture.RGBAFormat;
            if (Device.system.os == 'ios') {
                options.type = Texture.HALF_FLOAT;
                options.minFilter = Texture.NEAREST;
                options.magFilter = Texture.NEAREST;
            }
        }

        const RT = _this.nuke.useDrawBuffers && options.multiRenderTarget ? MultiRenderTarget : RenderTarget;
        _this.width = _nuke.stage.width * _this.resolution * _nuke.dpr;
        _this.height = _nuke.stage.height * _this.resolution * _nuke.dpr;

        let filter = options.mipmaps ? Texture.LINEAR_MIPMAP : Texture.LINEAR;
        _rt = rt || new RT(_this.width, _this.height, Object.assign({minFilter: filter, magFilter: filter, generateMipmaps: options.mipmaps || false}, options));
        _nuke.rtt = _this.rt = _rt;
        _rt.fxscene = _this;
        if (_this.vrRT) _rt.vrRT = true;
    }

    //*** Event handlers
    function addListeners() {
        _this.events.sub(Events.RESIZE, resizeHandler);
    }

    function resizeHandler() {
        _rt.setSize && _rt.setSize(_nuke.stage.width * _this.resolution * _nuke.dpr, _nuke.stage.height * _this.resolution * _nuke.dpr);
        _this.nuke.setSize(_rt.width, _rt.height);
        _this.width = _rt.width;
        _this.height = _rt.height;
    }

    //*** Public methods

    this.set('visible', v => {
        if (!_this.scene) return;
        _this.scene.visible = _visible = v;
        _this.onFXSceneVisibility?.(v);
    });
    this.get('visible', _ => _visible);

    /**
     * @name this.onInvisible
     * @memberof FXScene
     *
     * @function
    */
    this.onInvisible = this.fxInvisible = function() {
        if (this.scene.visible) {
            this.scene.visible = false;
            _this.flag('needsOnVisible', true);
        }

        if (_rtPool) _rtPool.putRT(_this.rt);
    }

    /**
     * @name this.onVisible
     * @memberof FXScene
     *
     * @function
    */
    this.onVisible = this.fxVisible = function() {
        if (_this.flag('needsOnVisible')) {
            this.scene.visible = true;
            _this.flag('needsOnVisible', false);
        }

        if (_rtPool) {
            _this.useRT(_rtPool.getRT());
            resizeHandler();
        }
    }

    /**
     * @name create()
     * @memberof FXScene
     *
     * @function
     * @param {Nuke} nuke
     * @param {String} type
     * @param {RenderTarget} rt
     */
    this.create = function(nuke = World.NUKE, rt, options) {
        if (_this.nuke) return;

        if (rt instanceof RTPool) {
            _rtPool = rt;
            rt = _rtPool.nullRT;
        }

        if (nuke instanceof RTPool) {
            _rtPool = nuke;
            options = rt;
            rt = _rtPool.nullRT;
            nuke = World.NUKE;
        } else if (rt && typeof rt === 'object') {
            if (!rt.isRT) {
                options = rt;
                rt = undefined;
            }
        } else if (nuke && !(nuke instanceof Nuke)) {
            options = nuke;
            nuke = World.NUKE;
        }


        if (!options) options = {};

        _this.rtFormat = options.format || Texture.RGBFormat;
        _this.rtType = options.type || Texture.UNSIGNED_BYTE;
        if (options.vr) _this.vrRT = RenderManager.type == RenderManager.VR;
        if (options.parentNuke) nuke = options.parentNuke;

        _this = this;
        _this.scene = _scene;
        _this.nuke = _nuke = _this.initClass(Nuke, nuke.stage, {
            renderer: nuke.renderer,
            camera: nuke.camera,
            scene: _scene,
            dpr: nuke.dpr,
            format: options.format,
            vrRT: _this.vrRT,
            multisample: options.multisample,
            samplesAmount: options.samplesAmount
        });

        _scene.nuke = _nuke;

        initRT(rt, options);
        if (rt) _this.flag('recycle_rt', true);
        else addListeners();

        if (FXScene.onCreate) FXScene.onCreate(_this);

        if (!options.manualRender && !_this.manualRender && !FXScene.manualRender) {
            if (Hydra.LOCAL) _showManualRenderWarning = true;
            if (_this.vrRT) {
                // vrRT renders need to be done before the base layer renders.
                // Use EYE_RENDER to get called back before World.NUKE.
                _this.startRender(({view}) => {
                    // Only render once per frame, because vrRenderingPath renders
                    // both eyes.
                    if (view === 0) _this.draw();
                }, RenderManager.EYE_RENDER);
            } else {
                _this.startRender(_ => {
                    _this.draw();
                }, nuke);
            }
        }
    }

    /**
     * @name this.fxDestroy
     * @memberof FXScene
     *
     * @function
    */
    this.onDestroy = this.fxDestroy = function() {
        _this.scene.deleted = true;
        if (!_this.flag('recycle_rt')) {
            _rt && _rt.destroy ? _rt.destroy() : null;
        } else if (_rtPool && _rt) {
            _rtPool.putRT(_rt);
        }
    }

    /**
     * @name setSize()
     * @memberof FXScene
     *
     * @function
     * @param {Number} width
     * @param {Number} height
     */
    this.setSize = function(width, height, exact) {
        if (!_nuke) return;
        if (!exact) {
            width = width * _this.resolution * _nuke.dpr;
            height = height * _this.resolution * _nuke.dpr;
        }
        if (_rt.width == width && _rt.height == height) return;
        _this.events.unsub(Events.RESIZE, resizeHandler);

        _this.width = width;
        _this.height = height;

        _rt && _rt.setSize(_this.width, _this.height);
        _nuke.setSize(_this.width, _this.height);
    }

    /**
     * @name addObject()
     * @name add()
     * @memberof FXScene
     *
     * @function
     * @param {Base3D} object
     */
    /**
     * @name this.add
     * @memberof FXScene
     *
     * @function
     * @param object
    */
    this.add = this.addObject = function(object) {
        if (!object) return console.error('FXScene addObject undefined!');
        let clone = object.clone();
        object['clone_' + _id] = clone;
        _scene.add(clone);
        _objects.push(object);
        object.shader._attachmentData = {format: _this.rtFormat, type: _this.rtType, attachments: 1};
        while (clone.children.length) clone.remove(clone.children[0]);
        return clone;
    }

    /**
     * @name removeObject()
     * @memberof FXScene
     *
     * @function
     * @param {Base3D} object
     */
    this.removeObject = function(object) {
        _scene.remove(object['clone_' + _id]);
        _objects.remove(object);
        delete object['clone_' + _id];
    }

    /**
     * @name this.setScissor
     * @memberof FXScene
     *
     * @function
     * @param x
     * @param y
     * @param w
     * @param h
    */
    this.setScissor = function(x, y, w, h) {
        if (!this.scissor) this.scissor = new Vector4();
        this.scissor.x = x * _this.width;
        this.scissor.y = _this.height - (h * _this.height) - (y * _this.height);
        this.scissor.width = w * _this.width;
        this.scissor.height = h * _this.height;

        this.rt.scissor = this.scissor;
    }

    /**
     * @name this.render
     * @memberof FXScene
     *
     * @function
     * @param stage
     * @param camera
    */
    this.render = this.draw = function(stage, camera) {
        if (_this.preventRender) return;
        if (_this.isVrWorldMode) {
            if (_this.onBeforeRender) _this.onBeforeRender();
            return;
        }

        if (_showManualRenderWarning && Render.TIME - _renderTime < (1000 / Render.REFRESH_RATE) / 2) {
            console.warn(`FXScene ${Utils.getConstructorName(_this)} rendering early (${
                Math.round(Render.TIME - _renderTime, 3)}ms elapsed, expected ~${
                Math.round(1000 / Render.REFRESH_RATE, 3)
            }ms. Set manualRender option if using own render loop.`);
            _showManualRenderWarning = false;
        }
        _renderTime = Render.TIME;

        if (_this.isVrSceneMode) {
            let enabled = World.NUKE.enabled && World.NUKE.passes.length;
            let rt = enabled ? World.NUKE.rttBuffer : undefined;
            let autoClear = _nuke.renderer.autoClear;
            _nuke.renderer.autoClear = false;
            _nuke.renderer.clearDepth(rt);
            if (_this.onBeforeRender) _this.onBeforeRender();
            _nuke.renderer.render(_scene, _nuke.camera, rt);
            _nuke.renderer.autoClear = autoClear;
            return;
        }

        if (stage) {
            _this.events.unsub(Events.RESIZE, resizeHandler);
            _this.nuke.stage = stage;
            _this.setSize(stage.width, stage.height);
        }

        if (camera) {
            _this.nuke.camera = camera;
        }

        let clearColor = null;
        let alpha = 1;
        if (_this.clearColor) {
            clearColor = _nuke.renderer.getClearColor().getHex();
            _nuke.renderer.setClearColor(_this.clearColor);
        }

        if (_this.clearAlpha > -1) {
            alpha = _nuke.renderer.getClearAlpha();
            _nuke.renderer.setClearAlpha(_this.clearAlpha);
        }

        if (!_this.renderShadows) _nuke.renderer.overridePreventShadows = true;

        for (let i = _objects.length-1; i > -1; i--) {
            let obj = _objects[i];
            let clone = obj['clone_' + _id];

            if (_this.forceVisible || obj.cloneVisible) clone.visible = typeof clone.isVisible === 'boolean' ? clone.isVisible : true;
            else clone.visible = obj.determineVisible();

            if (clone.visible) {
                obj.updateMatrixWorld(obj.visible === false ? true : undefined);
                if (!obj.ignoreMatrix) {
                    Utils3D.decompose(obj, clone);
                    if (clone.overrideScale) clone.scale.setScalar(clone.overrideScale);
                }
            }
        }

        if (!_this.preventRTDraw) {
            RenderStats.update('FXScene', 1, _this);
            if (_this.onBeforeRender) _this.onBeforeRender();
            _nuke.rtt = _rt;
            _nuke.render();
        }

        _nuke.renderer.overridePreventShadows = false;

        if (_this.clearColor) {
            _nuke.renderer.setClearColor(clearColor);
        }

        if (_this.clearAlpha > -1) {
            _nuke.renderer.setClearAlpha(_this.clearAlpha);
        }

        RenderManager.fire(_this);
    }

    /**
     * @name setDPR()
     * @memberof FXScene
     *
     * @function
     * @param {Number} dpr
     */
    this.setDPR = function(dpr) {
        if (!_nuke) return _this;
        _nuke.dpr = dpr;
        resizeHandler();
        return _this;
    }

    /**
     * @name addPass()
     * @memberof FXScene
     *
     * @function
     * @param {NukePass} pass
     */
    this.addPass = function(pass) {
        if (!_nuke) return;
        _nuke.add(pass);
    }

    /**
     * @name removePass()
     * @memberof FXScene
     *
     * @function
     * @param {NukePass} pass
     */
    this.removePass = function(pass) {
        if (!_nuke) return;
        _nuke.remove(pass);
    }

    /**
     * @name setResolution()
     * @memberof FXScene
     *
     * @function
     * @param {Number} res
     */
    this.setResolution = function(res) {
        _this.resolution = res;
        resizeHandler();
        return this;
    }

    /**
     * @name this.useRT
     * @memberof FXScene
     *
     * @function
     * @param rt
    */
    this.useRT = function(rt) {
        _rt = _this.rt = rt;
        if (_this.vrRT) rt.vrRT = true;
    }

    /**
     * @name this.upload
     * @memberof FXScene
     *
     * @function
    */
    this.upload = function() {
        if (_rt) _rt.upload();
    }

    /**
     * @name useCamera()
     * @memberof FXScene
     *
     * @function
     * @param {PerspectiveCamera} camera
     */
    this.useCamera = function(camera) {
        _this.nuke.camera = camera.camera || camera;
    }

    /**
     * @name useScene()
     * @memberof FXScene
     *
     * @function
     * @param {Scene} scene
     */
    this.useScene = function(scene) {
        _this.nuke.scene = scene;
    }

    /**
     * @name this.vrWorldMode
     * @memberof FXScene
     *
     * @function
    */
    this.vrWorldMode = function() {
        _this.isVrWorldMode = true;
        _this.group = new Group();
        for (let i = 0; i < this.scene.children.length; i++) {
            this.group.add(this.scene.children[i]);
        }
        _scene = _this.scene = _this.group;
        World.SCENE.add(_this.group);
    }

    /**
     * @name this.vrSceneMode
     * @memberof FXScene
     *
     * @function
    */
    this.vrSceneMode = function() {
        _this.isVrSceneMode = true;
        World.NUKE.autoClear = false;
        RenderManager.renderer.autoClear = false;
    }

    /**
     * @name this.createDepthTexture
     * @memberof FXScene
     *
     * @function
     * @param useRTTBuffer
    */
    this.createDepthTexture = function(useRTTBuffer) {
        if (_this.depthTexture) return _this.depthTexture;

        if (!_this.nuke.passes.length && !useRTTBuffer) {
            _this.rt.createDepthTexture();
            _this.depthTexture = _this.rt.depth;
        } else {
            _this.nuke.rttBuffer.createDepthTexture();
            _this.depthTexture = _this.nuke.rttBuffer.depth;
        }

        return _this.depthTexture;
    }

    if (_parentNuke instanceof Nuke) this.create(_parentNuke, _type, ...rest);
});

/**
 * @name FXSceneCompositor
 * @param {Shader} shader
 * @param {Texture} startTexture
 *
 * <br/>
 * FXSceneCompositor takes in a shader and a start texture (or FXScene) and creates a full screen quad mesh and manages it for you.
 *
 * ```
 * let transitionShader = _this.initClass(Shader, 'SomeTransition', {
 * ....
 * }):
 *
 * compositor = _this.initClass(FXSceneCompositor, transitionShader, {startTexture: sceneA});
 *```
 * FXSceneCompositor will decorate your shader with `tFrom`, `tTo`, and `uTransition`;
 * It's up to you to set `tFrom` and `tTo` and then to tween `uTransition`.
 * The goal is to keep this class simple and allow the developer to control everything.
 *
 * When your transition is either 0 or 1, FXSceneCompositor automatically swaps to a simple full screen quad basic shader.
 * When your uTransition hits 1, FXSceneCompositor resets uTransition to 0 and swaps back to the basic quad.
 * You can change the transition shader using `compositor.useShader(shader)`, and
 * change the basic shader with `compositor.useBasicShader(shader)`.
 *
 * All initialization options are optional:
 *   - startTexture: the texture/FXScene to render with the basic shader prior
 *     to any transitions
 *   - basicShader: override the default basic shader with your own. a `tMap`
 *     uniform will be added, and initialized to `startTexture` or null.
 */

Class(function FXSceneCompositor(_shader, _options = {}) {
    Inherit(this, Object3D);
    const _this = this;
    var _basicShader;

    //*** Constructor
    (function () {
        initOptions();
        decorateShader(_shader);
        initMesh();
        _this.startRender(loop);
    })();

    function initOptions() {
        // Backward compatibility: support _startTexture as second parameter
        if (_options === null || _options instanceof Texture || _options.texture || (_options.rt && _options.rt.texture)) {
            _options = {
                startTexture: _options,
            };
        }
    }

    function initMesh() {
        let uniforms = {
            tMap: {value: _options.startTexture || null},
        };
        if (_options.basicShader) {
            _basicShader = _options.basicShader;
            _basicShader.addUniforms(uniforms);
        } else {
            _basicShader = _this.initClass(Shader, 'ScreenQuad', uniforms);
        }
        _this.mesh = new Mesh(World.QUAD, _basicShader);
        _this.mesh.frustumCulled = false;
        _this.add(_this.mesh);
    }

    function decorateShader(shader) {
        shader.addUniforms({
            tFrom: {value: null},
            tTo: {value: null},
            uTransition: {value: 0}
        });
    }

    function loop() {
        _this.mesh.shader = _shader.uniforms.uTransition.value > 0 ? _shader : _basicShader;
        if (_shader.uniforms.uTransition.value >= 1) {
            _this.mesh.shader = _basicShader;
            _basicShader.set('tMap', _shader.get('tTo'));
            _shader.set('uTransition', 0);
        }
    }

    //*** Event handlers

    //*** Public methods
    /**
     * @name this.useShader
     * @memberof FXSceneCompositor
     *
     * @function
     * @param shader
    */
    this.useShader = function(shader) {
        _shader = shader;
        decorateShader(shader);
    }

    /**
     * @name this.useBasicShader
     * @memberof FXSceneCompositor
     *
     * @function
     * @param shader
     */
    this.useBasicShader = function(shader) {
        _basicShader.copyUniformsTo(shader, true);
        _basicShader = shader;
    }

    this.swap = function(showTransition) {
        if(showTransition) {
            _this.mesh.shader = _shader;
        }else{
            _basicShader.set('tMap', _shader.get('tTo'));
            _this.mesh.shader = _basicShader;
            _shader.set('tFrom', _basicShader.get('tMap'));
        }
    }

    this.set('manual', (v)=>{
        if(v) {
            _this.stopRender(loop);
        }else{
            _this.startRender(loop);
        }
    });

    this.transition = async function(texture, time, ease, delay) {
        let from = _shader.get('tFrom');
        _shader.set('tTo', texture);
        texture.visible = true;
        if (!from) _shader.set('uTransition', 1);
        else {
            await _shader.tween('uTransition', 1, time, ease, delay).promise();
        }
        if (from) from.visible = false;
        _shader.set('tFrom', texture);
    }
});
/**
 * @name FXStencil
 */

Class(function FXStencil() {
    Inherit(this, Component);
    const _this = this;
    var _nuke;

    this.mesh = new Mesh(World.PLANE, Utils3D.getTestShader());
    this.scene = new Scene();
    this.mask = new Scene();
    this.mode = 'inside';
    this.enabled = true;

    //*** Constructor
    (function () {
        _this.mesh.shader.neverRender = true;
        _this.mesh.shader.transparent = true;
        _this.mesh.renderOrder = 99999;
        _this.mesh.onBeforeRender = render;
    })();

    function findNuke() {
        let p = _this.mesh._parent;
        while (p) {
            if (p instanceof Scene) return p.nuke;
            p = p._parent;
        }
    }

    function render() {
        if (!_nuke) _nuke = findNuke();

        let autoClear = World.RENDERER.autoClear;
        World.RENDERER.autoClear = false;

        if (_this.enabled) {
            _this.onBeforeMaskRendered && _this.onBeforeMaskRendered();

            World.RENDERER.setupStencilMask();
            World.RENDERER.render(_this.mask, _nuke.camera, 'stencil');

            _this.onAfterMaskRendered && _this.onAfterMaskRendered();

            World.RENDERER.setupStencilDraw(_this.mode);
        }

        World.RENDERER.render(_this.scene, _nuke.camera, 'stencil');

        World.RENDERER.autoClear = autoClear;
        World.RENDERER.clearStencil();
    }

    //*** Event handlers

    //*** Public methods
    this.onDestroy = function() {
        _this.group._parent.remove(_this.mesh);
    }
});
Class(function FragCompositor() {
    Inherit(this, Component);
    const _this = this;

    
    //*** Event handlers
    
    //*** Public methods
    this._initCompositor = function(obj) {
        _this.shader = _this.initClass(Shader, obj.shader, _this.parent[obj.uniforms.slice(1)]);
        _this.basicShader = _this.initClass(Shader, obj.basicShader || 'ScreenQuad', _this.parent[obj.uniforms.slice(1)]);

        _this.compositor = _this.initClass(FXSceneCompositor, _this.shader, {basicShader: _this.basicShader});
        (obj.scene || World.SCENE).add(_this.compositor.mesh);
    }
});
Class(function BlitPass(_forceNuke) {
    Inherit(this, NukePass);
    const _this = this;

    this.uniforms = {};

    this.init('BlitPass');

    if (!_forceNuke) this.blitFramebuffer = true;

    //*** Event handlers

    //*** Public methods

});
/**
 * @name Nuke
 * @param {Object} stage
 * @param {Object} params
 */

Class(function Nuke(_stage, _params) {
    Inherit(this, Component);
    var _this = this;
    var _width, _height, _nukeMesh;

    if (!_params.renderer) console.error('Nuke :: Must define renderer');

   /**
    * @name stage
    * @memberof Nuke
    * @property
    */
    _this.stage = _stage;
   /**
    * @name renderer
    * @memberof Nuke
    * @property
    */
    _this.renderer = _params.renderer;
   /**
    * @name camera
    * @memberof Nuke
    * @property
    */
    _this.camera = _params.camera;
   /**
    * @name scene
    * @memberof Nuke
    * @property
    */
    _this.scene = _params.scene;
   /**
    * @name rtt
    * @memberof Nuke
    * @property
    */
    _this.rtt = _params.rtt; // optional, if available, renders finally to this and not canvas
   /**
    * @name enabled
    * @memberof Nuke
    * @property
    */
    _this.enabled = _params.enabled == false ? false : true;
   /**
    * @name passes
    * @memberof Nuke
    * @property
    */
    _this.passes = _params.passes || [];
   /**
    * @name format
    * @memberof Nuke
    * @property
    */
    _this.format = _params.format || Texture.RGBFormat;
   /**
    * @name useDrawBuffers
    * @memberof Nuke
    * @property
    */
    _this.useDrawBuffers = (_ => {
        if (Utils.query('noDrawBuffers') || Nuke.NO_DRAWBUFFERS) return false;
        if (typeof _params.useDrawBuffers !== 'undefined') return _params.useDrawBuffers;
        if (Renderer.type == Renderer.WEBGL2 || window.Metal) return true;
        return false;
    })();

    var _dpr = _params.dpr || 1;
    var _rts = {};
    var _rtStack = [];
    var _rttPing, _rttPong, _rttBuffer;
    var _drawBuffers = [];
    var _enabledPasses = [];

    var _multisample = _params.multisample || false;
    var _samplesAmount = _params.samplesAmount || 4;

    //*** Constructor
    (function () {
        _this.scene.nuke = _this;
        initDefaultPass();
        initNuke();
        addListeners();
    })();

    function initDefaultPass() {
        if (Nuke.defaultPass) return;
        Nuke.defaultPass = new BlitPass();
        let upload = Nuke.defaultPass.upload;
        Nuke.defaultPass.upload = function() {
            upload.apply(this, arguments);
            Nuke.defaultPass.uploaded = true;
        };
    }

    function initNuke() {
        let width = _this.stage.width * _dpr;
        let height = _this.stage.height * _dpr;
        _rttPing = Nuke.getRT(width, height, false, 1, _this.format, false, _samplesAmount);
        _rttPong = Nuke.getRT(width, height, false, 2, _this.format, false, _samplesAmount);
        _rttBuffer = Nuke.getRT(width, height, _this.useDrawBuffers, -1, _this.format, _multisample, _samplesAmount);

        _nukeMesh = new Mesh(World.QUAD, null);
        _nukeMesh.frustumCulled = false;
        _nukeMesh.noMatrices = true;
        _nukeMesh.transient = true;

        _width = width;
        _height = height;

        if (_params.vrRT) {
            _this.vrRT = true;
            _rttBuffer.vrRT = true;
        }
    }

    //*** Event handlers
    function addListeners() {
        _this.events.sub(Events.RESIZE, resizeHandler);
    }

    function resizeHandler() {
        var width = _this.stage.width * _dpr;
        var height = _this.stage.height * _dpr;

        _rttPing.setSize(width, height);
        _rttPong.setSize(width, height);
        _rttBuffer.setSize(width, height);

        Nuke.renameRT(_width, _height, width, height, false, 1, _this.format, false, _samplesAmount);
        Nuke.renameRT(_width, _height, width, height, false, 2, _this.format, false, _samplesAmount);
        Nuke.renameRT(_width, _height, width, height, _this.useDrawBuffers, -1, _this.format, _multisample, _samplesAmount);

        _width = width;
        _height = height;
    }

    //*** Public methods
     /**
     * @name this.onBeforeShaderCompile
     * @memberof Nuke
     *
     * @function
     * @param obj
    */
   _this.onBeforeShaderCompile = function(obj) {
        if (!obj) return;
        let shader = obj.shader;
        if (!shader || !shader.fragmentShader || !_this.useDrawBuffers || !_drawBuffers.length) return;

        const WEBGL2 = Renderer.type == Renderer.WEBGL2;

        let matched = false;
        _drawBuffers.forEach((t, i) => {
            let name = t.fxLayer.getName();
            let keyExpr = WEBGL2 ? new RegExp(`\\b${name}\\s*=`) : new RegExp(`\\bgl_FragData\\[${i + 1}\\]\\s*=`);

            if (!keyExpr.test(shader.fragmentShader) && _this.useDrawBuffers) {
                let fs = shader.fragmentShader;
                if (!fs.includes(`#drawbuffer ${name} gl_FragColor`)) {
                    let idx = fs.lastIndexOf('}');
                    fs = fs.slice(0, idx) + `#drawbuffer ${name} gl_FragColor = vec4(0.0);\n` + fs.slice(idx);
                    shader.fragmentShader = fs;
                }
                t.fxLayer.add(obj);
                matched = true;
            }
        });

        let keyExpr = WEBGL2 ? /\bColor\s*=/ : /\bgl_FragData\[0\]\s*=/;
        if (!keyExpr.test(shader.fragmentShader)) {
            let fs = shader.fragmentShader;
            if (!WEBGL2) fs = '#extension GL_EXT_draw_buffers : require\n' + fs;
            fs = fs.split('void main() {');
            fs = fs[0] + 'void main() {\nvec4 tmpFragColor;\n' + fs[1];
            fs = fs.replace(/gl_FragColor/g, 'tmpFragColor');
            let idx = fs.lastIndexOf('}');
            if (!matched) {
                fs = fs.slice(0, idx) + `#drawbuffer Color gl_FragColor = tmpFragColor;\n` + fs.slice(idx);
            } else {
                if (WEBGL2) fs = fs.slice(0, idx) + `Color = tmpFragColor;\n` + fs.slice(idx);
                else fs = fs.slice(0, idx) + `gl_FragData[0] = tmpFragColor;\n` + fs.slice(idx);
            }
            shader.fragmentShader = fs;
        }
        shader.onBeforePrecompilePromise.resolve();
    }

    /**
     * @name add()
     * @memberof Nuke
     *
     * @function
     * @param {NukePass} pass
     */
    _this.add = function(pass, index) {
        if (typeof index == 'number') {
            _this.passes.splice(index, 0, pass);
            return;
        }
        _this.passes.push(pass);
    };

    /**
     * @name remove()
     * @memberof Nuke
     *
     * @function
     * @param {NukePass} pass
     */
    _this.remove = function(pass) {
        if (typeof pass == 'number') {
            _this.passes.splice(pass);
        } else {
            _this.passes.remove(pass);
        }
    }

    /**
     * @name this.render
     * @memberof Nuke
     *
     * @function
     * @param directCallback
    */
    _this.render = function(directCallback) {
        RenderStats.update('Nuke');

        RenderManager.fire(_this);
        _this.events.fire(Nuke.RENDER, _this, true);
        _this.onBeforeRender && _this.onBeforeRender();

        let count = _this.passes.length;
        _enabledPasses.length = 0;
        for (let i = 0; i < count; i++) {
            let pass = _this.passes[i];
            if (!pass.disabled) {
                _enabledPasses.push(pass);
            }
        }
        if (_this.enabled && _enabledPasses.length === 0 && !_this.rtt) {
            // Can't render direct-to-canvas if we want MSAA or non-native DPR.
            if (_dpr !== Device.pixelRatio || _multisample) {
                _enabledPasses.push(Nuke.defaultPass);
            }
        }

        if (!_this.enabled || !_enabledPasses.length) {
            let autoClear = _this.renderer.autoClear;
            if (_this.autoClear == false) _this.renderer.autoClear = false;
            _this.renderer.render(_this.scene, _this.camera, _this.rtt, null, directCallback);
            _this.onBeforeProcess && _this.onBeforeProcess();
            _this.events.fire(Nuke.BEFORE_POST_RENDER, _this, true);
            _this.postRender && _this.postRender();
            _this.events.fire(Nuke.POST_RENDER, _this, true);
            if (_this.autoClear == false) {
                _this.renderer.autoClear = autoClear;
                _this.renderer.clearColor();
            }
            return;
        }

        RenderStats.update('NukePass', _enabledPasses.length);

        _this.hasRendered = true;
        _this.onBeforeProcess && _this.onBeforeProcess();

        let autoClear = _this.renderer.autoClear;
        if (_this.autoClear == false) _this.renderer.autoClear = false;
        if (!_this.preventNewRender) _this.renderer.render(_this.scene, _this.camera, _rttBuffer);
        if (_this.autoClear == false) _this.renderer.autoClear = autoClear;

        let pingPong = true;
        let skipMultisample = _this.rtt && _this.rtt.multisample;
        if (skipMultisample) {
            // Multisampling was already done when the scene rendered into _rttBuffer,
            // so don’t multisample on this pass.
            // (_this.rtt still needs to be created as a multisampled buffer in case
            // there are no nuke passes).
            _this.rtt.multisample = false;
        }
        count = _enabledPasses.length;

        for (var i = 0; i < count; i++) {
            let shader = _enabledPasses[i].pass;
            let inTexture = i === 0 ? _rttBuffer.texture : (pingPong ? _rttPing.texture : _rttPong.texture);
            let outTexture = pingPong ? _rttPong : _rttPing;
            if (i === count - 1) outTexture = _this.rtt;

            _nukeMesh.shader = shader;
            _nukeMesh.shader.depthTest = false;
            _nukeMesh.shader.depthWrite = false;
            _nukeMesh.shader.uniforms.tDiffuse.value = inTexture;
            _this.renderer.renderSingle(_nukeMesh, _this.camera || World.CAMERA, outTexture, i === count - 1 ? directCallback : null);

            pingPong = !pingPong;
        }

        if (skipMultisample) {
            _this.rtt.multisample = true;
        }

        _this.events.fire(Nuke.BEFORE_POST_RENDER, _this, true);
        _this.postRender && _this.postRender();
        _this.events.fire(Nuke.POST_RENDER, _this, true);
        if (_this.autoClear == false) _this.renderer.clearColor(_rttBuffer);
    }

    /**
     * @name this.setSize
     * @memberof Nuke
     *
     * @function
     * @param width
     * @param height
    */
    _this.setSize = function(width, height) {
        if (width == _width && height == _height) return;

        _width = width;
        _height = height;

        resizeHandler();
        _this.events.unsub(Events.RESIZE, resizeHandler);
    }

    /**
     * @name this.attachDrawBuffer
     * @memberof Nuke
     *
     * @function
     * @param texture
    */
    _this.attachDrawBuffer = function(texture) {
        if (_this.hasRendered) console.warn('Attempt to attach draw buffer after first render! Create FXLayer instance before first render.');
        _drawBuffers.push(texture);

        if (_rttBuffer && _rttBuffer.attachments) {
            _rttBuffer.attachments = [_this.rtt && _this.rtt.attachments ? _this.rtt.attachments[0] : _rttBuffer.attachments[0]];
            for (let i = 0; i < _drawBuffers.length; i++) {
                _rttBuffer.attachments.push(_drawBuffers[i]);
                if (_this.rtt && _this.rtt.attachments) _this.rtt.attachments.push(_drawBuffers[i]);
            }
        }

        return _drawBuffers.length;
    }

    /**
     * @name this.upload
     * @memberof Nuke
     *
     * @function
    */
    _this.upload = function() {
        if (_this.passes.length && _this.enabled) {
            _rttPing.upload();
            _rttPong.upload();
            _rttBuffer.upload();
        }

        if (_rttBuffer.depth) _rttBuffer.depth.upload();

        if (_this.rtt) _this.rtt.upload();
    }

    _this.set('dpr', function(v) {
        _dpr = v;
        resizeHandler();
    });

    _this.get('dpr', function() {
        return _dpr;
    });

    _this.get('output', function() {
        return _nukeMesh.shader && _nukeMesh.shader.uniforms ? _nukeMesh.shader.uniforms.tDiffuse.value : null;
    });

    _this.get('rttBuffer', function() {
        return _rttBuffer;
    });

    this.set('rttBuffer', function(v) {
        _rttBuffer = v;
    });

    _this.get('prevFrameRT', function() {
        return _rttBuffer && _rttBuffer.texture ? _rttBuffer.texture : null;
    });

    _this.get('nukeScene', function() {
        return _nukeScene;
    });

    _this.get('ping', function() {
        return _rttPing;
    });

    _this.get('pong', function() {
        return _rttPong;
    });

    _this.get('attachments', function() {
        return _rttBuffer.attachments ? _rttBuffer.attachments.length : 0;
    });

    /**
     * @name this.onDestroy
     * @memberof Nuke
     *
     * @function
    */
    this.onDestroy = function() {
        _rttBuffer.destroy();
    }

    this.clearMemory = function() {
        _rttBuffer.destroy();
        _rttPing.destroy();
        _rttPong.destroy();
    }

}, function() {
    Nuke.RENDER = 'nuke_render';
    Nuke.BEFORE_POST_RENDER = 'nuke_before_post_render';
    Nuke.POST_RENDER = 'nuke_post_render';

    var _camera, _geom;
    var _rts = {};
    Nuke.getRT = function(width, height, multi, index, format, multisample, samplesAmount) {
        let exists = _rts[`${width}_${height}_${multi}_${index}_${format}_${multisample}_${samplesAmount}`];
        if (exists) return exists;

        let rt;
        if (!multi) {
            rt = Utils3D.createRT(width, height, undefined, format, multisample, samplesAmount);
        } else {
            rt = Utils3D.createMultiRT(width, height, undefined, format, multisample, samplesAmount);
        }

        if (Nuke.recyclePingPong) {
            _rts[`${width}_${height}_${multi}_${index}_${format}_${multisample}_${samplesAmount}`] = rt;
        }

        return rt;
    };

    Nuke.renameRT = function(prevWidth, prevHeight, width, height, multi, index, format, multisample, samplesAmount) {
        _rts[`${width}_${height}_${multi}_${index}_${format}_${multisample}_${samplesAmount}`] = 
            _rts[`${prevWidth}_${prevHeight}_${multi}_${index}_${format}_${multisample}_${samplesAmount}`];
    }
});

/**
 * @name NukePass
 * @param {String} fragmentShader
 * @param {Object} uniforms
 */
Class(function NukePass(_fs, _uniforms, _pass) {
    Inherit(this, Component);
    var _this = this;

    if (typeof _fs === 'object') {
        let shader = _fs.shader;
        _uniforms = _fs.uniforms;
        _fs = shader;
    }

    this.UILPrefix = typeof _fs == 'string' ? _fs : Utils.getConstructorName(_fs);

    function prefix(code) {
        if (!code) throw `No shader ${_fs} found`;
        let pre = '';

        if (!code.includes('uniform sampler2D tDiffuse')) {
            pre += 'uniform sampler2D tDiffuse;\n';
            pre += 'varying vec2 vUv;\n';
        }

        code = pre + code;

        return code;
    }

    //*** Public methods
    /**
     * @name this.init
     * @memberof NukePass
     *
     * @function
     * @param fs
     * @param vs
    */
    this.init = function(fs, vs) {
        if (_this.pass) return;
        _this = this;

        let name = fs || this.constructor.toString().match(/function ([^\(]+)/)[1];
        let fragmentShader = Array.isArray(fs) ? fs.join('') : null;

        _this.uniforms = _uniforms || _this.uniforms || {};
        _this.uniforms.tDiffuse = {type: 't', value: null, ignoreUIL: true};

        if (_this.uniforms.unique) _this.UILPrefix += '_' + _this.uniforms.unique + '_';

        if (window.UILStorage) {
            for (let key in _this.uniforms) {
                if (key === 'unique') continue;
                _this.uniforms[key] = UILStorage.parse(_this.UILPrefix + key, _this.uniforms[key].value) || _this.uniforms[key];
            }
        }

        _this.pass = _this.initClass(Shader, vs || 'NukePass', fs, Utils.mergeObject(_this.uniforms, {precision: 'high'}), (code, type) => type == 'fs' ? prefix(code) : code);

        _this.uniforms = _this.pass.uniforms;
    };

    /**
     * @name set
     * @memberof NukePass
     *
     * @function
     * @param {String} key
     * @param {*} [value]
     * @returns {*} value of uniform
     */
    this.set = function(key, value) {
        TweenManager.clearTween(_this.uniforms[key]);
        _this.uniforms[key].value = value;
    };

    /**
     * @name get
     * @memberof NukePass
     *
     * @function
     * @param {String} key
     * @returns {*} value of uniform
     */
    this.get = function(key) {
        if (typeof _this.uniforms[key] === 'undefined') return null;
        return _this.uniforms[key].value;
    }

    /**
     * @name tween
     * @memberof NukePass
     *
     * @function
     * @param {String} key
     * @param {*} value
     * @param {Number} time
     * @param {String} ease
     * @param {Number} [delay]
     * @returns {Tween}
     */
    this.tween = function(key, value, time, ease, delay, callback, update) {
        return tween(_this.uniforms[key], {value: value}, time, ease, delay, callback, update);
    };

    /**
     * @name this.clone
     * @memberof NukePass
     *
     * @function
    */
    this.clone = function() {
        if (!_this.pass) _this.init(_fs);
        return new NukePass(null, null, _this.pass.clone());
    }

    /**
     * @name this.upload
     * @memberof NukePass
     *
     * @function
    */
    this.upload = function() {
        _this.pass.upload();
    }

    this.addUniforms = function(obj) {
        for (let key in obj) {
            _this.uniforms[key] = obj[key];
        }
    }

    if (typeof _fs === 'string') {
        _this.init(_fs);
    } else if (_pass) {
        _this.pass = _pass;
        _this.uniforms = _pass.uniforms;
    }
});

/**
 * @name Raycaster
 * @param {CameraBase3D} camera
 */
Class(function Raycaster(_camera) {
    Inherit(this, Component);
    const _this = this;

    let _mouse = new Vector3();
    let _raycaster = new RayManager();

    this.testVisibility = true;

    //*** Constructor
    (function () {

    })();

    function ascSort( a, b ) {
        return a.distance - b.distance;
    }

    function intersectObject( object, raycaster, intersects, recursive ) {
        let obj = object;
        while (obj && _this.testVisibility) {
            if (obj.visible === false && !obj.forceRayVisible && obj.testVisibility !== false) return;
            obj = obj.parent;
        }

        if (!object.raycast) return;
        object.raycast( raycaster, intersects );
        if ( recursive === true ) {
            let children = object.children;
            for ( let i = 0, l = children.length; i < l; i ++ ) {
                intersectObject( children[ i ], raycaster, intersects, true );
            }
        }
    }

    function intersect(objects) {
        if (!Array.isArray(objects)) objects = [objects];
        let intersects = [];
        objects.forEach(object => {
            intersectObject( object, _raycaster, intersects, false );
        });
        intersects.sort( ascSort );
        return intersects;
    }

    //*** Event handlers

    //*** Public methods

    /**
     * @name camera
     * @memberof Raycaster
     * @property
     */
    this.set('camera', function(camera) {
        _camera = camera;
    });

    /**
     * @name pointsThreshold
     * @memberof Raycaster
     * @property
     */
    this.set('pointsThreshold', function (value) {
        _raycaster.params.Points.threshold = value;
    });

    /**
     * @name ray
     * @memberof Raycaster
     * @property
     */
    this.get('ray', () => {
        return _raycaster.ray;
    });

    /**
     * @name checkHit
     * @memberof Raycaster
     *
     * @function
     * @param {Array} objects
     * @param {Vector2} point
     */
    this.checkHit = function(objects, mouse, rect = Stage) {
        mouse = mouse || Mouse;

        _mouse.x = (mouse.x / rect.width) * 2 - 1;
        _mouse.y = -(mouse.y / rect.height) * 2 + 1;

        _raycaster.setFromCamera(_mouse, _camera);

        return intersect(objects);
    };

    /**
     * @name checkFromValues
     * @memberof Raycaster
     *
     * @function
     * @param {Array} objects
     * @param {Vector3} origin
     * @param {Vector3} direction
     */
    this.checkFromValues = function(objects, origin, direction) {
        _raycaster.set(origin, direction, 0, Number.POSITIVE_INFINITY);

        return intersect(objects);
    };
}, _ => {
    var _map = new WeakMap();
    var _ray;

    Raycaster.checkHit = function(objects, mouse) {
        if (!_ray) _ray = new Raycaster(World.CAMERA);
        return _ray.checkHit(objects, mouse);
    }

    Raycaster.checkFromValues = function(objects, origin, direction) {
        if (!_ray) _ray = new Raycaster(World.CAMERA);
        return _ray.checkFromValues(objects, origin, direction);
    }

    Raycaster.find = function(camera) {
        if (!_map.has(camera)) {
            let ray = new Raycaster(camera);
            _map.set(camera, ray);
        }
        return _map.get(camera);
    }

    /**
     * @name Raycaster.checkHit
     * @memberof Raycaster
     *
     * @function
     * @param {Array} objects
     * @param {Vector2} point
     */

    /**
     * @name Raycaster.checkFromValues
     * @memberof Raycaster
     *
     * @function
     * @param {Array} objects
     * @param {Vector3} origin
     * @param {Vector3} direction
     */
});
/**
 * @name ScreenProjection
 * @param {CameraBase3D} camera
 */
Class(function ScreenProjection(_camera) {
    Inherit(this, Component);
    var _this = this;

    var _v3 = new Vector3();
    var _v32 = new Vector3();
    var _value = new Vector3();

    //*** Constructor
    (function () {
        _camera = _camera.camera || _camera;
    })();

    //*** Event handlers

    //*** Public methods

    /**
     * @name camera
     * @memberof ScreenProjection
     * @property
     */
    this.set('camera', function(v) {
        _camera = v.camera || v;
    });

    this.get('camera', _ => _camera);

    /**
     * @name unproject
     * @memberof ScreenProjection
     *
     * @function
     * @param {Vector2} point
     * @param {Number} distance
     */
    this.unproject = function(mouse, rect = Stage, distance = 1) {
        if (typeof rect === 'number') {
            distance = rect;
            rect = Stage;
        }

        _v3.set((mouse.x / rect.width) * 2 - 1, -(mouse.y / rect.height) * 2 + 1, 0.5);
        _v3.unproject(_camera);

        let pos = _camera.getWorldPosition();
        _v3.sub(pos).normalize().multiplyScalar(distance);
        _value.copy(pos).add(_v3);

        return _value;
    }

    /**
     * @name project
     * @memberof ScreenProjection
     *
     * @function
     * @param {Vector3} point
     * @param {Vector2} resolution
     */
    this.project = function(pos, screen) {
        screen = screen || Stage;

        if (pos instanceof Base3D) {
            pos.updateMatrixWorld();
            _v32.set(0, 0, 0).setFromMatrixPosition(pos.matrixWorld);
        } else {
            _v32.copy(pos);
        }

        _v32.project(_camera);
        _v32.x = (_v32.x + 1) / 2 * screen.width;
        _v32.y = -(_v32.y - 1) / 2 * screen.height;

        return _v32;
    }
}, _ => {
    var _map = new WeakMap();
    var _screen;

    ScreenProjection.unproject = function(mouse, distance) {
        if (!_screen) _screen = new ScreenProjection(World.CAMERA);
        return _screen.unproject(mouse, distance);
    }

    ScreenProjection.project = function(pos, screen) {
        if (!_screen) _screen = new ScreenProjection(World.CAMERA);
        return _screen.project(pos, screen);
    }

    ScreenProjection.find = function(camera) {
        if (!_map.has(camera)) {
            let projection = new ScreenProjection(camera);
            _map.set(camera, projection);
        }
        return _map.get(camera);
    }

    /**
     * @name ScreenProjection.unproject
     * @memberof ScreenProjection
     *
     * @function
     * @param {Vector2} point
     * @param {Number} distance
     */

    /**
     * @name ScreenProjection.project
     * @memberof ScreenProjection
     *
     * @function
     * @param {Vector3} point
     * @param {Vector2} resolution
     */
});
/**
 * @name Object3D
 */

Class(function Object3D() {
    Inherit(this, Component);
    var _this = this;

    var _visible = true;

    this.__element = true;

    /**
     * @name this.group
     * @memberof Object3D
     */
    this.group = new Group();
    this.group.classRef = this;

    //*** Event handlers

    //*** Public methods

    /**
     * @name this.add
     * @memberof Object3D
     *
     * @function
     * @param {Object3D} child
     */
    this.add = function(child) {
        this.group.add(child.group || child);
    };

    /**
     * @name this.remove
     * @memberof Object3D
     *
     * @function
     * @param {Object3D} child
     */
    this.remove = function(child) {
        if(!child) return;
        this.group.remove(child.group || child);
    };

    this.onDestroy = function() {
        this.group.deleted = true;
        this.group.classRef = null;
        if (this.group && this.group._parent) this.group._parent.remove(this.group);
    }

    this.set('visible', v => _this.group.visible = _visible = v);
    this.get('visible', _ => _visible);
});

Class(function OrbitTargetHelper() {
    Inherit(this, Object3D);
    const _this = this;

    function VelocityTracker(_vector) {    
        var Vector = typeof _vector.z === 'number' ? Vector3 : Vector2;
        var _velocity = new Vector();
        var _last = new Vector();
    
        this.value = _velocity;
    
        this.update = function loop(time, delta) {
            _velocity.subVectors(_vector, _last).divideScalar((delta || Render.DELTA) / (1000 / 60));
            _last.copy(_vector);
        }
    };

    var _velocity = new VelocityTracker(_this.group.position);
    
    //*** Constructor
    (async function () {
        if (!Global.PLAYGROUND) return;
        await defer();
        Playground.instance().orbitControls.target.copy(_this.group.position);
        _this.startRender(_ => {
            _velocity.update();
            if (_velocity.value.length() > 0) {
                _this.flag('needsReset', true);
                _this.events.sub(Mouse.input, Interaction.END, set);
            }
        });
    })();

    function set() {
        _this.flag('needsReset', false);
        Playground.instance().orbitControls.target.copy(_this.group.position);
        _this.events.unsub(Mouse.input, Interaction.END, set);
    }
    
    //*** Event handlers
    
    //*** Public methods
    
});
/**
 * @name Utils3D
 */

 Class(function Utils3D() {
    const _this = this;
    var _debugGeometry, _emptyTexture, _q,  _v3, _v3b, _v3c, _m4;
    var _quatV1, _quatV2;

    var _textures = {};
    var _restorable = {};
    var _supportsKtx1;

    window.Vec2 = window.Vector2;
    window.Vec3 = window.Vector3;

    this.localDebug = window.Hydra && Hydra.LOCAL;

    (async function() {
        await Hydra.ready();
        let threads = Thread.shared(true);
        for (let i = 0; i < threads.array.length; i++) _this.loadEngineOnThread(threads.array[i]);
    })();

    //*** Public methods
    /**
     * @name this.decompose
     * @memberof Utils3D
     *
     * @function
     * @param local
     * @param world
    */
    this.decompose = function(local, world) {
        if (local.decomposeDirty) {
            local.matrixWorld.decompose(world.position, world.quaternion, world.scale);
            local.decomposeDirty = false;
        }
    };

    /**
     * @name this.createDebug
     * @memberof Utils3D
     *
     * @function
     * @param size
     * @param color
    */
    this.createDebug = function(size = 1, color) {
        return new Mesh(new IcosahedronGeometry(size, 1), _this.getTestShader(color));
    };

    /**
     * @name this.getTestShader
     * @memberof Utils3D
     *
     * @function
     * @param color
    */
    this.getTestShader = function(color) {
        return color ? new Shader('ColorMaterial', {color: {value: color instanceof Color ? color : new Color(color)}, alpha: {value: 1}}) : new Shader('TestMaterial');
    }

    /**
     * @name this.createMultiRT
     * @memberof Utils3D
     *
     * @function
     * @param width
     * @param height
     * @param type
     * @param format
     * @param multisample
     * @param samplesAmount
    */
    this.createMultiRT = function(width, height, type, format, multisample = false, samplesAmount = 4) {
        let rt = new MultiRenderTarget(width, height, {minFilter: Texture.LINEAR, magFilter: Texture.LINEAR, format: format || Texture.RGBFormat, type, multisample, samplesAmount });
        rt.texture.generateMipmaps = false;
        return rt;
    };

    /**
     * @name this.createRT
     * @memberof Utils3D
     *
     * @function
     * @param width
     * @param height
     * @param type
     * @param format
     * @param multisample
     * @param samplesAmount
    */
    this.createRT = function(width, height, type, format, multisample = false, samplesAmount = 4) {
        let rt = new RenderTarget(width, height, {minFilter: Texture.LINEAR, magFilter: Texture.LINEAR, format: format || Texture.RGBFormat, type, multisample, samplesAmount });
        rt.texture.generateMipmaps = false;
        return rt;
    }

    /**
     * @name this.getFloatType
     * @memberof Utils3D
     *
     * @function
    */
    this.getFloatType = function() {
        return Device.system.os == 'android' ? Texture.FLOAT : Texture.HALF_FLOAT;
    }

    function getTexture(key, params, loadTexture) {
        if (!Device.graphics.webgl && !window.AURA) {
            let texture = new Texture();
            texture.promise = Promise.resolve();
            texture.dimensions = {width: 0, height: 0};
            return texture;
        }

        let restorable = _restorable[key];
        if (restorable) {
            restorable = restorable.deref();
            delete _restorable[key];
        }
        if (restorable) {
            restorable.restore();
        } else if (!_textures[key]) {
            let texture = new Texture();
            texture.exists = 1;
            texture.loaded = false;
            texture.promise = Promise.create();
            texture._destroy = texture.destroy;
            texture.destroy = function(force) {
                if (!force && (texture.forcePersist || --texture.exists > 0)) return;
                delete _textures[key];
                RenderCount.remove(`tex_${texture.dimensions.width}_${texture.dimensions.height}`);
                RenderCount.remove(`tex_${texture.compressed ? 'compressed' : 'uncompressed'}`);
                _restorable[key] = new WeakRef(this);
                this._destroy();
            };

            _textures[key] = texture;

            if (params.premultiplyAlpha === false) texture.premultiplyAlpha = false;

            if (_this.onTextureCreated) _this.onTextureCreated(texture);

            let doLoadTexture = async () => {
                try {
                    await loadTexture(texture);

                    texture.loaded = true;
                    texture.needsReupload = true;

                    RenderCount.add(`tex_${texture.dimensions.width}_${texture.dimensions.height}`);
                    RenderCount.add(`tex_${texture.compressed ? 'compressed' : 'uncompressed'}`);

                    if (texture.onload) {
                        texture.onload();
                        texture.onload = null;
                    }

                    texture.promise.resolve();
                } catch (e) {
                    texture.promise.reject(e);
                }
            };

            doLoadTexture(texture);
            texture.restore = function() {
                if (_textures[key]) return;
                delete _restorable[key];
                texture.exists++;
                texture.promise = Promise.create();
                texture.loaded = texture.needsReupload = false;
                _textures[key] = texture;
                doLoadTexture(texture);
            };
        } else {
            _textures[key].exists++;
        }

        return _textures[key];
    }

    function loadTextureSource(texture, path, params) {
        let promise = Promise.create();

        let cb = (imgBmp) => {
            imgBmp.crossOrigin = 'anonymous';
            texture.dimensions = {width: imgBmp.width, height: imgBmp.height};
            texture.loaded = true;
            texture.needsReupload = true;

            // In case of error, a fallback image is returned.
            if (texture.compressed && !imgBmp.compressedData) {
                texture.compressed = false;
            }
            if (World.RENDERER.type !== Renderer.WEBGL2 && !Math.isPowerOf2(imgBmp.width, imgBmp.height)) {
                texture.minFilter = Texture.LINEAR;
                texture.generateMipmaps = false;
            }

            promise.resolve(imgBmp);
        };

        ImageDecoder.decode(path, params).then(cb).catch(e => {
            promise.reject(e);
        });

        return promise;
    }

    function parseTexturePath(path) {
        if (path.includes('://')) {
            let guard = path.split('://');
            guard[1] = guard[1].replace(/\/\//g, '/');
            path = guard.join('://');
        } else {
            path = path.replace(/\/\//g, '/');
        }

        let compressed, compressedIdentifier;
        ({ compressed, compressedIdentifier, path } = parseCompressed(path));
        let cacheBust;
        if (window.URLSearchParams) {
            if (path.includes('?')) {
                let [withoutQuery, query] = path.split('?');
                let params = new URLSearchParams(query);
                for (const [key, value] of params.entries()) {
                    let check = key;
                    if (key.includes('-compressedKtx')) {
                        check = key.substring(0, key.indexOf('-compressedKtx'));
                    }
                    if (Number.isInteger(Number(check)) && Number(check) > 0 && value === '') {
                        params.delete(key);
                        if (check !== key && compressed) {
                            withoutQuery += compressedIdentifier;
                        }
                        cacheBust = true;
                    }
                }
                if (cacheBust) {
                    path = withoutQuery;
                    query = params.toString();
                    if (query) path += '?' + query;
                }
            }
        } else if (path.includes('?')) {
            cacheBust = true;
            path = path.split('?')[0];
        }
        if (!Hydra.LOCAL) cacheBust = false;

        let imgPath = path;
        if (cacheBust) {
            imgPath += (imgPath.includes('?') ? '&' : '?') + Date.now();
        }
        if (compressed && !imgPath.includes('compressed')) imgPath += compressedIdentifier;

        return { plainPath: path, imgPath, compressed };
    }

    function parseCompressed(path) {
        let compressedIdentifier = /-compressedKtx2?/.exec(path)?.[0];
        let compressed = false;
        if (compressedIdentifier) {
            if (!Utils.query('noKtx')) {
                if (compressedIdentifier.endsWith('2')) {
                    if (typeof Ktx2Transcoder !== 'undefined') compressed = 'ktx2';
                } else {
                    compressed = 'ktx1';
                }
            }
            path = path.replace(compressedIdentifier, '');
        }
        let requiresKtx = false;
        if (/\.ktx2(?:\?|#|$)/.test(path)) {
            compressed = 'ktx2';
            compressedIdentifier = '';
            requiresKtx = true;
        }
        return { compressed, compressedIdentifier, path, requiresKtx };
    }

    /**
     * @name this.getTexture
     * @memberof Utils3D
     *
     * @function
     * @param path
     * @param params
    */
    this.getTexture = function(path, params = {}) {
        let { imgPath, plainPath, compressed } = parseTexturePath(path);
        return getTexture(plainPath, params, async (texture) => {
            texture.compressed = compressed;
            texture.format = plainPath.match(/\.jpe?g/) ? Texture.RGBFormat : Texture.RGBAFormat;
            texture.src = plainPath;
            let imgBmp = await loadTextureSource(texture, imgPath, params);
            texture.image = imgBmp;
            if (imgBmp.sizes && imgBmp.sizes.length === 1) {
                texture.minFilter = Texture.LINEAR;
            }

            if (params.findDominantColors) {
                texture.dominantColors = _this.findDominantColors(path);
            }

            texture.onUpdate = function() {
                if (!params.preserveData && imgBmp.close) imgBmp.close();
                texture.onUpdate = null;
            };
        });
    };

    /**
     * @name this.getCubeTexture
     * @memberof Utils3D
     *
     * @function
     * @param paths an array of six paths, or the path to the first image which must contain a numeric pattern such as 0000 or 01, which will be incremented to construct paths for six image assets. The last numeric part in the path will be used.
     * @param params
     * @returns {Texture}
     */
    this.getCubeTexture = function(paths, params = {}) {
        paths = getCubePaths(paths);
        let parsed = paths.map(parseTexturePath);
        let key = `cube:${parsed.map(({ plainPath }) => plainPath).join('|')}`;
        return getTexture(key, params, async (texture) => {
            texture.cube = await Promise.all(parsed.map(({ imgPath, compressed }) => {
                texture.compressed = compressed;
                texture.format = imgPath.match(/\.jpe?g/) ? Texture.RGBFormat : Texture.RGBAFormat;
                return loadTextureSource(texture, imgPath, params);
            }));

            if (!texture.compressed && texture.cube.length === 1) {
                // Was a compressed texture, but an error occurred and a fallback image was returned.
                texture.cube = [...Array(6).keys()].map(_ => texture.cube[0]);
            }
            if (texture.compressed && texture.cube[0].sizes.length === 1) {
                texture.minFilter = Texture.LINEAR;
            }

            texture.onUpdate = function() {
                if (!params.preserveData) {
                    texture.cube.forEach(imgBmp => {
                        if (imgBmp.close) imgBmp.close();
                    });
                }
                texture.onUpdate = null;
            };
        });
    };

    /**
     * Preprocesses a cubemap url for use by Utils3D.getCubemapFacePaths().
     * @param url
     * @returns {{prefix: string, pattern: string, start: number, suffix: string}}
     */
    function splitCubemapPath(url) {
        let path = url.replace(/-compressedKtx2?/, '').split(/[#?]/)[0];
        let match = /(\d+)(?!.*\d+)/.exec(path);
        if (!match) {
            throw new Error('Cubemap texture path must include a numeric pattern');
        }
        let prefix = url.substring(0, match.index);
        let pattern = match[1];
        let suffix = url.substring(match.index + pattern.length);
        let start = +pattern;
        return { prefix, pattern, suffix, start };
    }

    /**
     * Returns the path to the six faces of a cubemap, given the
     * path to the first path. The last numeric pattern in the given
     * filename is found and incremented to obtain the paths to the
     * other five faces.
     * @param pathinfo obtained from Utils3D.splitCubemapPath(url)
     * @returns {string[]}
     */
    function getCubemapFacePaths(pathinfo) {
        let { prefix, pattern, suffix, start } = pathinfo;
        let padChar;
        if (pattern.length > String(start).length) {
            padChar = pattern.charAt(0);
        }
        return Array.from(Array(6).keys(), i => {
            let n = String(start + i);
            if (padChar) n = n.padStart(pattern.length, padChar);
            return `${prefix}${n}${suffix}`;
        });
    }

    function getCubePaths(url) {
        if (Array.isArray(url)) return url;
        let { compressed, compressedIdentifier, path, requiresKtx } = parseCompressed(url);
        if (requiresKtx) {
            return [path];
        }
        if (compressed === 'ktx1') {
            if (typeof _supportsKtx1 === 'undefined') {
                _supportsKtx1 = !!(Renderer.extensions.s3tc || Renderer.extensions.etc1 || Renderer.extensions.pvrtc || Renderer.extensions.astc);
            }
            if (!_supportsKtx1) {
                compressed = false;
            }
        }
        if (!compressed && compressedIdentifier) {
            // compression was requested in the original url, but has been disabled
            url = url.replace(compressedIdentifier, '');
        }

        let info = splitCubemapPath(url);
        if (compressed) {
            return [`${info.prefix}${info.suffix}`];
        }
        return getCubemapFacePaths(info);
    }

    this.splitCubemapPath = splitCubemapPath;
    this.getCubemapFacePaths = getCubemapFacePaths;

    /**
     * @name this.getLookupTexture
     * @memberof Utils3D
     *
     * @function
     * @param path
    */
    this.getLookupTexture = function(path) {
        let texture = _this.getTexture(path);
        texture.minFilter = texture.magFilter = Texture.NEAREST;
        texture.generateMipmaps = false;
        return texture;
    }

    /**
     * @name this.clearTextureCache
     * @memberof Utils3D
     *
     * @function
    */
    this.clearTextureCache = function() {
        for (let key in _textures) _textures[key].destroy();
        _textures = {};
    }

    this.makeDataTexturePowerOf2 = function(texture, itemSize) {
        let [maxDimension, minDimension] = [texture.width, texture.height].sort();
        maxDimension = Math.ceilPowerOf2(maxDimension);
        const newSize = {x: maxDimension, y: maxDimension};
        const totalLength = newSize.x * newSize.y * itemSize;

        const remainder = [];
        let j;
        for (let i = 0; i < totalLength - texture.data.length; i++) {
            j = i % texture.data.length;
            remainder.push(texture.data[j]);
        }

        const totalData = new Float32Array(totalLength);
        totalData.set(texture.data);
        totalData.set(remainder, texture.data.length);
        texture.data = totalData;
        texture.width = texture.height = maxDimension;
        texture.powerOfTwoScale = minDimension / maxDimension;
    }

    /**
     * @name this.loadCurve
     * @memberof Utils3D
     *
     * @function
     * @param obj
    */
    this.loadCurve = function(obj) {
        if (typeof obj === 'string') {
            obj = Assets.JSON[obj];
            obj.curves = obj.curves[0];
        }

        let data = obj.curves;
        let points = [];
        for (let j = 0; j < data.length; j += 3) {
            points.push(new Vector3(
                data[j + 0],
                data[j + 1],
                data[j + 2]
            ));
        }

        if (typeof CatmullRomCurve === 'undefined') throw 'loadCurve requires curve3d module';
        return new CatmullRomCurve(points);
    }

    /**
     * @name this.getEmptyTexture
     * @memberof Utils3D
     *
     * @function
    */
    this.getEmptyTexture = function() {
        if (!_emptyTexture) _emptyTexture = new Texture();
        return _emptyTexture;
    }

    /**
     * @name this.getRepeatTexture
     * @memberof Utils3D
     *
     * @function
     * @param src
     * @param scale
    */
    this.getRepeatTexture = function(src, scale) {
        let texture = _this.getTexture(src, scale);
        texture.promise.then(_ => {
            if (!Math.isPowerOf2(texture.dimensions.width, texture.dimensions.height)) console.warn(`getRepeatTexture :: ${src} not power of two!`);
        });
        texture.wrapS = texture.wrapT = Texture.REPEAT;
        return texture;
    }

    /**
     * @name this.findTexturesByPath
     * @memberof Utils3D
     *
     * @function
     * @param path
    */
    this.findTexturesByPath = function(path) {
        let array = [];
        for (let key in _textures) {
            if (key.includes(path)) array.push(_textures[key]);
        }
        return array;
    }

    /**
     * @name this.getHeightFromCamera
     * @memberof Utils3D
     *
     * @function
     * @param camera
     * @param dist
    */
    this.getHeightFromCamera = function(camera, dist) {
        camera = camera.camera || camera;
        if (!dist) dist = camera.position.length();
        let fov = camera.fov;
        return 2.00 * dist * Math.tan(Math.radians(fov) * 0.5);
    }

    /**
     * @name this.getWidthFromCamera
     * @memberof Utils3D
     *
     * @function
     * @param camera
     * @param dist
    */
    this.getWidthFromCamera = function(camera, dist) {
        camera = camera.camera || camera;
        const height = _this.getHeightFromCamera(camera, dist);
        return height * camera.aspect;
    }

    /**
     * @name this.getPositionFromCameraSize
     * @memberof Utils3D
     *
     * @function
     * @param camera
     * @param size
    */
    this.getPositionFromCameraSize = function(camera, size) {
        camera = camera.camera || camera;
        let fov = Math.radians(camera.fov);
        return Math.abs(size / Math.sin(fov/2));
    }

    /**
     * @name this.loadEngineOnThread
     * @memberof Utils3D
     *
     * @function
     * @param thread
    */
    this.loadEngineOnThread = function(thread) {
        [
            'Base3D', 'CameraBase3D', 'Mesh', 'OrthographicCamera', 'PerspectiveCamera', 'Geometry', 'GeometryAttribute', 'Points', 'Scene',
            'BoxGeometry', 'CylinderGeometry', 'PlaneGeometry', 'PolyhedronGeometry', 'IcosahedronGeometry', 'SphereGeometry',
            'Box2', 'Box3', 'Face3', 'Color', 'Cylindrical', 'Euler', 'Frustum', 'Line3', 'Matrix3', 'Matrix4', 'Plane', 'Quaternion',
            'Ray', 'Sphere', 'Spherical', 'Triangle', 'Vector2', 'Vector3', 'Vector4', 'RayManager', 'Vector3D', 'Group'
        ].forEach(name => {
            thread.importES6Class(name);
        });

        thread.importCode(`Class(${zUtils3D.constructor.toString()}, 'static')`);
    }

    /**
     * @name this.billboard
     * @memberof Utils3D
     *
     * @function
     * @param mesh
     * @param camera
    */
    this.billboard = function(mesh, camera = World.CAMERA) {
        if (!_q) _q = new Quaternion();
        if (mesh._parent) {
            mesh._parent.getWorldQuaternion(_q).inverse();
            _q.multiply(camera.quaternion);
            mesh.quaternion.copy(_q);

            // Apply rotation from UIL
            if (mesh.customRotation) {
                mesh.quaternion.multiply(mesh.customRotation);
            }
        } else {
            mesh.quaternion.copy(World.CAMERA.quaternion);
        }
    }

    /**
     * @name this.positionInFrontOfCamera
     * @memberof Utils3D
     *
     * @param object
     * @param distance
     * @param alpha
     * @param camera
     */
    this.positionInFrontOfCamera = function(object, distance, alpha = 1, camera = World.CAMERA) {
        if (!_v3) _v3 = new Vector3();
        if (!_v3b) _v3b = new Vector3();
        if (!_m4) _m4 = new Matrix4();
        if (!_q) _q = new Quaternion();

        let cameraPosition = _v3b;
        let cameraQuaternion = _q;
        camera.updateMatrixWorld();
        camera.matrixWorld.decompose(cameraPosition, cameraQuaternion, _v3);
        _v3.set(0, 0, -distance)
            .applyQuaternion(cameraQuaternion)
            .add(cameraPosition);
        _m4.lookAt(cameraPosition, _v3, object.up);
        _q.setFromRotationMatrix(_m4);
        object.position.lerp(_v3, alpha);
        object.quaternion.slerp(_q, alpha);
    }

    /**
     * @name this.getSignedQuaternionAngleToPlane
     * @memberof Utils3D
     *
     * Calculates the angle between a direction vector, after rotation by a
     * quaternion, and a plane. If an optional axis is supplied, the angle is
     * given as a rotation around that axis; otherwise the shortest angle is
     * calculated.
     * Can be used to deconstruct a quaternion to its effective rotation about
     * a single axis.
     *
     * @param {Quaternion} quaternion
     * @param {Vector3} direction
     * @param {Vector3} planeNormal
     * @param {Vector3} axis
     */
    this.getSignedQuaternionAngleToPlane = function (quaternion, direction, planeNormal, axis) {
        if (!_v3c) _v3c = new Vector3();
        let vector = _v3c.copy(direction).applyQuaternion(quaternion);
        return _this.getSignedAngleToPlane(vector, planeNormal, axis);
    }

    /**
     * @name this.getSignedAngleToPlane
     * @memberof Utils3D
     *
     * Calculates the angle between a vector and plane. If an optional axis is
     * supplied, the angle is given as a rotation around that axis; otherwise
     * the shortest angle is calculated.
     *
     * @param {Vector3} vector
     * @param {Vector3} planeNormal
     * @param {Vector3} axis
     */
    this.getSignedAngleToPlane = function (vector, planeNormal, axis) {
        if (!_v3) _v3 = new Vector3();
        if (!_v3b) _v3b = new Vector3();
        let projected = _v3.copy(vector).projectOnPlane(planeNormal).normalize();
        if (projected.length() === 0) {
            return Math.PI / 2;
        }
        if (!axis) {
            axis = _v3b.crossVectors(projected, planeNormal);
        } else {
            vector = _v3b.copy(vector).projectOnPlane(axis).normalize();
        }
        let dot = vector.dot(projected);
        let det = axis.dot(projected.cross(vector));
        return Math.atan2(det, dot);
    }

    /**
     * @name this.getQuad
     * @memberof Utils3D
     *
     * @function
    */
    this.getQuad = function() {
        let geom = new Geometry();
        let position = new Float32Array([-1, -1, 0, 3, -1, 0, -1, 3, 0]);
        let uv = new Float32Array([0, 0, 2, 0, 0, 2]);
        geom.addAttribute('position', new GeometryAttribute(position, 3));
        geom.addAttribute('uv', new GeometryAttribute(uv, 2));

        return geom;
    }

    /**
     * @name this.findParentCamera
     * @memberof Utils3D
     *
     * @function
     * @param group
    */
    this.findParentCamera = function(group) {
        let parent = group.parent;
        while (parent) {
            if (parent.nuke) return parent.nuke.camera;
            parent = parent.parent;
        }
        return World.CAMERA;
    }

    this.cameraIntrinsicsToObject = function(camera, object) {
        object.fov = camera.fov;
        object.aspect = camera.aspect;
        object.near = camera.near;
        object.far = camera.far;
        if (!object.p) {
            object.p = [];
            object.q = [];
            object.projectionMatrix = [];
        }
        camera.getWorldPosition().toArray(object.p);
        camera.getWorldQuaternion().toArray(object.q);
        camera.projectionMatrix.toArray(object.projectionMatrix);
        object.width = Stage.width;
        object.height = Stage.height;
    }

    this.createFXLayer = function(name, nuke = World.NUKE, options) {
        let layer = new FXLayer(nuke, options);
        layer.name = name;
        return layer;
    }

    this.ensureAttributes = function(mesh) {
        const vs = Shaders.getShader(mesh.shader.vsName + '.vs');
        const attrib_regex = /attribute (\w+) (\w+);/g;
        const attribs = mesh.geometry.attributes;
        const first = Object.keys(attribs)[0];
        const firstCount = attribs[first].count;

        let attrib;
        while ((attrib = attrib_regex.exec(vs)) !== null) {
            const name = attrib[2];
            if (name && !attribs[name]) {
                const size = parseInt(attrib[1][attrib[1].length - 1]) || 1;
                mesh.geometry.addAttribute(name, new GeometryAttribute(new Float32Array(size * firstCount), size));
                mesh.geometry.needsUpdate = true;
            }
        }
    }

    this.findDominantColors = async function(path) {

        let colors = [new Color(), new Color(), new Color(), new Color()];
        let ready = Promise.create();

        fetch(Assets.getPath(path), {mode: 'cors'}).then(

            async data => {

                let blob = await data.blob();
                let bitmap = await createImageBitmap(blob);
                let canvas = document.createElement('canvas');
                canvas.context = canvas.getContext('2d');
                canvas.width = Math.round(bitmap.width);
                canvas.height = Math.round(bitmap.height);
                ww = canvas.width;
                hh = canvas.height;
                canvas.context.drawImage(bitmap, 0, 0, canvas.width, canvas.height);

                let imageData = canvas.context.getImageData(0, 0, canvas.width, canvas.height);
                imageData = imageData.data;

                let result = await ImageDecoder.parseColors(imageData);

                colors = result.colors.map(e => new Color(e.r, e.g, e.b));

                ready.resolve();


            }

        ).catch(er => {

            ready.resolve();

        })

        await ready;
        return colors;
    }

}, 'static');

function NoGLPolyfill() {
    let noop = _ => {};
    this.activeTexture = this.attachShader = this.bindAttribLocation = this.bindBuffer = this.bindFramebuffer = this.bindRenderbuffer = this.bindTexture = this.blendColor = this.blendEquation = this.blendEquationSeparate = this.blendFunc = this.blendFuncSeparate = this.bufferData = this.bufferSubData = this.checkFramebufferStatus = this.clear = this.clearColor = this.clearDepthf = this.clearStencil = this.colorMask = this.compileShader = this.compressedTexImage2D = this.compressedTexSubImage2D = this.copyTexImage2D = this.copyTexSubImage2D = this.createProgram = this.createShader = this.cullFace = this.deleteBuffers = this.deleteFramebuffers = this.deleteProgram = this.deleteRenderbuffers = this.deleteShader = this.deleteTextures = this.depthFunc = this.depthMask = this.depthRangef = this.detachShader = this.disable = this.disableVertexAttribArray = this.drawArrays = this.drawElements = this.enable = this.enableVertexAttribArray = this.finish = this.flush = this.framebufferRenderbuffer = this.framebufferTexture2D = this.frontFace = this.generateMipmap = this.getActiveAttrib = this.getActiveUniform = this.getAttachedShaders = this.getAttribLocation = this.getBooleanv = this.getBufferParameteriv = this.getError = this.getFloatv = this.getFramebufferAttachmentParameteriv = this.getIntegerv = this.getProgramiv = this.getProgramInfoLog = this.getRenderbufferParameteriv = this.getShaderiv = this.getShaderInfoLog = this.getShaderPrecisionFormat = this.getShaderSource = this.getString = this.getTexParameterfv = this.getTexParameteriv = this.getUniformfv = this.getUniformiv = this.getUniformLocation = this.getVertexAttribfv = this.getVertexAttribiv = this.getVertexAttribPointerv = this.isBuffer = this.isEnabled = this.isFramebuffer = this.isProgram = this.isRenderbuffer = this.isShader = this.isTexture = this.lineWidth = this.linkProgram = this.pixelStorei = this.polygonOffset = this.readPixels = this.releaseShaderCompiler = this.renderbufferStorage = this.sampleCoverage = this.scissor = this.shaderBinary = this.shaderSource = this.stencilFunc = this.stencilFuncSeparate = this.stencilMask = this.stencilMaskSeparate = this.stencilOp = this.stencilOpSeparate = this.texParameterf = this.texParameterfv = this.texParameteri = this.texParameteriv = this.texSubImage2D = this.uniform1f = this.uniform1fv = this.uniform1i = this.uniform1iv = this.uniform2f = this.uniform2fv = this.uniform2i = this.uniform2iv = this.uniform3f = this.uniform3fv = this.uniform3i = this.uniform3iv = this.uniform4f = this.uniform4fv = this.uniform4i = this.uniform4iv = this.uniformMatrix2fv = this.uniformMatrix3fv = this.uniformMatrix4fv = this.useProgram = this.validateProgram = this.vertexAttrib1f = this.vertexAttrib1fv = this.vertexAttrib2f = this.vertexAttrib2fv = this.vertexAttrib3f = this.vertexAttrib3fv = this.vertexAttrib4f = this.vertexAttrib4fv = this.vertexAttribPointer = this.viewport = this.getParameter = this.getExtension = this.drawElementsInstanced = this.drawArraysInstanced = this.vertexAttribDivisor = this.getUniformBlockIndex = this.uniformBlockBinding = this.bindBufferBase = this.createVertexArray = this.bindVertexArray = this.deleteVertexArray = this.drawBuffers = this.blitFramebuffer = this.texImage2D = this.getContextAttributes = this.isContextLost = this.clearDepth = this.depthRange = this.createTexture = this.createBuffer = this.createFramebuffer = this.createRenderbuffer = this.deleteTexture = this.deleteBuffer = this.deleteFramebuffer = this.getBufferParameter = this.getRenderbufferParameter = this.getProgramParameter = this.getVertexAttribOffset = this.getFramebufferAttachmentParemeter = this.getUniform = this.getTexParameter = this.getShaderParameter = this.getSupportedExtensions = this.activeTexture = this.attachShader = noop;
    this.getShaderParameter = this.getProgramParameter = function() {
        return true;
    }
}
if (window.WebGLRenderingContext) !function(){"use strict";var e={};function r(r,t){var i;e[r]=!0,void 0!==t&&(i=t,window.console&&window.console.error&&window.console.error(i))}var t=function e(r){var t=r.gl;this.ext=r,this.isAlive=!0,this.hasBeenBound=!1,this.elementArrayBuffer=null,this.attribs=new Array(r.maxVertexAttribs);for(var i=0;i<this.attribs.length;i++){var a=new e.VertexAttrib(t);this.attribs[i]=a}this.maxAttrib=0};(t.VertexAttrib=function(e){this.enabled=!1,this.buffer=null,this.size=4,this.type=e.FLOAT,this.normalized=!1,this.stride=16,this.offset=0,this.cached="",this.recache()}).prototype.recache=function(){this.cached=[this.size,this.type,this.normalized,this.stride,this.offset].join(":")};var i=function(r){var t,i,a=this;this.gl=r,i=(t=r).getError,t.getError=function(){do{(r=i.apply(t))!=t.NO_ERROR&&(e[r]=!0)}while(r!=t.NO_ERROR);for(var r in e)if(e[r])return delete e[r],parseInt(r);return t.NO_ERROR};var n=this.original={getParameter:r.getParameter,enableVertexAttribArray:r.enableVertexAttribArray,disableVertexAttribArray:r.disableVertexAttribArray,bindBuffer:r.bindBuffer,getVertexAttrib:r.getVertexAttrib,vertexAttribPointer:r.vertexAttribPointer};r.getParameter=function(e){return e==a.VERTEX_ARRAY_BINDING_OES?a.currentVertexArrayObject==a.defaultVertexArrayObject?null:a.currentVertexArrayObject:n.getParameter.apply(this,arguments)},r.enableVertexAttribArray=function(e){var r=a.currentVertexArrayObject;return r.maxAttrib=Math.max(r.maxAttrib,e),r.attribs[e].enabled=!0,n.enableVertexAttribArray.apply(this,arguments)},r.disableVertexAttribArray=function(e){var r=a.currentVertexArrayObject;return r.maxAttrib=Math.max(r.maxAttrib,e),r.attribs[e].enabled=!1,n.disableVertexAttribArray.apply(this,arguments)},r.bindBuffer=function(e,t){switch(e){case r.ARRAY_BUFFER:a.currentArrayBuffer=t;break;case r.ELEMENT_ARRAY_BUFFER:a.currentVertexArrayObject.elementArrayBuffer=t}return n.bindBuffer.apply(this,arguments)},r.getVertexAttrib=function(e,t){var i=a.currentVertexArrayObject.attribs[e];switch(t){case r.VERTEX_ATTRIB_ARRAY_BUFFER_BINDING:return i.buffer;case r.VERTEX_ATTRIB_ARRAY_ENABLED:return i.enabled;case r.VERTEX_ATTRIB_ARRAY_SIZE:return i.size;case r.VERTEX_ATTRIB_ARRAY_STRIDE:return i.stride;case r.VERTEX_ATTRIB_ARRAY_TYPE:return i.type;case r.VERTEX_ATTRIB_ARRAY_NORMALIZED:return i.normalized;default:return n.getVertexAttrib.apply(this,arguments)}},r.vertexAttribPointer=function(e,r,t,i,s,A){var o=a.currentVertexArrayObject;o.maxAttrib=Math.max(o.maxAttrib,e);var c=o.attribs[e];return c.buffer=a.currentArrayBuffer,c.size=r,c.type=t,c.normalized=i,c.stride=s,c.offset=A,c.recache(),n.vertexAttribPointer.apply(this,arguments)},r.instrumentExtension&&r.instrumentExtension(this,"OES_vertex_array_object"),r.canvas.addEventListener("webglcontextrestored",function(){var e;e="OESVertexArrayObject emulation library context restored",window.console&&window.console.log&&window.console.log(e),a.reset_()},!0),this.reset_()};i.prototype.VERTEX_ARRAY_BINDING_OES=34229,i.prototype.reset_=function(){if(void 0!==this.vertexArrayObjects)for(var e=0;e<this.vertexArrayObjects.length;++e)this.vertexArrayObjects.isAlive=!1;var r=this.gl;this.maxVertexAttribs=r.getParameter(r.MAX_VERTEX_ATTRIBS),this.defaultVertexArrayObject=new t(this),this.currentVertexArrayObject=null,this.currentArrayBuffer=null,this.vertexArrayObjects=[this.defaultVertexArrayObject],this.bindVertexArrayOES(null)},i.prototype.createVertexArrayOES=function(){var e=new t(this);return this.vertexArrayObjects.push(e),e},i.prototype.deleteVertexArrayOES=function(e){e.isAlive=!1,this.vertexArrayObjects.splice(this.vertexArrayObjects.indexOf(e),1),this.currentVertexArrayObject==e&&this.bindVertexArrayOES(null)},i.prototype.isVertexArrayOES=function(e){return!!(e&&e instanceof t&&e.hasBeenBound&&e.ext==this)},i.prototype.bindVertexArrayOES=function(e){var t=this.gl;if(!e||e.isAlive){var i=this.original,a=this.currentVertexArrayObject;this.currentVertexArrayObject=e||this.defaultVertexArrayObject,this.currentVertexArrayObject.hasBeenBound=!0;var n=this.currentVertexArrayObject;if(a!=n){a&&n.elementArrayBuffer==a.elementArrayBuffer||i.bindBuffer.call(t,t.ELEMENT_ARRAY_BUFFER,n.elementArrayBuffer);for(var s=this.currentArrayBuffer,A=Math.max(a?a.maxAttrib:0,n.maxAttrib),o=0;o<=A;o++){var c=n.attribs[o],b=a?a.attribs[o]:null;if(a&&c.enabled==b.enabled||(c.enabled?i.enableVertexAttribArray.call(t,o):i.disableVertexAttribArray.call(t,o)),c.enabled){var u=!1;a&&c.buffer==b.buffer||(s!=c.buffer&&(i.bindBuffer.call(t,t.ARRAY_BUFFER,c.buffer),s=c.buffer),u=!0),(u||c.cached!=b.cached)&&i.vertexAttribPointer.call(t,o,c.size,c.type,c.normalized,c.stride,c.offset)}}this.currentArrayBuffer!=s&&i.bindBuffer.call(t,t.ARRAY_BUFFER,this.currentArrayBuffer)}}else r(t.INVALID_OPERATION,"bindVertexArrayOES: attempt to bind deleted arrayObject")},function(){var e=WebGLRenderingContext.prototype.getSupportedExtensions;WebGLRenderingContext.prototype.getSupportedExtensions=function(){var r=e.call(this)||[];return r.indexOf("OES_vertex_array_object")<0&&r.push("OES_vertex_array_object"),r};var r=WebGLRenderingContext.prototype.getExtension;WebGLRenderingContext.prototype.getExtension=function(e){var t=r.call(this,e);return t||("OES_vertex_array_object"!==e?null:(this.__OESVertexArrayObject||(console.log("Setup OES_vertex_array_object polyfill"),this.__OESVertexArrayObject=new i(this)),this.__OESVertexArrayObject))}}()}();

Class(function DracoThread() {
    const _this = this;

    // Code in this class is used to create the draco loading function
    // in GeomThread that gets uploaded to the thread pool.

    let decoderConfig;
	let decoderPending;

    this.loadDraco = function(e, id) {
        const message = e;

        switch (message.type) {
			case 'init':
                decoderConfig = message.decoderConfig;
                decoderPending = new Promise(function (pendingResolve/*, reject*/) {
                    decoderConfig.onModuleLoaded = function (draco) {
                        pendingResolve({ draco: draco }); // lib loaded internally
                        resolve({}, id); // notify hydra
                    };
                    DracoDecoderModule(decoderConfig);
                });
                break;

            case 'decode':
                fetch(message.path).then(res => {
                    if (!res.ok) throw new Error();
                    return res.arrayBuffer();
                }).then((dracoBuffer) => {
                    // get json data size (first 10 bytes), json and draco data
                    const decoder = new TextDecoder();
                    const jsonSize = parseInt(decoder.decode(dracoBuffer.slice(0, 10)));
                    const jsonData = JSON.parse(decoder.decode(dracoBuffer.slice(10, 10 + jsonSize)));
                    const buffer = dracoBuffer.slice(10 + jsonSize);

                    const TYPED_ARRAYS = Object.keys(Geometry.TYPED_ARRAYS);
                    const attributeIDs = {};
                    const attributeTypes = {};
                    jsonData.attributes.forEach((att, i) => {
                        const name = att[0];
                        attributeIDs[name] = i;
                        attributeTypes[name] = TYPED_ARRAYS[att[1]];
                    });

                    const taskConfig = { attributeIDs, attributeTypes, useUniqueIDs: true };
                    const isMesh = jsonData.type === 0;

                    decoderPending.then((module) => {
                        const draco = module.draco;
                        const decoder = new draco.Decoder();
                        const decoderBuffer = new draco.DecoderBuffer();
                        decoderBuffer.Init(new Int8Array(buffer), buffer.byteLength);

                        try {
                            const geometry = decodeGeometry(draco, decoder, decoderBuffer, taskConfig);
                            const buffers = geometry.attributes.map((attr) => attr.array.buffer);
                            if (isMesh && geometry.index) buffers.push(geometry.index.array.buffer);

                            // transform response to hydra's format
                            const response = { _type: 'BufferGeometry', userData: jsonData.userData || {} };
                            response.userData.dracoType = jsonData.type; // mesh or pointcloud info

                            if (isMesh && geometry.index) response.index = geometry.index.array;
                            geometry.attributes.forEach((att) => {
                                response[att.name] = att.array;
                                response[`${att.name}ItemSize`] = att.itemSize;
                            });
                            if (isMesh && response.position) computeBounding(response); // this function lives on the thread

                            resolve(response, id, buffers);
                        } catch (error) {
                            onError({ message, er: `Parsing error on Draco file ${message.path}.`, resolve, id });
                        } finally {
                            draco.destroy(decoderBuffer);
                            draco.destroy(decoder);
                        }
                    });
                }).catch(() => {
                    onError({ message, er: `Network error: Draco file (${message.path}) could not be loaded.`, resolve, id });
                });
                break;
        }
    };

    function onError(opts) {
        if (opts.message.preloading) console.warn(opts.er);
        let plane = new PlaneGeometry(1, 1).toNonIndexed();
        let buff = [];
        let data = {};
        for (let key in plane.attributes) {
            data[key] = plane.attributes[key].array;
            buff.push(data[key].buffer);
        }
        computeBounding(data);
        opts?.resolve(data, opts.id, buff);
    }

    function decodeGeometry(draco, decoder, decoderBuffer, taskConfig) {
        const attributeIDs = taskConfig.attributeIDs;
		const attributeTypes = taskConfig.attributeTypes;

		let dracoGeometry;
		let decodingStatus;

		const geometryType = decoder.GetEncodedGeometryType(decoderBuffer);

		if (geometryType === draco.TRIANGULAR_MESH) {
			dracoGeometry = new draco.Mesh();
			decodingStatus = decoder.DecodeBufferToMesh(decoderBuffer, dracoGeometry);
		} else if (geometryType === draco.POINT_CLOUD) {
			dracoGeometry = new draco.PointCloud();
			decodingStatus = decoder.DecodeBufferToPointCloud(decoderBuffer, dracoGeometry);
		} else {
			throw new Error('DRACOLoader: Unexpected geometry type.');
		}
		if (!decodingStatus.ok() || dracoGeometry.ptr === 0) {
			throw new Error('DRACOLoader: Decoding failed: ' + decodingStatus.error_msg());
		}

		const geometry = { index: null, attributes: [] };

		for (const attributeName in attributeIDs) {
			const attributeType = self[ attributeTypes[ attributeName ] ];

			let attribute;
			let attributeID;

			if (taskConfig.useUniqueIDs) {
				attributeID = attributeIDs[ attributeName ];
				attribute = decoder.GetAttributeByUniqueId(dracoGeometry, attributeID);
			} else {
				attributeID = decoder.GetAttributeId(dracoGeometry, draco[ attributeIDs[ attributeName ] ]);
				if (attributeID === - 1) continue;
				attribute = decoder.GetAttribute(dracoGeometry, attributeID);
			}
			geometry.attributes.push(decodeAttribute(draco, decoder, dracoGeometry, attributeName, attributeType, attribute));
		}

		if (geometryType === draco.TRIANGULAR_MESH) {
			geometry.index = decodeIndex(draco, decoder, dracoGeometry);
		}

		draco.destroy(dracoGeometry);
		return geometry;
    }

    function decodeIndex(draco, decoder, dracoGeometry) {
		const numFaces = dracoGeometry.num_faces();
		const numIndices = numFaces * 3;
		const byteLength = numIndices * 4;

		const ptr = draco._malloc(byteLength);
		decoder.GetTrianglesUInt32Array(dracoGeometry, byteLength, ptr);
		const index = new Uint32Array(draco.HEAPF32.buffer, ptr, numIndices).slice();
		draco._free(ptr);

		return { array: index, itemSize: 1 };
	}

    function decodeAttribute(draco, decoder, dracoGeometry, attributeName, attributeType, attribute) {
		const numComponents = attribute.num_components();
		const numPoints = dracoGeometry.num_points();
		const numValues = numPoints * numComponents;
		const byteLength = numValues * attributeType.BYTES_PER_ELEMENT;
		const dataType = getDracoDataType(draco, attributeType);

		const ptr = draco._malloc(byteLength);
		decoder.GetAttributeDataArrayForAllPoints(dracoGeometry, attribute, dataType, byteLength, ptr);
		const array = new attributeType(draco.HEAPF32.buffer, ptr, numValues).slice();
		draco._free(ptr);

		return {
			name: attributeName,
			array: array,
			itemSize: numComponents
		};
	}

    function getDracoDataType(draco, attributeType) {
		switch (attributeType) {
			case Float32Array: return draco.DT_FLOAT32;
			case Int8Array: return draco.DT_INT8;
			case Int16Array: return draco.DT_INT16;
			case Int32Array: return draco.DT_INT32;
			case Uint8Array: return draco.DT_UINT8;
			case Uint16Array: return draco.DT_UINT16;
			case Uint32Array: return draco.DT_UINT32;
		}
	}

    _this.decodeGeometry = decodeGeometry;
    _this.decodeIndex = decodeIndex;
    _this.decodeAttribute = decodeAttribute;
    _this.getDracoDataType = getDracoDataType;
    _this.onError = onError;

}, 'static');
Class( function GLTFLoader() {

    Inherit(this, Component);

    const _this = this;

    const TYPE_ARRAY = {
        5121: Uint8Array,
        5122: Int16Array,
        5123: Uint16Array,
        5125: Uint32Array,
        5126: Float32Array,
        'image/jpeg': Uint8Array,
        'image/png': Uint8Array,
    };
    
    const TYPE_SIZE = {
        SCALAR: 1,
        VEC2: 2,
        VEC3: 3,
        VEC4: 4,
        MAT2: 4,
        MAT3: 9,
        MAT4: 16,
    };
    
    const ATTRIBUTES = {
        POSITION: 'position',
        NORMAL: 'normal',
        TANGENT: 'tangent',
        TEXCOORD_0: 'uv',
        TEXCOORD_1: 'uv2',
        COLOR_0: 'color',
        WEIGHTS_0: 'skinWeight',
        JOINTS_0: 'skinIndex',
    };
    
    const TRANSFORMS = {
        translation: 'position',
        rotation: 'quaternion',
        scale: 'scale',
    };

    let m1 = new Matrix4();

    let _sceneLayout, _path, _id;

    _this.textures = null;

    _this.parse = async function(path, sceneLayout) {



        let name = path.split("/");
        name = name[name.length - 1];
        console.log(name);
        name = name.split(".")[0];

        _id = name;
        _path = path;

        if(sceneLayout) {
            _sceneLayout = _this.initClass(SceneLayout, name);
        }

        let nodes = null;
        let json, binary;

        //For .glb files
        if(String(path).indexOf(".glb") > 0 ) {

            let data = await _this.loadBinary(_path);
            json = data.json;
            binary = data.binary;

        }

        //For .gltf + binary files.
        if(String(path).indexOf(".gltf") > 0) {

            json = await fetch(path).then((res) => res.json());
            
            console.log(json);

            binary = await Promise.all(
                json.buffers.map(buffer => {
                    const uri = this.resolveURI(buffer.uri);
                    return fetch(uri).then((res) => res.arrayBuffer());
                })
            );

            binary = binary[0];

        }

        const desc = json; 
        const buffers = binary;

        const bufferViews = _this.parseBufferViews(desc, buffers);

        const images = await _this.parseImages(desc, bufferViews);

        const textures = await _this.parseTextures(desc, images);

        await Promise.all(textures).then((values) => {
            _this.textures = values;
        });

        const materials = await _this.parseMaterials(desc, textures);

        meshes = await _this.parseMeshes(desc, bufferViews, materials);

        nodes = await _this.parseNodes(desc, meshes);

        return nodes;
    }

    this.loadBinary = async function(path) {

        let json, binary;
        let result = Promise.create();

        fetch(path).then(res => {

            if (!res.ok) throw new Error();
            return res.arrayBuffer();

        }).then(async (gltfBuffer) => {

            const BINARY_EXTENSION_HEADER_MAGIC = 'glTF';
            const BINARY_EXTENSION_HEADER_LENGTH = 12;
            const BINARY_EXTENSION_CHUNK_TYPES = {
                JSON: 0x4E4F534A,
                BIN: 0x004E4942
            };

            const headerView = new DataView( gltfBuffer, 0, BINARY_EXTENSION_HEADER_LENGTH );
            const decoder = new TextDecoder();

            let header = {
                magic: decoder.decode(gltfBuffer.slice(0, 4)),
                version: headerView.getUint32( 4, true ),
                length: headerView.getUint32( 8, true )
            };

            if ( header.magic !== BINARY_EXTENSION_HEADER_MAGIC ) {

                throw new Error( 'GLTFLoader: Unsupported glTF-Binary header.' );

            } else if (header.version < 2.0 ) {

                throw new Error( 'GLTFLoader: Legacy binary file detected.' );

            }

            const chunkContentsLength = header.length - BINARY_EXTENSION_HEADER_LENGTH;
            const chunkView = new DataView( gltfBuffer, BINARY_EXTENSION_HEADER_LENGTH );
            let chunkIndex = 0;

            let _content = null;

            while ( chunkIndex < chunkContentsLength ) {

                const chunkLength = chunkView.getUint32( chunkIndex, true );
                chunkIndex += 4;
                const chunkType = chunkView.getUint32( chunkIndex, true );
                chunkIndex += 4;

                if ( chunkType === BINARY_EXTENSION_CHUNK_TYPES.JSON ) {

                    const contentArray = new Uint8Array( gltfBuffer, BINARY_EXTENSION_HEADER_LENGTH + chunkIndex, chunkLength );
                    _content = decoder.decode( contentArray );

                } else if ( chunkType === BINARY_EXTENSION_CHUNK_TYPES.BIN ) {

                    const byteOffset = BINARY_EXTENSION_HEADER_LENGTH + chunkIndex;
                    binary = gltfBuffer.slice( byteOffset, byteOffset + chunkLength );

                }

                chunkIndex += chunkLength;

            }

            if ( _content === null ) {

                throw new Error( 'GLTFLoader: JSON content not found.' );

            }

            json = JSON.parse( _content );

            console.log(json);

            if ( json.asset === undefined || json.asset.version[ 0 ] < 2 ) {

                if ( onError ) onError( new Error( 'GLTFLoader: Unsupported asset. glTF versions >=2.0 are supported.' ) );
                return;

            }

            result.resolve();
        });

        await result;
        return {json, binary}
    }

    this.parseBufferViews = function(desc, buffers) {

        if (!desc.bufferViews) return null;

        // Clone to leave description pure
        const bufferViews = desc.bufferViews.map((o) => Object.assign({}, o));

        // Get componentType of each bufferView from the accessors
        desc.accessors.forEach(({ bufferView: i, componentType }) => {
            bufferViews[i].componentType = componentType;
        });

        // Push each bufferView to the GPU as a separate buffer
        bufferViews.forEach(
            (
                {
                    byteOffset = 0, // optional
                    byteLength, // required
                    componentType,
                },
                i
            ) => {
                bufferViews[i].data = buffers.slice(byteOffset, byteOffset + byteLength);
            }
        );

        return bufferViews;
    }

    this.parseMeshes = function( desc, bufferViews, materials) {
        if (!desc.meshes) return null;

        
        return desc.meshes.map(
            (
                {
                    name,
                    primitives
                },
                index1
            ) => {

                let shader = Utils3D.getTestShader();
                shader.side = Shader.DOUBLE_SIDE;

                primitives = this.parsePrimitives(primitives, desc, bufferViews, materials).map(
                    async ({geometry, materialDefinition}, index2) => {

                        let setupShader = (el) => {
                            if(!materialDefinition) return;
                            let shader = el.shader;
                            
                            //diffuse color
                            if(materialDefinition.baseColorTexture) {
                                materialDefinition.baseColorTexture.texture.then( res => {
                                    if(shader.get("tMap")) shader.set("tMap", res);
                                    if(shader.get("tBaseColor")) shader.set("tBaseColor", res);
                                })
                            }

                            //normal texture
                            if(materialDefinition.normalTexture) {
                                materialDefinition.normalTexture.texture.then( res => {
                                    if(shader.get("tNormal")) shader.set("tNormal", res);
                                })
                            }

                            //MRO texture
                            if(materialDefinition.metallicRoughnessTexture) {
                                materialDefinition.metallicRoughnessTexture.texture.then( res => {
                                    if(shader.get("tMRO")) shader.set("tMRO", res);
                                })
                            }

                        }

                        if(_sceneLayout) {

                            let naming = `${_id}_mesh_${index1}_${index2}`;
                            if(name) naming = naming.concat(`_${name}`);
                            naming = naming.replace(/ /g,"_");

                            let exists = _sceneLayout.exists(naming);
                
                            let mesh = !(typeof exists === "undefined") ? await _sceneLayout.getLayer(naming) : null;
                
                            if(!!mesh) {
                                
                                mesh.geometry = geometry;
                            
                            } else {

                                let id = await _sceneLayout._createLayer(`${_id}_meshes`, true);
                                mesh = await _sceneLayout.getLayer(String(id)); 
                                mesh.geometry = geometry;
                                _sceneLayout._rename(id, String(id), naming);

                            }

                            setupShader(mesh);

                            return mesh;
                        }
                        
                        else {

                            let mesh = new Mesh(geometry, shader);
                            setupShader(mesh);
                            return mesh;

                        } 

                    }
                );

                return primitives;
            }
        );
    }

    this.parsePrimitives = function(primitives, desc, bufferViews, materials) {
        return primitives.map(
            ({
                attributes, // required
                indices,
                material: materialIndex
            }) => {

                let materialDefinition = null;
                
                if (materialIndex !== undefined) {
                    materialDefinition = materials[materialIndex];
                }

                const geometry = new Geometry();

                // Add each attribute found in primitive
                for (let attr in attributes) {
                    let buffer = this.parseAccessor(attributes[attr], desc, bufferViews);
                    let data = new GeometryAttribute(buffer.data, buffer.size);

                    geometry.addAttribute(ATTRIBUTES[attr], data);
                }

                // Add index attribute if found
                if (indices !== undefined) {
                    let buffer = this.parseAccessor(indices, desc, bufferViews);
                    geometry.index = buffer.data;
                }

                return {geometry, materialDefinition};
            }
        );
    }

    this.parseAccessor = function(index, desc, bufferViews) {
        // TODO: init missing bufferView with 0s
        // TODO: support sparse

        const {
            bufferView: bufferViewIndex, // optional
            byteOffset = 0, // optional
            componentType, // required
            normalized = false, // optional
            count, // required
            type, // required
            min, // optional
            max, // optional

        } = desc.accessors[index];

        const {
            data, // attached in parseBufferViews
            buffer, // replaced to be the actual GL buffer
            // byteOffset: bufferByteOffset = 0,
            byteStride = 0,

        } = bufferViews[bufferViewIndex];

        const size = TYPE_SIZE[type];


        // Parse data from joined buffers
        const TypeArray = TYPE_ARRAY[componentType];
        const newData =  new TypeArray(data, byteOffset, count * size);

        // Return attribute data
        return {
            data: newData,
            size,
            type: componentType,
            normalized,
            buffer,
            stride: byteStride,
            offset: byteOffset,
            count,
            min,
            max,
        };
    }

    this.parseNodes = async function(desc, meshes) {

        if (!desc.nodes) return null;
        let nodes = desc.nodes.map(
            async ({
                matrix, // optional
                mesh: meshIndex, // optional
                rotation, // optional
                scale, // optional
                translation, // optional
                name
            }, index) => {

                let node = new Group();

                if(_sceneLayout) {

                    let naming = `${_id}_hierarchy_${index}`;
                    if(name) naming = naming.concat(`_${name}`);
                    naming = naming.replace(/ /g,"_");

                    let exists = _sceneLayout.exists(naming);
        
                    node = exists ? await _sceneLayout.getLayer(naming) : null;
                        
                    if(!node) {

                        let ref = await _sceneLayout._createLayer(`${_id}_hierarchy`, true);
                        node = await _sceneLayout.getLayer(String(ref)); 
                        _sceneLayout._rename(ref, String(ref), naming);
                        
                    }

                    node.geometry = new PlaneGeometry(0, 0, 1, 1);
                    node._parent = null;
                }

                if (name) node.name = name;

                // Apply transformations
                if (matrix) {
                    
                    let m = new Matrix4().set(...matrix);
                    m = m.transpose();
                    node.matrix.copy(m);
                    node.matrix.decompose(node.position, node.quaternion, node.scale);

                } else {
  
                    if(rotation || scale || translation) {
                        if (rotation) node.quaternion.set(...rotation);
                        if (scale) node.scale.set(...scale);
                        if (translation) node.position.set(...translation);
                        node.updateMatrix();
                    }

                }

                // add mesh if included
                if (meshIndex !== undefined) {
         
                        meshes[meshIndex].forEach(async (mesh) => {

                            mesh.then(res => {
                                    node.add(res)
                                }
                            );
  
                        });
                    
                }

                return node;
            }
        );

        await Promise.all(nodes).then((values) => {
        nodes = values;
        });
        

        desc.nodes.forEach(({ children = [] }, i) => {

            // Set hierarchy now all nodes created
            children.forEach((childIndex) => {                
                nodes[i].add(nodes[childIndex]);
            });

        });

        let parentNodes = nodes.filter(node => {
            
            if(node._parent == null) return node;

        });
        
        return parentNodes;
    }

    this.parseTextures = function(desc, images) {
        if (!desc.textures) return null;
        return desc.textures.map((textureInfo) => _this.createTexture(desc, images, textureInfo));
    }

    this.createTexture = async function(desc, images, { sampler: samplerIndex, source: sourceIndex, name, extensions, extras }) {
        if (sourceIndex === undefined && !!extensions) {
            console.warn("extensions required to load texture");
            return;
        }

        const image = images[sourceIndex];
        if (image.texture) return image.texture;

        const sampler = samplerIndex !== undefined ? desc.samplers[samplerIndex] : null;
        let options = {};
        if (sampler) {
            ['magFilter', 'minFilter', 'wrapS', 'wrapT'].forEach((prop) => {
                if (sampler[prop]) options[prop] = sampler[prop];
            });
        }

        await image.ready;

        const texture = new Texture(image);
        texture.name = name;
        texture.flipY = false;
        texture.wrapS = texture.wrapT = Texture.REPEAT;
        image.texture = texture;

        return texture;

    }

    this.parseImages = async function(desc, bufferViews) {

        if (!desc.images) return null;

        return await Promise.all(
            desc.images.map(async ({ uri, bufferView: bufferViewIndex, mimeType, name }) => {
                if (mimeType === 'image/ktx2') {
                    console.warn("image type is ktx2, update the loader to support this type")
                    return null;
                }

                // jpg / png
                const image = new Image();
                image.name = name;
                if (uri) {
                    image.src = this.resolveURI(uri);
                } else if (bufferViewIndex !== undefined) {
                    const { data } = bufferViews[bufferViewIndex];
                    const blob = new Blob([data], { type: mimeType });
                    image.src = URL.createObjectURL(blob);
                }
                image.ready = new Promise((res) => {
                    image.onload = () => res();
                });
                return image;
            })
        );
    }

    this.resolveURI = function(uri) {

        let dir = _path.split("/");
        dir.pop();
        dir = dir.join("/");

        // Invalid URI
        if (typeof uri !== 'string' || uri === '') return '';

        // Host Relative URI
        if (/^https?:\/\//i.test(dir) && /^\//.test(uri)) {
            dir = dir.replace(/(^https?:\/\/[^\/]+).*/i, '$1');
        }

        // Absolute URI http://, https://, //
        if (/^(https?:)?\/\//i.test(uri)) return uri;

        // Data URI
        if (/^data:.*,.*$/i.test(uri)) return uri;

        // Blob URI
        if (/^blob:.*$/i.test(uri)) return uri;

        // Relative URI
        return dir + "/" + uri;
    }

    this.parseMaterials = function(desc, textures) {
        if (!desc.materials) return null;
        return desc.materials.map(
            ({
                name,
                extensions,
                extras,
                pbrMetallicRoughness = {},
                normalTexture,
                occlusionTexture,
                emissiveTexture,
                emissiveFactor = [0, 0, 0],
                alphaMode = 'OPAQUE',
                alphaCutoff = 0.5,
                doubleSided = false,
            }) => {
                const {
                    baseColorFactor = [1, 1, 1, 1],
                    baseColorTexture,
                    metallicFactor = 1,
                    roughnessFactor = 1,
                    metallicRoughnessTexture,
                } = pbrMetallicRoughness;

                if (baseColorTexture) {
                    baseColorTexture.texture = textures[baseColorTexture.index];
                }

                if (normalTexture) {
                    normalTexture.texture = textures[normalTexture.index];
                }

                if (metallicRoughnessTexture) {
                    metallicRoughnessTexture.texture = textures[metallicRoughnessTexture.index];
                }

                if (occlusionTexture) {
                    occlusionTexture.texture = textures[occlusionTexture.index];
                }

                if (emissiveTexture) {
                    emissiveTexture.texture = textures[emissiveTexture.index];
                }

                return {
                    name,
                    extensions,
                    extras,
                    baseColorFactor,
                    baseColorTexture,
                    metallicFactor,
                    roughnessFactor,
                    metallicRoughnessTexture,
                    normalTexture,
                    occlusionTexture,
                    emissiveTexture,
                    emissiveFactor,
                    alphaMode,
                    alphaCutoff,
                    doubleSided,
                };
            }
        );
    }
})
/**
 * @name GeomThread
 */
Class(function GeomThread() {
    Inherit(this, Component);
    const _this = this;

    var _cache = {};
    var _cacheWait = {};
    var _receive = {};
    var _dracoLoaded = null;

    this.caching = true;

    (async function() {
        await Hydra.ready();
        Thread.upload(loadGeometry, geom_useFn, computeBounding);
    })();

    function computeBounding(data) {
        let geom = new Geometry();
        geom.addAttribute('position', new GeometryAttribute(data.position, 3));
        if (data.index) geom.setIndex(data.index);
        geom.computeBoundingBox();
        geom.computeBoundingSphere();
        data.boundingBox = geom.boundingBox;
        data.boundingSphere = geom.boundingSphere;
    }

    function loadGeometry(e, id) {
        get(e.path).then(data => {
            let buffers = [];
            if (data.data && data.metadata?.type) {
                let bufferList = { _type: data.metadata.type };
                let jsonData = data.data;
                if (jsonData.index) {
                    bufferList.index = new Geometry.TYPED_ARRAYS[jsonData.index.type](jsonData.index.array);
                    buffers.push(bufferList.index.buffer);
                }
                for (let key in jsonData.attributes) {
                    let attrib = jsonData.attributes[key];
                    bufferList[key] = new Geometry.TYPED_ARRAYS[attrib.type](attrib.array);
                    bufferList[`${key}ItemSize`] = attrib.itemSize;
                    buffers.push(bufferList[key].buffer);
                }
                if (bufferList.position) computeBounding(bufferList);
		        if (data.userData) bufferList.userData = data.userData;
                resolve(bufferList, id, buffers);
            } else {
                for (let key in data) {
                    if (key == 'bones') continue;
                    if (Array.isArray(data[key])) {
                        const ArrayType = key == 'index' ? (Geometry.arrayNeedsUint32(data[key]) ? Uint32Array : Uint16Array) : Float32Array;
                        data[key] = new ArrayType(data[key]);
                        buffers.push(data[key].buffer);
                    } else if (data[key].length > 0) {
                        buffers.push(data[key].buffer);
                    }
                }
                computeBounding(data);
                if (e.custom) self[e.custom](data);
                resolve(data, id, buffers);
            }
        }).catch(er => {
            if (!e.preloading) console.error(er);

            let plane = new PlaneGeometry(1, 1).toNonIndexed();
            let buffers = [];
            let data = {};
            for (let key in plane.attributes) {
                data[key] = plane.attributes[key].array;
                buffers.push(data[key].buffer);
            }
            computeBounding(data);
            resolve(data, id, buffers);
        });
    }

    function geom_useFn(e) {
        if (!Global.FNS) Global.FNS = [];
        Global.FNS.push(e.name);
    }

    function loadDracoLib() {
        _dracoLoaded = Promise.create();

        // load draco lib
        const useJS = typeof WebAssembly !== 'object';
        const libFolder = '~assets/js/lib/_draco/';
        const libs = useJS ? [`${libFolder}draco_decoder.js`] : [`${libFolder}draco_wasm_wrapper.js`, `${libFolder}draco_decoder.wasm`];

        Promise.all(
            libs.map((url, i) =>
                fetch(Assets.getPath(url)).then(res => {
                    if (!res.ok) throw new Error();
                    return (i === 0 ? res.text() : res.arrayBuffer());
                })
            )
        ).then(async (loadedLibs) => {
            // build worker function from DracoThread
            Thread.upload([
                'function loadDraco() {',
                    '/* draco decoder */',
                    loadedLibs[0],
                    '',
                    '/* worker */',
                    '',
                    'let decoderConfig, decoderPending;',
                    '',
                    DracoThread.onError.toString(),
                    DracoThread.decodeGeometry.toString(),
                    DracoThread.decodeIndex.toString(),
                    DracoThread.decodeAttribute.toString(),
                    DracoThread.getDracoDataType.toString(),
                    '',
                    'return ' + DracoThread.loadDraco.toString(),
                '};',
            ].join('\n'));

            // initialize it
            const pool = Thread.shared(true).array;
            const decoderConfig = useJS ? {} : { wasmBinary: loadedLibs[1] };
            pool.forEach(t => t.importCode('self.loadDraco = loadDraco();'));
            await Promise.all(pool.map(t => t.loadDraco({ type: 'init', decoderConfig })));
            _dracoLoaded.resolve();

        }).catch(() => { console.warn('Draco libs could not be loaded. Fallback to .json'); _dracoLoaded.reject(); });
    }

    function parseGeometry(data, path, custom) {
        let geometry;
        if (custom && _receive[custom]) {
            geometry = _receive[custom](data);
        } else {
            let geom = new Geometry();

            if (data._type) {
                // typed json format
                for (key in data) {
                    if (key === '_type' || key.endsWith('ItemSize')) continue;
                    switch (key) {
                        case 'userData':
                            geom.userData = data.userData;
                            break;
                        case 'boundingBox':
                            geom.boundingBox = new Box3(new Vector3().set(data.boundingBox.min.x, data.boundingBox.min.y, data.boundingBox.min.z), new Vector3().set(data.boundingBox.max.x, data.boundingBox.max.y, data.boundingBox.max.z));
                            break;
                        case 'boundingSphere':
                            geom.boundingSphere = new Sphere(new Vector3().set(data.boundingSphere.center.x, data.boundingSphere.center.y, data.boundingSphere.center.z), data.boundingSphere.radius);
                            break;
                        case 'index':
                            geom.setIndex(data.index);
                            break;
                        default:
                            if (data[`${key}ItemSize`]) geom.addAttribute(key, new GeometryAttribute(data[key], data[`${key}ItemSize`]));
                            break;
                    }
                }
            } else {
                // normal format
                geom.addAttribute('position', new GeometryAttribute(data.position, 3));
                geom.addAttribute('normal', new GeometryAttribute(data.normal || data.position.length, 3));
                geom.addAttribute('uv', new GeometryAttribute(data.uv || data.position.length / 3 * 2, 2));
                if (data.uv2) geom.addAttribute('uv2', new GeometryAttribute(data.uv2, 2));
                if (data.vdata) geom.addAttribute('vdata', new GeometryAttribute(data.vdata, 3));
                if (data.index) geom.setIndex(data.index);
                if (data.skinIndex) geom.addAttribute('skinIndex', new GeometryAttribute(data.skinIndex, 4));
                if (data.skinWeight) geom.addAttribute('skinWeight', new GeometryAttribute(data.skinWeight, 4));
                if (data.rig || data.bones) geom.bones = (data.rig ? data.rig.bones : data.bones).slice(0);
                geom.boundingBox = new Box3(new Vector3().set(data.boundingBox.min.x, data.boundingBox.min.y, data.boundingBox.min.z), new Vector3().set(data.boundingBox.max.x, data.boundingBox.max.y, data.boundingBox.max.z));
                geom.boundingSphere = new Sphere(new Vector3().set(data.boundingSphere.center.x, data.boundingSphere.center.y, data.boundingSphere.center.z), data.boundingSphere.radius);
            }

            geometry = geom;
            geom._src = path;
        }

        if (!geometry.attributes.position) throw `GeomThread :: Malformed geometry is missing position data. ${path}`;

        if (_this.caching) _cache[path] = geometry;
        _cacheWait[path]?.resolve(geometry);
    }

    //*** Event handlers

    //*** Public methods

    /**
     * @name loadGeometry
     * @memberof GeomThread
     *
     * @function
     * @param {String} path
     * @param {String} custom
     * @returns {Promise} geometry
     */
    this.loadGeometry = function(path, custom, preloading) {
        if (!Device.graphics.gpu) return Promise.resolve(new PlaneGeometry(1, 1));

        if (_cache[path]) return Promise.resolve(_cache[path]);

        let cacheBust = false;
        if (path.includes('?')) {
            path = path.split('?')[0];
            cacheBust = '?' + Utils.timestamp();
        }
        let isBinary = path.endsWith('.bin');
        if (!path.includes('http')) {
            if (!Hydra.LOCAL) cacheBust = false;
            if (!path.includes('assets/geometry/')) path = 'assets/geometry/' + path;
            if (!path.includes('.')) path += '.json';
            if (cacheBust) path += cacheBust;
        }
        path = Thread.absolutePath(Assets.getPath(path));

        if (_this.caching) {
            if (!_cacheWait[path]) _cacheWait[path] = Promise.create();
            else return _cacheWait[path];
        }

        if (isBinary) {
            if (!_dracoLoaded) loadDracoLib();
            _dracoLoaded.then(() => {
                Thread.shared().loadDraco({type: 'decode', path, custom, preloading}).then(data => parseGeometry(data, path, custom));
            }).catch(() => {
                path = path.replace('.bin', '.json'); // fallback to json
                Thread.shared().loadGeometry({path, custom, preloading}).then(data => parseGeometry(data, path, custom));
            });
        } else {
            Thread.shared().loadGeometry({path, custom, preloading}).then(data => parseGeometry(data, path, custom));
        }

        return _cacheWait[path];
    }

    this.removeFromCache = function(path) {
        if (!path.includes('assets/geometry/')) path = 'assets/geometry/' + path;
        if (!path.includes('.')) path += '.json';
        path = Thread.absolutePath(Assets.getPath(path));
        delete _cache[path];
        delete _cacheWait[path];
    }

    this.loadDracoLib = function() {
        if (!_dracoLoaded) loadDracoLib();
        return _dracoLoaded;
    }

    /**
     * @name loadSkinnedGeometry
     * @memberof GeomThread
     *
     * @function
     * @param {String} path
     * @param {String} custom
     * @returns {Promise} geometry
     */
    this.loadSkinnedGeometry = function(path, custom, preloading) {
        return this.loadGeometry(path, custom, preloading);
    }

    /**
     * @name customFunction
     * @memberof GeomThread
     *
     * @function
     * @param {Function} function
     * @param {Function} receive
     */
    this.customFunction = function(fn, receive) {
        let name = Thread.upload(fn);
        name = name[0];
        t.geom_useFn({name});

        _receive[name] = receive;
    }
}, 'static');

/**
 * @name InstanceMesh
 */

Class(function InstanceMesh(_mesh, _shader, _group, _input) {
    Inherit(this, Component);
    const _this = this;
    var _config;
    var _frustumCulled = false;
    var _blankShader;
    var _instanceGroup;

    /**
     * @name instanceMultiplier
     * @memberof InstanceMesh
     * @property
     */
    this.instanceMultiplier = 1;

    //*** Constructor
    (function () {
        _config = InputUIL.create('im_' + _input.prefix, _group);
        _config.addFile('json', {relative: 'assets/geometry'});
        _config.add('test');
        _config.addToggle('dynamic', false);
        _config.setLabel('Instance');

        if (_input.get('visible') === false) return;

        _blankShader = Utils3D.getTestShader();
        _blankShader.visible = false;

        _instanceGroup = new Group();
        _instanceGroup.doNotProject = true;
        _mesh._parent.add(_instanceGroup);

        _mesh._parent.remove(_mesh);
        _mesh.visible = false;
        _mesh.instanceMeshReady = Promise.create();
        _mesh.instanceMeshBeforeReady = Promise.create();

        createInstanceMesh(_config.getFilePath('json'));
        _config.onUpdate = _ => {
            createInstanceMesh(_config.getFilePath('json'));
        };
        addHandlers();

        if (Hydra.LOCAL) initHotReload();
    })();

    function initHotReload() {
        _mesh.cacheGeom = _mesh.geometry.clone();
        _this.events.sub(SceneLayout.HOTLOAD_GEOMETRY, ({file}) => {
            if (_mesh.geometry?._src?.includes(file)) {
                GeomThread.loadGeometry(file).then(_ => {
                    createInstanceMesh(_config.getFilePath('json'));
                });
            }

            if (file.includes(_config.getFilePath('json'))) {
                createInstanceMesh(_config.getFilePath('json'));
            }
        });
    }

    async function createInstanceMesh(file) {
        if (!file) return;
        let isBinary = file.includes('.bin');

        if (!file.includes('assets/geometry')) file = `assets/geometry/${file}`;
        if (!isBinary && !file.includes('.json')) file += '.json';
        if (_mesh.cacheGeom) file += '?' + Utils.timestamp();
        if (_mesh.instanceMesh) _mesh.instanceMesh.visible = false;

        let data;

        if (isBinary) {
            await GeomThread.loadDracoLib();
            data = await Thread.shared().loadDraco({type: 'decode', path: Thread.absolutePath(Assets.getPath(file))});
        } else {
            data = await Thread.shared().parseInstanceMesh({url: Thread.absolutePath(Assets.getPath(file))});
        }

        let isStatic = !_config.get('dynamic');
        _this.batch = _this.initClass(MeshBatch, { visibilityCheck: !isStatic });
        _mesh._parent.add(_this.batch.group);
        _this.batch.static = isStatic;
        _this.batch.frustumCulled = _frustumCulled;
        _this.batch.onMeshCreated = (mesh) => {
            let geom = mesh.geometry;
            for (let key in data) {
                if (['_type', 'userData', 'offset', 'orientation', 'scale'].includes(key)) continue;
                let itemSize = data[`${key}ItemSize`];
                if (typeof itemSize === 'number') {
                    geom.addAttribute(key, new GeometryAttribute(data.random, itemSize, 1, _this.batch.useDynamic));
                }
            }

            //For the instance attribute
            let instances = [];
            for (let i = 0; i < count; i++) instances.push(i);
            geom.addAttribute('instance', new GeometryAttribute(new Float32Array(instances), 1, 1));

            _mesh.instanceMesh = mesh;
            mesh.position.copy(_mesh.position);
            mesh.quaternion.copy(_mesh.quaternion);
            mesh.scale.copy(_mesh.scale);
            mesh.geometry.maxInstancedCount = _this.maxInstancedCount * _this.instanceMultiplier;
            _mesh.instanceMeshReady.resolve();
        };
        if (!data.offsetItemSize) return;
        let count = data.offset.length / data.offsetItemSize;
        for (let i = 0; i < count; ++i) {
            let m = new Mesh(_mesh.cacheGeom || _mesh.geometry, _mesh.shader);
            m.position.fromArray(data.offset, i * data.offsetItemSize);
            if (data.orientation) m.quaternion.fromArray(data.orientation, i * data.orientationItemSize);
            if (data.scale) m.scale.fromArray(data.scale, i * data.scaleItemSize);
            m.renderOrder = _mesh.renderOrder;
            m.castShadow = _mesh.castShadow;
            m.frustumCulled = false;
            m.renderOrder = _mesh.renderOrder;
            m.castShadow = _mesh.castShadow;
            m.receiveLight = _mesh.receiveLight;
            m.shader.neverRender = false;
            _this.batch.add(m);
            m.shader.neverRender = false;
            m.shader = _blankShader;
            _instanceGroup.add(m);
        }

        let test = _config.get('test');
        if (test) _this.instanceMultiplier = eval(test);

        if (_this.maxInstancedCount === undefined) _this.maxInstancedCount = count;

        if (isStatic) {
            await _this.batch.staticReady();
            _instanceGroup.matrixAutoUpdate = false;
        }
    }

    //*** Event handlers
    function addHandlers() {
        _this.events.sub(MeshUIL.UPDATE, handleMeshUpdate);
    }

    function handleMeshUpdate({ key, prefix, val }) {
        if (!_mesh.instanceMesh) return;
        prefix = prefix.substring(5); // MESH_xxx
        if (prefix !== _mesh.prefix) return;
        switch (key) {
            case 'position':
                _mesh.instanceMesh.position.fromArray(val);
                break;
            case 'rotation':
                _mesh.instanceMesh.rotation.fromArray(val);
                break;
            case 'scale':
                _mesh.instanceMesh.scale.fromArray(val);
                break;
        }
    }

    //*** Public methods
    /**
     * @name this.applyToShader
     * @memberof InstanceMesh
     *
     * @function
     * @param shader
    */
    this.applyToShader = function(shader) {
        _this.batch.applyToShader(shader);
    }

    this.get('frustumCulled', () => {
        if (!_this.batch) return _frustumCulled;
        return _this.batch.frustumCulled;
    });

    this.set('frustumCulled', async b => {
        if (_this.batch) _this.batch.frustumCulled = b;
        _frustumCulled = b;
    });
}, _ => {
    function parseInstanceMesh({url}, id) {
        get(url).then(data => {
            let bufferList = {};
            let buffers = [];
            if (data.data && data.metadata?.type) {
                bufferList._type = data.metadata.type;
                let jsonData = data.data;
                for (let key in jsonData.attributes) {
                    let attrib = jsonData.attributes[key];
                    bufferList[key] = new Geometry.TYPED_ARRAYS[attrib.type](attrib.array);
                    bufferList[`${key}ItemSize`] = attrib.itemSize;
                    buffers.push(bufferList[key].buffer);
                }
            } else {
                bufferList._type = 'BufferGeometry';
                for (let key in data) {
                    let attrib = data[key];
                    bufferList[key] = new Float32Array(attrib.buffer)
                    bufferList[`${key}ItemSize`] = attrib.components;
                    buffers.push(bufferList[key].buffer);
                }
            }
            resolve(bufferList, id, buffers);
        });
    }

    Thread.upload(parseInstanceMesh);
});

/**
 * @name MeshBatch
 */

Class(function MeshBatch(_input, _config) {
    Inherit(this, Object3D);
    const _this = this;
    var _geom, _shader, _mesh, _firstRender, _static = false, _shaderKey;
    var _availableIndices, _packedData, _packedTexture, _maxIndices;
    var _renderOrder = 0;

    var _objects = [];
    var _offset = [];
    var _quaternion = [];
    var _scale = [];
    var _attributes = {};
    var _uniformToAttrib = [];
    var _uniformNoAttrib = [];

    var _frustumCulled = true;

    var _v1 = new Vector3();
    var _v2 = new Vector3();
    var _q = new Quaternion();
    var _list = new LinkedList();

    _this.useDynamic = false;

    //*** Constructor
    (function () {
        if (!(_input instanceof InputUILConfig)) {
            _config = _input;
            _input = null;
        }

        _config = _config || {};

        if (_input) {
            _this.parent.ready(true).then(initFromSceneLayout);
        }

        _this.group.asyncPromise = Promise.create();

        if (Hydra.LOCAL) initHotReload();
    })();

    function initHotReload() {
        _this.events.sub(ShaderUIL.SHADER_UPDATE, ({shader}) => {
            if (_shader && _shader.vsName && shader.includes(_shader.vsName)) {
                let newShader = new Shader(_shader.vsName, _shader.fsName);
                delete MeshBatch.shaders[`${_shader.vsName}|${_shader.fsName}`];
                updateShader(newShader);
                Shader.renderer.hotReloadClearProgram(_shader.vsName);
                newShader.upload(_mesh, _geom);
                if (_shader._gl) _shader._gl = newShader._gl;
                if (_shader._gpu) _shader._gpu = newShader._gpu;
                if (_shader._metal) _shader._metal = newShader._metal;
            }
        });
    }

    async function initFromSceneLayout() {
        let wildcard = _input.get('wildcard');
        if (!wildcard || !wildcard.length) return;
        let groupName = wildcard.split('|')[0];
        let group = await _this.parent.getLayer(groupName);

        await _this.wait(group.children, 'length');

        let children = [...group.children];
        children.sort((a, b) => a.renderOrder - b.renderOrder);

        children.forEach(mesh => _this.add(mesh));
        if (wildcard.includes('static')) _this.static = true;
        _this.group.renderOrder = children[0].renderOrder;
        group.add(_this.group);
    }

    function uniformToAttrib(key) {
        key = key.trim();
        for (let i = 0; i < _uniformToAttrib.length; i++) {
            let val = _uniformToAttrib[i];
            if (key.includes(val) || val.includes(key)) {
                if (_uniformNoAttrib.includes(key)) return false;
                return true;
            }
        }
        return false;
    }

    function updateShader(shader, castShadow) {
        let predefined = false;
        let prefetchCode = Shaders.getShader(shader.vsName + '.vs');

        shader.customCompile = `${shader.vsName}|${shader.fsName}|instance`;
        shader.castShadow = castShadow;

        shader.resetProgram();

        let cached = MeshBatch.shaders[`${shader.vsName}|${shader.fsName}`];
        if (cached) {
            shader.fragmentShader = shader.restoreFS = cached.fragment;
            shader.vertexShader = shader.restoreVS = cached.vertex;
            return;
        }

        let vsSplit = shader.vertexShader.split('__ACTIVE_THEORY_LIGHTS__');
        let fsSplit = shader.fragmentShader.split('__ACTIVE_THEORY_LIGHTS__');

        if (!vsSplit[1].includes('vec3 pos = position;') && !vsSplit[1].includes('pos = pos;') && !shader.vertexShader.includes('vec3 transformPosition')) {
            throw `Shader ${shader.vsName} needs to have "vec3 pos = position;" in order for batching to work`;
        }

        let definitions = [];
        vsSplit[1].split('\n').forEach(line => {
            if (line.includes('uniform')) {
                if (line.includes('sampler2D')) return;
                let data = line.split(' ');
                let uni = data[2].replace(';', '');
                if (uniformToAttrib(uni)) {
                    definitions.push(`${uni} = a_${data[2]}`);
                    vsSplit[1] = vsSplit[1].replace(line, `attribute ${data[1]} a_${data[2]}\nvarying ${data[1]} ${data[2]}`);
                    fsSplit[1] = fsSplit[1].replace(line, `varying ${data[1]} ${data[2]}`);
                }
            }
        });

        vsSplit[1] = vsSplit[1].replace(/vec3 pos = position;/g, 'vec3 pos = transformPosition(position, offset, scale, orientation);');
        vsSplit[1] = vsSplit[1].replace(/pos = pos;/g, 'pos = transformPosition(pos, offset, scale, orientation);');
        vsSplit[1] = vsSplit[1].replace(/vNormal = normalMatrix \* normal;/g, 'vNormal = normalMatrix * transformNormal(normal, orientation);');
        vsSplit[1] = vsSplit[1].replace(/vWorldNormal = transpose(inverse(mat3(modelMatrix))) \* normal;/g, 'vWorldNormal = transpose(inverse(mat3(modelMatrix))) * transformNormal(normal, orientation);');
        vsSplit[1] = vsSplit[1].replace(/vec3 transformedNormal = normal;/g, 'vec3 transformedNormal = transformNormal(normal, orientation);');

        let main = vsSplit[1].split('main() {');
        main[1] = '\n' + definitions.join('\n') + main[1];
        vsSplit[1] = main.join('main() {');

        vsSplit[0] += '#define INSTANCED 1\n';
        fsSplit[0] += '#define INSTANCED 1\n';

        if (!prefetchCode || !prefetchCode.includes('attribute vec3 offset')) {
            vsSplit[0] += '\n';
            vsSplit[0] += 'attribute float instance;\n'; // will be available when using InstanceMesh
            vsSplit[0] += 'attribute vec3 offset;\n';
            vsSplit[0] += 'attribute vec3 scale;\n';
            vsSplit[0] += 'attribute vec4 orientation;\n';
        }
        if (!shader.vertexShader.includes('vec3 transformPosition')) vsSplit[0] += Shaders.getShader('instance.vs') + '\n';

        if (_packedData) {
            vsSplit[0] += `
            attribute float batchIndex;
            uniform vec3 uPackedInfo;
            uniform sampler2D tPackedTexture;
            vec2 getPackedUV(float index, float offset) {
                float pixel = (index*uPackedInfo.x) + offset;
            
                float size = uPackedInfo.y;
                float p0 = pixel / size;
                float y = floor(p0);
                float x = p0 - y;
            
                vec2 uv = vec2(0.0);
                uv.x = x;
                uv.y = y / size;
                return uv;
            }
            
            vec4 getPackedData(float offset) {
                return texture2D(tPackedTexture, getPackedUV(batchIndex, offset));
            }
            `;
        }

        vsSplit = vsSplit.join('__ACTIVE_THEORY_LIGHTS__');
        fsSplit = fsSplit.join('__ACTIVE_THEORY_LIGHTS__');

        shader.vertexShader = shader.restoreVS = vsSplit;
        shader.fragmentShader = shader.restoreFS = fsSplit;

        _shaderKey = `${shader.vsName}|${shader.fsName}`;
        MeshBatch.shaders[_shaderKey] = {fragment: shader.fragmentShader, vertex: shader.vertexShader};
    }

    function initGeometry(mesh) {
        _geom = new Geometry().instanceFrom(mesh.geometry);
        _this.geom = _geom;

        if (!_shader) {
            _shader = mesh.shader.clone();
            _shader.debug = true;

            if (_packedData) {
                let total = Object.keys(_packedData).length;
                let pixels = Math.sqrt(_maxIndices * total);
                let size = Math.pow(2, Math.ceil(Math.log(pixels)/Math.log(2)));
                _packedTexture = new DataTexture(new Float32Array(size * size * 4), size, size, Texture.RGBAFormat, Texture.FLOAT);
                _packedTexture.keys = total;
                _shader.addUniforms({
                    tPackedTexture: {value: _packedTexture},
                    uPackedInfo: {value: new Vector3(total, size, _maxIndices)},
                });
            }

            mesh.shader.copyUniformsTo(_shader, true);
            updateShader(_shader, mesh.castShadow);
        }

        if (mesh.attributes) {
            for (let key in mesh.attributes) {
                _attributes[key] = [];
            }
        }

        if (_static) defer(initializeStatic);
    }

    function initMesh() {
        _geom.addAttribute('offset', new GeometryAttribute(new Float32Array(_offset), 3, 1, _this.useDynamic));
        _geom.addAttribute('scale', new GeometryAttribute(new Float32Array(_scale), 3, 1, _this.useDynamic));
        _geom.addAttribute('orientation', new GeometryAttribute(new Float32Array(_quaternion), 4, 1, _this.useDynamic));

        if (_frustumCulled) {
            let box = new Box3();
            _objects.forEach(mesh => box.expandByObject(mesh, true));
            _geom.boundingBox = box;
            _geom.boundingSphere = box.getBoundingSphere();
        }

        _mesh = new Mesh(_geom, _shader);
        if (_shader.castShadow) _mesh.castShadow = true;
        _mesh.asyncPromise = _this.group.asyncPromise;
        _this.group.asyncPromise.resolve();
        _this.mesh = _mesh;
        _this.shader = _mesh.shader;
        _this.mesh.isMeshBatch = true;
        _this.group.add(_mesh);
        _mesh.frustumCulled = _frustumCulled;

        if (_renderOrder) _mesh.renderOrder = _renderOrder;

        _offset = new Float32Array(_offset);
        _quaternion = new Float32Array(_quaternion);
        _scale = new Float32Array(_scale);

        for (let key in _attributes) {
            _attributes[key] = new Float32Array(_attributes[key]);
            let components = 1;
            let mesh = _objects[0];
            let attr = mesh.attributes[key];
            let value = attr.value || attr;
            if (value instanceof Vector3) components = 3;
            else if (value instanceof Vector4 || value instanceof Quaternion) components = 4;
            else if (value instanceof Color) components = 3;
            else if (value instanceof Vector2) components = 2;
            _geom.addAttribute(key, new GeometryAttribute(new Float32Array(_attributes[key]), components, 1, _this.useDynamic));
        }

        if (_this.onMeshCreated) _this.onMeshCreated(_mesh);
    }

    function modifyGeometry(dir) {
        if (!_geom || !_geom.attributes || !_geom.attributes.offset) return;
        let count = _geom.attributes.offset.count + dir;

        _offset = new Float32Array(count * 3);
        _scale = new Float32Array(count * 3);
        _quaternion = new Float32Array(count * 4);

        _geom.attributes.offset.setArray(new Float32Array(count * 3));
        _geom.attributes.scale.setArray(new Float32Array(count * 3));
        _geom.attributes.orientation.setArray(new Float32Array(count * 4));

        for (let key in _attributes) {
            let components = _geom.attributes[key].itemSize;
            _attributes[key] = new Float32Array(count * components);
            _geom.attributes[key].setArray(new Float32Array(count * components));
        }

        _geom.maxInstancedCount = _objects.length;

        loop();
    }

    function dirty(a, b) {
        for (let i = a.length-1; i > -1; i--) {
            if (a[i] != b[i]) return true;
        }
        return false;
    }

    function prepareMesh(mesh, i) {
        let pos = _v1;
        let scale = _v2;
        let quaternion = _q;

        if (_config.worldCoords) {
            try {
                if (_config.parent > 0) {
                    switch (_config.parent) {
                        case 1:
                            pos.copy(mesh._parent.position);
                            scale.copy(mesh._parent.scale);
                            quaternion.copy(mesh._parent.quaternion);
                            break;

                        case 2:
                            pos.copy(mesh._parent._parent.position);
                            scale.copy(mesh._parent._parent.scale);
                            quaternion.copy(mesh._parent._parent.quaternion);
                            break;
                    }
                } else if (_config.addParentPosition) {
                    pos.copy(mesh.position).add(mesh._parent.position);
                    if (_config.addParentPosition == 2) pos.add(mesh._parent._parent.position);
                    scale.copy(mesh.scale);
                    quaternion.copy(mesh.quaternion);
                } else {
                    pos.copy(mesh.getWorldPosition());
                    scale.copy(mesh.getWorldScale());
                    quaternion.copy(mesh.getWorldQuaternion());
                }

                if (!_config.bypassVisibilityCheck && !mesh.determineVisible()) {
                    scale.x = scale.y = scale.z = 0;
                }
            } catch(e) {
                pos.copy(mesh.position);
                scale.copy(mesh.scale);
                quaternion.copy(mesh.quaternion);
            }
        } else {
            pos.copy(mesh.position);
            scale.copy(mesh.scale);
            quaternion.copy(mesh.quaternion);
            if (_config.visibilityCheck && !mesh.determineVisible()) {
                scale.setScalar(0);
            }
        }

        if (mesh.batchOffsetPos) pos.add(mesh.batchOffsetPos);

        let i3 = i * 3;
        let i4 = i * 4;

        _offset[i3 + 0] = pos.x;
        _offset[i3 + 1] = pos.y;
        _offset[i3 + 2] = pos.z;

        _scale[i3 + 0] = scale.x;
        _scale[i3 + 1] = scale.y;
        _scale[i3 + 2] = scale.z;

        _quaternion[i4 + 0] = quaternion.x;
        _quaternion[i4 + 1] = quaternion.y;
        _quaternion[i4 + 2] = quaternion.z;
        _quaternion[i4 + 3] = quaternion.w;

        if (mesh.attributes) {
            for (let key in mesh.attributes) {
                let attr = mesh.attributes[key];
                let value = attr.value === undefined ? attr : attr.value;
                if (value instanceof Color) {
                    _attributes[key][i * 3 + 0] = value.r;
                    _attributes[key][i * 3 + 1] = value.g;
                    _attributes[key][i * 3 + 2] = value.b;
                } else if (value instanceof Vector3) {
                    _attributes[key][i * 3 + 0] = value.x;
                    _attributes[key][i * 3 + 1] = value.y;
                    _attributes[key][i * 3 + 2] = value.z;
                } else if (value instanceof Vector4 || value instanceof Quaternion) {
                    _attributes[key][i * 4 + 0] = value.x;
                    _attributes[key][i * 4 + 1] = value.y;
                    _attributes[key][i * 4 + 2] = value.z;
                    _attributes[key][i * 4 + 3] = value.w;
                } else if (value instanceof Vector2) {
                    _attributes[key][i * 2 + 0] = value.x;
                    _attributes[key][i * 2 + 1] = value.y;
                } else {
                    _attributes[key][i] = value;
                }
            }
        }

        if (_packedTexture) {
            let batchIndex = mesh.batchIndex;
            let stride = _packedTexture.keys * 4;
            for (let key in _packedData) {
                let offset = _packedData[key] * 4;
                let value = mesh.packedData[key].value;
                let index = batchIndex * stride + offset;

                let r = g = b = a = 1;

                if (value instanceof Color) {
                    r = value.r;
                    g = value.g;
                    b = value.b;
                } else if (value instanceof Vector3) {
                    r = value.x;
                    g = value.y;
                    b = value.z;
                } else if (value instanceof Vector4 || value instanceof Quaternion) {
                    r = value.x;
                    g = value.y;
                    b = value.z;
                    a = value.w;
                } else if (value instanceof Vector2) {
                    r = value.x;
                    g = value.y;
                } else {
                    r = value;
                }

                _packedTexture.data[index + 0] = r;
                _packedTexture.data[index + 1] = g;
                _packedTexture.data[index + 2] = b;
                _packedTexture.data[index + 3] = a;
            }

            _packedTexture.needsUpdate = true;
        }
    }

    function updateBuffers() {
        if (!_mesh) {
            initMesh();
        } else {
            if (dirty(_quaternion, _geom.attributes.orientation.array)) {
                _geom.attributes.orientation.array.set(_quaternion);
                _geom.attributes.orientation.needsUpdate = true;
            }

            if (dirty(_offset, _geom.attributes.offset.array)) {
                _geom.attributes.offset.array.set(_offset);
                _geom.attributes.offset.needsUpdate = true;
            }

            if (dirty(_scale, _geom.attributes.scale.array)) {
                _geom.attributes.scale.array.set(_scale);
                _geom.attributes.scale.needsUpdate = true;
            }

            for (let key in _attributes) {
                if (dirty(_attributes[key], _geom.attributes[key].array)) {
                    _geom.attributes[key].array.set(_attributes[key]);
                    _geom.attributes[key].needsUpdate = true;
                }
            }
        }
    }

    async function initializeStatic() {
        let runMeshes = _ => {
            let promise = Promise.create();
            let mesh = _list.start();
            let i = 0;
            let worker = new Render.Worker(_ => {
                mesh.updateMatrixWorld(true);
                prepareMesh(mesh, i);
                i++;
                mesh = _list.next();
                if (!mesh) {
                    worker.stop();
                    promise.resolve();
                }
            }, 1);
            return promise;
        };

        let wasVisible = _this.group.determineVisible();
        // Need to initialize immediately regardless of visibility, so that
        // Initializer3D doesn’t wait forever.
        await runMeshes();
        updateBuffers();
        if (wasVisible) {
            if (_frustumCulled) {
                let box = new Box3();
                _objects.forEach(mesh => box.expandByObject(mesh, true));
                _geom.boundingBox = box;
                _geom.boundingSphere = box.getBoundingSphere();
            }
            _this.flag('isStaticReady', true);
        } else {
            // Need to recalculate positions when finally becomes visible.
            await _this.wait(() => _this.group.determineVisible());
            if (_static) initializeStatic();
        }
    }

    function loop() {
        if (_static) _this.stopRender(loop, RenderManager.AFTER_LOOPS);

        let first = !_firstRender;
        _firstRender = true;
        let i = 0;
        let mesh = _list.start();
        while (mesh) {
            if (mesh.batchNeedsUpdate !== false || first) {
                if (first) mesh.updateMatrixWorld(true);
                prepareMesh(mesh, i);
            }

            mesh = _list.next();
            i++;
        }

        updateBuffers();
    }

    function firstLoop() {
        if (!_static) _this.startRender(loop, RenderManager.AFTER_LOOPS);
        loop();
    }

    //*** Event handlers

    //*** Public methods
    /**
     * @name this.add
     * @memberof MeshBatch
     *
     * @function
     * @param mesh
    */
    this.add = function(mesh) {
        _objects.push(mesh);
        _list.push(mesh);

        mesh.uploadIgnore = true;
        mesh.batch = _this;
        if (_availableIndices && !mesh.batchIndex) {
            mesh.batchIndex = _availableIndices.shift();
            if (!mesh.attributes) mesh.attributes = {};
            mesh.attributes.batchIndex = {value: mesh.batchIndex};
        }

        let shader = mesh.shader;
        for (let key in shader.uniforms) {
            let uniform = shader.uniforms[key];
            if (uniform.value instanceof Color || uniform.value instanceof Vector2 || uniform.value instanceof Vector3 || uniform.value instanceof Vector4 || uniform.value instanceof Quaternion || typeof uniform.value === 'number') {
                if (uniform.batchUnique || _config.batchUnique) {
                    _uniformToAttrib.push(key);
                    if (!mesh.attributes) mesh.attributes = {};
                    mesh.attributes['a_' + key] = uniform;
                } else {
                    if (!_uniformNoAttrib.includes(key)) _uniformNoAttrib.push(key);

                    if (typeof uniform.packedIndex !== 'undefined') {
                        if (!_packedData) _packedData = {};
                        if (!_availableIndices) throw `Can't use packedData without first setting .maxIndices`;
                        if (!_packedData[key]) _packedData[key] = uniform.packedIndex;
                        if (!mesh.packedData) mesh.packedData = {};
                        mesh.packedData[key] = uniform;
                    }
                }
            }
        }

        if (!_geom) initGeometry(mesh);
        if (_mesh) {
            modifyGeometry(1);
            if (_static) console.error(`Don't add more meshes to a static MeshBatch`);
        }

        mesh.shader.neverRender = true;
        if (!_static) {
            // We need an initial loop() call to occur regardless of visibility,
            // or the asyncPromise used by Initializer3D won’t resolve.
            RenderManager.scheduleOne(firstLoop, RenderManager.AFTER_LOOPS);
        }
    }

    /**
     * @name this.remove
     * @memberof MeshBatch
     *
     * @function
     * @param mesh
    */
    this.remove = function(mesh) {
        if (!_objects.includes(mesh)) return;
        _objects.remove(mesh);
        _list.remove(mesh);

        if (mesh.batchIndex > -1 && !mesh.persistBatchIndex) {
            _availableIndices.push(mesh.batchIndex);
            _availableIndices.sort((a, b) => a - b);
        }

        modifyGeometry(-1);
    }

    /**
     * @name this.onDestroy
     * @memberof MeshBatch
     *
     * @function
    */
    this.onDestroy = function() {
        if(_this.mesh && _this.mesh.destroy) {
            _this.mesh.destroy();
        }
        delete MeshBatch.shaders[_shaderKey];
    }

    /**
     * @name this.loadFromFile
     * @memberof MeshBatch
     *
     * @function
     * @param shader
     * @param geomFile
     * @param instanceFile
     */
    this.loadFromFile = async function(shader, geomFile, instanceFile) {
        if (!geomFile.includes('assets/geometry')) geomFile = 'assets/geometry/' + geomFile;
        if (!geomFile.includes('.json')) geomFile += '.json';

        if (!instanceFile.includes('assets/geometry')) instanceFile = 'assets/geometry/' + instanceFile;
        if (!instanceFile.includes('.json')) instanceFile += '.json';

        let [geom, data] = await Promise.all([
            GeomThread.loadGeometry(Assets.getPath(geomFile)),
            get(Assets.getPath(instanceFile))
        ]);

        let array = [];
        let count = data.offset.buffer.length / 3;
        for (let i = 0; i < count; i++) {
            let mesh = new Mesh(geom, shader);
            mesh.position.fromArray(data.offset.buffer, i * 3);
            mesh.scale.fromArray(data.scale.buffer, i * 3);
            mesh.quaternion.fromArray(data.orientation.buffer, i * 4);
            array.push(mesh);
            _this.add(mesh);
        }
        await _this.ready();
        return array;
    }

    /**
     * @name this.ready
     * @memberof MeshBatch
     *
     * @function
    */
    this.ready = function() {
        return _this.wait('mesh');
    }

    /**
     * Resolves when the static batch is fully initialized, i.e. properties for all
     * instances have been written to the buffers.
     * @name this.staticReady
     * @memberof MeshBatch
     * @function
     */
    this.staticReady = function() {
        if (_static) {
            return _this.wait('isStaticReady');
        }
    }

    /**
     * @name this.getMeshByIndex
     * @memberof MeshBatch
     *
     * @function
     * @param index
    */
    this.getMeshByIndex = function(index) {
        return _objects[index];
    }

    this.getMeshCount = function() {
        return _objects.length;
    }

    this.get('static', () => _static);
    this.set('static', b => {
        if (!!b === _static) return;
        _static = !!b;
        if (_objects.length) {
            if (_static) {
                console.warn('For better initialization performance, set meshBatch.static before adding any meshes');
            }
            _this.stopRender(loop, RenderManager.AFTER_LOOPS);
            RenderManager.scheduleOne(firstLoop, RenderManager.AFTER_LOOPS);
        }
    });

    this.set('maxIndices', value => {
        _maxIndices = value;
        _availableIndices = _config.availableIndices || [];
        if (!_availableIndices.length) {
            for (let i = 0; i < value; i++) _availableIndices[i] = i;
        }
    });

    this.get('attributes', _ => _attributes);
    this.get('maxIndices', _ => _maxIndices);

    this.set('renderOrder', v => {
        _renderOrder = v;
        if (_mesh) _mesh.renderOrder = v;
    });
    this.get('renderOrder', _ => _renderOrder);

    this.set('frustumCulled', b => {
        _frustumCulled = b;
        if (_mesh) _mesh.frustumCulled = b;
    });

    /**
     * @name this.applyToShader
     * @memberof InstanceMesh
     *
     * @function
     * @param shader
     * @param castShadow
     */
    this.applyToShader = function(shader, castShadow = shader.mesh?.castShadow ?? false) {
        updateShader(shader, castShadow);
    };
}, _ => {
    MeshBatch.shaders = {};
});

/**
 * @name MeshMerge
 */


Class(function MeshMerge(_input, _dynamic) {
    Inherit(this, Object3D);
    const _this = this;
    var _mesh, _geom, _texture, _shaderKey;

    var _meshes = [];
    var _pending = [];
    var _index = 0;

    //*** Constructor
    (function () {
        if (typeof _input === 'object') {
            if (_input.get('visible') === false) return;
            _this.parent.ready().then(initFromSceneLayout);
        } else if (typeof _input === 'boolean') {
            _dynamic = _input;
        }
    })();

    function initDynamic() {
        let size = 16;
        let array = new Float32Array(size * size * 4);
        _texture = new DataTexture(array, size, size, Texture.RGBAFormat, Texture.FLOAT);
        _texture.dynamic = true;
        _texture.promise = Promise.resolve();
        updateShader(_mesh.shader);

        let loop = _ => {
            for (let i = _meshes.length-1; i > -1; i--) {
                let mesh = _meshes[i];
                let index = mesh.mergeIndex;
                array[index * 12 + 0] = mesh.position.x;
                array[index * 12 + 1] = mesh.position.y;
                array[index * 12 + 2] = mesh.position.z;
                array[index * 12 + 3] = 1;
                array[index * 12 + 4] = mesh.scale.x;
                array[index * 12 + 5] = mesh.scale.y;
                array[index * 12 + 6] = mesh.scale.z;
                array[index * 12 + 7] = 1;
                array[index * 12 + 8] = mesh.quaternion.x;
                array[index * 12 + 9] = mesh.quaternion.y;
                array[index * 12 + 10] = mesh.quaternion.z;
                array[index * 12 + 11] = mesh.quaternion.w;
            }
        };
        defer(loop);
        _this.startRender(loop);
    }

    function updateShader(shader) {
        shader.customCompile = `${shader.vsName}|${shader.fsName}|dynamicMerge`;
        shader.addUniforms({
            tDynamicMerge: {value: _texture}
        });

        let cached = MeshMerge.shaders[`${shader.vsName}|${shader.fsName}`];
        if (cached) {
            shader.fragmentShader = cached.fragment;
            return shader.resetProgram();
        }

        shader.resetProgram();

        let vsSplit = shader.vertexShader.split('__ACTIVE_THEORY_LIGHTS__');

        if (!vsSplit[1].includes('vec3 pos = position;')) {
            throw `Shader ${shader.vsName} needs to have "vec3 pos = position;" in order for dynamic merging to work`;
        }

        vsSplit[0] += 'attribute float mIndex;\n';
        vsSplit[0] += 'uniform sampler2D tDynamicMerge;\n';
        vsSplit[0] += 'vec3 offset;\n';
        vsSplit[0] += 'vec3 scale;\n';
        vsSplit[0] += 'vec4 orientation;\n';
        if (!shader.vertexShader.includes('vec3 transformPosition')) vsSplit[0] += Shaders.getShader('instance.vs') + '\n';

        vsSplit[0] += `
        vec2 getDMUV(float index, float offset) {
            float pixel = (index*3.0) + offset;
        
            float size = 16.0;
            float p0 = pixel / size;
            float y = floor(p0);
            float x = p0 - y;
        
            vec2 uv = vec2(0.0);
            uv.x = x;
            uv.y = y / size;
            return uv;
        }
        \n`;

        vsSplit[1] = vsSplit[1].replace(/vec3 pos = position;/g, 'vec3 pos = transformPosition(position, offset, scale, orientation);');
        vsSplit[1] = vsSplit[1].replace(/vNormal = normalMatrix \* normal;/g, 'vNormal = normalMatrix * transformNormal(normal, orientation);');
        vsSplit[1] = vsSplit[1].replace(/vec3 transformedNormal = normal;/g, 'vec3 transformedNormal = transformNormal(normal, orientation);');

        let oso = `
        offset = texture2D(tDynamicMerge, getDMUV(mIndex, 0.0)).xyz;
        scale = texture2D(tDynamicMerge, getDMUV(mIndex, 1.0)).xyz;
        orientation = texture2D(tDynamicMerge, getDMUV(mIndex, 2.0));
        `;

        let main = vsSplit[1].split('main() {');
        main[1] = '\n' + oso + main[1];
        vsSplit[1] = main.join('main() {');

        vsSplit = vsSplit.join('__ACTIVE_THEORY_LIGHTS__');

        shader.vertexShader = vsSplit;

        _shaderKey = `${shader.vsName}|${shader.fsName}`;
        MeshMerge.shaders[_shaderKey] = {vertex: shader.vertexShader};
    }

    function completeMerge() {
        _mesh.geometry = _geom;
        _mesh.asyncPromise.resolve();
        if (_this.onMeshCreated) _this.onMeshCreated(_mesh);
        _this.mesh = _mesh;
    }

    async function initMesh(mesh) {
        _mesh = new Mesh(World.QUAD, mesh.shader);
        _mesh.asyncPromise = Promise.create();
        _this.group.add(_mesh);

        if (_input?.get) {
            _mesh.castShadow = _input.get('castShadow');
            _mesh.shader.receiveShadow = _input.get('receiveShadow');
        }

        if (_dynamic) initDynamic();

        if (_input?.prefix) {
            let cached = MeshMerge.cache[_input.prefix];
            if (cached) {
                _geom = await cached;
                completeMerge();
                return;
            }
        }

        await defer();
        let data = await Promise.all(_pending);
        let buffers = [];
        data.forEach(obj => {
            for (let key in obj) {
                if (obj[key].buffer) buffers.push(obj[key].buffer);
            }
        });

        let merged = await Thread.shared().meshMergeComplete({data}, buffers);
        _geom = new Geometry();
        for (let key in merged) {
            if (key === 'components') continue;
            _geom.addAttribute(key, new GeometryAttribute(merged[key], merged.components[key]));
        }
        if (merged.indexBuffer) _geom.index = merged.indexBuffer;

        if (_input?.prefix) MeshMerge.cache[_input.prefix].resolve(_geom);
        completeMerge();
    }

    async function initFromSceneLayout() {
        let wildcard = _input.get('wildcard');
        if (!wildcard || !wildcard.length) return;
        let [groupName, dynamic] = wildcard.split('|');
        await _this.parent.loadedAllLayers();
        let group = await _this.parent.getLayer(groupName);

        _dynamic = dynamic == 'dynamic';

        let children = [...group.children];
        children.sort((a, b) => a.renderOrder - b.renderOrder);

        children.forEach(mesh => _this.add(mesh));
        group.add(_this.group);

        if (!MeshMerge.cache[_input.prefix]) MeshMerge.cache[_input.prefix] = Promise.create();
    }

    //*** Event handlers

    //*** Public methods
    /**
     * @name this.onDestroy
     * @memberof MeshMerge
     *
     * @function
    */
    this.onDestroy = function() {
        _mesh.destroy();
        delete MeshBatch.shaders[_shaderKey];
    }

    /**
     * @name this.ready
     * @memberof MeshMerge
     *
     * @function
    */
    this.ready = function() {
        return _this.wait('mesh');
    }

    /**
     * @name this.add
     * @memberof MeshMerge
     *
     * @function
     * @param mesh
    */
    this.add = function(mesh) {
        mesh.uploadIgnore = true;
        if (!mesh.visible) return;

        mesh.merge = _this;

        mesh.updateMatrixWorld(true);
        if (!_mesh) initMesh(mesh);

        if (_input?.prefix) {
            let cached = MeshMerge.cache[_input.prefix];
            if (cached) {
                mesh.visible = false;
                _meshes.push(mesh);
                mesh.mergeIndex = _index++;
                return;
            }
        }

        let geom = mesh.geometry;

        if (mesh.attributes) {
            for (let key in mesh.attributes) {
                let attr = mesh.attributes[key];
                if (attr instanceof Vector4) attr.isVector4 = true;
                if (attr instanceof Vector3) attr.isVector3 = true;
                if (attr instanceof Vector2) attr.isVector2 = true;
                if (attr instanceof Color) attr.isColor = true;
            }
        }

        let data = {};
        let components = {};
        let buffers = [];
        for (let key in geom.attributes) {
            data[key] = new Float32Array(geom.attributes[key].array);
            buffers.push(data[key].buffer);
            components[key] = geom.attributes[key].itemSize;
        }

        if (geom.index) {
            data.indexBuffer = new Uint32Array(geom.index);
            buffers.push(data.indexBuffer.buffer);
        }

        data.attributes = mesh.attributes;
        data.components = components;
        data.matrix = _input == 'world' ? mesh.matrixWorld.elements : mesh.matrix.elements;
        if (_dynamic) data.matrix = null;
        data.dynamic = _dynamic;
        data.index = mesh.mergeIndex = _index++;
        mesh.visible = false;
        _meshes.push(mesh);

        _pending.push(Thread.shared().meshMergeTransform(data, buffers));
    }

    this.onDestroy = function() {
        if (_input?.prefix) delete MeshMerge.cache[_input.prefix];
    }
}, _ => {
    function meshMergeTransform(e, id) {
        let geom = new Geometry();
        for (let key in e) {
            if (key.includes(['components', 'matrix']) || !(e[key] instanceof Float32Array)) continue;
            geom.addAttribute(key, new GeometryAttribute(e[key], e.components[key]));
        }

        if (e.indexBuffer) {
            geom.index = e.indexBuffer;
        }

        if (e.attributes) {
            for (let key in e.attributes) {
                let components = 1;
                let attr = e.attributes[key];
                if (attr.isVector4) components = 4;
                else if (attr.isVector3) components = 3;
                else if (attr.isColor) components = 3;
                else if (attr.isVector2) components = 2;
                let buffer = new Float32Array(geom.attributes.position.count * components);

                let step = buffer.length / components;
                for (let i = 0; i < step; i++) {
                    if (components == 4) {
                        buffer[i * 4 + 0] = attr.x;
                        buffer[i * 4 + 1] = attr.y;
                        buffer[i * 4 + 2] = attr.z;
                        buffer[i * 4 + 3] = attr.w;
                    } else if (components == 3) {
                        buffer[i * 3 + 0] = attr.x || attr.r || 0;
                        buffer[i * 3 + 1] = attr.y || attr.g || 0;
                        buffer[i * 3 + 2] = attr.z || attr.b || 0;
                    } else if (components == 2) {
                        buffer[i * 2 + 0] = attr.x;
                        buffer[i * 2 + 1] = attr.y;
                    } else {
                        buffer[i] = attr;
                    }
                }

                geom.addAttribute(key, new GeometryAttribute(buffer, components));
            }
        }

        if (e.matrix) {
            geom.applyMatrix(new Matrix4().fromArray(e.matrix));
        }

        let indexBuffer = new Float32Array(geom.attributes.position.count);
        for (let i = 0; i < indexBuffer.length; i++) indexBuffer[i] = e.index;
        geom.addAttribute('mIndex', new GeometryAttribute(indexBuffer, 1));

        let data = {};
        let buffers = [];
        let components = {};
        for (let key in geom.attributes) {
            data[key] = geom.attributes[key].array;
            components[key] = geom.attributes[key].itemSize;
            buffers.push(data[key].buffer);
        }

        if (geom.index) {
            data.indexBuffer = geom.index;
            buffers.push(data.indexBuffer.buffer);
        }

        data.components = components;
        resolve(data, id, buffers);
    }

    function meshMergeComplete({data}, id) {
        let _geom;
        data.forEach(data => {
            let geom = new Geometry();
            for (let key in data) {
                if (key == 'components') continue;
                if (key == 'indexBuffer') {
                    geom.index = data[key];
                } else {
                    geom.addAttribute(key, new GeometryAttribute(data[key], data.components[key]));
                }
            }

            if (!_geom) _geom = geom;
            else _geom.merge(geom);
        });

        let result = {};
        let components = {};
        let buffers = [];
        for (let key in _geom.attributes) {
            result[key] = _geom.attributes[key].array;
            components[key] = _geom.attributes[key].itemSize;
            buffers.push(result[key].buffer);
        }

        if (_geom.index) {
            result.indexBuffer = _geom.index;
            buffers.push(result.indexBuffer.buffer);
        }

        result.components = components;
        resolve(result, id, buffers);
    }

    Thread.upload(meshMergeTransform);
    Thread.upload(meshMergeComplete);

    MeshMerge.shaders = {};
    MeshMerge.cache = {};
});

Class(function OptimizationProfiler() {
    Inherit(this, Component);
    const _this = this;
    var _shaders, _count;

    this.active = Utils.query('optimizationProfiler') || location.hash?.includes('optimizationProfiler');

    //*** Constructor
    (function () {
        if (!_this.active) return;
        _shaders = [];
        _count = Number(Utils.query('optimizationProfiler') || location.hash.split('optimizationProfiler=')[1]?.split('&')[0]);
        if (isNaN(_count)) _count = null;
    })();

    function getFSDefintions() {
        return `
        #define TEXEL_DENSITY_EPSILON 10e-10
        uniform float texDimensions;
        uniform float texelsPerMeter;
        in vec3 vDensityPos;
 
float MipLevel(vec2 uv)
{
  vec2 dx = dFdx(uv);
  vec2 dy = dFdy(uv);
  float d = max( dot(dx, dx), dot(dy, dy) );
 
  float maxRange = pow(2., (10.0 - 1.) * 2.);
  d = clamp(d, 1., maxRange);
 
  float mipLevel = 0.5 * log2(d);
  return floor(mipLevel);
}

vec3 getDensityColor() {
    vec2 uv = vUv.xy;
    
    float texWidth = texDimensions;
    float texHeight = texDimensions;

    vec2 ddxUV  = dFdx(uv * texWidth  / texelsPerMeter);
    vec2 ddyUV  = dFdy(uv * texHeight / texelsPerMeter);
    vec3 ddxPos = dFdx(vDensityPos);
    vec3 ddyPos = dFdy(vDensityPos);
\t
\t// NOTE(jserrano): check LOD ?
\t//float mipLevel = MipLevel(uv * texDimensions);
    //float mipSize  = pow(2., mipLevel);
    
    //ddxUV /= mipSize;
    //ddyUV /= mipSize;

    float uvArea   = length( cross(vec3(ddxUV,0), vec3(ddyUV,0)) );
    float faceArea = length( cross(ddxPos, ddyPos) );
\tfloat density  = uvArea / max(10e-10, faceArea);
    
    const float lowRatioLimit  = 0.8;
    const float midRatio       = 1.0;
    const float highRatioLimit = 1.2;
    
    vec3 finalColor = vec3(0);
    
\tif (density > lowRatioLimit && density < highRatioLimit)
\t{
        vec3 lowDensityColor  = vec3( 1., 1., 1. );
        vec3 midDensityColor  = vec3( 0., 1., 0. );
        vec3 highDensityColor = vec3( 0., 0., 0. );
        
        vec3 lowColorStep = mix( lowDensityColor, midDensityColor, smoothstep(lowRatioLimit, midRatio, density) );
        finalColor = mix( lowColorStep, highDensityColor, smoothstep(midRatio, highRatioLimit, density) );
\t}
    else if (density > highRatioLimit)
    {
        vec3 lowDensityColor  = vec3( 1., 1., 0. );
        vec3 highDensityColor = vec3( 1., 0., 0. );
        
        float ratio = smoothstep(highRatioLimit, 2., density);
        finalColor = mix( lowDensityColor, highDensityColor, ratio );
    }
    else
    {
        vec3 lowDensityColor  = vec3( 0., 0., 1. );
        vec3 highDensityColor = vec3( 0., 1., 1. );
        
        float ratio = smoothstep(0., lowRatioLimit, density);
        finalColor = mix( lowDensityColor, highDensityColor, ratio );
    }

    return finalColor;
}
        `;
    }

    function getVSDefinitions() {
        return `
        out vec3 vDensityPos;
        `;
    }

    //*** Event handlers

    //*** Public methods
    this.setupShader = function(shader) {
        shader.addUniforms({
            texDimensions: {value: 0},
            texelsPerMeter: {value: _count}
        });

        const parse = _ => {
            for (let key in shader.uniforms) {
                let value = shader.uniforms?.[key]?.value;
                if (value instanceof Texture) {
                    if (!value.data) {
                        if (!value.dimensions) value.promise?.then(parse);
                        else {
                            shader.uniforms.texDimensions.value = Math.max(shader.uniforms.texDimensions.value, Math.max(value.dimensions.width, value.dimensions.height));
                        }
                    }
                }
            }
        };

        _shaders.push(shader);

        parse();
    }

    this.override = function(shader, vsCode, fsCode) {
        if (!_count) return [vsCode, fsCode];
        if (shader?.mesh instanceof Mesh && fsCode.includes('vUv')) {
            try {

                let vs = vsCode;
                let fs = fsCode;

                (function() {
                    vs = vs.slice(0, -(vs.length - vs.lastIndexOf('}')));
                    vs += `vDensityPos = ${vs.includes('vec3 pos ') ? 'pos' : 'position'};\n`;
                    vs += '}';

                    let split = vs.split('void main');
                    split[0] += getVSDefinitions();

                    vs = split.join('void main');
                })();


                (function() {
                    fs = fs.slice(0, -(fs.length - fs.lastIndexOf('}')));
                    fs += `FragColor = vec4(getDensityColor(), 1.0);\n`
                    fs += '}';

                    let split = fs.split('void main');
                    split[0] += getFSDefintions();

                    fs = split.join('void main');
                })();

                return [vs, fs];
            } catch(e) {
                return [vsCode, fsCode];
            }
        } else {
            return [vsCode, fsCode];
        }
    }

    this.logTextures = function() {
        if (!this.active) {
            console.log('Add optimizationProfiler in the URL!');
        }

        _shaders?.forEach(shader => {
            let found = false;
            for (let key in shader.uniforms) {
                let value = shader.uniforms?.[key]?.value;
                if (value instanceof Texture) {
                    if (!value.data && value.dimensions) {
                        if (!found) {
                            console.group(shader.mesh?.uilName || shader.fsName);
                            found = true;
                        }

                        let size = Math.max(value.dimensions.width, value.dimensions.height);
                        let bgColor = (function() {
                            if (size <= 512) return '#00ff00';
                            if (size <= 1024) return '#ffff00';
                            return '#ff0000';
                        })();
                        console.log(`%c ${key}: ${size}`, `background-color: ${bgColor}; color: #000000;`, `Compressed: ${value.compressed ? '✔️' : '❌'}`);
                    }
                }
            }
            if (found) console.groupEnd();
        });
    }

    this.logVertices = function(sort = false) {
        if (!_shaders || !_shaders.length) return;

        let total = 0;
        let shaders = _shaders
            .filter(shader => Boolean(shader?.mesh?.geometry) && !(shader?.mesh instanceof Points))
            .map(shader => ({
                shader,
                count: shader.mesh.geometry.isInstanced ? 
                        shader.mesh.geometry.attributes.position.count * shader.mesh.geometry.maxInstancedCount :
                        shader.mesh.geometry.attributes.position.count
                
            }));

        if (sort) shaders = shaders.sort((a, b) => b.count - a.count);

        function bgColor(count) {
            if (count <= 15000) return '#00ff00';
            if (count <= 30000) return '#ffff00';
            return '#ff0000';
        };

        shaders.forEach(({shader, count}) => {
            total += count;
            console.group(shader.mesh.uilName || shader.fsName);
            if (!shader.mesh.uilName) console.log(shader.mesh);
            console.log(`%c ${shader.mesh.geometry.isInstanced ? 'Instanced' : ''} Vertices ${count}`, `background-color: ${bgColor(count)}; color: #000000;`);
            console.groupEnd();
        });

        console.log('%c TOTAL VERTICES '+total, `background-color: #ff00ff; color: #000000;`);
    }
}, 'static');

Class(function RTPool(_type, _size = 3, _format, _multisample = false, _samplesAmount = 4) {
    Inherit(this, Component);
    const _this = this;
    var _pool;
    var _indexed = {};

   /**
    * @name nullRT
    * @memberof RTPool
    * @property
    */
    this.nullRT = Utils3D.createRT(2, 2);
    this.nullRT.setSize = () => {};

    var _array = [];
    var _resizeDisabled = false;

    //*** Constructor
    (function() {
        initPool();
        defer(addListeners);
    })();

    function createRT() {
        let rt = Utils3D.createRT(Stage.width * World.DPR, Stage.height * World.DPR, _type, _format, _multisample, _samplesAmount);
        rt.index = _pool.length();
        return rt;
    }


    function initPool() {
        _pool = new ObjectPool();
        for (let i = 0; i < _size; i++) {
            let rt = createRT();
            _pool.put(rt);
            _array.push(rt);
        }
    }

    //*** Event handlers
    function addListeners() {
        if (!_resizeDisabled) {
            _this.events.sub(Events.RESIZE, resizeHandler);
        }
    }

    function resizeHandler() {
        _array.forEach(rt => {
            rt.setSize(Stage.width * World.DPR, Stage.height * World.DPR);
        });
    }

    //*** Public methods
    this.get('array', _ => _array);

    /**
     * @name this.getRT
     * @memberof RTPool
     *
     * @function
    */
    this.getRT = function(index) {
        if (index) {
            if (!_indexed[index]) _indexed[index] = createRT();
            return _indexed[index];
        }

        return _pool.get() || createRT();
    };

    /**
     * @name this.putRT
     * @memberof RTPool
     *
     * @function
     * @param rt
    */
    this.putRT = function(rt) {
        if (rt.scissor) delete rt.scissor;
        if (rt === _this.nullRT) return;
        _pool.put(rt);
    };

    /**
     * @name this.setSize
     * @memberof RTPool
     *
     * @function
     * @param width
     * @param height
    */
    this.setSize = function(width, height) {
        _this.disableResize();
        _array.forEach(rt => {
            rt.setSize(width, height);
        });
    };

    /**
     * @name this.onDestroy
     * @memberof RTPool
     *
     * @function
    */
    this.onDestroy = function() {
        let p = _pool.get();
        while (p) {
            p.dispose();
            p = _pool.get();
        }
    };

    /**
     * @name this.clone
     * @memberof RTPool
     *
     * @function
     * @param type
     * @param size
     * @param format
     * @param multisample
     * @param samplesAmount
    */
    this.clone = function(type = _type, size = _size, format = _format, multisample = _multisample, samplesAmount = _samplesAmount) {
        return new RTPool(type, size, format, multisample, samplesAmount);
    };

    /**
     * @name this.disableResize
     * @memberof RTPool
     *
     * @function
    */
    this.disableResize = function() {
        _resizeDisabled = true;
        _this.events.unsub(Events.RESIZE, resizeHandler);
    };
}, 'singleton');

Class(function PerformanceAnalyzer() {
    Inherit(this, Component);
    const _this = this;
    var _lowFrame = 0;
    
    //*** Constructor
    (function () {
        if (Hydra.LOCAL) init();
    })();

    function init() {
        _this.delayedCall(startRender, 10000);
    }

    function startRender() {
        _this.startRender(loop);
    }

    function loop() {
        let targetDelta = 1000 / Render.REFRESH_RATE;
        let realDelta = Render.DELTA;
        if (Math.abs(targetDelta - realDelta) > 2) {
            _lowFrame++;
            if (_lowFrame > Render.REFRESH_RATE*2) {
                _this.stopRender(loop);
                reportLowFPS();
            }
        }
    }

    function reportLowFPS() {
        Dev.postPerfLog({message: "Unable to meet target framerate"});
    }
    
    //*** Event handlers
    
    //*** Public methods
    
}, 'static');
/**
 * @name RenderCount
 */

Class(function RenderCount() {
    const _this = this;
    var $container;

    var _map = {};
    var _display = {};

    var LOG;

    //*** Constructor
    (async function () {
        await Hydra.ready();
        _this.active = Utils.query('renderCount');
        LOG = _this.active && Utils.query('log');
        if (_this.active) initUIL();
    })();

    async function initUIL() {
        await Hydra.ready();
        $container = Stage.create('RenderCount');
        $container.css({width: 150, height: 'auto', paddingBottom: 5, bottom: 0}).bg('#111').setZ(9999999);
    }
    //*** Event handlers

    //*** Public methods
    /**
     * @name this.add
     * @memberof RenderCount
     *
     * @function
     * @param name
     * @param detail
     * @param amt
    */
    this.add = function(name, detail, amt = 1) {
        if (!_this.active) return;

        if (_map[name] === undefined) {
            _map[name] = 0;

            if ($container) {
                let $wrapper = $container.create('wrapper');
                $wrapper.css({position: 'relative', width: '100%', height: 20});

                $wrapper.label = $wrapper.create('label');
                $wrapper.label.fontStyle('Arial', 12, '#fff').text(name).css({left: 10});

                $wrapper.value = $wrapper.create('value');
                $wrapper.value.fontStyle('Arial', 12, '#fff').text(0).css({right: 10});

                _display[name] = $wrapper;
            }
        }

        if (LOG) {
            console.groupCollapsed(name);
            if (detail) console.log(detail);
            console.trace();
            console.groupEnd();
        }

        _map[name] += amt;
        _display[name].value.text(_map[name] || '0');
    }

    /**
     * @name this.remove
     * @memberof RenderCount
     *
     * @function
     * @param name
     * @param amt
    */
    this.remove = function(name, amt = 1) {
        if (!_this.active) return;

        if (_map[name]) {
            _map[name] -= amt;
            _display[name].value.text(_map[name] || '0');
        }
    }

}, 'static');
/**
 * @name RenderStats
 */

Class(function RenderStats() {
    const _this = this;
    var _input, _trace, _filter;
    var $container;

    var _map = {};
    var _stats = {};
    var _display = {};

    //*** Constructor
    (async function () {
        await Hydra.ready();
        _this.active = Utils.query('renderStats');
        if (Utils.query('renderStats')) initUIL();
        Render.drawFrame = flush;
        Render.start(_ => {
            _this.update('FPS', Math.round(1000 / Render.DELTA));
        });
    })();

    async function initUIL() {
        await Hydra.ready();
        $container = Stage.create('RenderStats');
        $container.css({position: 'fixed', width: 150, height: 'auto', paddingTop: 5}).bg('#111').setZ(99999);

        if (Utils.query('uil')) {
            const left = RenderCount.active ? 150 : 0;
            $container.css({ bottom: 0, left });
        }
    }

    function flush() {
        for (let key in _map) {
            _stats[key] = _map[key];

            if (_display[key]) _display[key].value.text(_map[key] || '0');

            _map[key] = 0;
        }

        _trace = null
    }

    //*** Event handlers

    //*** Public methods
    /**
     * @name this.update
     * @memberof RenderStats
     *
     * @function
     * @param name
     * @param amt
     * @param detail
     * @param detail2
    */
    this.update = function(name, amt = 1, detail, detail2) {
        if (!Hydra.LOCAL) return;
        if (_trace == name) {
            if (_filter && detail) {
                let detailString = typeof detail == 'string' ? detail : Utils.getConstructorName(detail);
                if (!detailString.toLowerCase().includes(_filter.toLowerCase())) return;
            }
            console.groupCollapsed(name);
            if (detail) console.log(typeof detail == 'string' ? detail : Utils.getConstructorName(detail));
            if (detail2) console.log(detail2);
            console.trace();
            console.groupEnd();
        }

        if (_map[name] === undefined) {
            _map[name] = 0;

            if ($container) {
                let $wrapper = $container.create('wrapper');
                $wrapper.css({position: 'relative', width: '100%', height: 20});

                $wrapper.label = $wrapper.create('label');
                $wrapper.label.fontStyle('Arial', 12, '#fff').text(name).css({left: 10});

                $wrapper.value = $wrapper.create('value');
                $wrapper.value.fontStyle('Arial', 12, '#fff').text(0).css({right: 10});

                _display[name] = $wrapper;
            }
        }
        _map[name] += amt;
    }

    /**
     * @name this.trace
     * @memberof RenderStats
     *
     * @function
     * @param name
     * @param filter
    */
    this.trace = function(name, filter = null) {
        _trace = name;
        _filter = filter;
    }

    /**
     * @name this.log
     * @memberof RenderStats
     *
     * @function
    */
    this.log = function() {
        for (let key in _stats) {
            console.log(key, _stats[key]);
        }
        console.log('----');
    }

}, 'static');
/**
 * @name RenderTimer
 */

Class(function RenderTimer() {
    const _this = this;
    var $container;

    var _display = {};
    var _times = {};

    //*** Constructor
    (async function () {
        await Hydra.ready();
        _this.active = Utils.query('renderTimer');
        if (_this.active) initUIL();
    })();

    async function initUIL() {
        $container = Stage.create('RenderTimer');
        $container.css({width: 150, height: 'auto', paddingBottom: 5, bottom: 0, right: 0}).bg('#111').setZ(9999999);
    }
    //*** Event handlers

    //*** Public methods
    /**
     * @name this.start
     * @memberof RenderTimer
     *
     * @function
     * @param name
    */
    this.start = function(name) {
        _times[name] = performance.now();
    }

    /**
     * @name this.stop
     * @memberof RenderTimer
     *
     * @function
     * @param name
    */
    this.stop = function(name) {
        if (!_display[name]) {
            if ($container) {
                let $wrapper = $container.create('wrapper');
                $wrapper.css({position: 'relative', width: '100%', height: 20});

                $wrapper.label = $wrapper.create('label');
                $wrapper.label.fontStyle('Arial', 12, '#fff').text(name).css({left: 10});

                $wrapper.value = $wrapper.create('value');
                $wrapper.value.fontStyle('Arial', 12, '#fff').text(0).css({right: 10});

                _display[name] = $wrapper;
            }
        }

        if (_display[name]) _display[name].value.text((performance.now() - _times[name]).toFixed(3) || '0');
    }

}, 'static');
/**
 * Fullscreen controller.<br />
 * IE 10 and below has no fullscreen API
 * @name Fullscreen
 */

Class(function Fullscreen() {
    Inherit(this, Events);
    const _this = this;

    /**
     * @name Fullscreen.isOpen
     * @memberof Fullscreen
     */
    this.isOpen = false;

    (function() {
        addHandlers();

        // TODO: May not need to check in loop
        // Render.start(check, 2);
    })();

    function addHandlers() {
        [
            'onfullscreenchange',
            'onwebkitfullscreenchange',
            'onmozfullscreenchange',
            'onmsfullscreenchange',

            'onfullscreenerror',
            'onwebkitfullscreenerror',
            'onmozfullscreenerror',
            'onmsfullscreenerror'
        ].forEach(evt => {
            if (typeof document[evt] !== 'undefined') document[evt] = update;
        });
    }

    function update() {
        const isOpen = !!(document.fullscreenElement || document.webkitFullscreenElement || document.mozFullScreenElement || document.msFullscreenElement);
        if (isOpen === _this.isOpen) return;
        _this.isOpen = isOpen;

        _this.events.fire(Events.FULLSCREEN, {fullscreen: _this.isOpen});
    }

    //*** Public methods

    /**
     * @name Fullscreen.open
     * @memberof Fullscreen
     *
     * @function
     * @param {DocumentElement} element
     */
    this.open = function(element) {
        element = element || document.body;

        [
            'requestFullscreen',
            'webkitRequestFullscreen',
            'mozRequestFullScreen',
            'msRequestFullscreen'
        ].every(method => {
            if (typeof element[method] == 'undefined') return true;
            element[method]({navigationUI: 'hide'});
        });
    };

    /**
     * @name Fullscreen.close
     * @memberof Fullscreen
     *
     * @function
     */
    this.close = function() {
        [
            'exitFullscreen',
            'webkitExitFullscreen',
            'mozCancelFullScreen',
            'msExitFullscreen'
        ].every(method => {
            if (typeof document[method] == 'undefined') return true;
            document[method]();
        });
    };

    Object.defineProperty(this, 'enabled', {
        get() {
            return [
                'fullscreenEnabled',
                'webkitFullscreenEnabled',
                'mozFullScreenEnabled',
                'msFullscreenEnabled'
            ].some(prop => Boolean(document[prop]));
        }
    });

}, 'static');
Class(function FXAA() {
    Inherit(this, NukePass);
    const _this = this;

    this.uniforms = {
        tMask: {value: null}
    };

    this.init('FXAA', 'FXAA');

    //*** Event handlers

    //*** Public methods
    this.setMask = function(texture) {
        this.uniforms.tMask.value = texture;
    }
});

Class(function GLA11y() {
    Inherit(this, Element);
    const _this = this;
    var $this;

    var _groups = [];
    var _links = [];

    //*** Constructor
    (async function () {
        window.GLSEO = _this;
        await Hydra.ready();
        initHTML();
        HydraCSS.style('.GLA11y *', { position: 'relative' });
    })();

    function initHTML() {
        $this = _this.element;
        $this.setZ(-1);
        Stage.add($this);
    }

    function isVisible(group) {
        if (group.__glseoParent) {
            const seoHidden = !!group.__glseoParent.seoHidden;
            const hidden = !!group.__glseoParent.hidden;

            return (!seoHidden && !hidden);
        }

        return group.seo.enabled && group.determineVisible();
    }

    function isDeleted(group) {
        if (group.__glseoParent) {
            return group.__glseoParent.deleted;
        }

        return group.deleted;
    }

    function checkItemVisibility(seo) {
        Array.prototype.slice.call(seo.div.children).forEach(div => {
            let seo = div.hydraObject;
            let group = seo && seo.group;
            if (!seo || !group) return;
            let hidden = !group.determineVisible();
            if (hidden !== seo.hidden) {
                if (hidden) {
                    seo.hide();
                } else {
                    seo.show();
                }
                seo.hidden = hidden;
            }
        });
    }

    function loop() {
        for (let i = _groups.length - 1; i > -1; i--) {
            let group = _groups[i];

            if (isDeleted(group)) {
                $this.removeChild(group.seo);
                return _groups.splice(i, 1);
            }

            if (isVisible(group)) {
                if (group.seo && group.seo.hidden) {
                    group.seo.hidden = false;
                    $this.add(group.seo);
                }
                checkItemVisibility(group.seo);
            } else {
                if (group.seo && !group.seo.hidden) {
                    group.seo.hidden = true;
                    $this.removeChild(group.seo, true);
                }
            }
        }

        for (let i = _links.length - 1; i > -1; i--) {
            let group = _links[i];

            if (isDeleted(group)) {
                $this.removeChild(group.seo);
                return _groups.splice(i, 1);
            }

            if (isVisible(group)) {
                if (group.seoHidden) {
                    group.seoHidden = false;
                    group.seoDOM.forEach(obj => obj.show());
                }
            } else {
                if (!group.seoHidden) {
                    group.seoHidden = true;
                    group.seoDOM.forEach(obj => obj.hide());
                }
            }
        }
    }

    //*** Event handlers

    //*** Public methods
    this.registerPage = function (group, name) {
        let topLevel = group;

        group = group instanceof GLUIObject ? group : (group.group || group.scene || group);
        if (!group.determineVisible && group.group) group.determineVisible = group.group.determineVisible.bind(group.group);

        if (!Global.PLAYGROUND) World.ELEMENT.mouseEnabled(false);

        topLevel.seo = group.seo = $(name);
        group.seo.hidden = true;
        group.seo.enabled = true;

        let remove = group.seo.remove.bind(group.seo);
        group.seo.remove = _ => {
            _groups.remove(group);
            remove();
        };

        _groups.push(group);
        _this.startRender(loop, 10);
    }

    this.setPageH1 = function (group, title) {
        let $h1 = group.seo.h1;
        if (!$h1) {
            $h1 = group.seo.create('title', 'h1');
            defer(() => {
                // Move it to the top.
                let el = $h1.div;
                el.parentNode.insertBefore(el, el.parentNode.firstChild);
            })
        }
        $h1.text(title);
    }

    this.registerPersist = function (group, name) {
        let topLevel = group;
        group = group instanceof GLUIObject ? group : (group.group || group.scene || group);
        if (!Global.PLAYGROUND) World.ELEMENT.mouseEnabled(false);
        topLevel.seo = group.seo = $this.create(name);
    }

    this.link = function ($dom, group) {
        if ($dom instanceof HydraObject) {
            group = group.group || group.scene || group;

            if (!group.seoDOM) group.seoDOM = [];
            group.seoDOM.push($dom);

            _links.push(group);
        }

        if ($dom instanceof GLUIObject) {
            $dom.seo = group.seo;
        }
    }

    function aLink($object, url, label, options = {}) {
        let seo = $('link', 'a');
        seo.group = $object.group;
        seo.attr('href', url === '#' ? url : Hydra.absolutePath(url));
        seo.text(label);
        seo.accessible();
        seo.div.onfocus = _ => $object._divFocus();
        seo.div.onblur = _ => $object._divBlur();
        seo.div.onclick = e => {
            e.preventDefault();
            $object._divSelect();
        };
        if (options.role) {
            seo.attr('role', options.role);
            seo.div.onkeydown = e => {
                switch (e.key) {
                    case ' ':
                    case 'Spacebar':
                        e.preventDefault();
                        e.stopPropagation();
                        $object._divSelect();
                        break;
                }
            }
        }
        return seo;
    }

    this.textNode = function ($text, text) {
        let parent = ($text._3d ? $text.anchor || $text.group : $text)._parent;
        if ($text.parentSeo) {
            let parentSeo = $text.parentSeo;
            if (parentSeo.group && parentSeo.group.seo) parent = parentSeo.group
            else parent = parentSeo;

        } else if (parent) {
            while (parent && !parent.seo) {
                parent = parent._parent;
            }
        }

        if (!parent) return;

        if (parent.seo) {
            if (!$text.seo) {
                $text.seo = $('text');
                $text.seo.group = $text.group;
                $text.seo.text(text);
                $text.seo.accessible();
                parent.seo.add($text.seo);

                $text.seo.aLink = function (url, options) {
                    let index = Array.prototype.slice.call(parent.seo.div.children).indexOf($text.seo.div);
                    $text.seo.remove();
                    $text.seo = aLink($text, url, text, options);
                    parent.seo.div.insertBefore($text.seo.div, parent.seo.div.children[index]);
                };

                $text.seo.unlink = function () {
                    parent.seo.div.removeChild($text.seo.div);
                    $text.seo.group = null;
                    $text.seo = null;
                };
            } else {
                $text.seo.text(text);
                $text.seo.accessible();
            }
        }
    }

    this.bindToPage = function (parent, child, name) {
        child.__glseoParent = parent;
        _this.registerPage(child, name);
    }

    this.objectNode = function ($object, $parent) {
        let parent = $parent || ($object._3d ? $object.group : $object)._parent;
        if ($object.parentSeo) parent = $object.parentSeo.group || $object.parentSeo;
        else {
            if (!parent) return;
            while (parent && !parent.seo) {
                parent = parent._parent;
            }
        }

        if (!parent) return;
        if (parent.seo) {
            if (!$object.seo) {
                $object.seo = {};
                $object.seo.group = $object.group;

                $object.seo.aLink = function (url, label, options) {
                    let index = Array.prototype.slice.call(parent.seo.div.children).indexOf($object.seo.div);
                    $object.seo = aLink($object, url, label, options);
                    parent.seo.div.insertBefore($object.seo.div, parent.seo.div.children[index]);

                    $object.seo.unlink = function () {
                        parent.seo.div.removeChild($object.seo.div);
                        $object.seo.group = null;
                        $object.seo = null;
                    };
                }
            }
        }
    }
}, 'static');

Class(function GLText({

    // Generation props
    font,
    italic = false,
    bold = false,
    text,
    width = Infinity,
    align = 'left',
    size = 1,
    direction = 'ltr',
    letterSpacing = 0,
    lineHeight = 1.4,
    wordSpacing = 0,
    wordBreak = false,
    langBreak = false,
    paragraphSpacing = 1,

    // Shader props
    color = new Color('#000000'),
    alpha = 1,
    shader = 'DefaultText',
    customCompile = false
}) {
    const _this = this;
    var _override;
    var _promise = Promise.create();

    const config = GLText.FONT_CONFIG[font];

    //*** Constructor
    (function () {
        init();
        if ( typeof font === 'undefined' ) console.log( font, text );
    })();

    function init() {
        overrideParams();
        _this.charLength = text.length;
        _this.text = new GLTextGeometry({font, italic, bold, text, width, align, direction, wordSpacing, letterSpacing, paragraphSpacing, size, lineHeight, wordBreak, langBreak, config});

        _this.string = text;

        resetOverride();

        _this.text.loaded.then(({buffers, texture, textureBold, textureItalic, height, numLines}) => {
            _this.texture = texture;
            if (bold) _this.textureBold = textureBold;
            if (italic) _this.textureItalic = textureItalic;

            _this.shader = new Shader(shader, {
                tMap: { value:_this.texture, ignoreUIL: true},
                tMapBold: {value: _this.textureBold || Utils3D.getEmptyTexture(), ignoreUIL: true},
                tMapItalic: {value: _this.textureItalic || Utils3D.getEmptyTexture(), ignoreUIL: true},
                uColor: {value: color, ignoreUIL: true},
                uAlpha: {value: alpha, ignoreUIL: true},
                transparent: true,
                customCompile
            });

            if (_this.onCreateShader) _this.onCreateShader(_this.shader);

            createGeometry(buffers);

            _this.mesh = new Mesh(_this.geometry, _this.shader);
            _this.height = height;

            _promise.resolve();
        });
    }

    function overrideParams() {
        if (GLText.overrideParams) {
            _override = {letterSpacing, size, wordSpacing, lineHeight};
            let obj = GLText.overrideParams({letterSpacing, size, wordSpacing, lineHeight});
            letterSpacing = obj.letterSpacing;
            size = obj.size;
            wordSpacing = obj.wordSpacing;
            lineHeight = obj.lineHeight;
        }
    }

    function resetOverride() {
        if (_override) {
            letterSpacing = _override.letterSpacing;
            size = _override.size;
            wordSpacing = _override.wordSpacing;
            lineHeight = _override.lineHeight;
        }
    }

    function createGeometry(buffers) {
        _this.geometry = new Geometry();
        _this.geometry.addAttribute('position', new GeometryAttribute(buffers.position, 3));
        _this.geometry.addAttribute('uv', new GeometryAttribute(buffers.uv, 2));
        _this.geometry.addAttribute('local', new GeometryAttribute(buffers.local, 2));
        _this.geometry.addAttribute('animation', new GeometryAttribute(buffers.animation, 3));
        _this.geometry.addAttribute('weight', new GeometryAttribute(buffers.weight, 1));
        _this.geometry.setIndex(new GeometryAttribute(buffers.index, 1));
        _this.geometry.boundingBox = buffers.boundingBox;
        _this.geometry.boundingSphere = buffers.boundingSphere;

        _this.geometry.letterCount = buffers.letterCount+1;
        _this.geometry.wordCount = buffers.wordCount+1;
        _this.geometry.lineCount = buffers.lineCount+1;
    }

    function updateGeometry(buffers) {
        _this.geometry.attributes.position.setArray(buffers.position);
        _this.geometry.attributes.uv.setArray(buffers.uv);
        _this.geometry.attributes.animation.setArray(buffers.animation);
        _this.geometry.attributes.weight.setArray(buffers.weight);
        _this.geometry.index = buffers.index;
        _this.geometry.indexNeedsUpdate = true;
        _this.geometry.boundingBox = buffers.boundingBox;
        _this.geometry.boundingSphere = buffers.boundingSphere;

        _this.geometry.letterCount = buffers.letterCount+1;
        _this.geometry.wordCount = buffers.wordCount+1;
        _this.geometry.lineCount = buffers.lineCount+1;
    }

    function setVars(options) {
        font = options.font || font;
        bold = options.bold || bold;
        italic = options.italic || italic;
        width = options.width || width;
        align = options.align || align;
        wordSpacing = options.wordSpacing || wordSpacing;
        letterSpacing = options.letterSpacing || letterSpacing;
        paragraphSpacing = options.paragraphSpacing || paragraphSpacing;
        size = options.size || size;
        lineHeight = options.lineHeight || lineHeight;
        wordBreak = options.wordBreak || wordBreak;
        langBreak = options.langBreak || langBreak;
        direction = options.direction || direction;
    }

    function match(options) {
        if (!options) return true;
        if (options.font != font) return false;
        if (options.italic != italic) return false;
        if (options.bold != bold) return false;
        if (options.width != width) return false;
        if (options.align != align) return false;
        if (options.direction != direction) return false;
        if (options.wordSpacing > 0 && options.wordSpacing != wordSpacing) return false;
        if (options.letterSpacing != letterSpacing) return false;
        if (options.paragraphSpacing != paragraphSpacing) return false;
        if (options.size != size) return false;
        if (options.lineHeight != lineHeight) return false;
        if ((options.wordBreak === true && !options.wordBreak) || (options.wordBreak == false && options.wordBreak)) return false;
        return true;
    }

    //*** Event handlers
    function loop() {
    }

    //*** Public methods
    this.destroy = function() {
        _this.mesh && _this.mesh.destroy && _this.mesh.destroy();
    }

    this.ready = this.loaded = function() {
        return _promise;
    }

    this.centerY = function() {
        _this.mesh.position.y = _this.height * 0.5;
        _this.needsCenterY = true;
    }

    this.resize = function(options) {
        return this.setText(text, options);
    }

    this.tweenColor = function(c, time = 300, ease = 'easeOutCubic') {
        if (c) color.tween(c, time, ease);
    }

    this.setColor = function(c) {
        if (c) color.set(c);
    }

    this.setText = function(txt, options) {
        if (text == txt && match(options)) return;
        text = txt;
        if (!text) return;
        setVars(options || {});
        overrideParams();

        _this.string = text;

        _this.charLength = text.length;
        _this.text = new GLTextGeometry({font, italic, bold, text, width, align, direction, wordSpacing, letterSpacing, paragraphSpacing, size, lineHeight, wordBreak, langBreak, config});

        resetOverride();
        _promise = Promise.create();
        _this.text.loaded.then(({ buffers, height }) => {
            updateGeometry(buffers);

            _this.height = height;

            if (_this.needsCenterY) _this.centerY();
            _promise.resolve();
        });

        return _promise;
    }

    this.getData = function() {
        return {font, italic, bold, text, width, align, direction, wordSpacing, letterSpacing, paragraphSpacing, size, lineHeight, wordBreak, langBreak, color};
    }
}, _ => {
    GLText.FONT_CONFIG = {};
});

Class(function GLTextGeometry({
    font,
    italic,
    bold,
    text,
    width = Infinity,
    align = 'left',
    size = 1,
    direction = 'ltr',
    letterSpacing = 0,
    paragraphSpacing = 1,
    lineHeight = 1.4,
    wordSpacing = 0,
    wordBreak = false,
    langBreak = false,
    config = {}
}) {
    let _this = this;
    let json, texture, glyphs, buffers;
    let bJson, bTexture, bGlyphs;
    let iJson, iTexture, iGlyphs;
    let fontHeight, baseline, scale;

    _this.loaded = Promise.create();
    _this.fontLoaded = Promise.create();

    (async function init() {
        await loadFont();
        createGeometry();
    })();

    async function loadFont() {
        [json, texture, glyphs] = await GLTextGeometry.loadFont(font);
        if ( bold ) [bJson, bTexture, bGlyphs] = await GLTextGeometry.loadFont(bold);
        if ( italic ) [iJson, iTexture, iGlyphs] = await GLTextGeometry.loadFont(italic);
        _this.fontLoaded.resolve();
    }

    async function createGeometry() {
        let buffers = await GLTextThread.generate({
			font, bold, italic, text, width, align, size, direction, letterSpacing,
			paragraphSpacing, lineHeight, wordSpacing, wordBreak, langBreak,
			json, glyphs, bJson, bGlyphs, iJson, iGlyphs, config
        });

        _this.buffers = buffers;
        _this.texture = texture;
        _this.textureBold = bTexture;
        _this.textureItalic = iTexture;
        _this.numLines = buffers.lineLength;
        _this.height = _this.numLines * size * lineHeight;

        _this.onLayout && _this.onLayout(buffers, texture, _this.height, _this.numLines);

        _this.loaded.resolve({buffers, texture, textureBold: bTexture, textureItalic: iTexture, height: _this.height, numLines: _this.numLines});
    }
}, _ => {
    async function loadJSON(font) {
        return await get(getPathTo(font, 'json'));
    }

    async function loadTexture(font) {
        // check for existence of compressed versions of the texture
        let base = `${getFontPath(font)}${font}`;
        let candidates = [`${base}.ktx2`, Assets.supportsWebP() && `${base}.webp`].filter(Boolean);
        let path = candidates.find(candidate => (window.ASSETS?.SW || []).includes(candidate)) || `${base}.png`;
        let texture = await Utils3D.getTexture(path);
        texture.generateMipmaps = false;
        texture.minFilter = Texture.LINEAR;
        return texture;
    }

    function getPathTo(font, ext) {
        let fontName = GLTextGeometry.fontMapping[font] || font;
        let suffix = ext ? `.${ext}` : '';
        // suffix = `${suffix}?${window._CACHE_ || Date.now()}`;
        return Assets.getPath(`${getFontPath(font)}${fontName}${suffix}`);
    }

    function getFontPath(font) {
        if (GLTextGeometry.fontMapping[font] && GLTextGeometry.fontPath) {
            return GLTextGeometry.fontPath;
        }
        return 'assets/fonts/';
    }

    let _promises = {};

    GLTextGeometry.fontMapping = {};
    GLTextGeometry.chars = {};

    GLTextGeometry.loadFont = function(font) {
        if (!_promises[font]) {
            let promise = Promise.create();
            _promises[font] = promise;

            (async function() {
                let [json, texture] = await Promise.all([loadJSON(font), loadTexture(font)]);
                let glyphs = {};
                json.chars.forEach(d => glyphs[d.char] = d);
                promise.resolve([json, texture, glyphs]);
                GLTextGeometry.chars[font] = json.chars;
            })();
        }

        return _promises[font];
    };
});

Class(function GLTextThread() {
    const _this = this;

    //*** Constructor
    (function () {
        Thread.upload(loadTextGeometry);
    })();

    function loadTextGeometry({font, bold, italic, text, width, align, size, direction, letterSpacing, paragraphSpacing, lineHeight, wordSpacing, wordBreak, langBreak, json, glyphs, bJson, bGlyphs, iJson, iGlyphs, config}, pid) {
        const newline = /\n/;
        const whitespace = /[^\S ]/; // matches whitespace except NBSP
        const langbreak = langBreak ? new RegExp( langBreak ) : false;
        const dir = direction === 'rtl' ? -1: 1;

        if (!config) config = {};

        config.boldBaseOffset = config.boldBaseOffset ? config.boldBaseOffset : 0;
        config.italicBaseOffset = config.italicBaseOffset ? config.italicBaseOffset : 0;

        let weights = [];
        let weight = {
            0: glyphs,
            1: bGlyphs,
            2: iGlyphs
        };

        var buffers;

        setWeights();
        createGeometry();

        function setWeights() {
            let i = 0;
            let w = 0;
            while ( i < text.length ) {
                let code = text.substring(i, i+3).toLowerCase();
                let endcode = text.substring(i, i+4).toLowerCase();

                if ( code === '<b>' || code === '<i>') {
                    w = code === '<b>' ? 1 : 2;
                    text = text.substr(0,i) + text.substr(i + 3);
                }

                if ( endcode === '</b>' || endcode === '</i>') {
                    w = 0;
                    text = text.substr(0,i) + text.substr(i + 4);
                }

                weights.push(w);
                i++;
            }
        }

        function createGeometry() {
            fontHeight = json.common.lineHeight;
            baseline = json.common.base;

            // Use baseline so that actual text height is as close to 'size' value as possible
            scale = size / baseline;

            // Strip spaces and newlines to get actual character length for buffers
            let chars = text.replace(/[ \n]/g, '');
            let numChars = chars.length;

            // Create output buffers
            buffers = {
                position: new Float32Array(numChars * 4 * 3),
                uv: new Float32Array(numChars * 4 * 2),
                local: new Float32Array(numChars * 4 * 2),
                animation: new Float32Array(numChars * 3 * 4),
                index: new Uint16Array(numChars * 6),
                weight: new Float32Array( numChars * 4 )
            };

            // Set values for buffers that don't require calculation
            for (let i = 0; i < numChars; i++) {
                buffers.index.set([i * 4, i * 4 + 2, i * 4 + 1, i * 4 + 1, i * 4 + 2, i * 4 + 3], i * 6);
            }

            layout();
        }

        function layout() {
            const lines = [];

            let cursor = 0;

            let wordCursor = 0;
            let wordWidth = 0;
            let line = newLine();

            function newLine( br = false ) {
                const line = {
                    width: 0,
                    glyphs: [],
                };
                if ( lines.last() ) lines.last().br = br;
                lines.push(line);
                wordCursor = cursor;
                wordWidth = 0;
                return line;
            }

            // let maxTimes = 999;
            // let count = 0;
            while (cursor < text.length) {
                // count++;

                let prev = text[cursor - 1];
                let char = text[cursor];
                let next = text[cursor + 1];
                // if (!glyphs[char]) char = 'x';

                // Skip whitespace at start of line
                if (!line.width && whitespace.test(char) && !(prev && newline.test(char) && newline.test(prev))) {
                    cursor++;
                    wordCursor = cursor;
                    wordWidth = 0;
                    continue;
                }

                // If newline char, skip to next line
                if (newline.test(char)) {
                    cursor++;
                    line = newLine( true );
                    continue;
                }

                let style = weight[weights[cursor]] || weight[0];
                let glyph = style[char];
                if (!glyph) {
                    console.warn(`font ${font} missing character '${char}'`);
                    char = Object.keys(style)[0];
                    glyph = style[char];
                }

                glyph.weight = weights[cursor];


                // Find any applicable kern pairs
                if (line.glyphs.length) {
                    const prevGlyph = line.glyphs[line.glyphs.length - 1][0];
                    let kern = getKernPairOffset(glyph.id, prevGlyph.id) * scale;
                    line.width += kern;
                    wordWidth += kern * dir;
                }

                // add char to line
                let gl = Object.assign({}, glyph);
                gl.weight = weights[cursor];
                line.glyphs.push([gl, line.width]);

                // calculate advance for next glyph
                let advance = 0;

                // If whitespace, update location of current word for line breaks
                if (whitespace.test(char)) {
                    gl.whitespace = true;
                    wordCursor = cursor;
                    wordWidth = 0;

                    // Add wordspacing
                    advance += wordSpacing * size;
                } else {

                    // Add letterspacing
                    advance += letterSpacing * size;
                }

                advance += glyph.xadvance * scale;

                line.width += advance;
                wordWidth += advance;

                // If width defined
                if (line.width > width) {

                    // If can break words, undo latest glyph if line not empty and create new line
                    if ((wordBreak || ( char && langBreak && !langbreak.test(char))) && line.glyphs.length > 1) {
                        line.width -= advance;
                        line.glyphs.pop();
                        line = newLine();
                        continue;

                        // If not first word, undo current word and cursor and create new line
                    } else if (!wordBreak && wordWidth !== line.width) {
                        let numGlyphs = cursor - wordCursor + 1;
                        line.glyphs.splice(-numGlyphs, numGlyphs);
                        cursor = wordCursor;
                        line.width -= wordWidth;
                        line = newLine();
                        continue;
                    }
                }

                cursor++;
            }

            // Remove last line if empty
            if (!line.width) lines.pop();

            // If justify
            if (align === 'justify') {
                let max = -Infinity;
                lines.forEach(l => {
                    l.whitespaces = 0;
                    if (max < l.width) max = l.width;
                    l.glyphs.forEach(g => {
                        if (g[0].whitespace) l.whitespaces++;
                    })
                });

                // Calc how much we should add to each whitespace so all lines are equal width
                lines.forEach(l => {
                    let totalToAdd = max - l.width;
                    let addToWhitespace = l.whitespaces === 0 ? 0 : totalToAdd / l.whitespaces;

                    l.width = max;

                    let additionalOffset = 0;
                    l.glyphs.forEach(g => {
                        g[1] += additionalOffset;
                        if (g[0].whitespace) additionalOffset += addToWhitespace;
                    })
                });
            }

            populateBuffers(lines);
        }

        function populateBuffers(lines) {
            const texW = json.common.scaleW;
            const texH = json.common.scaleH;
            const baseOffset = config.baseOffset ? config.baseOffset : 0.07;

            // For all fonts tested, a little offset was needed to be right on the baseline, hence 0.07.
            let y = baseOffset * size;
            let j = 0;

            let glyphIndex = 0;
            let wordIndex = -1;
            let lineId = -1;

            for (let lineIndex = 0; lineIndex < lines.length; lineIndex++) {
                let line = lines[lineIndex];

                wordIndex++;
                lineId++;

                for (let i = 0; i < line.glyphs.length; i++) {
                    const glyph = line.glyphs[i][0];
                    let x = line.glyphs[i][1];

                    if ( dir === -1 ) x = line.width - x;
                    if (align === 'center' || align === 'justify') {
                        x -= line.width * 0.5;
                    } else if (align === 'right') {
                        x -= line.width * dir;
                    }

                    // If space, don't add to geometry
                    if (whitespace.test(glyph.char)) {
                        wordIndex++;
                        continue;
                    }

                    if ( glyph.weight === 1 ) y += config.boldBaseOffset * scale;
                    if ( glyph.weight === 2 ) y += config.italicBaseOffset * scale;

                    // Apply char sprite offsets
                    x += glyph.xoffset * scale * dir;
                    y -= glyph.yoffset * scale;

                    buffers.weight.set([
                        glyph.weight,
                        glyph.weight,
                        glyph.weight,
                        glyph.weight
                    ], glyphIndex * 4 );

                    // each letter is a quad. axis bottom left
                    let w = glyph.width * scale;
                    let h = glyph.height * scale;

                    if ( dir === -1 ) {
						buffers.position.set([
							x - w,  y - h, 0,
							x - w,  y,     0,
							x, 		y - h, 0,
							x, 		y,     0
						], j * 4 * 3);
					} else {
						buffers.position.set([
							x,     y - h, 0,
							x,     y,     0,
							x + w, y - h, 0,
							x + w, y,     0
						], j * 4 * 3);
					}

                    buffers.animation.set([
                        glyphIndex, wordIndex, lineId,
                        glyphIndex, wordIndex, lineId,
                        glyphIndex, wordIndex, lineId,
                        glyphIndex, wordIndex, lineId
                    ],  glyphIndex * 3 *  4);

                    glyphIndex++;

                    let u = glyph.x / texW;
                    let uw = glyph.width / texW;
                    let v = 1.0 - glyph.y / texH;
                    let vh = glyph.height / texH;
                    buffers.uv.set([
                        u,      v - vh,
                        u,      v,
                        u + uw, v - vh,
                        u + uw, v,
                    ], j * 4 * 2);

                    buffers.local.set([
                        0,      1,
                        0,      0,
                        1,      1,
                        1,      0,
                    ], j * 4 * 2);

                    if ( glyph.weight === 1 ) y -= config.boldBaseOffset * scale;
                    if ( glyph.weight === 2 ) y -= config.italicBaseOffset * scale;

                    // Reset cursor to baseline
                    y += glyph.yoffset * scale;

                    j++;
                }

                y -= size * lineHeight * ( line.br ? paragraphSpacing : 1 );
            }

            let geom;
            if (window.zUtils3D) {
                geom = new Geometry();
                geom.addAttribute('position', new GeometryAttribute(buffers.position, 3));
                geom.computeBoundingBox();
                geom.computeBoundingSphere();
            }

            let backing = [];
            for (let key in buffers) {
                backing.push(buffers[key].buffer);
            }

            buffers.lineLength = lines.length;
            if (geom) {
                buffers.boundingBox = geom.boundingBox;
                buffers.boundingSphere = geom.boundingSphere;
            }
            buffers.letterCount = glyphIndex;
            buffers.lineCount = lineId;
            buffers.wordCount = wordIndex;

            resolve(buffers, pid, backing);
        }

        function getKernPairOffset(id1, id2) {
            for (let i = 0; i < json.kernings.length; i++) {
                let k = json.kernings[i];
                if (k.first < id1) continue;
                if (k.second < id2) continue;
                if (k.first > id1) return 0;
                if (k.first === id1 && k.second > id2) return 0;
                return k.amount;
            }
            return 0;
        }
    }

    //*** Event handlers

    //*** Public methods
    this.generate = async function(obj) {
        return Thread.shared().loadTextGeometry(obj);
    }
}, 'static');

    /**
     * @name this.init
     * @memberof GLUI
     *
     * @function
     * @param is2D
     * @param is3D
    */
/**
 * @name GLUI
 */
Class(function GLUI() {
    Inherit(this, Component);
    const _this = this;

    const hasMetal = !!window.Metal;
    const hasAuraAR = !!window.AURA_AR;

    function loop() {
        if (hasMetal) return;

        //sad little workaround for native AR
        if (hasAuraAR && AURA_AR.active) {
            World.NUKE.postRender = null;
            AURA_AR.postRender = loop;
        }

        if (_this.Scene) _this.Scene.render();
        if (_this.Stage) _this.Stage.render();
    }

    //*** Event handlers

    //*** Public methods
    window.$gl = function(width, height, map, customCompile) {
        return new GLUIObject(width, height, map, customCompile);
    }

    window.$glText = function(text, fontName, fontSize, options, customCompile) {
        return new GLUIText(text, fontName, fontSize, options, customCompile);
    }

    this.init = async function(is2D, is3D) {
        if (_this.initialized) return;

        if (is2D === undefined) {
            is2D = true;
            is3D = true;
        }

        await AssetLoader.waitForLib('zUtils3D');
        if (is2D) _this.Stage = new GLUIStage();
        if (is3D) {
            _this.Scene = new GLUIStage3D();
            _this.Scene.interaction.input = Mouse;
        }

        _this.wait(World, 'NUKE', _ => {
            _this.initialized = true;
            if (_this.Scene) World.NUKE.onBeforeRender = _this.Scene.mark;
            World.NUKE.postRender = loop;
        });
    }

    /**
     * @name this.clear
     * @memberof GLUI
     *
     * @function
    */
    this.clear = function() {
        _this.Stage.clear();
        _this.Scene.clear();
    }

    /**
     * @name this.ready
     * @memberof GLUI
     *
     * @function
    */
    this.ready = function() {
        return _this.wait(_this, 'initialized');
    }

    /**
     * @name this.renderDirect
     * @memberof GLUI
     *
     * @function
     * @param render
    */
    this.renderDirect = function(render) {
        if (_this.Scene) _this.Scene.renderDirect(render);
        if (_this.Stage) _this.Stage.renderDirect(render);
    }
}, 'static');
/**
 * @name GLUIElement
 */
Class(function GLUIElement() {
    Inherit(this, Component);
    const _this = this;

    this.element = $gl();

    /**
     * @name this.create
     * @memberof GLUIElement
     *
     * @function
     * @param w
     * @param h
     * @param t
    */
    this.create = function (w, h, t) {
        return this.element.create(w, h, t);
    }
});
Class(function GLUIUtils () {
    const _this = this;

    //*** Constructor
    (function () {

    })()

    //*** Event handlers

    //*** Public methods

    /**
     * Enables or disables “retina mode” for the given GLUI $obj - that is,
     * whether the object is rendered as part of the main 3D scene at the
     * configured DPR, or rendered directly to the framebuffer at the canvas’
     * full native resolution.
     * For convenience, this function can also be used to add a newly created
     * GLUI object to the scene with the requested `retinaMode` setting, by
     * passing the object’s logical parent as the third parameter.
     * If `parent` is omitted, and the object is not already in the scene,
     * this function does nothing.
     * If the renderer does not support retina mode, the `retinaMode` parameter
     * is effectively ignored - the GLUI object is always added to the main
     * scene.
     *
     * @name GLUIUtils.setRetinaMode()
     * @memberof GLUIUtils
     *
     * @param $obj GLUIObject
     * @param retinaMode boolean
     * @param parent Base3D
     */
    _this.setRetinaMode = function($obj, retinaMode, parent) {
        if (RenderManager.type === RenderManager.WEBVR) retinaMode = false;
        if (!parent) {
            parent = ($obj.anchor && $obj.anchor._parent) || $obj.group._parent;
            if (!parent) return;
        }
        if (retinaMode) {
            let gluiToRTScene;
            let p = parent;
            while (p) {
                if (p.glSceneEnabled) gluiToRTScene = p;
                p = p.parent;
            }

            if (gluiToRTScene) {
                gluiToRTScene.glScene.add($obj);
            } else {
                GLUI.Scene.add($obj); // Note: this may replace obj.anchor
            }

            parent.add($obj.anchor);
            $obj.anchor.retinaAnchorFor = $obj;
            if ($obj.group.asyncPromise && !$obj.anchor.asyncPromise) {
                $obj.anchor.asyncPromise = $obj.group.asyncPromise;
            }
            if (
                !$obj.anchor.position.equals($obj.group.position) ||
                !$obj.anchor.scale.equals($obj.group.scale) ||
                !$obj.anchor.quaternion.equals($obj.group.quaternion)
            ) {
                $obj.isDirty = true;
                $obj.mesh && $obj.mesh.onBeforeRender && $obj.mesh.onBeforeRender();
            }
        } else {
            if (_this.isRetinaMode($obj)) {
                parent.remove($obj.anchor);
                GLUI.Scene.remove($obj);
                $obj.anchor._parent = null;
                $obj.group.visible = parent.determineVisible(); // because mark() in GLUIStage3D may have set this to false, and it won’t be called again.
                // Because loop() in GLUIStage3D decomposes the anchor’s world matrix into the group,
                // will need to reset the group transform.
                if (typeof $obj.isDirty === 'boolean' && $obj.mesh && $obj.mesh.onBeforeRender) {
                    $obj.isDirty = true;
                    $obj.mesh.onBeforeRender();
                } else {
                    $obj.group.position.setScalar(0);
                    $obj.group.quaternion.set(0, 0, 0, 1);
                    $obj.group.scale.setScalar(1);
                }
                $obj.deferred = false;
                $obj.parent = null;
            }
            parent.add($obj.group);
        }
    };

    /**
     * Returns `true` if the given GLUI object will be rendered in “retina mode”.
     * Always returns `false` on VR where there is no retina mode.
     *
     * @name GLUIUtils.isRetinaMode()
     * @memberof GLUIUtils
     *
     * @param $obj GLUIObject
     * @return boolean
     */
    _this.isRetinaMode = function($obj) {
        return RenderManager.type !== RenderManager.WEBVR &&
            $obj.anchor && $obj.anchor._parent && $obj.parent === GLUI.Scene;
    }

}, 'static')

/**
 * @name GLUIBatch
 */
Class(function GLUIBatch(globalUniforms = {}, _useWorldCoords, cacheSuffix = '') {
    Inherit(this, Component);
    const _this = this;
    var _timer, _geometry, _shader;

    var _objects = [];

   /**
    * @name group
    * @memberof GLUIBatch
    * @property
    */
    this.group = new Group();

    //*** Constructor
    (function () {
        if (typeof globalUniforms === 'boolean') {
            _useWorldCoords = globalUniforms;
            globalUniforms = {};
        }
        if (!GLUIBatch.cache) GLUIBatch.cache = {};
        _this.startRender(loop);
    })();

    function loop() {
        if (!_geometry) return;

        for (let i = 0; i < _objects.length; i++) {
            let obj = _objects[i];
            if (!obj._buffers) continue;

            obj.mesh.onBeforeRender();

            if (_useWorldCoords) {
                obj.group.updateMatrixWorld();
                obj.mesh.getWorldPosition(obj.worldPosition);
                obj.worldRotation.setFromQuaternion(obj.mesh.getWorldQuaternion());
                obj.mesh.getWorldScale(obj.worldScale);
            }

            obj._buffers.forEach(buffer => {
                let dirty = false;
                dirty = !buffer.value.equals(buffer.lookup);
                buffer.value.copy(buffer.lookup);

                if (dirty) {
                    let attribute = _geometry.attributes[buffer.key];
                    let array = attribute.array;
                    switch (buffer.key) {
                        case 'scale':
                            if (_useWorldCoords) {
                                array[i * 2 + 0] = obj.worldScale.x;
                                array[i * 2 + 1] = obj.worldScale.y;
                            } else {
                                array[i * 2 + 0] = obj.group.scale.x * obj.mesh.scale.x;
                                array[i * 2 + 1] = obj.group.scale.y * obj.mesh.scale.y;
                            }
                            break;

                        case 'rotation':
                            array[i] = buffer.lookup.z;
                            break;

                        default:
                            if (!_useWorldCoords) {
                                array[i * 3 + 0] = obj.group.position.x;
                                array[i * 3 + 1] = obj.group.position.y;
                            } else {
                                array[i * 3 + 0] = obj.worldPosition.x;
                                array[i * 3 + 1] = obj.worldPosition.y;
                            }
                            array[i * 3 + 2] = obj.mesh.renderOrder;
                            break;
                    }

                    attribute.needsUpdate = true;
                }
            });

            obj._uniforms.forEach(uniform => {
                let dirty = false;
                if (uniform.type == 'f') {
                    dirty = obj.mesh.shader.uniforms[uniform.key].value != uniform.value;
                    uniform.value = obj.mesh.shader.uniforms[uniform.key].value;
                } else {
                    dirty = !obj.mesh.shader.uniforms[uniform.key].value.equals(uniform.value);
                    uniform.value.copy(obj.mesh.shader.uniforms[uniform.key].value);
                }

                if (dirty) {
                    let attribute = _geometry.attributes['a_' + uniform.key];
                    let array = attribute.array;

                    if (uniform.type == 'f') {
                        array[i] = uniform.value;
                    } else {
                        uniform.value.toArray(array, i * uniform.components);
                    }

                    attribute.needsUpdate = true;
                }
            });
        }
    }

    function getTypeFromSize(size) {
        switch (size) {
            case 1: return 'float'; break;
            case 2: return 'vec2'; break;
            case 3: return 'vec3'; break;
            case 4: return 'vec4'; break;
        }
    }

    function createMesh() {
        let obj = _objects[0];
        let shader = obj.mesh.shader;
        _geometry = new Geometry().instanceFrom(_objects[0].mesh.geometry.clone());

        let map = {};
        let arrays = {};
        _objects.forEach((obj, i) => {
            obj.mesh.onBeforeRender();

            let buffers = [];
            let uniforms = [];
            for (let key in shader.uniforms) {
                let uniform = shader.uniforms[key];
                if (!uniform) continue;
                if (uniform.value instanceof Color) uniforms.push({key, type: 'c', components: 3});
                if (uniform.value instanceof Vector4) uniforms.push({key, type: 'v4', components: 4});
                if (uniform.value instanceof Vector3) uniforms.push({key, type: 'v3', components: 3});
                if (uniform.value instanceof Vector2) uniforms.push({key, type: 'v', components: 2});
                if (typeof uniform.value === 'number') uniforms.push({key, type: 'f', components: 1});
            }

            if (_useWorldCoords) {
                obj.worldScale = new Vector3();
                obj.worldRotation = new Euler();
                obj.worldPosition = new Vector3();
            }

            buffers.push({key: 'scale', lookup: _useWorldCoords ? obj.worldScale : obj.group.scale, components: 2});
            buffers.push({key: 'rotation', lookup: _useWorldCoords ? obj.worldRotation : obj.group.rotation, components: 1});
            buffers.push({ key: 'offset', lookup: _useWorldCoords ? obj.worldPosition : obj.group.position, components: 3 });

            uniforms.forEach(uniform => {
                if (!arrays['a_' + uniform.key]) arrays['a_' + uniform.key] = [];
                if (!map['a_' + uniform.key]) map['a_' + uniform.key] = uniform;
                let value = shader.uniforms[uniform.key].value;
                if (typeof value === 'object') {
                    uniform.value = value.clone();
                    uniform.value.toArray(arrays['a_' + uniform.key], i * uniform.components);
                } else {
                    uniform.value = shader.uniforms[uniform.key].value;
                    arrays['a_' + uniform.key].push(uniform.value);
                }
            });

            buffers.forEach(buffer => {
                if (!arrays[buffer.key]) arrays[buffer.key] = [];
                if (!map[buffer.key]) map[buffer.key] = buffer;
                buffer.value = buffer.lookup.clone();

                switch (buffer.key) {
                    case 'scale':
                        arrays[buffer.key].push(obj.group.scale.x * obj.mesh.scale.x, obj.group.scale.y * obj.mesh.scale.y);
                        break;

                    case 'rotation':
                        arrays[buffer.key].push(buffer.lookup.z);
                        break;

                    default:
                        arrays[buffer.key].push(buffer.lookup.x, buffer.lookup.y, obj.mesh.renderOrder);
                        break;
                }
            });

            obj._buffers = buffers;
            obj._uniforms = uniforms;

            obj.shader.neverRender = true;
        });

        let attributes = [];
        let defines = [];
        for (let key in map) {
            if (key.includes('a_')) {
                attributes.push(`% ${getTypeFromSize(map[key].components)} ${key};`);
                defines.push(`${key.replace('a_', 'v_')} = ${key};`);
            }
        }
        attributes = attributes.join('\n');
        defines = defines.join('\n');

        for (let key in arrays) {
            _geometry.addAttribute(key, new GeometryAttribute(new Float32Array(arrays[key]), map[key].components, 1));
        }

        let cacheKey = shader.fsName + cacheSuffix;

        if (GLUIBatch.cache[cacheKey]) _shader = GLUIBatch.cache[cacheKey];
        else {
            _shader = _this.initClass(Shader, 'GLUIBatch', shader.fsName, Object.assign({}, {
                transparent: true,
                depthWrite: false,
                depthTest: false,
                customCompile: Utils.uuid()
            }, globalUniforms));

            let vsSplit = _shader.vertexShader.split('__ACTIVE_THEORY_LIGHTS__');
            let fsSplit = _shader.fragmentShader.split('__ACTIVE_THEORY_LIGHTS__');

            let definitions = [];
            fsSplit[1].split('\n').forEach(line => {
                if (line.includes('uniform')) {
                    if (line.includes('sampler2D')) return;
                    let data = line.split(' ');
                    definitions.push(`${data[2].replace(';', '')} = a_${data[2]}`);
                    vsSplit[1] = `\nattribute ${data[1]} a_${data[2]}\nvarying ${data[1]} ${data[2]}` + vsSplit[1];
                    vsSplit[1] = vsSplit[1].replace(line, '');
                    fsSplit[1] = fsSplit[1].replace(line, `varying ${data[1]} ${data[2]}`);
                }
            });

            vsSplit[1] = vsSplit[1].replace('//vdefines', '\n' + definitions.join('\n'));

            _shader.vertexShader = vsSplit.join('__ACTIVE_THEORY_LIGHTS__');
            _shader.fragmentShader = fsSplit.join('__ACTIVE_THEORY_LIGHTS__');

            GLUIBatch.cache[cacheKey] = _shader;
        }

        shader.copyUniformsTo(_shader);
        _this.mesh = new Mesh(_geometry, _shader);
        _this.mesh.frustumCulled = false;
        _this.group.add(_this.mesh);
    }

    //*** Event handlers

    //*** Public methods
    /**
     * @name this.add
     * @memberof GLUIBatch
     *
     * @function
     * @param obj
    */
    this.add = function(obj) {
        clearTimeout(_timer);
        _timer = _this.delayedCall(createMesh, 50);
        if (_useWorldCoords) {
            let getAlpha = obj.getAlpha;
            if (getAlpha) {
                obj.getAlpha = () => {
                    let parentAlpha = _this.parent ? _this.parent.getAlpha() : 1;
                    return parentAlpha * getAlpha.call(obj);
                };
            }
        } else {
            _this.parent.add(obj);
        }
        _objects.push(obj);
    }

    /**
     * @name this.setZ
     * @memberof GLUIBatch
     *
     * @function
     * @param z
     */
    this.setZ = async function(z) {
        await _this.wait('mesh');
        _this.mesh.renderOrder = z;
    }

    /**
     * @name this.onDestroy
     * @memberof GLUIBatch
     *
     * @function
    */
    this.onDestroy = function() {
        if (_this.mesh) {
            _this.mesh.destroy();
        }
    }
});

/**
 * @name GLUIBatchText
 */
 Class(function GLUIBatchText(globalUniforms = {}, _useWorldCoords, _shaderName) {
    Inherit(this, Component);
    const _this = this;
    var _geometry, _shader, _timer, _forceUpdate;

    var _promises = [];
    var _toSplice = [];
    var _objects = [];
    var _offset = 0;

   /**
    * @name group
    * @memberof GLUIBatchText
    * @property
    */
    this.group = new Group();
    this.enable3D = () => {};

    //*** Constructor
    (function () {
        if (typeof globalUniforms === 'boolean') {
            _useWorldCoords = globalUniforms;
            globalUniforms = {};
        }
        _this.flag('canLoad', true);
        _this.startRender(loop);
    })();

    function loop() {
        if (!_geometry) return;
        let updated = false;

        for (let key in _geometry.attributes) {
            let attrib = _geometry.attributes[key];
            if (attrib.updateRange.length) attrib.updateRange.length = 0;
        }

        let len = _objects.length;
        for (let i = 0; i < len; i++) {
            let obj = _objects[i];
            obj.mesh.onBeforeRender();

            if (_useWorldCoords) {
                obj.group.updateMatrixWorld();
                obj.mesh.getWorldPosition(obj.worldPosition);
                obj.worldRotation.setFromQuaternion(obj.mesh.getWorldQuaternion());
                obj.mesh.getWorldScale(obj.worldScale);
            }

            let offset = obj._offset;
            let count = obj._count;
            let end = offset + count;

            obj._buffers.forEach(buffer => {
                let dirty = false;
                dirty = !buffer.value.equals(buffer.lookup);
                buffer.value.copy(buffer.lookup);

                if (dirty) {
                    let array = _geometry.attributes[buffer.key].array;
                    for (let j = offset; j < end; j++) {
                        switch (buffer.components) {
                            case 4:
                                array[j * 4 + 0] = buffer.lookup.x;
                                array[j * 4 + 1] = buffer.lookup.y;
                                array[j * 4 + 2] = buffer.lookup.z;
                                array[j * 4 + 3] = buffer.lookup.w;
                                break

                            case 3:
                                array[j * 3 + 0] = buffer.lookup.x;
                                array[j * 3 + 1] = buffer.lookup.y;
                                array[j * 3 + 2] = buffer.lookup.z;
                                break;

                            case 2:
                                array[j * 2 + 0] = buffer.lookup.x;
                                array[j * 2 + 1] = buffer.lookup.y;
                                break;

                            case 1:
                                array[j] = buffer.lookup.z;
                                break;
                        }
                    }

                    updated = true;
                    buffer.updateRange.offset = offset * buffer.components;
                    buffer.updateRange.count = count * buffer.components;
                    _geometry.attributes[buffer.key].updateRange.push(buffer.updateRange);
                    _geometry.attributes[buffer.key].needsUpdate = true;
                }
            });

            obj._uniforms.forEach(uniform => {
                let dirty = false;
                if (uniform.type == 'f') {
                    dirty = obj.mesh.shader.uniforms[uniform.key].value != uniform.value;
                    uniform.value = obj.mesh.shader.uniforms[uniform.key].value;
                } else {
                    dirty = !obj.mesh.shader.uniforms[uniform.key].value.equals(uniform.value);
                    uniform.value.copy(obj.mesh.shader.uniforms[uniform.key].value);
                }

                if (dirty || _forceUpdate) {
                    let array = _geometry.attributes['a_' + uniform.key].array;
                    for (let j = offset; j < end; j++) {
                        if (uniform.type == 'f') {
                            array[j] = obj.mesh.shader.uniforms[uniform.key].value;
                        } else {
                            obj.mesh.shader.uniforms[uniform.key].value.toArray(array, j * uniform.components);
                        }
                    }

                    updated = true;
                    uniform.updateRange.offset = offset * uniform.components;
                    uniform.updateRange.count = count * uniform.components;
                    _geometry.attributes['a_' + uniform.key].updateRange.push(uniform.updateRange);
                    _geometry.attributes['a_' + uniform.key].needsUpdate = true;
                }
            });
        }

        if (updated) {
            for (let key in _geometry.attributes) {
                let attrib = _geometry.attributes[key];
                if (!attrib.updateRange.length) continue;

                let bottom;
                let toSplice = _toSplice;
                toSplice.length = 0;
                for (let i = 0; i < attrib.updateRange.length; i++) {
                    let current = attrib.updateRange[i];
                    let prev = attrib.updateRange[i-1];
                    if (!prev) {
                        bottom = current;
                        continue;
                    }
                    let prevRange = prev.offset + prev.count;
                    if (prevRange == current.offset) {
                        bottom.count += current.count;
                        toSplice.push(i);
                    } else {
                        bottom = current;
                    }
                }
                for (let i = toSplice.length-1; i > -1; i--) attrib.updateRange.splice(toSplice[i], 1);
            }
        }
        _forceUpdate = false;
    }

    function addAttributes(obj, mesh) {
        let {geometry, shader} = mesh;
        let count = geometry.attributes.uv.count;

        mesh.onBeforeRender();

        let buffers = [];
        let uniforms = [];
        for (let key in shader.uniforms) {
            let uniform = shader.uniforms[key];
            if (uniform.value instanceof Color) uniforms.push({key, type: 'c', components: 3});
            if (uniform.value instanceof Vector3) uniforms.push({key, type: 'v3', components: 3});
            if (uniform.value instanceof Vector4) uniforms.push({key, type: 'v4', components: 4});
            if (uniform.value instanceof Vector2) uniforms.push({key, type: 'v', components: 2});
            if (typeof uniform.value === 'number') uniforms.push({key, type: 'f', components: 1});
        }

        if (_useWorldCoords) {
            obj.worldScale = new Vector3();
            obj.worldRotation = new Euler();
            obj.worldPosition = new Vector3();
        }

        buffers.push({key: 'offset', lookup: _useWorldCoords ? obj.worldPosition : obj.group.position, components: 3});
        buffers.push({key: 'scale', lookup: _useWorldCoords ? obj.worldScale : obj.group.scale, components: 2});
        buffers.push({key: 'rotation', lookup: _useWorldCoords ? obj.worldRotation : obj.group.rotation, components: 1});

        uniforms.forEach(uniform => {
            uniform.updateRange = {};
            uniform.value = shader.uniforms[uniform.key].value;
            if (typeof uniform.value === 'object') uniform.value = uniform.value.clone();
            uniform.buffer = new Float32Array(count * uniform.components);
        });

        buffers.forEach(buffer => {
            buffer.updateRange = {};
            buffer.value = buffer.lookup.clone();
            buffer.buffer = new Float32Array(count * buffer.components);
        });

        for (let i = 0; i < count; i++) {
            buffers.forEach(buffer => {
                switch (buffer.components) {
                    case 4:
                        buffer.buffer[i * 4 + 0] = buffer.lookup.x;
                        buffer.buffer[i * 4 + 1] = buffer.lookup.y;
                        buffer.buffer[i * 4 + 2] = buffer.lookup.z;
                        buffer.buffer[i * 4 + 3] = buffer.lookup.w;
                        break

                    case 3:
                        buffer.buffer[i * 3 + 0] = buffer.lookup.x;
                        buffer.buffer[i * 3 + 1] = buffer.lookup.y;
                        buffer.buffer[i * 3 + 2] = buffer.lookup.z;
                        break;

                    case 2:
                        buffer.buffer[i * 2 + 0] = buffer.lookup.x;
                        buffer.buffer[i * 2 + 1] = buffer.lookup.y;
                        break;

                    case 1:
                        buffer.buffer[i] = buffer.lookup.z;
                        break;
                }
            });

            uniforms.forEach(uniform => {
                if (uniform.type == 'f') uniform.buffer[i] = shader.uniforms[uniform.key].value;
                else shader.uniforms[uniform.key].value.toArray(uniform.buffer, i * uniform.components);
            });
        }

        buffers.forEach(buffer => {
            geometry.addAttribute(buffer.key, new GeometryAttribute(buffer.buffer, buffer.components));
        })

        uniforms.forEach(uniform => {
            geometry.addAttribute('a_' + uniform.key, new GeometryAttribute(uniform.buffer, uniform.components));
        });

        obj._offset = _offset;
        obj._count = count;
        obj._uniforms = uniforms;
        obj._buffers = buffers;
        _objects.push(obj);
        _offset += count;
    }

    function getTypeFromSize(size) {
        switch (size) {
            case 1: return 'float'; break;
            case 2: return 'vec2'; break;
            case 3: return 'vec3'; break;
            case 4: return 'vec4'; break;
        }
    }

    function initGeometry(mesh) {
        _shader = _this.initClass(Shader, _shaderName || 'GLUIBatchText', _shaderName || mesh.shader.fsName, Object.assign({}, {
            transparent: true,
            depthWrite: false,
            customCompile: `${mesh.shader.vsName}|${mesh.shader.fsName}|instance`,
        }, globalUniforms));

        if (!_shader.vertexShader) {
            _shader.resetProgram();
        }
        let vsSplit = _shader.vertexShader.split('__ACTIVE_THEORY_LIGHTS__');
        let fsSplit = _shader.fragmentShader.split('__ACTIVE_THEORY_LIGHTS__');

        let definitions = [];
        let definitionSplit = [];
        fsSplit[1].split('\n').forEach(line => {
            if (line.includes('uniform')) {
                if (line.includes('sampler2D')) return;
                let data = line.split(' ');
                definitions.push(`${data[2].replace(';', '')} = a_${data[2]}`);
                vsSplit[1] = `\nattribute ${data[1]} a_${data[2]}\nvarying ${data[1]} ${data[2]}` + vsSplit[1];
                vsSplit[1] = vsSplit[1].replace(line, '');
                fsSplit[1] = fsSplit[1].replace(line, `varying ${data[1]} ${data[2]}`);
            }
        });

        definitions.forEach(def => definitionSplit.push(def.split(' =')[0].trim()));

        let baseVS = Shaders.getShader(mesh.shader.vsName+'.vs');
        if (baseVS.includes('//start batch main')) {
            let main = baseVS.split('//start batch main')[1].split('//end batch main')[0];
            vsSplit[1] = vsSplit[1].replace('//custommain', main);

            let beforeMain = baseVS.split('void main() {')[0];
            beforeMain = beforeMain.replace('uniform sampler2D tMap;', '');
            beforeMain = beforeMain.replace('varying vec2 vUv;', '');
            beforeMain.split('\n').forEach(line => {
                definitionSplit.forEach(def => {
                    if (line.includes(def) && line.includes(['uniform', 'varying'])) {
                        beforeMain = beforeMain.replace(line, '');
                    }
                });
            });
            vsSplit[0] += beforeMain;
        }

        vsSplit[1] = vsSplit[1].replace('//vdefines', '\n' + definitions.join('\n'));

        _shader.vertexShader = vsSplit.join('__ACTIVE_THEORY_LIGHTS__');
        _shader.fragmentShader = fsSplit.join('__ACTIVE_THEORY_LIGHTS__');

        mesh.shader.copyUniformsTo(_shader);

        _geometry = mesh.geometry.clone();

        for (let key in _geometry.attributes) _geometry.attributes[key].updateRange = [];
    }

    async function createMesh() {
        if (_this.flag('mesh')) return;
        _this.flag('mesh', true);
        await Promise.all(_promises);
        await _this.wait(100);
        let mesh = new Mesh(_geometry, _shader);
        _this.mesh = mesh;
        mesh.frustumCulled = false;
        _this.group.add(mesh);
    }

    //*** Event handlers

    //*** Public methods
    /**
     * @name this.add
     * @memberof GLUIBatchText
     *
     * @function
     * @param obj
     */
    _this.add = async function(obj) {
        await _this.flag('canLoad');
        if (!_this.destroy) return;
        _this.flag('canLoad', false);
        await obj.loaded();
        obj.mesh.shader.neverRender = true;

        _promises.push(obj.loaded());

        addAttributes(obj, obj.mesh);

        if (_useWorldCoords) {
            let getAlpha = obj.getAlpha;
            if (getAlpha) {
                obj.getAlpha = () => {
                    let parentAlpha = _this.parent ? _this.parent.getAlpha() : 1;
                    return parentAlpha * getAlpha.call(obj);
                };
            }
        } else {
            _this.parent.add(obj);
        }

        if (!_geometry) initGeometry(obj.mesh);
        else _geometry.merge(obj.mesh.geometry);
        _this.flag('canLoad', true);

        clearTimeout(_timer);
        _timer = _this.delayedCall(createMesh, 50);

        obj.isDirty = true;
    }

    /**
     * @name this.forceUpdate
     * @memberof GLUIBatchText
     *
     * @function
    */
    _this.forceUpdate = function() {
        _forceUpdate = true;
    }

    /**
     * @name this.onDestroy
     * @memberof GLUIBatchText
     *
     * @function
    */
    _this.onDestroy = function() {
        if (_this.mesh) _this.mesh.destroy();
    }
});

Class(function GLUIStageInteraction2D(_camera, _scene, _stage, _custom) {
    Inherit(this, Component);
    const _this = this;
    var _ray, _over, _click, _customTest, _disabled, _blocked;

    var _test = [];
    var _objects = this.objects = [];
    var _hold = new Vector2();
    var _calc = new Vector2();
    var _lastTestedPoint = new Vector2();
    var _plane = new Plane();

    this.preventDoubleClickTime = 300;

    //*** Constructor
    (function () {
        addListeners();
        _this.startRender(_ => {});
    })();

    function cacheTopScene(obj) {
        let p = obj;
        while (p) {
            if (p instanceof Scene) obj.interactionScene = p;
            p = p._parent;
        }
    }

    function testObjects() {
        let objects = GLUI.Stage.interaction.objects;
        _test.length = 0;
        for (let i = objects.length-1; i > -1; i--) {
            let obj = objects[i];
            if (!obj.interactionScene) cacheTopScene(obj);
            if (obj.forceGLUIInteraction || (obj.determineVisible() && _scene == obj.interactionScene)) _test.push(obj);
        }
        return _test;
    }

    //*** Event handlers
    function addListeners() {
        if (!_custom) _this.events.sub(Mouse.input, Interaction.MOVE, move);
        _this.events.sub(Mouse.input, Interaction.START, start);
        _this.events.sub(Mouse.input, Interaction.END, end);
        _this.events.sub(Interaction3D.EXTERNAL_PRESS, externalStart);
        _this.events.sub(Interaction3D.EXTERNAL_RELEASE, externalRelease);
    }

    function externalStart() {
        if (_this._invisible) return;
        start(_lastTestedPoint);
    }

    function externalRelease() {
        if (_this._invisible) return;
        end(_lastTestedPoint);
    }

    function move(e) {
        if (GLUI.PREVENT_INTERACTION || _this._invisible || _disabled || _blocked) return;
        if (!_ray) {
            _ray = new Raycaster(_camera);
            _ray.testVisibility = false;
        }

        let objects = testObjects();
        if (!objects.length) {
            if (_over) {
                _over._onOver({action: 'out', object: _over});
                _over = null;
                Stage.cursor('auto');
            }
            return;
        }

        let hit = _ray.checkHit(objects, e, _stage);
        try {
            if (hit[0]) {
                if (!_customTest) GLUI.HIT = true;
                let obj = hit[0].object.glui;
                if (!_over) {
                    _over = obj;
                    _over._onOver({action: 'over', object: obj});
                    Stage.cursor('pointer');
                }

                if (_over != obj) {
                    _over._onOver({action: 'out', object: _over});
                    _over = obj;
                    _over._onOver({action: 'over', object: obj});
                    Stage.cursor('pointer');
                }
            } else {
                if (!_customTest) GLUI.HIT = false;
                if (_over) {
                    _over._onOver({action: 'out', object: _over});
                    _over = null;
                    Stage.cursor('auto');
                }
            }
        } catch(e) {
            console.warn(e);
        }
    }

    function start(e) {
        let handlingEvent = !(e instanceof Vector2);
        let checkDefault = GLUI.PREVENT_DEFAULT_INTERACTION && handlingEvent;
        let checkPrevention = GLUI.PREVENT_INTERACTION || _this._invisible || _disabled || _blocked;
        if (checkDefault || checkPrevention) return;
        // _custom means move() should only be called via testWith() and friends.
        if (!(_custom && handlingEvent) && (Device.mobile || RenderManager.type == RenderManager.WEBVR)) move(e);
        if (_over && !_click) {
            _click = _over;
            _hold.copy(e);
            _hold.time = Date.now();
        }
    }

    function end(e) {
        if (GLUI.PREVENT_INTERACTION || _this._invisible || _disabled || _blocked) return;

        if (_customTest) {
            if (Device.mobile) {
                if (_click && _over == null) _over = _click;
            }
        }

        GLUI.HIT = false;
        if (_click) {
            if (Date.now() - _hold.time > 750) return _click = null;
            if (_click == _over) {
                try {
                    _blocked = true;
                    _this.delayedCall(_ => {
                        _blocked = false;
                    }, _this.preventDoubleClickTime);

                    _click._onClick({action: 'click', object: _click});
                    if ((Device.mobile || _custom) && _over) {
                        _over._onOver({action: 'out', object: _over});
                        _over = null;
                        Stage.cursor('auto');
                    }
                } catch(e) {
                    console.warn(e);
                }
            }
        }

        _click = null;
    }

    //*** Public methods
    this.add = function(obj) {
        if (obj) _objects.push(obj.mesh || obj);
    }

    this.remove = function(obj) {
        if (obj) _objects.remove(obj.mesh || obj);
    }

    this.testWith = function(point, id) {
        point.customTest = true;
        _lastTestedPoint.copy(point);
        _lastTestedPoint.customTest = true;

        _customTest = true;

        move(point);
        if (Device.mobile && RenderManager.type != RenderManager.WEBVR) {
            if (_over) start(point);
        }
    }

    this.testWithFinger = function(point, distance, minDistance) {
        if (!_ray) {
            _ray = new Raycaster(_camera);
            _ray.testVisibility = false;
        }

        _customTest = true;

        let objects = testObjects();
        if (!objects.length) return;

        if (distance < 0.02) {
            let hit = _ray.checkHit(objects, point, _stage);
            try {
                if (hit[0]) {
                    let obj = hit[0].object.glui;
                    if (!obj._preventClickTime || Render.TIME - obj._preventClickTime > _this.preventDoubleClickTime) {
                        if (!obj._requiresClear) {
                            _over = obj;
                            obj._onOver({ action: 'over', object: obj });
                            obj._onClick({ action: 'click', object: obj });
                            obj._preventClickTime = Render.TIME;
                            obj._requiresClear = true;
                        }
                    }
                } else {
                    if (_over) {
                        _over._requiresClear = false;
                        _over._onOver({action: 'out', object: _over});
                        _over = null;
                    }
                }
            } catch (e) {
                console.warn(e);
            }
        } else {
            if (_over) {
                _over._requiresClear = false;
                _over._onOver({action: 'out', object: _over});
                _over = null;
            }
        }
    }

    function findCapture(object) {
        let capture = object.__slc;
        if (capture === undefined && window.UI3D) {
            return object.__slc = UI3D.findStageLayoutCapture(object) || null;
        }
        return capture;
    }

    this.checkObjectHit = function(object, mouse) {
        let capture = findCapture(object);
        if (capture) {
            return capture.checkObjectHit(object.mesh || object, mouse);
        }
        if (!_ray) {
            _ray = new Raycaster(_camera);
            _ray.testVisibility = false;
        }
        return _ray.checkHit(object.mesh || object, mouse, _stage)[0];
    };

    this.checkObjectFromValues = function(object, origin, direction) {
        let capture = findCapture(object);
        if (capture) {
            return capture.checkObjectFromValues(object.mesh || object, origin, direction);
        }
        if (!_ray) {
            _ray = new Raycaster(_camera);
            _ray.testVisibility = false;
        }
        return _ray.checkFromValues(object.mesh || object, origin, direction)[0];
    };

    this.getObjectHitLocalCoords = function(v, object, mouse) {
        let capture = findCapture(object);
        if (capture) {
            return capture.getObjectHitLocalCoords(v, object, mouse);
        }
        let hit = _this.checkObjectHit(object, mouse);
        if (hit) {
            v.copy(hit.point);
            return hit.object.worldToLocal(v);
        } else {
            // intersect with the infinite plane
            let mesh = object.mesh || object;
            _plane.normal.set(0, 0, 1).applyQuaternion(mesh.getWorldQuaternion());
            _plane.constant = -mesh.getWorldPosition().dot(_plane.normal);
            _ray.ray.intersectPlane(_plane, v);
            return mesh.worldToLocal(v);
        }
    };

    this.set('_disabled', v => {
        _disabled = v;
        if (_disabled) {
            _click = null;
            if (_over) {
                _over._onOver({action: 'out', object: _over});
                _over = null;
                Stage.cursor('auto');
            }
        }
    });

    this.onInvisible = () => {
        _click = null;
        if (_over) {
            _over._onOver({action: 'out', object: _over});
            _over = null;
            Stage.cursor('auto');
        }
    };
});

Class(function GLUIStageInteraction3D() {
    Inherit(this, Component);
    const _this = this;

    //*** Event handlers
    function onHover(e) {
        e.mesh.glui._onOver({action: e.action, object: e.mesh.glui});
    }

    function onClick(e) {
        e.mesh.glui._onClick({action: e.action, object: e.mesh.glui});
    }

    //*** Public methods
    this.add = function(obj, camera = World.CAMERA) {
        Interaction3D.find(camera).add(obj.mesh || obj, onHover, onClick);
    }

    this.remove = function(obj, camera = World.CAMERA) {
        Interaction3D.find(camera).remove(obj.mesh || obj);
    }

    this.checkObjectHit = function(object, mouse, camera = World.CAMERA) {
        return Interaction3D.find(camera).checkObjectHit(object.mesh, mouse);
    };

    this.checkObjectFromValues = function(object, origin, direction, camera = World.CAMERA) {
        return Interaction3D.find(camera).checkObjectFromValues(object.mesh, origin, direction);
    };

    this.getObjectHitLocalCoords = function(v, object, mouse, camera = World.CAMERA) {
        return Interaction3D.find(camera).getObjectHitLocalCoords(v, object.mesh, mouse);
    };
});
/**
 * @name GLUICornerPin
 */
Class(function GLUICornerPin($obj) {
    Inherit(this, Component);
    const _this = this;
    var _geom, _vertices, _last;

   /**
    * @name tl
    * @memberof GLUICornerPin
    * @property
    */
    this.tl = new Vector2(0, 0);
   /**
    * @name tr
    * @memberof GLUICornerPin
    * @property
    */
    this.tr = new Vector2($obj.width, 0);
   /**
    * @name bl
    * @memberof GLUICornerPin
    * @property
    */
    this.bl = new Vector2(0, $obj.height);
   /**
    * @name br
    * @memberof GLUICornerPin
    * @property
    */
    this.br = new Vector2($obj.width, $obj.height);

    //*** Constructor
    (function () {
        initGeometry();
        _this.startRender(loop);
    })();

    function initGeometry() {
        _geom = $obj.mesh.geometry.toNonIndexed();
        $obj.useGeometry(_geom);
        $obj.mesh.scale.set(1, 1, 1);

        _vertices = _geom.attributes.position.array;
        _last = new Float32Array(_vertices);
    }

    function loop() {
        _vertices[0] = _this.tl.x;
        _vertices[1] = -_this.tl.y;

        _vertices[3] = _vertices[9] = _this.bl.x;
        _vertices[4] = _vertices[10] = -_this.bl.y;

        _vertices[6] = _vertices[15] = _this.tr.x;
        _vertices[7] = _vertices[16] = -_this.tr.y;

        _vertices[12] = _this.br.x;
        _vertices[13] = -_this.br.y;

        if (dirty()) _geom.attributes.position.needsUpdate = true;
        _last.set(_vertices);
    }

    function dirty() {
        let a = _vertices;
        let b = _last;
        for (let i = a.length-1; i > -1; i--) {
            if (a[i] != b[i]) return true;
        }
        return false;
    }

    //*** Event handlers

    //*** Public methods
    /**
     * @name this.update
     * @memberof GLUICornerPin
     *
     * @function
    */
    this.update = function() {
        this.tl.set(0, 0);
        this.tr.set($obj.width, 0);
        this.bl.set(0, $obj.height);
        this.br.set($obj.width, $obj.height);
    }

    /**
     * @name this.tween
     * @memberof GLUICornerPin
     *
     * @function
     * @param type
     * @param val
     * @param time
     * @param ease
     * @param delay
    */
    this.tween = function(type, val, time, ease, delay) {
        val = val instanceof Vector2 ? val : new Vector2(val.x, val.y);
        return tween(_this[type], val, time, ease, delay);
    }
});

/**
 * @name GLUIObject
 */
class GLUIObject {
    constructor(width, height, map, customCompile) {
        let getMap = _ => {
            if (typeof map === 'string') {
                if (map.includes(['#', '0x'])) return map;
                if (map === 'empty' || map === '') return null;
                return Utils3D.getTexture(map, { premultiplyAlpha: false })
            }
            return map;
        };

        let shader = this.textureShader = new Shader('GLUIObject', {
            tMap: { value: null },
            uAlpha: { type: 'f', value: 1 },
            transparent: true,
            depthTest: false,
            customCompile
        });

        shader.persists = true;

        if (!map) shader.visible = false;

        this.usingMap = map != undefined && map != 'empty' && map != '';
        this.tMap = shader.uniforms.tMap;
        this.group = new Group();
        this.alpha = 1;
        this._x = 0;
        this._y = 0;
        this._z = 0;
        this._scaleX = 1;
        this._scaleY = 1;
        this._scale = 1;
        this._rotation = 0;
        this.multiTween = true;
        this.children = [];
        this.dimensions = new Vector3(width, height, 1);
        this._shader = shader;

        this.mesh = new Mesh(GLUIObject.getGeometry('2d'), shader);
        this.mesh.glui = this;
        this.group.add(this.mesh);

        shader.mesh = this.mesh;

        if (window.GLSEO) GLSEO.objectNode(this);

        this.bg(getMap());

        const _this = this;
        this.mesh.onBeforeRender = _ => {
            if (!_this.mesh.determineVisible() && _this.firstRender) return;
            let alpha = _this.getAlpha();
            if (_this.mesh.shader.uniforms.uAlpha) _this.mesh.shader.uniforms.uAlpha.value = alpha;

            if (_this.usingMap) {
                if (alpha < 0.001) {
                    _this.mesh.hidden = true;
                    _this.mesh.shader.visible = false;
                    if (!_this.isDirty && _this.firstRender) return;
                } else {
                    _this.mesh.hidden = false;
                    _this.mesh.shader.visible = true;
                }
            }

            if (!_this.isDirty && _this.firstRender) return;

            if (RenderStats.active) RenderStats.update('GLUIObject', 1, _this.mesh.shader.vsName + '|' + _this.mesh.shader.fsName, _this.mesh);

            _this.group.position.x = _this._x;
            _this.group.position.y = _this._3d ? _this._y : -_this._y;
            _this.group.position.z = _this._z;

            if (_this.scale != 1) {
                _this.group.position.x += (_this.dimensions.x - (_this.dimensions.x * _this.scale)) / 2;
                _this.group.position.y -= (_this.dimensions.y - (_this.dimensions.y * _this.scale)) / 2;
            }

            let shader = _this.mesh.shader;


            if (_this.calcMask) {
                let v = _this.isMasked;
                v.copy(v.origin);
                _this.group.localToWorld(v);
                v.z = v.width;
                v.w = v.height;
            }

            if (map) {
                if (!_this.corners) {
                    _this.mesh.scale.set(1, 1, 1).multiply(_this.dimensions);
                    _this.group.scale.x = _this._scaleX * _this._scale;
                    _this.group.scale.y = _this._scaleY * _this._scale;
                }
            } else {
                _this.group.scale.set(_this._scaleX * _this._scale, _this._scaleY * _this._scale, 1);
            }

            if (!_this._3d) {
                _this.group.rotation.z = Math.radians(_this._rotation);
            } else {
                if (_this.anchor && _this.anchor._parent) {
                    _this.anchor.position.copy(_this.group.position);
                    _this.anchor.scale.copy(_this.group.scale);
                    _this.anchor.quaternion.setFromEuler(_this._rotation);
                    _this.anchor.isDirty = true;
                } else {
                    _this.group.quaternion.setFromEuler(_this._rotation);
                    _this.group.matrixDirty = true;
                }
            }

            if (!_this.firstRender) {
                _this.group.updateMatrixWorld(true);
                _this.firstRender = true;
                if (_this.onMountedHook) _this.onMountedHook();
            }

            _this.isDirty = false;
        };

        _this.isDirty = true;
    }

    get width() {
        return this.dimensions.x;
    }

    /**
      * @name width
      * @memberof GLUIObject
      * @property
      */
    set width(w) {
        let dirty = Math.abs(this.dimensions.x - w) > Base3D.DIRTY_EPSILON;
        this.dimensions.x = w;
        if (dirty) {
            this.isDirty = true;
            this.__internalDirty && this.__internalDirty();
        }
    }

    get height() {
        return this.dimensions.y;
    }

    /**
      * @name height
      * @memberof GLUIObject
      * @property
      */
    set height(h) {
        let dirty = Math.abs(this.dimensions.y - h) > Base3D.DIRTY_EPSILON;
        this.dimensions.y = h;
        if (dirty) {
            this.isDirty = true;
            this.__internalDirty && this.__internalDirty();
        }
    }

    get x() {
        return this._x;
    }

    /**
      * @name x
      * @memberof GLUIObject
      * @property
      */
    set x(v) {
        let dirty = Math.abs(this._x - v) > Base3D.DIRTY_EPSILON;
        this._x = v;
        if (dirty) {
            this.isDirty = true;
            this.__internalDirty && this.__internalDirty();
        }
    }

    get y() {
        return this._y;
    }

    /**
      * @name y
      * @memberof GLUIObject
      * @property
      */
    set y(v) {
        let dirty = Math.abs(this._y - v) > Base3D.DIRTY_EPSILON;
        this._y = v;
        if (dirty) {
            this.isDirty = true;
            this.__internalDirty && this.__internalDirty();
        }
    }

    get z() {
        return this._z;
    }

    /**
      * @name z
      * @memberof GLUIObject
      * @property
      */
    set z(v) {
        let dirty = Math.abs(this._z - v) > Base3D.DIRTY_EPSILON;
        this._z = v;
        if (dirty) {
            this.isDirty = true;
            this.__internalDirty && this.__internalDirty();
        }
    }

    get scale() {
        return this._scale;
    }

    /**
      * @name scale
      * @memberof GLUIObject
      * @property
      */
    set scale(v) {
        let dirty = Math.abs(this._scale - v) > Base3D.DIRTY_EPSILON;
        this._scale = v;
        if (dirty) {
            this.isDirty = true;
            this.__internalDirty && this.__internalDirty();
        }
    }

    get scaleX() {
        return this._scaleX;
    }

    /**
      * @name scaleX
      * @memberof GLUIObject
      * @property
      */
    set scaleX(v) {
        let dirty = Math.abs(this._scaleX - v) > Base3D.DIRTY_EPSILON;
        this._scaleX = v;
        if (dirty) {
            this.isDirty = true;
            this.__internalDirty && this.__internalDirty();
        }
    }

    get scaleY() {
        return this._scaleY;
    }

    /**
      * @name scaleY
      * @memberof GLUIObject
      * @property
      */
    set scaleY(v) {
        let dirty = Math.abs(this._scaleY - v) > Base3D.DIRTY_EPSILON;
        this._scaleY = v;
        if (dirty) {
            this.isDirty = true;
            this.__internalDirty && this.__internalDirty();
        }
    }

    get rotation() {
        return this._rotation;
    }

    /**
      * @name rotation
      * @memberof GLUIObject
      * @property
      */
    set rotation(v) {
        let dirty = Math.abs(this._rotation - v) > Base3D.DIRTY_EPSILON;
        this._rotation = v;
        if (dirty) {
            this.isDirty = true;
            this.__internalDirty && this.__internalDirty();
        }
    }

    /**
     * @name this.style
     * @memberof GLUIObject
     *
     * @function
     * @param props
    */
    style(props) {
        for (let prop in props) {
            if (this[prop] !== undefined) this[prop] = props[prop];
        }
        return this;
    }

    /**
     * @name this.size
     * @memberof GLUIObject
     *
     * @function
     * @param w
     * @param h
    */
    size(w, h) {
        this.width = w;
        this.height = h;
        if (this.corners) this.corners.update();
        return this;
    }

    /**
     * @name this.add
     * @memberof GLUIObject
     *
     * @function
     * @param $obj
    */
    add($obj) {
        $obj?.parent?.children?.remove($obj);
        $obj.parent = this;
        this.group.add($obj.group);
        this.children.push($obj);

        if (this.isMasked) $obj.mask(this.isMasked, this.maskShader);
        if (this._3d && !$obj._3d) $obj.enable3D();
        if (this.deferred) {
            $obj.deferRender(true);
            if ($obj.anchor && this.anchor) this.anchor.add($obj.anchor);
        }

        return this;
    }

    /**
     * @name this.interact
     * @memberof GLUIObject
     *
     * @function
     * @param over
     * @param click
     * @param camera
     * @param url
     * @param label
     * @param options optional object containing further parameters:
     *                  * `role`: pass 'button' to use button interaction conventions, such as firing on spacebar as well as the enter key
    */
    interact(over, click, camera = World.CAMERA, url, label, options) {
        if (typeof camera === 'string') {
            options = label;
            label = url;
            url = camera;
            camera = World.CAMERA;
        }

        const bubble = (e, fn) => {
            e.stopPropagation = function () {
                e._stopProp = true;
            };
            let parent = this._parent;
            while (parent) {
                if (e._stopProp) return;
                parent[fn]?.(e);
                parent = parent.parent;
            }
        };

        this._onOver = e => {
            bubble(e, '_onChildHover');
            over(e);
        };
        this._onClick = e => {
            bubble(e, '_onChildClick');
            click(e);
        };
        this._interactCamera = camera;
        if (over) this.interaction.add(this, camera);
        else this.interaction.remove(this, camera);

        if (typeof url === 'string' && typeof label === 'string') {
            const _this = this;
            defer(_ => {
                if (!_this.seo && window.GLSEO) {
                    GLSEO.objectNode(_this);
                }

                _this.seo && _this.seo.aLink && _this.seo.aLink(url, label, options);
            });
        }

        return this;
    }

    /**
     * @name this.clearInteract
     * @memberof GLUIObject
     *
     * @function
    */
    clearInteract() {
        if (this._onOver) {
            this.interaction.remove(this, this._interactCamera);
            this._onClick = GLUIObject.noop;
            this._onOver = GLUIObject.noop;
        }

        if (this.seo) {
            this.seo.unlink();
        }

        return this;
    }

    /**
     * @name this.remove
     * @memberof GLUIObject
     *
     * @function
    */
    remove(param) {
        if (param) console.warn('GLUIObject.remove removes ITSELF from its parent. use removeChild instead');
        // Take a copy of children before iterating, otherwise we’ll miss
        // some children because this.children may be mutated by child.remove()
        // [it calls this.parent.children.remove()].
        let children = this.children.slice();
        children.forEach(child => {
            if (child.remove) child.remove();
            else if (child.destroy) child.destroy();
        });

        this.clearInteract();
        if (this.parent) {
            if (this.parent.children) this.parent.children?.remove(this);
            else GLUI.Stage.remove(this);
        }
        if (this.mesh._parent) {
            this.group._parent?.remove(this.group);
        } else {
            if (!this._3d) GLUI.Stage.remove(this);
            else GLUI.Scene.remove(this);
        }

        let textureShader = this.textureShader;
        for (let key in textureShader.uniforms) {
            let uniform = textureShader.uniforms[key];
            if (uniform && uniform.value && uniform.value.destroy) uniform.value.destroy();
        }
    }

    /**
     * @name this.create
     * @memberof GLUIObject
     *
     * @function
     * @param width
     * @param height
     * @param map
    */
    create(width, height, map, customCompile) {
        let $obj = $gl(width, height, map, customCompile);
        this.add($obj);
        if (this._3d) $obj.enable3D();
        return $obj;
    }

    /**
     * @name this.removeChild
     * @memberof GLUIObject
     *
     * @function
     * @param obj
    */
    removeChild(obj) {
        this.group.remove(obj.group);
        return this;
    }

    /**
     * @name this.tween
     * @memberof GLUIObject
     *
     * @function
     * @param obj
     * @param time
     * @param ease
     * @param delay
    */
    tween(obj, time, ease, delay) {
        return tween(this, obj, time, ease, delay);
    }

    /**
     * @name this.enable3D
     * @memberof GLUIObject
     *
     * @function
     * @param style2d
    */
    enable3D(style2d) {
        this._3d = true;
        this.mesh.geometry = GLUIObject.getGeometry(style2d ? '2d' : '3d');
        this.mesh.shader.depthTest = true;
        this._rotation = new Euler();

        if(!this.anchor) this.anchor = new Group();
        this.anchor.onMatrixDirty = _ => {
            _this.isDirty = true;
        };

        const _this = this;
        _this._rotation.onChange(_ => {
            _this.isDirty = true;
        });

        return this;
    }

    /**
     * @name this.loaded
     * @memberof GLUIObject
     *
     * @function
    */
    loaded() {
        return true;
    }

    /**
     * @name this.setZ
     * @memberof GLUIObject
     *
     * @function
     * @param z
    */
    setZ(z) {
        this.mesh.renderOrder = z;
        return this;
    }

    /**
     * @name this.bg
     * @memberof GLUIObject
     *
     * @function
     * @param path
    */
    bg(path) {
        if (path === undefined) return;

        if (typeof path === 'string') {
            if (path.length <= 10 && (path.startsWith('0x') || path.startsWith('#'))) {
                if (!this.colorShader) {
                    this.colorShader = new Shader('GLUIColor', {
                        transparent: true,
                        uAlpha: { type: 'f', value: 1 },
                        uColor: { value: new Color(path) }
                    });
                }
                this.colorShader.set('uColor', new Color(path));
                if (this._shader != this.colorShader) this.useShader(this.colorShader);
            } else {
                this.textureShader.uniforms.tMap.value = Utils3D.getTexture(path, { premultiplyAlpha: false });
                if (this._shader != this.textureShader) this.useShader(this.textureShader);
            }
        } else {
            if (!this._shader.uniforms.tMap) this.useShader(this.textureShader);
            this._shader.uniforms.tMap.value = path;
        }
        return this;
    }

    /**
     * @name this.show
     * @memberof GLUIObject
     *
     * @function
    */
    show() {
        this.group.matrixDirty = true;
        this.mesh.matrixDirty = true;
        this.group.visible = true;
        if (this.anchor) this.anchor.visible = true;
        return this;
    }

    /**
     * @name this.hide
     * @memberof GLUIObject
     *
     * @function
    */
    hide() {
        this.group.visible = false;
        if (this.anchor) this.anchor.visible = false;
        return this;
    }

    /**
     * @name this.useShader
     * @memberof GLUIObject
     *
     * @function
     * @param shader
    */
    useShader(shader) {
        if (shader) {
            if (shader != this.textureShader && shader != this.colorShader) {
                shader.uniforms.tMap = this.mesh.shader.uniforms.tMap;
                shader.uniforms.uAlpha = this.mesh.shader.uniforms.uAlpha;
            }
            if (!this._3d) shader.depthTest = false;
            shader.transparent = true;
        }

        this._shader = shader;
        this.mesh.shader = shader || this._shader;
        shader.mesh = this.mesh;
        return this;
    }

    /**
     * @name this.depthTest
     * @memberof GLUIObject
     *
     * @function
     * @param bool
    */
    depthTest(bool) {
        this.mesh.shader.depthTest = bool;
    }

    /**
     * @name this.childInteract
     * @memberof GLUIObject
     *
     * @function
     * @param hover
     * @param click
    */
    childInteract(hover, click) {
        this._onChildHover = hover;
        this._onChildClick = click;
    }

    /**
     * @name this.useGeometry
     * @memberof GLUIObject
     *
     * @function
     * @param geom
    */
    useGeometry(geom) {
        this.mesh.geometry = geom;
        return this;
    }

    /**
     * @name this.updateMap
     * @memberof GLUIObject
     *
     * @function
     * @param src
    */
    updateMap(src) {
        this._shader.uniforms.tMap.value = typeof src === 'string' ? Utils3D.getTexture(src) : src;
    }

    /**
     * @name this.mask
     * @memberof GLUIObject
     *
     * @function
     * @param obj
     * @param shader
    */
    async mask(obj, shader) {
        await defer();

        let dimensions = {};
        let p = this._parent;
        while (p) {
            if (p.stageLayoutCapture) {
                dimensions.width = p.stageLayoutCapture.width;
                dimensions.height = p.stageLayoutCapture.height;
            }
            p = p._parent;
        }
        if (!dimensions.width) {
            dimensions.width = Stage.width;
            dimensions.height = Stage.height;
        }

        obj.group.updateMatrixWorld(true);
        obj.mesh.onBeforeRender();
        let box = new Box3().setFromObject(obj.mesh);
        let minX = box.min.x / dimensions.width;
        let minY = box.max.y / dimensions.height;
        let maxX = box.max.x / dimensions.width;
        let maxY = -box.min.y / dimensions.height;

        if (this.shader) {
            this.useShader(shader);
            this.shader.addUniforms({
                uMaskValues: { value: new Vector4(minX, minY, maxX, maxY) }
            });
        }

        obj.hide();

        this.group.traverse(o => {
            if (!!o.glui && o.glui != this) {
                o.glui.mask(obj, shader);
            }
        });
    }

    /**
     * @name this.deferRender
     * @memberof GLUIObject
     *
     * @function
     * @param parent
    */
    deferRender(parent) {
        this.deferred = true;
        if (!parent) {
            this.anchor = new Group();
            GLUI.Scene.addDeferred(this);
        }
    }

    /**
     * @name this.clearTween
     * @memberof GLUIObject
     *
     * @function
    */
    clearTween() {
        if (this._mathTweens) {
            this._mathTweens.forEach(t => {
                t.tween.stop();
            });
        }

        return this;
    }

    /**
     * @name this.createCorners
     * @memberof GLUIObject
     *
     * @function
    */
    createCorners() {
        this.corners = new GLUICornerPin(this);
    }

    /**
     * @name this.getAlpha
     * @memberof GLUIObject
     *
     * @function
    */
    getAlpha() {
        if (this._gluiParent) {
            let alpha = this._gluiParent.getAlpha();
            this.alpha = alpha;
            return alpha;
        }

        let alpha = this.alpha;
        let $parent = this.parent;

        while ($parent) {
            alpha *= $parent.alpha;
            $parent = $parent.parent;
        }
        return alpha;
    }

    get shader() {
        return this._shader;
    }

    _divFocus() {
        if (this._onOver) this._onOver({ action: 'over', object: this });
        if (this.onDivFocus) this.onDivFocus();
    }

    _divBlur() {
        if (this._onOver) this._onOver({ action: 'out', object: this });
        if (this.onDivBlur) this.onDivBlur();
    }

    _divSelect() {
        if (this._onClick) this._onClick({ action: 'click', object: this });
        if (this.onDivSelect) this.onDivSelect();
    }

    get _parent() {
        return this.parent;
    }

    get interaction() {
        let stage = this._3d ? GLUI.Scene : GLUI.Stage;
        return stage.interaction;
    }

    forceUpdate() {
        this.firstRender = false;
        this.mesh.onBeforeRender();
    }
}

(function () {
    var _geom2d, _geom3d;
    GLUIObject.getGeometry = function (type) {
        if (type == '2d') {
            if (!_geom2d) {
                _geom2d = new PlaneGeometry(1, 1);
                _geom2d.applyMatrix(new Matrix4().makeTranslation(0.5, -0.5, 0));
            }
            return _geom2d;
        } else {
            if (!_geom3d) {
                _geom3d = World.PLANE;
            }

            return _geom3d;
        }
    }

    GLUIObject.clear = function () {
        _geom2d = _geom3d = null;
    }

    GLUIObject.noop = _ => { };
})();

/**
 * @name GLUIText
 */
class GLUIText {
    constructor(text, fontName, fontSize, options = {}, customCompile) {
        options.font = fontName || options.font;
        options.text = text;
        options.seoText = options.seoText || text;
        options.width = options.width;
        options.align = options.align || 'left';
        options.size = fontSize || options.size;
        options.lineHeight = options.lineHeight;
        options.letterSpacing = options.letterSpacing;
        options.wordSpacing = options.wordSpacing;
        options.wordBreak = options.wordBreak;
        options.langBreak = options.langBreak;
        options.color = new Color(options.color);
        options.customCompile = customCompile;

        this.text = new GLText(options);
        this.group = new Group();
        this.group.asyncPromise = this.text.text.fontLoaded;
        this.alpha = 1;

        this._x = 0;
        this._y = 0;
        this._z = 0;
        this._scaleX = 1;
        this._scaleY = 1;
        this._scale = 1;
        this._rotation = 0;
        this.multiTween = true;

        const _this = this;

        if (text) {
            defer(_ => {
                // Initialize a11y text, but not if the text has already been
                // changed via setText().
                if (!_this.seo) _this.seoText(options.seoText);
            });
        }

    /**
     * @name this.this.text.ready
     * @memberof GLUIText
     *
     * @function
    */
        this.text.ready().then(_ => {
            let mesh = _this.text.mesh;
            mesh.glui = _this;
            mesh.shader.visible = false;

            _this.mesh = mesh;
            _this.group.add(mesh);

            if (_this._3d && !_this._style2d) _this.text.centerY();
            if (!_this._3d) _this.text.mesh.shader.depthTest = false;

            mesh.shader.mesh = mesh;

            mesh.onBeforeRender = _ => {
                if (!mesh.determineVisible() && _this.firstRender) return;
                let alpha = _this.getAlpha();
                if (mesh.shader.uniforms.uAlpha) mesh.shader.uniforms.uAlpha.value = alpha;

                if (alpha < 0.001) {
                    mesh.shader.visible = false;
                    mesh.hidden = false;
                    if (!_this.isDirty && _this.firstRender) return;
                } else {
                    mesh.hidden = false;
                    mesh.shader.visible = true;
                }

                if (!_this.isDirty && _this.firstRender) return;

                if (RenderStats.active) RenderStats.update('GLUIText', 1, mesh.shader.vsName+'|'+mesh.shader.fsName, mesh);

                _this.group.position.x = _this._x;
                _this.group.position.y = _this._3d ? _this._y : -_this._y;
                _this.group.position.z = _this._z;

                _this.group.scale.set(_this._scaleX * _this._scale, _this._scaleY * _this._scale, 1);

                if (!_this._3d) _this.group.rotation.z = Math.radians(_this._rotation);
                else {
                    if (_this.anchor && _this.anchor._parent) {
                        _this.anchor.position.copy(_this.group.position);
                        _this.anchor.scale.copy(_this.group.scale);
                        _this.anchor.quaternion.setFromEuler(_this._rotation);
                    } else {
                        _this.group.quaternion.setFromEuler(_this._rotation);
                    }
                }

                if (!_this.firstRender) {
                    _this.group.updateMatrixWorld(true);
                    _this.firstRender = true;
                    mesh.shader.visible = true;
                }

                _this.onInternalUpdate && _this.onInternalUpdate();

                _this.isDirty = false;
            };
        });
    }

    get x() {
        return this._x;
    }

   /**
     * @name x
     * @memberof GLUIText
     * @property
     */
    set x(v) {
       if (Math.abs(this._x - v) > Base3D.DIRTY_EPSILON) this.isDirty = true;
       this._x = v;
    }

    get y() {
        return this._y;
    }

   /**
     * @name y
     * @memberof GLUIText
     * @property
     */
    set y(v) {
       if (Math.abs(this._y - v) > Base3D.DIRTY_EPSILON) this.isDirty = true;
       this._y = v;
    }

    get z() {
        return this._z;
    }

   /**
     * @name z
     * @memberof GLUIText
     * @property
     */
    set z(v) {
       if (Math.abs(this._z - v) > Base3D.DIRTY_EPSILON) this.isDirty = true;
       this._z = v;
    }

    get scale() {
        return this._scale;
    }

   /**
     * @name scale
     * @memberof GLUIText
     * @property
     */
    set scale(v) {
       if (Math.abs(this._scale - v) > Base3D.DIRTY_EPSILON) this.isDirty = true;
       this._scale = v;
    }

    get scaleX() {
        return this._scaleX;
    }

   /**
     * @name scaleX
     * @memberof GLUIText
     * @property
     */
    set scaleX(v) {
       if (Math.abs(this._scaleX - v) > Base3D.DIRTY_EPSILON) this.isDirty = true;
       this._scaleX = v;
    }

    get scaleY() {
        return this._scaleY;
    }

   /**
     * @name scaleY
     * @memberof GLUIText
     * @property
     */
    set scaleY(v) {
       if (Math.abs(this._scaleY - v) > Base3D.DIRTY_EPSILON) this.isDirty = true;
       this._scaleY = v;
    }

    get rotation() {
        return this._rotation;
    }

   /**
     * @name rotation
     * @memberof GLUIText
     * @property
     */
    set rotation(v) {
       if (Math.abs(this._rotation - v) > Base3D.DIRTY_EPSILON) this.isDirty = true;
       this._rotation = v;
    }

    get dimensions() {
        if (!this._dimensions) this._dimensions = {};
        if (this.text && this.text.geometry && !this._dimensions.max) {
            this._dimensions = this.text.geometry.boundingBox;
            this._dimensions.width = Math.abs(this._dimensions.min.x - this._dimensions.max.x);
            this._dimensions.height = Math.abs(this._dimensions.min.y - this._dimensions.max.y);
        }
        return this._dimensions;
    }

    /**
     * @name this.interact
     * @memberof GLUIText
     *
     * @function
     * @param over
     * @param click
     * @param camera
     * @param seoLink
     * @param options optional object containing further parameters:
     *                  * `role`: pass 'button' to use button interaction conventions, such as firing on spacebar as well as the enter key
    */
    interact(over, click, camera = World.CAMERA, seoLink, options) {
        if (typeof camera == 'string') {
            options = seoLink;
            seoLink = camera;
            camera = World.CAMERA;
        }

        this._onOver = over;
        this._onClick = click;
        this._interactCamera = camera;

        let stage = this._3d ? GLUI.Scene : GLUI.Stage;

        const _this = this;
        _this.text.ready().then(_ => {
            if (over) {
                if (!_this.text.geometry.boundingBox) _this.text.geometry.computeBoundingBox();

                if (!_this.hitArea) {
                    let bb = _this.text.geometry.boundingBox;
                    let shader = Utils3D.getTestShader();
                    shader.visible = false;
                    _this.hitArea = new Mesh(World.PLANE, shader);
                    _this.hitArea.glui = _this;
                    _this.hitArea.scale.set(Math.abs(bb.min.x) + Math.abs(bb.max.x), Math.abs(bb.min.y) + Math.abs(bb.max.y), 1);
                    if (!_this._3d || _this._style2d) _this.hitArea.position.x = (bb.max.x - bb.min.x)/2;
                    _this.hitArea.position.y = (bb.min.y - bb.max.y)/2;

                    if (_this._3d) {
                        switch (_this.text.getData().align) {
                            case 'center': _this.hitArea.position.x = 0; break;
                            case 'right': _this.hitArea.position.x = (bb.min.x - bb.max.x) / 2; break;
                        }
                    } else {
                        switch (_this.text.getData().align) {
                            case 'center': _this.hitArea.position.x = 0; break;
                            case 'right': _this.hitArea.position.x = -(bb.max.x - bb.min.x)/2; break;
                        }
                    }

                    _this.text.mesh.add(_this.hitArea);
                }

                stage.interaction.add(_this.hitArea, camera);
            } else {
                stage.interaction.remove(_this.hitArea, camera);
            }
        });

        defer(_ => {
            if (seoLink) _this.seo && _this.seo.aLink && _this.seo.aLink(seoLink, options);
        });

        return this;
    }

    /**
     * @name this.clearInteract
     * @memberof GLUIText
     *
     * @function
    */
    clearInteract() {
        if (this._onOver) {
            let stage = this._3d ? GLUI.Scene : GLUI.Stage;
            stage.interaction.remove(this.hitArea, this._interactCamera);
            this._onClick = GLUIObject.noop;
            this._onOver = GLUIObject.noop;
        }
        return this;
    }

    /**
     * @name this.remove
     * @memberof GLUIText
     *
     * @function
    */
    remove(param) {
        if (param) console.warn('GLUIObject.remove removes ITSELF from its parent. use removeChild instead');

        let stage = this._3d ? GLUI.Scene : GLUI.Stage;

        if (this.mesh && this.mesh.parent) {
            this.group.parent.remove(this.group);
        } else {
            stage.remove(this);
        }

        if (this.hitArea) stage.interaction.remove(this.hitArea, this._interactCamera);
        if (this.text && this.text.destroy) this.text.destroy();

        Utils.nullObject(this.mesh);
        Utils.nullObject(this);
    }

    /**
     * @name this.tween
     * @memberof GLUIText
     *
     * @function
     * @param obj
     * @param time
     * @param ease
     * @param delay
    */
    tween(obj, time, ease, delay) {
        return tween(this, obj, time, ease, delay);
    }

    /**
     * @name this.enable3D
     * @memberof GLUIText
     *
     * @function
     * @param style2d
    */
    enable3D(style2d) {
        this._3d = true;
        this._style2d = style2d;
        this._rotation = new Euler();

        const _this = this;
        _this._rotation.onChange(_ => {
            _this.isDirty = true;
        });

        _this.text.ready().then(_ => {
            _this.text.mesh.shader.depthTest = true;
        });

        if(!this.anchor) this.anchor = new Group();
        this.anchor.onMatrixDirty = _ => {
            _this.isDirty = true;
        };

        _this.isDirty = true;

        return this;
    }

    /**
     * @name this.depthTest
     * @memberof GLUIText
     *
     * @function
     * @param bool
    */
    depthTest(bool) {
        const _this = this;
        _this.text.ready().then(_ => {
            _this.text.mesh.shader.depthTest = bool;
        });

        return this;
    }

    /**
     * @name this.setZ
     * @memberof GLUIText
     *
     * @function
     * @param z
    */
    setZ(z) {
        const _this = this;

        _this.text.ready().then(_ => {
            _this.text.mesh.renderOrder = z;
        });

        return this;
    }

    /**
     * @name this.height
     * @memberof GLUIText
     *
     * @function
    */
    height() {
        if (!this.mesh) return 0;
        return this.text.height;
    }

    /**
     * @name this.setText
     * @memberof GLUIText
     *
     * @function
     * @param text
     * @param options
    */
    async setText(text, options) {
        if (text) {
            text = text.toString();
            this.seoText(text);
        }
        await this.text.ready();
        await this.text.setText(text, options);
        this._dimensions = null;
        return this;
    }

    /**
     * @name this.seoText
     * @memberof GLUIText
     *
     * @function
     * @param text
    */
    seoText(text) {
        if (window.GLSEO) {
            GLSEO.textNode(this, text);
        }
    }

    /**
     * @name this.getTextString
     * @memberof GLUIText
     *
     * @function
    */
    getTextString() {
        return this.text.string;
    }

    /**
     * @name this.setColor
     * @memberof GLUIText
     *
     * @function
     * @param color
    */
    setColor(color) {
        const _this = this;
        _this.text.ready().then(_ => _this.text.setColor(color));
        return this;
    }

    /**
     * @name this.tweenColor
     * @memberof GLUIText
     *
     * @function
     * @param color
     * @param time
     * @param ease
     * @param delay
    */
    tweenColor(color, time, ease, delay) {
        const _this = this;
        _this.text.ready().then(_ => _this.text.tweenColor(color, time, ease, delay));
        return this;
    }

    /**
     * @name this.resize
     * @memberof GLUIText
     *
     * @function
     * @param options
    */
    async resize(options) {
        await this.text.ready();
        await this.text.resize(options);
        this._dimensions = null;
    }

    /**
     * @name this.show
     * @memberof GLUIText
     *
     * @function
    */
    show() {
        const _this = this;
        _this.text.ready().then(_ => {
            this.text.mesh.visible = true;
            this.text.mesh.updateMatrixWorld(true);
        });
        return this;
    }

    /**
     * @name this.mask
     * @memberof GLUIText
     *
     * @function
     * @param obj
     * @param shader
    */
    async mask(obj, shader) {
        await defer();

        let dimensions = {};
        let p = this._parent;

        while (p) {
            if (p.stageLayoutCapture) {
                dimensions.width = p.stageLayoutCapture.width;
                dimensions.height = p.stageLayoutCapture.height;
            }
            p = p._parent;
        }
        if (!dimensions.width) {
            dimensions.width = Stage.width;
            dimensions.height = Stage.height;
        }

        obj.group.updateMatrixWorld(true);
        obj.mesh.onBeforeRender();
        let box = new Box3().setFromObject(obj.mesh);
        let minX = box.min.x / dimensions.width;
        let minY = box.max.y / dimensions.height;
        let maxX = box.max.x / dimensions.width;
        let maxY = -box.min.y / dimensions.height;

        if (this.shader) {
            this.useShader(shader);
            this.shader.addUniforms({
                uMaskValues: {value: new Vector4(minX, minY, maxX, maxY)}
            });
        }

        obj.hide();

        this.group.traverse(o => {
            if (!!o.glui && o.glui != this) {
                o.glui.mask(obj, shader);
            }
        });
    }

    /**
     * @name this.hide
     * @memberof GLUIText
     *
     * @function
    */
    hide() {
        const _this = this;
        _this.text.ready().then(_ => _this.text.mesh.visible = false);
        return this;
    }

    /**
     * @name this.loaded
     * @memberof GLUIText
     *
     * @function
    */
    loaded() {
        return this.text.ready();
    }

    /**
     * @name this.length
     * @memberof GLUIText
     *
     * @function
    */
    length() {
        return this.text.charLength;
    }

    /**
     * @name this.deferRender
     * @memberof GLUIText
     *
     * @function
     * @param parent
    */
    deferRender(parent) {
        this.deferred = true;
        if (!parent) {
            if (!this.anchor) this.anchor = new Group();
            GLUI.Scene.addDeferred(this);
        }
    }

    /**
     * @name this.getAlpha
     * @memberof GLUIText
     *
     * @function
    */
    getAlpha() {
        if (this._gluiParent) {
            let alpha = this._gluiParent.getAlpha();
            this.alpha = alpha;
            return alpha;
        }

        let alpha = this.alpha;
        let $parent = this.parent;
        while ($parent) {
            alpha *= $parent.alpha;
            $parent = $parent.parent;
        }

        return alpha;
    }

    /**
     * @name this.size
     * @memberof GLUIText
     *
     * @function
    */
    size() {

    }

    /**
     * @name this.upload
     * @memberof GLUIText
     *
     * @function
    */
    upload() {
        const _this = this;
        _this.text.ready().then(_ => _this.text.mesh.upload());
        return this;
    }

    /**
     * @name this._divFocus
     * @memberof GLUIText
     *
     * @function
    */
    _divFocus() {
        if (this._onOver) this._onOver({action: 'over', object: this});
        if (this.onDivFocus) this.onDivFocus();
    }

    /**
     * @name this._divBlur
     * @memberof GLUIText
     *
     * @function
    */
    _divBlur() {
        if (this._onOver) this._onOver({action: 'out', object: this});
        if (this.onDivBlur) this.onDivBlur();
    }

    /**
     * @name this._divSelect
     * @memberof GLUIText
     *
     * @function
    */
    _divSelect() {
        if (this._onClick) this._onClick({action: 'click', object: this});
        if (this.onDivBlurSelect) this.onDivSelect();
    }

    get _parent() {
        return this.parent;
    }

    /**
     * @name this.useShader
     * @memberof GLUIText
     *
     * @function
     * @param shader
    */
    async useShader(shader) {
        await this.text.ready();
        shader.uniforms.tMap = this.text.shader.uniforms.tMap;
        shader.uniforms.uAlpha = this.text.shader.uniforms.uAlpha;
        shader.uniforms.uColor = this.text.shader.uniforms.uColor;
        shader.transparent = true;

        if (!this._3d || !(!this._3d && !this.parent)) shader.depthTest = false;

        this.text.mesh.shader = shader || this.text.shader;
        this.text.shader = shader;
        this.text.mesh.shader.mesh = this.text.mesh;
    }
}

/**
 * @name GLUIStage
 */
Class(function GLUIStage() {
    Inherit(this, Component);
    const _this = this;

    var _scene = new Scene();
    var _camera = new OrthographicCamera(1, 1, 1, 1, 0.1, 1);

   /**
    * @name interaction
    * @memberof GLUIStage
    * @property
    */
    this.interaction = new GLUIStageInteraction2D(_camera, _scene, Stage);
   /**
    * @name alpha
    * @memberof GLUIStage
    * @property
    */
    this.alpha = 1;
   /**
    * @name scene
    * @memberof GLUIStage
    * @property
    */
    this.scene = _scene;

    //*** Constructor
    (function () {
        _scene.disableAutoSort = true;
        _camera.position.z = 1;
        addListeners();
        resizeHandler();
    })();

    function loop() {
        if (!_scene.children.length) return;
        let clear = World.RENDERER.autoClear;
        World.RENDERER.autoClear = false;
        World.RENDERER.render(_scene, _camera, null, true);
        World.RENDERER.autoClear = clear;
    }

    //*** Event handlers
    function addListeners() {
        _this.events.sub(Events.RESIZE, resizeHandler);
    }

    function resizeHandler() {
        _camera.left = Stage.width / -2;
        _camera.right = Stage.width / 2;
        _camera.top = Stage.height / 2;
        _camera.bottom = Stage.height / -2;
        _camera.near = 0.01;
        _camera.far = 1000;
        _camera.updateProjectionMatrix();
        _camera.position.x = Stage.width/2;
        _camera.position.y = -Stage.height/2;
    }

    //*** Public methods
    /**
     * @name this.add
     * @memberof GLUIStage
     *
     * @function
     * @param $obj
    */
    this.add = function($obj) {
        $obj.parent = _this;
        _scene.add($obj.group || $obj.mesh);
    }

    /**
     * @name this.remove
     * @memberof GLUIStage
     *
     * @function
     * @param $obj
    */
    this.remove = function($obj) {
        $obj.parent = null;
        _scene.remove($obj.group);
    }

    /**
     * @name this.clear
     * @memberof GLUIStage
     *
     * @function
    */
    this.clear = function() {
        _scene.traverse(obj => {
            if (obj.geometry && obj.shader) {
                obj.destroy();
            }
        });

        _scene.children.length = _scene.childrenLength = 0;
    }

    /**
     * @name this.renderToRT
     * @memberof GLUIStage
     *
     * @function
     * @param scene
     * @param rt
    */
    this.renderToRT = function(scene, rt) {
        let clearAlpha;
        if (rt.fxscene && rt.fxscene.clearAlpha > -1) {
            clearAlpha = World.RENDERER.getClearAlpha();
            World.RENDERER.setClearAlpha(0);
        }

        let autoClear = World.RENDERER.autoClear;
        World.RENDERER.autoClear = false;
        World.RENDERER.render(scene, _camera, rt);
        World.RENDERER.autoClear = autoClear;

        if (clearAlpha) World.RENDERER.setClearAlpha(clearAlpha);
    };

    this.resize = resizeHandler;
    this.render = loop;
    this.renderDirect = callback => {
        if (_scene.children.length) {
            _scene.traverse(obj => {
                if (obj.shader) obj.shader.depthTest = false;
            });
            callback(_scene, _camera);
        }
    };
});
/**
 * @name GLUIStage3D
 */
Class(function GLUIStage3D() {
    Inherit(this, Object3D);
    const _this = this;
    var _camera;

    var _externalRenders = [];
    var _scene = new Scene();
    var _list = new LinkedList();

    this.alpha = 1;

    this.interaction = new GLUIStageInteraction3D();

    function mark() {
        let obj = _list.start();
        while (obj) {
            if (obj.anchor._parent) obj.group.visible = obj.anchor.determineVisible();
            if (obj.mesh && obj.mesh.determineVisible() && obj.anchor._parent) {
                obj._marked = true;
            }
            obj = _list.next();
        }
    }

    function loop() {
        if (window.Metal) return;
        if (_list.length) {
            let obj = _list.start();
            while (obj) {
                if (obj._marked) {
                    obj._marked = false;
                    Utils3D.decompose(obj.anchor, obj.group);
                }
                obj = _list.next();
            }

            let clear = World.RENDERER.autoClear;
            Renderer.context.clear(Renderer.context.DEPTH_BUFFER_BIT);
            World.RENDERER.autoClear = false;
            World.RENDERER.render(_scene, _camera || World.CAMERA);
            World.RENDERER.autoClear = clear;
        }

        if (_externalRenders.length) {
            while (_externalRenders.length) {
                let scene = _externalRenders.shift();
                let camera = scene._textRenderCamera;

                let clear = World.RENDERER.autoClear;
                Renderer.context.clear(Renderer.context.DEPTH_BUFFER_BIT);
                World.RENDERER.autoClear = false;
                World.RENDERER.render(scene, camera);
                World.RENDERER.autoClear = clear;
            }
        }
    }

    //*** Public methods
    /**
     * @name this.add
     * @memberof GLUIStage3D
     *
     * @function
     * @param obj
     * @param parent
    */
    this.add = function(obj, parent) {
        obj.parent = _this;
        obj._gluiParent = parent;

        if(obj.anchor) {
            obj.anchor._gluiParent = parent;
        }

        if (!obj._3d) obj.enable3D();
        obj.deferRender();
    }

    /**
     * @name this.clear
     * @memberof GLUIStage3D
     *
     * @function
    */
    this.clear = function() {
        _scene.traverse(obj => {
            if (obj.geometry && obj.shader) {
                obj.destroy();
            }
        });

        _scene.children.length = _scene.childrenLength = 0;
    }

    /**
     * @name this.addDeferred
     * @memberof GLUIStage3D
     *
     * @function
     * @param obj
    */
    this.addDeferred = function(obj) {
        _list.push(obj);
        _scene.add(obj.group || obj.mesh);
    }

    /**
     * @name this.remove
     * @memberof GLUIStage3D
     *
     * @function
     * @param obj
    */
    this.remove = function(obj) {
        _scene.remove(obj.group || obj.mesh);
        _list.remove(obj);
    }

    /**
     * @name this.disableAutoSort
     * @memberof GLUIStage3D
     *
     * @function
    */
    this.disableAutoSort = function() {
        _scene.disableAutoSort = true;
    }

    /**
     * @name this.renderToRT
     * @memberof GLUIStage3D
     *
     * @function
     * @param scene
     * @param camera
    */
    this.renderToRT = function(scene, camera) {
        camera = camera.camera || camera;

        scene.traverse(mesh => {
            let obj = mesh.glui || mesh;
            if (!obj || !obj.anchor) return;

            if (obj.anchor.determineVisible()) {
                Utils3D.decompose(obj.anchor, obj.group || obj);
            }
        });

        scene._textRenderCamera = camera;
        _externalRenders.push(scene);
    }

    /**
     * @name this.renderToRT2
     * @memberof GLUIStage3D
     *
     * @function
     * @param scene
     * @param rt
     * @param camera
    */
    this.renderToRT2 = function(scene, rt, camera) {
        let clearAlpha;
        if (rt.fxscene && rt.fxscene.clearAlpha > -1) {
            clearAlpha = World.RENDERER.getClearAlpha();
            World.RENDERER.setClearAlpha(0);
        }

        let autoClear = World.RENDERER.autoClear;
        World.RENDERER.autoClear = false;
        World.RENDERER.render(scene, camera, rt);
        World.RENDERER.autoClear = autoClear;

        if (clearAlpha) World.RENDERER.setClearAlpha(clearAlpha);
    }

    this.render = loop;
    this.mark = mark;

    /**
     * @name this.renderDirect
     * @memberof GLUIStage3D
     *
     * @function
     * @param callback
    */
    this.renderDirect = function(callback) {
        if (_list.length) {
            let obj = _list.start();
            while (obj) {
                if (obj._marked) {
                    obj._marked = false;
                    Utils3D.decompose(obj.anchor, obj.group);
                }
                obj = _list.next();
            }

            _scene.traverse(obj => {
                if (obj.shader) obj.shader.depthTest = false;
            });

            callback(_scene, _camera || World.CAMERA);
        }
    }

    this.set('camera', c => {
        _camera = c.camera || c;
    });
});
Module(function FirefoxGPUFixer() {
    this.exports = function() {
        if (GPU.detect('radeon r9 200')) {
            if (Device.system.os == 'mac' || Device.pixelRatio > 1) {
                Device.graphics.webgl.gpu = 'radeon pro 455';
            }
        }
    }
});

Class(function GPU() {
    Inherit(this, Component);
    var _this = this;
    var _split = {};


    Hydra.ready(async () => {

        _this.detect = function (match) {
            if (!Device.graphics.gpu) return;
            return Device.graphics.gpu.detect(match);
        }

        _this.detectAll = function() {
            if (!Device.graphics.gpu) return;
            var match = true;
            for (var i = 0; i < arguments.length; i++) {
                if (!Device.graphics.gpu.detect(arguments[i])) match = false;
            }
            return match;
        }

        _this.matchGPU = function(str, min, max = 99999) {
            let num = splitGPU(str);
            return num >= min && num < max;
        }

        _this.gpu = Device.graphics.gpu ? Device.graphics.gpu.identifier : '';

        if (_this.gpu == 'apple gpu') {
            if (Device.mobile) await require('iOSGPUTest')();
            else require('MacOSPerformanceTest')();
        }

        if (Device.system.browser === 'firefox') {
            require('FirefoxGPUFixer')();
        }

        function splitGPU(string) {
            if (_split[string]) return _split[string];
            if (!_this.detect(string)) return -1;
            try {
                var num = Number(_this.gpu.split(string)[1].split(' ')[0]);
                _split[string] = num;
                return num;
            } catch (e) {
                return -1;
            }
        }

        _this.BLOCKLIST = require('GPUBlocklist').match();

        _this.T0 = (function () {
            if (Device.mobile) return false;
            if (_this.BLOCKLIST) return true;

            if (_this.detect('radeon(tm) r5')) return true;
            if (_this.detect('radeon r9 200')) return true;
            if (_this.detect('hd graphics family')) return true;
            if (_this.detect('intel(r) uhd graphics direct')) return true;
            if (_this.matchGPU('hd graphics ', 1000, 5001)) return true;
            if (_this.matchGPU('hd graphics ', 0, 618) && Device.pixelRatio > 1) return true;
            if (_this.detect(['hd graphics', 'iris']) && Math.max(Stage.width, Stage.height) > 1800) return true;
            if (_this.detect(['intel iris opengl engine'])) return true;
            if (_this.matchGPU('iris(tm) graphics ', 1000)) return true;

            return false;
        })();

        _this.T1 = (function () {
            if (_this.BLOCKLIST) return false;
            if (Device.mobile) return false;

            if (_this.T0) return false;
            if (_this.matchGPU('iris(tm) graphics ', 540, 1000)) return true;
            if (_this.matchGPU('hd graphics ', 514, 1000)) return true;
            if (_this.matchGPU('intel(r) uhd graphics ', 600, 1000)) return true;
            if (!_this.detect(['nvidia', 'amd', 'radeon', 'geforce'])) return true;
            if (_this.detect(['vega 8'])) return true;

            return false;
        })();

        _this.T2 = (function () {
            if (_this.BLOCKLIST) return false;
            if (Device.mobile) return false;
            if (_this.detect(['nvidia', 'amd', 'radeon', 'geforce']) && !_this.T1 && !_this.T0) return true;
            return false;
        })();

        _this.T3 = (function () {
            if (_this.BLOCKLIST) return false;
            if (Device.mobile) return false;
            if (_this.detect(['titan', 'amd radeon pro', 'quadro'])) return true;
            if (_this.matchGPU('gtx ', 940)) return true;
            if (_this.matchGPU('radeon (tm) rx ', 400)) return true;
            if (_this.detect('amd radeon(tm) graphics direct3d11 vs_5_0')) return true;
            if (_this.matchGPU('radeon rx ', 400)) return true;
            if (_this.matchGPU('radeon pro ', 420)) return true;
            return false;
        })();

        _this.T4 = (function () {
            if (_this.BLOCKLIST) return false;
            if (Device.mobile) return false;
            if (_this.detect(['titan', 'quadro', 'radeon vii', 'apple m'])) return true;
            if (_this.matchGPU('gtx ', 1060)) return true;
            if (_this.matchGPU('rtx')) return true;
            if (_this.matchGPU('radeon rx ', 500)) return true;
            if (_this.matchGPU('vega ', 50)) return true;
            if (_this.detect(['radeon pro 5300m', 'radeon pro 5500m', 'radeon pro 5600m', 'amd radeon unknown prototype'])) return true;
            return false;
        })();

        _this.T5 = (function () {
            if (_this.BLOCKLIST) return false;
            if (Device.mobile) return false;
            if (_this.detect(['titan', 'radeon vii'])) return true;
            if (_this.matchGPU('gtx ', 1080)) return true;
            if (_this.matchGPU('rtx ', 2060)) return true;
            if (_this.matchGPU('radeon rx ', 5500)) return true;
            if (_this.detect('apple m') && _this.detect('max')) return true;
            return false;
        })();

        _this.MT0 = (function () {
            if (!Device.mobile) return false;
            if (_this.BLOCKLIST) return true;
            if (Device.system.os == 'ios' && _this.detect('a7')) return true;

            if (Device.system.os == 'android' && _this.detect('sgx')) return true;

            if (_this.detect('adreno')) return _this.matchGPU('adreno (tm) ', 0, 415);
            if (_this.detect('mali')) return _this.matchGPU('mali-t', 0, 628);

            if (Device.system.os == 'ios' && _this.detect(['a8', 'a9'])) return true;
            if (_this.detect('mali-g')) return true;

            if (_this.matchGPU('adreno (tm) ', 420)) return true;

            return false;
        })();

        _this.MT1 = (function () {
            if (!Device.mobile) return false;
            if (_this.BLOCKLIST) return false;
            if (Device.system.os == 'ios' && _this.detect('a10')) return true;

            if (Device.system.os == 'android' && !_this.MT0) return true;

            if (_this.detect('nvidia tegra') && Device.detect('pixel c')) {
                return true;
            }

            if (_this.detect('mali-g')) return _this.matchGPU('mali-g', 73);

            if (_this.detect('adreno')) {
                if (_this.matchGPU('adreno (tm) ', 600, 616)) return true;
                if (_this.matchGPU('adreno (tm) ', 530, 600)) return true;
            }
            return false;
        })();

        _this.MT2 = (function () {
            if (!Device.mobile) return false;
            if (_this.BLOCKLIST) return false;
            if (Device.system.os == 'ios' && _this.detect(['a11', 'a12'])) return true;

            if (_this.detect('adreno')) return _this.matchGPU('adreno (tm) ', 630);
            if (_this.detect('mali-g')) return _this.matchGPU('mali-g', 74);

            if (navigator.platform.toLowerCase().includes(['mac', 'windows']) && Device.system.browser == 'chrome') return true;

            return false;
        })();

        _this.MT3 = (function () {
            if (!Device.mobile) return false;
            if (_this.BLOCKLIST) return false;
            if (Device.system.os == 'ios' && _this.detect(['a12', 'a13', 'a14', 'a15', 'a16', 'a17', 'a18'])) return true;

            if (_this.detect('adreno')) return _this.matchGPU('adreno (tm) ', 640);
            if (_this.detect('mali-g')) return _this.matchGPU('mali-g', 76);

            if (navigator.platform.toLowerCase().includes(['mac', 'windows']) && Device.system.browser == 'chrome') return true;

            return false;
        })();

        _this.MT4 = (function () {
            if (!Device.mobile) return false;
            if (_this.BLOCKLIST) return false;
            if (Device.system.os == 'ios' && _this.detect(['a14', 'a15', 'a16', 'a17', 'a18', 'a19', 'a20', 'apple m'])) return true;

            if (_this.detect('adreno')) return _this.matchGPU('adreno (tm) ', 650);
            if (_this.detect('mali-g')) return _this.matchGPU('mali-g', 78);

            if (navigator.platform.toLowerCase().includes(['mac', 'windows']) && Device.system.browser == 'chrome') return true;

            return false;
        })();

        _this.lt = function(num) {
            if (_this.TIER > -1) {
                return _this.TIER <= num;
            }
            return false;
        }

        _this.gt = function(num) {
            if (_this.TIER > -1) {
                return _this.TIER >= num;
            }
            return false;
        }

        _this.eq = function(num) {
            if (_this.TIER > -1) {
                return _this.TIER == num;
            }

            return false;
        }

        _this.mobileEq = function(num) {
            if (_this.M_TIER > -1) {
                return _this.M_TIER == num;
            }

            return false;
        }

        _this.mobileLT = function(num) {
            if (_this.M_TIER > -1) {
                return _this.M_TIER <= num;
            }
            return false;
        }

        _this.mobileGT = function(num) {
            if (_this.M_TIER > -1) {
                return _this.M_TIER >= num;
            }
            return false;
        }

        for (var key in _this) {
            if (key.charAt(0) == 'T' && _this[key] === true) _this.TIER = Number(key.charAt(1));
            if (key.slice(0, 2) == 'MT' && _this[key] === true) _this.M_TIER = Number(key.charAt(2));
        }

        if (Utils.query('gpu') !== false) {
            if (Device.mobile || Utils.query('gpu').toString().includes('m')) {
                _this.TIER = -1;
                _this.M_TIER = Number(Utils.query('gpu').slice(1));
            }
            else _this.TIER = Number(Utils.query('gpu'));
        }

        if (Device.system.os == 'ios' && Render.REFRESH_RATE < 40) {
            _this.M_TIER -= 1;
        }

        _this.OVERSIZED = (function() {
            if (!Device.mobile && _this.TIER <= 0 && Math.max(window.innerWidth, window.innerHeight) > 1400) return true;
            if (!Device.mobile && _this.TIER <= 1 && Device.pixelRatio < 2 && Math.max(window.innerWidth, window.innerHeight) > 1600) return true;
            return false;
        })();
        if (Device.system.browser == 'ie') _this.OVERSIZED = true;

        _this.initialized = true;

    });

    this.ready = function() {
        return this.wait('initialized');
    }
}, 'static');

Module(function MacOSPerformanceTest() {
    function test() {
        let results = [];
        function getPrime() {
            return largest_prime_factor(1000000000000);
        }
        function factors(n) {
            var i;
            var out = [];
            var sqrt_n = Math.sqrt(n);
            for (i = 2; i <= sqrt_n; i++) {
                if (n % i === 0) {
                    out.push(i);
                }
            }
            return out;
        }
        function primep(n) {
            return factors(n).length === 0;
        }
        function largest_prime_factor(n) {
            return factors(n).filter(primep).pop();
        }

        for (let i = 0; i < 3; i++) {
            let time = performance.now();
            getPrime();
            results.push((performance.now() - time) * 10);
        }

        results.sort((a, b) => a - b);
        return results[0];
    }

    this.exports = function() {
        let result = test();

        if (screen.width <= 1440 && screen.height <= 900) {
            //probably a 13" laptop
            if (result > 540) {
                Device.graphics.webgl.gpu = 'intel iris opengl engine';
            } else {
                Device.graphics.webgl.gpu = 'safari tier 1';
            }
        } else {
            //probably a mbp
            if (result > 475) {
                if (result > 540) {
                    Device.graphics.webgl.gpu = 'intel iris opengl engine';
                } else {
                    Device.graphics.webgl.gpu = 'safari tier 1';
                }
            } else {
                if (result < 375) {
                    Device.graphics.webgl.gpu = 'amd radeon pro 455 opengl engine';
                } else {
                    Device.graphics.webgl.gpu = 'nvidia geforce 750m opengl engine';
                }
            }
        }
    }
});
Module(function iOSGPUTest() {
    function getRenderer(complete, takUrl) {
        var nodes = 
            [
              {
                "x": "Unknown",
                "m": function(n){return family(n);},
                "n": [
                  4,
                  2,
                  1,
                  3
                ]
              },
              {
                "x": "Apple A7 GPU|Apple A8 GPU|Apple A9 GPU|Apple A10 GPU|Apple A11 GPU|Apple A12 GPU|Apple A13 GPU|Apple A14 GPU|Apple A15 GPU",
                "m": function(n){return height(n);},
                "n": [
                  15,
                  10,
                  11,
                  12,
                  14,
                  6,
                  7,
                  8,
                  13,
                  5,
                  9
                ],
                "v": [
                  "iPhone"
                ]
              },
              {
                "x": "Apple A7 GPU|Apple A8 GPU|Apple A9X GPU|Apple A10X GPU|Apple A9 GPU|Apple A12X GPU|Apple A10 GPU|Apple A12 GPU|Apple A8X GPU|Apple M1 GPU|Apple A14 GPU|Apple A12Z GPU",
                "m": function(n){return height(n);},
                "n": [
                  21,
                  20,
                  18,
                  19,
                  17,
                  16
                ],
                "v": [
                  "iPad"
                ]
              },
              {
                "x": "Apple A9X GPU|Apple A10X GPU|Apple A9 GPU|Apple A10 GPU|Apple A11 GPU|Apple A12X GPU|Apple A12 GPU|Apple A8 GPU|Apple A8X GPU|Apple A13 GPU|Apple A14 GPU|Apple M1 GPU|Apple A12Z GPU|Apple A15 GPU",
                "m": function(n){return height(n);},
                "n": [
                  20,
                  18,
                  27,
                  10,
                  11,
                  12,
                  14,
                  19,
                  23,
                  26,
                  24,
                  17,
                  25,
                  13,
                  9,
                  22
                ],
                "v": [
                  "Macintosh"
                ]
              },
              {
                "x": "Apple A10 GPU",
                "v": [
                  "iPod Touch"
                ]
              },
              {
                "x": "Apple A7 GPU|Apple A9 GPU|Apple A10 GPU|Apple A11 GPU|Apple A8 GPU|Apple A13 GPU",
                "m": function(n){return mediacolorgamut(n);},
                "n": [
                  29,
                  28
                ],
                "v": [
                  1136
                ]
              },
              {
                "x": "Apple A8 GPU|Apple A10 GPU|Apple A11 GPU|Apple A9 GPU",
                "m": function(n){return mediacolorgamut(n);},
                "n": [
                  30,
                  31
                ],
                "v": [
                  2001
                ]
              },
              {
                "x": "Apple A8 GPU|Apple A9 GPU|Apple A10 GPU|Apple A11 GPU",
                "m": function(n){return mediacolorgamut(n);},
                "n": [
                  32,
                  33
                ],
                "v": [
                  2208
                ]
              },
              {
                "x": "Apple A8 GPU|Apple A9 GPU|Apple A10 GPU|Apple A11 GPU|Apple A13 GPU",
                "m": function(n){return mediacolorgamut(n);},
                "n": [
                  34,
                  35
                ],
                "v": [
                  1334
                ]
              },
              {
                "x": "Apple A11 GPU|Apple A12 GPU|Apple A13 GPU|Apple A14 GPU|Apple A15 GPU",
                "m": function(n){return hash3d(n);},
                "n": [
                  37,
                  38,
                  39,
                  40,
                  36,
                  41
                ],
                "v": [
                  2436
                ]
              },
              {
                "x": "Apple A12 GPU|Apple A13 GPU",
                "m": function(n){return hash3d(n);},
                "n": [
                  42,
                  36
                ],
                "v": [
                  2688
                ]
              },
              {
                "x": "Apple A12 GPU|Apple A13 GPU",
                "m": function(n){return hash3d(n);},
                "n": [
                  44,
                  43
                ],
                "v": [
                  1624
                ]
              },
              {
                "x": "Apple A12 GPU|Apple A13 GPU",
                "m": function(n){return hash3d(n);},
                "n": [
                  44,
                  36
                ],
                "v": [
                  1792
                ]
              },
              {
                "x": "Apple A11 GPU|Apple A12 GPU|Apple A14 GPU|Apple A13 GPU|Apple A15 GPU",
                "m": function(n){return hash3d(n);},
                "n": [
                  47,
                  45,
                  36,
                  46,
                  41
                ],
                "v": [
                  2079
                ]
              },
              {
                "x": "Apple A14 GPU",
                "v": [
                  2532
                ]
              },
              {
                "x": "Apple A14 GPU",
                "v": [
                  2778
                ]
              },
              {
                "x": "Apple A7 GPU|Apple A8 GPU|Apple A9X GPU|Apple A10X GPU|Apple A9 GPU|Apple A12X GPU|Apple A10 GPU|Apple A12 GPU|Apple A8X GPU|Apple M1 GPU",
                "m": function(n){return mediacolorgamut(n);},
                "n": [
                  49,
                  48
                ],
                "v": [
                  2048
                ]
              },
              {
                "x": "Apple A9X GPU|Apple A10X GPU|Apple A12X GPU|Apple M1 GPU|Apple A12Z GPU",
                "m": function(n){return mediacolorgamut(n);},
                "n": [
                  50,
                  51
                ],
                "v": [
                  2732
                ]
              },
              {
                "x": "Apple A10X GPU|Apple A12 GPU",
                "m": function(n){return hash(n);},
                "n": [
                  53,
                  52
                ],
                "v": [
                  2224
                ]
              },
              {
                "x": "Apple A12X GPU|Apple M1 GPU|Apple A12Z GPU",
                "m": function(n){return hash3d(n);},
                "n": [
                  55,
                  54
                ],
                "v": [
                  2388
                ]
              },
              {
                "x": "Apple A10 GPU|Apple A12 GPU",
                "m": function(n){return hash(n);},
                "n": [
                  56,
                  57
                ],
                "v": [
                  2160
                ]
              },
              {
                "x": "Apple A14 GPU",
                "v": [
                  2360
                ]
              },
              {
                "x": "Apple A9X GPU|Apple A10X GPU|Apple A9 GPU|Apple A12X GPU|Apple A10 GPU|Apple A12 GPU|Apple A8 GPU|Apple A8X GPU|Apple M1 GPU",
                "m": function(n){return mediacolorgamut(n);},
                "n": [
                  58,
                  49
                ],
                "v": [
                  2048
                ]
              },
              {
                "x": "Apple A9 GPU|Apple A10 GPU|Apple A11 GPU",
                "m": function(n){return mediacolorgamut(n);},
                "n": [
                  59,
                  33
                ],
                "v": [
                  2208
                ]
              },
              {
                "x": "Apple A9 GPU|Apple A10 GPU|Apple A11 GPU|Apple A13 GPU",
                "m": function(n){return mediacolorgamut(n);},
                "n": [
                  59,
                  35
                ],
                "v": [
                  1334
                ]
              },
              {
                "x": "Apple A9 GPU|Apple A10 GPU|Apple A11 GPU|Apple A13 GPU",
                "m": function(n){return mediacolorgamut(n);},
                "n": [
                  60,
                  29
                ],
                "v": [
                  1136
                ]
              },
              {
                "x": "Apple A10 GPU|Apple A11 GPU|Apple A9 GPU",
                "m": function(n){return mediacolorgamut(n);},
                "n": [
                  59,
                  31
                ],
                "v": [
                  2001
                ]
              },
              {
                "x": "Apple A14 GPU",
                "v": [
                  2360,
                  2778
                ]
              },
              {
                "x": "Apple A7 GPU|Apple A9 GPU|Apple A8 GPU",
                "m": function(n){return hash(n);},
                "n": [
                  61,
                  63,
                  62,
                  64,
                  65
                ],
                "v": [
                  "srgb"
                ]
              },
              {
                "x": "Apple A10 GPU|Apple A11 GPU|Apple A13 GPU",
                "m": function(n){return hash3d(n);},
                "n": [
                  66,
                  37,
                  67
                ],
                "v": [
                  "p3"
                ]
              },
              {
                "x": "Apple A8 GPU|Apple A9 GPU",
                "m": function(n){return hash(n);},
                "n": [
                  68,
                  69
                ],
                "v": [
                  "srgb"
                ]
              },
              {
                "x": "Apple A10 GPU|Apple A11 GPU",
                "m": function(n){return hash(n);},
                "n": [
                  70,
                  71
                ],
                "v": [
                  "p3"
                ]
              },
              {
                "x": "Apple A8 GPU|Apple A9 GPU",
                "m": function(n){return hash(n);},
                "n": [
                  72,
                  73
                ],
                "v": [
                  "srgb"
                ]
              },
              {
                "x": "Apple A10 GPU|Apple A11 GPU",
                "m": function(n){return hash(n);},
                "n": [
                  70,
                  74
                ],
                "v": [
                  "p3"
                ]
              },
              {
                "x": "Apple A8 GPU|Apple A9 GPU",
                "m": function(n){return hash(n);},
                "n": [
                  75,
                  76
                ],
                "v": [
                  "srgb"
                ]
              },
              {
                "x": "Apple A10 GPU|Apple A11 GPU|Apple A13 GPU",
                "m": function(n){return hash3d(n);},
                "n": [
                  66,
                  37,
                  67
                ],
                "v": [
                  "p3"
                ]
              },
              {
                "x": "Apple A12 GPU",
                "v": [
                  958581112,
                  2301174800,
                  4085158452
                ]
              },
              {
                "x": "Apple A11 GPU",
                "v": [
                  367695777,
                  411650080,
                  1220644697
                ]
              },
              {
                "x": "Apple A13 GPU",
                "v": [
                  4193218782
                ]
              },
              {
                "x": "Apple A14 GPU",
                "v": [
                  105985484
                ]
              },
              {
                "x": "Apple A14 GPU",
                "v": [
                  3403189785
                ]
              },
              {
                "x": "Apple A14 GPU|Apple A15 GPU",
                "v": [
                  2364051618
                ]
              },
              {
                "x": "Apple A13 GPU",
                "v": [
                  352823931,
                  4193218782
                ]
              },
              {
                "x": "Apple A12 GPU",
                "v": [
                  958581112,
                  2301174800,
                  3403189785,
                  4085158452
                ]
              },
              {
                "x": "Apple A13 GPU",
                "v": [
                  352823931,
                  3335845976,
                  4193218782
                ]
              },
              {
                "x": "Apple A11 GPU",
                "v": [
                  367695777,
                  411650080
                ]
              },
              {
                "x": "Apple A14 GPU",
                "v": [
                  105985484,
                  679860869,
                  3403189785
                ]
              },
              {
                "x": "Apple A13 GPU",
                "v": [
                  352823931
                ]
              },
              {
                "x": "Apple A7 GPU|Apple A8 GPU|Apple A9X GPU|Apple A9 GPU|Apple A10 GPU|Apple A8X GPU",
                "m": function(n){return hash(n);},
                "n": [
                  80,
                  77,
                  81,
                  82,
                  83,
                  85,
                  78,
                  79,
                  84,
                  61
                ],
                "v": [
                  "srgb"
                ]
              },
              {
                "x": "Apple A10X GPU|Apple A9X GPU|Apple A12X GPU|Apple A12 GPU|Apple M1 GPU",
                "m": function(n){return hash3d(n);},
                "n": [
                  55,
                  87,
                  86,
                  88,
                  89
                ],
                "v": [
                  "p3"
                ]
              },
              {
                "x": "Apple A9X GPU",
                "v": [
                  "srgb"
                ]
              },
              {
                "x": "Apple A10X GPU|Apple A12X GPU|Apple M1 GPU|Apple A12Z GPU",
                "m": function(n){return hash3d(n);},
                "n": [
                  91,
                  90,
                  94,
                  92,
                  93
                ],
                "v": [
                  "p3"
                ]
              },
              {
                "x": "Apple A10X GPU",
                "v": [
                  63583436,
                  2114570256,
                  3129316290
                ]
              },
              {
                "x": "Apple A12 GPU",
                "v": [
                  1349146759,
                  2917249763
                ]
              },
              {
                "x": "Apple A12X GPU|Apple A12Z GPU",
                "v": [
                  4085158452
                ]
              },
              {
                "x": "Apple M1 GPU",
                "v": [
                  105985484,
                  3403189785
                ]
              },
              {
                "x": "Apple A10 GPU",
                "v": [
                  2114570256
                ]
              },
              {
                "x": "Apple A12 GPU",
                "v": [
                  1349146759,
                  2206992415
                ]
              },
              {
                "x": "Apple A9X GPU|Apple A9 GPU|Apple A10 GPU|Apple A8 GPU|Apple A8X GPU",
                "m": function(n){return hash3d(n);},
                "n": [
                  101,
                  96,
                  98,
                  97,
                  95,
                  99,
                  100
                ],
                "v": [
                  "srgb"
                ]
              },
              {
                "x": "Apple A9 GPU",
                "v": [
                  "srgb"
                ]
              },
              {
                "x": "Apple A9 GPU|Apple A10 GPU",
                "m": function(n){return hash(n);},
                "n": [
                  102,
                  64,
                  65
                ],
                "v": [
                  "srgb"
                ]
              },
              {
                "x": "Apple A7 GPU",
                "v": [
                  857422828,
                  1915583345
                ]
              },
              {
                "x": "Apple A9 GPU",
                "v": [
                  46663968,
                  3129316290
                ]
              },
              {
                "x": "Apple A8 GPU",
                "v": [
                  839732043,
                  3816812018,
                  4125234388
                ]
              },
              {
                "x": "Apple A9 GPU",
                "v": [
                  2114570256
                ]
              },
              {
                "x": "Apple A9 GPU",
                "v": [
                  63583436
                ]
              },
              {
                "x": "Apple A10 GPU",
                "v": [
                  583354101,
                  3458129248,
                  3928876783
                ]
              },
              {
                "x": "Apple A13 GPU",
                "v": [
                  352823931,
                  3335845976,
                  3403189785,
                  4193218782
                ]
              },
              {
                "x": "Apple A8 GPU",
                "v": [
                  1411440593,
                  1924197914,
                  4125234388
                ]
              },
              {
                "x": "Apple A9 GPU",
                "v": [
                  2114570256,
                  3129316290
                ]
              },
              {
                "x": "Apple A10 GPU",
                "v": [
                  63583436,
                  2114570256,
                  3129316290
                ]
              },
              {
                "x": "Apple A11 GPU",
                "v": [
                  1349146759,
                  2917249763
                ]
              },
              {
                "x": "Apple A8 GPU",
                "v": [
                  1411440593,
                  1913250432,
                  3074367344,
                  4125234388
                ]
              },
              {
                "x": "Apple A9 GPU",
                "v": [
                  46663968,
                  2114570256,
                  3129316290
                ]
              },
              {
                "x": "Apple A11 GPU",
                "v": [
                  2917249763,
                  3237505312
                ]
              },
              {
                "x": "Apple A8 GPU",
                "v": [
                  3128296539,
                  3816812018,
                  4125234388
                ]
              },
              {
                "x": "Apple A9 GPU",
                "v": [
                  46663968,
                  63583436,
                  2114570256,
                  3129316290
                ]
              },
              {
                "x": "Apple A8 GPU",
                "v": [
                  2656686317,
                  3710391565
                ]
              },
              {
                "x": "Apple A9X GPU|Apple A9 GPU|Apple A10 GPU",
                "v": [
                  3129316290
                ]
              },
              {
                "x": "Apple A9 GPU|Apple A9X GPU|Apple A10 GPU",
                "m": function(n){return hash3d(n);},
                "n": [
                  103,
                  95,
                  99
                ],
                "v": [
                  2114570256
                ]
              },
              {
                "x": "Apple A10 GPU",
                "v": [
                  46663968
                ]
              },
              {
                "x": "Apple A8 GPU|Apple A8X GPU",
                "m": function(n){return benchmarkcpuavg(n);},
                "n": [
                  105,
                  104
                ],
                "v": [
                  4125234388
                ]
              },
              {
                "x": "Apple A8 GPU|Apple A8X GPU",
                "m": function(n){return hash3d(n);},
                "n": [
                  106,
                  107,
                  108
                ],
                "v": [
                  4005673483
                ]
              },
              {
                "x": "Apple A8 GPU|Apple A8X GPU",
                "v": [
                  1350183384,
                  1361285941,
                  3816812018
                ]
              },
              {
                "x": "Apple A9X GPU|Apple A9 GPU|Apple A10 GPU",
                "m": function(n){return hash3d(n);},
                "n": [
                  101,
                  100
                ],
                "v": [
                  63583436
                ]
              },
              {
                "x": "Apple A8 GPU|Apple A8X GPU",
                "m": function(n){return hash3d(n);},
                "n": [
                  110,
                  109
                ],
                "v": [
                  2870741841
                ]
              },
              {
                "x": "Apple A10X GPU|Apple A9X GPU",
                "v": [
                  3458129248
                ]
              },
              {
                "x": "Apple A12X GPU|Apple A12 GPU",
                "v": [
                  4085158452
                ]
              },
              {
                "x": "Apple A10X GPU|Apple A9X GPU",
                "m": function(n){return benchmarkcpuavg(n);},
                "n": [
                  111,
                  112
                ],
                "v": [
                  583354101
                ]
              },
              {
                "x": "Apple A10X GPU|Apple A9X GPU",
                "m": function(n){return benchmarkcpuavg(n);},
                "n": [
                  113,
                  114
                ],
                "v": [
                  3928876783
                ]
              },
              {
                "x": "Apple A12X GPU",
                "v": [
                  4085158452
                ]
              },
              {
                "x": "Apple A10X GPU",
                "v": [
                  583354101,
                  3458129248,
                  3928876783
                ]
              },
              {
                "x": "Apple M1 GPU",
                "v": [
                  105985484
                ]
              },
              {
                "x": "Apple M1 GPU|Apple A10X GPU",
                "m": function(n){return hash(n);},
                "n": [
                  116,
                  115
                ],
                "v": [
                  3403189785
                ]
              },
              {
                "x": "Apple A12Z GPU",
                "v": [
                  958581112
                ]
              },
              {
                "x": "Apple A9X GPU|Apple A10 GPU",
                "v": [
                  3458129248
                ]
              },
              {
                "x": "Apple A8X GPU",
                "v": [
                  1480368425,
                  1783160115
                ]
              },
              {
                "x": "Apple A8X GPU|Apple A10 GPU",
                "m": function(n){return hash(n);},
                "n": [
                  56,
                  117
                ],
                "v": [
                  3403189785
                ]
              },
              {
                "x": "Apple A8 GPU",
                "v": [
                  3312905059,
                  3928382683
                ]
              },
              {
                "x": "Apple A9 GPU|Apple A9X GPU|Apple A10 GPU",
                "m": function(n){return benchmarkcpuavg(n);},
                "n": [
                  118,
                  119
                ],
                "v": [
                  583354101
                ]
              },
              {
                "x": "Apple A9X GPU|Apple A9 GPU|Apple A10 GPU",
                "m": function(n){return benchmarkcpuavg(n);},
                "n": [
                  120,
                  122,
                  121
                ],
                "v": [
                  3928876783
                ]
              },
              {
                "x": "Apple A10 GPU",
                "v": [
                  1058363647,
                  2015944978
                ]
              },
              {
                "x": "Apple A9 GPU",
                "v": [
                  46663968
                ]
              },
              {
                "x": "Apple A10 GPU",
                "v": [
                  3403189785
                ]
              },
              {
                "x": "Apple A8 GPU|Apple A8X GPU",
                "m": function(n){return benchmarkcpustd(n);},
                "n": [
                  123,
                  124
                ],
                "r": [
                  {
                    "a": 29.78,
                    "b": 30.87
                  }
                ]
              },
              {
                "x": "Apple A8 GPU",
                "r": [
                  {
                    "a": 31.19,
                    "b": 31.59
                  }
                ]
              },
              {
                "x": "Apple A8X GPU",
                "v": [
                  1783160115
                ]
              },
              {
                "x": "Apple A8 GPU",
                "v": [
                  3928382683
                ]
              },
              {
                "x": "Apple A8 GPU|Apple A8X GPU",
                "m": function(n){return benchmarkcpustd(n);},
                "n": [
                  125,
                  126
                ],
                "v": [
                  3403189785
                ]
              },
              {
                "x": "Apple A8 GPU",
                "v": [
                  3312905059
                ]
              },
              {
                "x": "Apple A8X GPU",
                "v": [
                  1480368425
                ]
              },
              {
                "x": "Apple A10X GPU",
                "r": [
                  {
                    "a": 14.16,
                    "b": 17.21
                  }
                ]
              },
              {
                "x": "Apple A9X GPU",
                "r": [
                  {
                    "a": 18.44,
                    "b": 35.94
                  }
                ]
              },
              {
                "x": "Apple A10X GPU",
                "r": [
                  {
                    "a": 12.34,
                    "b": 15.6
                  }
                ]
              },
              {
                "x": "Apple A9X GPU",
                "r": [
                  {
                    "a": 16.8,
                    "b": 121.37
                  }
                ]
              },
              {
                "x": "Apple M1 GPU",
                "v": [
                  1349146759
                ]
              },
              {
                "x": "Apple A10X GPU",
                "v": [
                  2114570256
                ]
              },
              {
                "x": "Apple A8X GPU",
                "v": [
                  4005673483
                ]
              },
              {
                "x": "Apple A9X GPU|Apple A9 GPU",
                "r": [
                  {
                    "a": 24.38,
                    "b": 31.67
                  }
                ]
              },
              {
                "x": "Apple A10 GPU|Apple A9X GPU",
                "r": [
                  {
                    "a": 16.82,
                    "b": 22.52
                  }
                ]
              },
              {
                "x": "Apple A9 GPU|Apple A9X GPU",
                "r": [
                  {
                    "a": 19.79,
                    "b": 21.64
                  }
                ]
              },
              {
                "x": "Apple A10 GPU|Apple A9X GPU",
                "m": function(n){return benchmarkcpustd(n);},
                "n": [
                  127
                ],
                "r": [
                  {
                    "a": 14.44,
                    "b": 19.65
                  }
                ]
              },
              {
                "x": "Apple A9 GPU|Apple A9X GPU",
                "r": [
                  {
                    "a": 22.74,
                    "b": 24.91
                  }
                ]
              },
              {
                "x": "Apple A8X GPU",
                "r": [
                  {
                    "a": 0.26,
                    "b": 5.62
                  }
                ]
              },
              {
                "x": "Apple A8 GPU",
                "r": [
                  {
                    "a": 6.32,
                    "b": 161.36
                  }
                ]
              },
              {
                "x": "Apple A8X GPU",
                "r": [
                  {
                    "a": 0.53,
                    "b": 13.31
                  }
                ]
              },
              {
                "x": "Apple A8 GPU",
                "r": [
                  {
                    "a": 83.08,
                    "b": 2952.42
                  }
                ]
              },
              {
                "x": "Apple A9X GPU|Apple A10 GPU",
                "r": [
                  {
                    "a": 29.8,
                    "b": 228.33
                  }
                ]
              }
            ];
    
        function hash3d() {
            // This function is based on this article: https://bl.ocks.org/camargo/649e5903c4584a21a568972d4a2c16d3
            // The 'mat4' object is created from code in the gl-matrix library: https://github.com/toji/gl-matrix
            var gl, program, canvas;
    
            // The non-minified versions of these shaders are available in
            // WebSite/partials/fragment-shader.glsl and
            // WebSite/partials/vertex-shader.glsl
            var VERTEX_SHADER = 'attribute vec3 c,d; uniform vec4 e; uniform vec3 f,g;uniform mat4 h,i;varying vec3 j;void main(){vec3 a=normalize(d);vec4 b=h*vec4(c,1.);vec3 k=normalize(vec3(e-b));j=g*f*max(dot(k,a),0.),gl_Position=i*vec4(c,1.);}';
            var FRAGMENT_SHADER = '#ifdef GL_ES\n' +
                'precision mediump float;\n' +
                '#endif\n' +
                'varying vec3 j;void main(){gl_FragColor = vec4(j, 1.0);}';
    
            // This object uses code from the gl-matrix library: https://github.com/toji/gl-matrix
            var mat4 = {
                create: function () {
                    var result = new Array(16);
                    for (var i = 0; i < 16; i++) {
                        result[i] = (i % 5 == 0 ? 1 : 0);
                    }
                    return result;
                },
                perspective: function (out, fovy, aspect, near, far) {
                    var f = 1.0 / Math.tan(fovy / 2), nf;
                    out[0] = f / aspect;
                    out[1] = 0;
                    out[2] = 0;
                    out[3] = 0;
                    out[4] = 0;
                    out[5] = f;
                    out[6] = 0;
                    out[7] = 0;
                    out[8] = 0;
                    out[9] = 0;
                    out[11] = -1;
                    out[12] = 0;
                    out[13] = 0;
                    out[15] = 0;
                    if (far != null && far !== Infinity) {
                        nf = 1 / (near - far);
                        out[10] = (far + near) * nf;
                        out[14] = (2 * far * near) * nf;
                    } else {
                        out[10] = -1;
                        out[14] = -2 * near;
                    }
                    return out;
                },
                lookAt: function (out, eye, center, up) {
                    var x0, x1, x2, y0, y1, y2, z0, z1, z2, len;
                    var eyex = eye[0];
                    var eyey = eye[1];
                    var eyez = eye[2];
                    var upx = up[0];
                    var upy = up[1];
                    var upz = up[2];
                    var centerx = center[0];
                    var centery = center[1];
                    var centerz = center[2];
    
                    if (Math.abs(eyex - centerx) < 0.000001 &&
                        Math.abs(eyey - centery) < 0.000001 &&
                        Math.abs(eyez - centerz) < 0.000001) {
                        return mat4.identity(out);
                    }
    
                    z0 = eyex - centerx;
                    z1 = eyey - centery;
                    z2 = eyez - centerz;
    
                    len = 1 / Math.hypot(z0, z1, z2);
                    z0 *= len;
                    z1 *= len;
                    z2 *= len;
    
                    x0 = upy * z2 - upz * z1;
                    x1 = upz * z0 - upx * z2;
                    x2 = upx * z1 - upy * z0;
                    len = Math.hypot(x0, x1, x2);
                    if (!len) {
                        x0 = 0;
                        x1 = 0;
                        x2 = 0;
                    } else {
                        len = 1 / len;
                        x0 *= len;
                        x1 *= len;
                        x2 *= len;
                    }
    
                    y0 = z1 * x2 - z2 * x1;
                    y1 = z2 * x0 - z0 * x2;
                    y2 = z0 * x1 - z1 * x0;
    
                    len = Math.hypot(y0, y1, y2);
                    if (!len) {
                        y0 = 0;
                        y1 = 0;
                        y2 = 0;
                    } else {
                        len = 1 / len;
                        y0 *= len;
                        y1 *= len;
                        y2 *= len;
                    }
    
                    out[0] = x0;
                    out[1] = y0;
                    out[2] = z0;
                    out[3] = 0;
                    out[4] = x1;
                    out[5] = y1;
                    out[6] = z1;
                    out[7] = 0;
                    out[8] = x2;
                    out[9] = y2;
                    out[10] = z2;
                    out[11] = 0;
                    out[12] = -(x0 * eyex + x1 * eyey + x2 * eyez);
                    out[13] = -(y0 * eyex + y1 * eyey + y2 * eyez);
                    out[14] = -(z0 * eyex + z1 * eyey + z2 * eyez);
                    out[15] = 1;
    
                    return out;
                },
                multiply: function (out, a, b) {
                    var a00 = a[0], a01 = a[1], a02 = a[2], a03 = a[3];
                    var a10 = a[4], a11 = a[5], a12 = a[6], a13 = a[7];
                    var a20 = a[8], a21 = a[9], a22 = a[10], a23 = a[11];
                    var a30 = a[12], a31 = a[13], a32 = a[14], a33 = a[15];
    
                    var b0 = b[0], b1 = b[1], b2 = b[2], b3 = b[3];
                    out[0] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
                    out[1] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
                    out[2] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
                    out[3] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
    
                    b0 = b[4]; b1 = b[5]; b2 = b[6]; b3 = b[7];
                    out[4] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
                    out[5] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
                    out[6] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
                    out[7] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
    
                    b0 = b[8]; b1 = b[9]; b2 = b[10]; b3 = b[11];
                    out[8] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
                    out[9] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
                    out[10] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
                    out[11] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
    
                    b0 = b[12]; b1 = b[13]; b2 = b[14]; b3 = b[15];
                    out[12] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
                    out[13] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
                    out[14] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
                    out[15] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
                    return out;
                },
                identity: function (out) {
                    out[0] = 1;
                    out[1] = 0;
                    out[2] = 0;
                    out[3] = 0;
                    out[4] = 0;
                    out[5] = 1;
                    out[6] = 0;
                    out[7] = 0;
                    out[8] = 0;
                    out[9] = 0;
                    out[10] = 1;
                    out[11] = 0;
                    out[12] = 0;
                    out[13] = 0;
                    out[14] = 0;
                    out[15] = 1;
                    return out;
                }
            };
    
            function initVertexBuffers(gl) {
                var latitudeBands = 50;
                var longitudeBands = 50;
                var radius = 2;
    
                var vertexPositionData = [];
                var normalData = [];
                var textureCoordData = [];
                var indexData = [];
    
                var latNumber, longNumber;
    
                // Calculate sphere vertex positions, normals, and texture coordinates.
                for (latNumber = 0; latNumber <= latitudeBands; ++latNumber) {
                    var theta = latNumber * Math.PI / latitudeBands;
                    var sinTheta = Math.sin(theta);
                    var cosTheta = Math.cos(theta);
    
                    for (longNumber = 0; longNumber <= longitudeBands; ++longNumber) {
                        var phi = longNumber * 2 * Math.PI / longitudeBands;
                        var sinPhi = Math.sin(phi);
                        var cosPhi = Math.cos(phi);
    
                        var x = cosPhi * sinTheta;
                        var y = cosTheta;
                        var z = sinPhi * sinTheta;
    
                        var u = 1 - (longNumber / longitudeBands);
                        var v = 1 - (latNumber / latitudeBands);
    
                        vertexPositionData.push(radius * x);
                        vertexPositionData.push(radius * y);
                        vertexPositionData.push(radius * z);
    
                        normalData.push(x);
                        normalData.push(y);
                        normalData.push(z);
    
                        textureCoordData.push(u);
                        textureCoordData.push(v);
                    }
                }
    
                // Calculate sphere indices.
                for (latNumber = 0; latNumber < latitudeBands; ++latNumber) {
                    for (longNumber = 0; longNumber < longitudeBands; ++longNumber) {
                        var first = (latNumber * (longitudeBands + 1)) + longNumber;
                        var second = first + longitudeBands + 1;
    
                        indexData.push(first);
                        indexData.push(second);
                        indexData.push(first + 1);
    
                        indexData.push(second);
                        indexData.push(second + 1);
                        indexData.push(first + 1);
                    }
                }
    
                vertexPositionData = new Float32Array(vertexPositionData);
                normalData = new Float32Array(normalData);
                textureCoordData = new Float32Array(textureCoordData);
                indexData = new Uint16Array(indexData);
    
                // Create buffer objects.
                var vertexPositionBuffer = gl.createBuffer();
                var vertexNormalBuffer = gl.createBuffer();
                var indexBuffer = gl.createBuffer();
    
                // Write the vertex positions to their buffer object.
                gl.bindBuffer(gl.ARRAY_BUFFER, vertexPositionBuffer);
                gl.bufferData(gl.ARRAY_BUFFER, vertexPositionData, gl.STATIC_DRAW);
    
                // Assign position coords to attrib and enable it.
                var VertexPosition = gl.getAttribLocation(program, 'c');
                gl.vertexAttribPointer(VertexPosition, 3, gl.FLOAT, false, 0, 0);
                gl.enableVertexAttribArray(VertexPosition);
    
                // Write the normals to their buffer object.
                gl.bindBuffer(gl.ARRAY_BUFFER, vertexNormalBuffer);
                gl.bufferData(gl.ARRAY_BUFFER, normalData, gl.STATIC_DRAW);
    
                // Assign normal to attrib and enable it.
                var VertexNormal = gl.getAttribLocation(program, 'd');
                gl.vertexAttribPointer(VertexNormal, 3, gl.FLOAT, false, 0, 0);
                gl.enableVertexAttribArray(VertexNormal);
    
                // Pass index buffer data to element array buffer.
                gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indexBuffer);
                gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, indexData, gl.STATIC_DRAW);
    
                return indexData.length;
            }
    
            function generate() {
                if (!(gl = getRenderingContext()))
                    return;
    
                var vertexShader = gl.createShader(gl.VERTEX_SHADER);
                gl.shaderSource(vertexShader, VERTEX_SHADER);
                gl.compileShader(vertexShader);
                var fragmentShader = gl.createShader(gl.FRAGMENT_SHADER);
                gl.shaderSource(fragmentShader, FRAGMENT_SHADER);
                gl.compileShader(fragmentShader);
                program = gl.createProgram();
                gl.attachShader(program, vertexShader);
                gl.attachShader(program, fragmentShader);
                gl.linkProgram(program);
                gl.detachShader(program, vertexShader);
                gl.detachShader(program, fragmentShader);
                gl.deleteShader(vertexShader);
                gl.deleteShader(fragmentShader);
                gl.useProgram(program);
    
                // Init vertex buffers (position, color, and index data).
                var n = initVertexBuffers(gl);
    
                // Set up clear color and enable depth testing.
                gl.clearColor(0.0, 0.0, 0.0, 1.0);
                gl.enable(gl.DEPTH_TEST);
    
                // Create projection matrix.
                var projection = mat4.create();
                mat4.perspective(projection, Math.PI / 6, 1.0, 0.1, 100.0);
    
                // Create model-view matrix.
                var modelView = mat4.create();
                mat4.lookAt(modelView, [0.0, 0.0, 10.0], [0.0, 0.0, 0.0], [0.0, 1.0, 0.0]);
    
                // Multiply the projection matrix by the model-view matrix to create the mvpMatrix.
                var mvpMatrix = mat4.create();
                mat4.multiply(mvpMatrix, projection, modelView);
    
                // Pass the modelView matrix into the shader.
                var ModelViewMatrix = gl.getUniformLocation(program, 'h');
                gl.uniformMatrix4fv(ModelViewMatrix, false, modelView);
    
                // Pass the mvp matrix into the shader.
                var MVP = gl.getUniformLocation(program, 'i');
                gl.uniformMatrix4fv(MVP, false, mvpMatrix);
    
                // Pass the light position into the shader.
                var LightPosition = gl.getUniformLocation(program, 'e');
                gl.uniform4fv(LightPosition, [10.0, 10.0, 10.0, 1.0]);
    
                // Pass the material diffuse color into the shader.
                var Kd = gl.getUniformLocation(program, 'f');
                gl.uniform3fv(Kd, [0.9, 0.5, 0.3]);
    
                // Pass the light diffuse color into the shader.
                var Ld = gl.getUniformLocation(program, 'g');
                gl.uniform3fv(Ld, [1.0, 1.0, 1.0]);
    
                // Clear & draw.
                gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
                gl.drawElements(gl.TRIANGLES, n, gl.UNSIGNED_SHORT, 0);
    
                cleanup();
                return canvas.toDataURL();
            }
    
            function cleanup() {
                gl.useProgram(null);
                if (program)
                    gl.deleteProgram(program);
            }
    
            function getRenderingContext() {
                canvas.width = 67;
                canvas.height = 67;
                var gl = canvas.getContext("webgl")
                    || canvas.getContext("experimental-webgl");
                if (gl) {
                    gl.viewport(0, 0, 67, 67);
                    gl.clearColor(0.0, 0.0, 0.0, 1.0);
                    gl.clear(gl.COLOR_BUFFER_BIT);
                }
                return gl;
            }
    
            var imageHash = 0;
    
            canvas = document.createElement("canvas");
            if (canvas != null) {
                // Get the image data as a string.
                var imageData = generate();
                if (imageData) {
                    // Hash the image data.
                    imageHash = fnvHash(imageData);
                }
            }
    
            return imageHash;
        }
    
        // An uninitialised array of CPU benchmark results. Used to store results
        // from the first run to avoid performing the benchmark a subsequent time.
        var benchmarkValues = null;
    
        // Performs the CPU benchmark using multiple web workers and records the
        // samples in benchmarkValues. If the benchmark samples have already been
        // collected the promise resolves immediately.
        // @return a promise that will either resolve to the CPU benchmark
        // value, or reject with an error message. 
        function benchmarkcpu() {
    
            function workerState() {
                this.samples = [];
                this.active = 0;
            }
    
            function timerComplete(worker) {
    
                // Stop the web worker as it's timed out.
                worker.terminate();
    
                finished(worker.state);
            }
    
            function workerComplete(source) {
    
                // Clear the timer if present.
                clearTimeout(source.currentTarget.timeout);
    
                // Get the state attached to the web worker.
                var state = source.currentTarget.state;
    
                // Stop the web worker as there are no more messages for it.
                source.currentTarget.terminate();
    
                // Add the sample from the web worker to the main array of samples.
                state.samples = state.samples.concat(source.data);
    
                finished(state);
            }
    
            function finished(state) {
    
                // Reduce the number of active web workers.
                state.active--;
    
                // If this is the last web worker then finish the test.
                if (state.active === 0) {
    
                    // Record the CPU cleaned benchmark value to avoid repeated
                    // execution.
                    benchmarkValues = state.samples;
    
                    // Resolve the promise.
                    state.resolve(benchmarkValues);
                }
            }
    
            // Starts the web workers using the URL provided.
            function workersStart(resolve, reject, url) {
                var workers = [];
                var state = new workerState();
                state.resolve = resolve;
                state.reject = reject;
                try {
                    for (var i = 0; i < 2; i++) {
    
                        // Start a web worker with the URL provided.
                        var worker = new Worker(url);
    
                        // Add the state for all web workers to this web worker.
                        worker.state = state;
    
                        // Set functions and add to the array of workers.
                        worker.onmessage = workerComplete;
                        worker.onerror = function (error) { reject(error); };
                        workers.push(worker);
                    }
    
                    // Get the web workers to run the benchmark 80 times. If the 
                    // worker doesn't complete within 4 seconds then timeout.
                    for (var i = 0; i < workers.length; i++) {
                        state.active++;
                        workers[i].postMessage(80);
                        workers[i].timeout = setTimeout(
                            timerComplete, 4000, workers[i]);
                    }
                }
                catch (ex) {
                    reject(new Error(ex));
                }
            }
    
            // Valids the URL and starts the web workers if valid, otherwise
            // rejects the promise.
            function workerFetchUrl(resolve, reject, url) {
                fetch(url, {
                    mode: 'same-origin'
                }).then(function (response) {
    
                    // If the URL is valid then use it to start the workers
                    // running the CPU benchmark.
                    if (response.ok) {
                        workersStart(resolve, reject, response.url);
                    }
    
                    // If the URL is not valid then use the reject method
                    // to return the Profile Id of the current node.
                    else {
                        var error = new Error('Url could not be reached');
                        error.response = response;
                        reject(error);
                    }
                }).catch(function (error) {
    
                    // The Url can not be loaded. Reject the operation.                  
                    reject(error);
                });
            }
    
            // Create a new promise that will validate the URL for the web workers
            // and then start them, or if the URL is invalid reject the promise.
            return new Promise(function (resolve, reject) {
                if (benchmarkValues != null) {
                    resolve(benchmarkValues);
                }
                else {
                    // Wait 1 second before executing the benchmark.
                    // Testing has shown that this benchmark can return significantly
                    // slower results when a page is being retrieved for the first
                    // time.
                    // This can often mean that devices are reported incorrectly.
                    // Waiting for 1 second gives the device enough time to settle 
                    // down and gives a far more consistent benchmark result.
                    // Note that this does not affect page load time as the wait
                    // occurs on a background thread.
                    setTimeout(function () {
                        workerFetchUrl(resolve, reject, takUrl);
                    }, 1000);
                }
            });
        }
    
        // Uses the CPU benchmark data to work out an average.
        // @param node that the benchmark is being run for. 
        // @return a promise which when resolved will produce the average.
        function benchmarkcpuavg(node) {
            return benchmarkcpu().then(function (values) {
                var average = 0;
                if (values.length > 0) {
                    var sum = values.reduce(function (previous, current) {
                        return current += previous;
                    });
                    average = sum / values.length;
                }
                resolveNode(node, average, 0);
            }).catch(function (error) {
                complete(node.x);
            });;
        }
    
        // Uses the CPU benchmark data to work out a the standard deviation.
        // @param node that the benchmark is being run for. 
        // @return a promise which when resolved will produce the standard 
        // deviation..
        function benchmarkcpustd(node) {
            return benchmarkcpu().then(function (values) {
                var std = 0;
                if (values.length > 0) {
                    var sum = values.reduce(function (previous, current) {
                        return current += previous;
                    });
                    var average = values.length > 0 ? sum / values.length : 0;
                    std = values.reduce(function (sq, n) {
                        return sq + Math.pow(n - average, 2);
                    }, 0) / (values.length - 1);
                }
                resolveNode(node, std, 0);
            }).catch(function (error) {
                complete(node.x);
            });;
        }
    
        // Performs an FNV hash on the string provided.
        // @param str the string to be hashed.
        // @return the hash value as a 32 bit integer.
        function fnvHash(str) {
            var h = 0x811c9dc5;
            for (var i = 0; i < str.length; ++i) {
                h ^= str.charCodeAt(i);
                h += (h << 1) + (h << 4) + (h << 7) + (h << 8) + (h << 24);
            }
            return h >>> 0;
        }
    
        function hash() {
    
            // Draws an image that changes very subtly based on the GPU model used
            // to render it.
            // @param a canvas instance that has not be drawn to.
            // @return a base 64 encoded string containing the image.
            function drawImage(canvas) {
    
                // Configure the canvas and get context.
                canvas.width = 67;
                canvas.height = 67;
                var ctx = canvas.getContext('2d', { alpha: true });
    
                if (ctx != null) {
    
                    // Configure the canvas context.
                    ctx.imageSmoothingQuality = "low";
                    ctx.imageSmoothingEnabled = true;
                    ctx.globalCompositeOperation = "source-over";
                    ctx.globalAlpha = 1;
                    ctx.miterLimit = Infinity;
                    ctx.filter = "none";
                    ctx.lineCap = "butt";
                    ctx.lineDashOffset = 0;
                    ctx.lineJoin = "miter";
                    ctx.font = "10pt Arial";
                    ctx.lineWidth = 2;
                    // setLineDash not supported on iPhone 3G / iOS 4.2
                    if (ctx.setLineDash !== undefined) {
                        ctx.setLineDash([10, 20]);
                    }
                    ctx.shadowColor = "black";
                    ctx.shadowOffsetX = -3;
                    ctx.shadowOffsetY = -5;
    
                    // Rotate the canvas and add some text.
                    ctx.translate(canvas.width / 2, canvas.height / 2);
                    ctx.rotate(0.8901179);
                    ctx.fillStyle = "green";
                    ctx.textAlign = "center";
                    ctx.textBaseline = "middle";
                    ctx.fillText("*51Degrees*", 0, 0);
    
                    // Draw a transparent circle or elipse over the text. A circle
                    // is used if the ellipse feature is not supported by the GPU.
                    ctx.beginPath();
                    ctx.shadowColor = "yellow";
                    ctx.shadowBlur = 1;
                    ctx.shadowOffsetX = 1;
                    ctx.shadowOffsetY = 1;
                    ctx.strokeStyle = "red";
                    ctx.fillStyle = "rgba(0, 0, 255, 0.6)";
                    if (ctx.ellipse === undefined) {
                        ctx.arc(0, 0, 25, 0, 2 * Math.PI);
                    }
                    else {
                        ctx.ellipse(0, 0, 25, 15, Math.PI / 4, 0, 2 * Math.PI);
                    }
                    ctx.fill();
                    ctx.stroke();
    
                    // Return the image as a base 64 encoded string.
                    return canvas.toDataURL();
                }
            }
    
            var imageHash = 0;
    
            var canvas = document.createElement("canvas");
            if (canvas != null) {
    
                // Get the image data as a string.
                var imageData = drawImage(canvas);
                if (imageData) {
    
                    // Hash the image data.
                    imageHash = fnvHash(imageData);
                }
            }
    
            return imageHash;
        }
    
        // Try getting the renderer string via the conventional debug extension.
        // @return the UNMASKED_RENDERER_WEBGL parameter value.
        function reportedrenderer() {
            var canvas = document.createElement("canvas");
            if (canvas != null) {
                var context = canvas.getContext("webgl") ||
                    canvas.getContext("experimental-webgl");
                if (context) {
                    var info = context.getExtension("WEBGL_debug_renderer_info");
                    if (info) {
                        return context.getParameter(info.UNMASKED_RENDERER_WEBGL);
                    }
                }
            }
            return '';
        }
    
        // Width of the screen in pixels.
        function width() {
            return window.screen.width * window.devicePixelRatio;
        }
    
        // Height of the screen in pixels.
        function height() {
            return window.screen.height * window.devicePixelRatio;
        }
    
        // Pixel ratio of the screen.
        function ratio() {
            return window.devicePixelRatio;
        }
    
        // Determines if the query is supported by the device.
        // @param query the media query to check
        // @return true if the query is supported, otherwise false
        function hasMediaSupport(query) {
            return window.matchMedia(query).matches;
        }
    
        // Takes a list of values for a media query name and returns
        // the one that is supported, or undefined if none are supported.
        // @param name of the media query
        // @param possibleValues possible values for the media query name
        // @return the first value from the list that matches, otherwise "n/a"
        function getMediaSingleValue(name, possibleValues) {
            for (var i = 0; i < possibleValues.length; i++) {
                if (hasMediaSupport('(' + name + ': ' + possibleValues[i] + ')')) {
                    return possibleValues[i];
                }
            }
            return 'n/a';
        }
    
        // Returns the color gamut value from the media queries.
        // @return p2 or srgb or undefined
        function mediacolorgamut() {
            return getMediaSingleValue('color-gamut', ['p3', 'srgb']);
        }
    
        // Returns the portion of the User-Agent which represents the family of 
        // Apple products the device belongs.
        // @return iPhone, iPad or Macintosh otherwise empty string
        function family() {
            var segments = /iPhone|iPad|Macintosh/.exec(navigator.userAgent);
            if (segments && segments.length > 0) {
                return segments[0];
            }
            return '';
        }
    
        function resolveNode(node, value, iterations) {
    
            // For all the children of the node being evaluated.
            for (var i = 0; i < node.n.length; i++) {
    
                // Get the values for the child.
                var child = nodes[node.n[i]];
    
                // If the child is a range of values.
                if (child.r) {
    
                    for (var c = 0; c < child.r.length; c++) {
                        var range = child.r[c];
    
                        // If the value is between the two values as a range.
                        if ((range.a === null || value >= range.a) &&
                            (range.b === null || value <= range.b)) {
                            evaluateNode(child, 0);
                            return;
                        }
                    }
                }
    
                // If the child has a specific list of values.
                else if (child.v) {
    
                    // Compare for equality with the value found.
                    if (child.v.indexOf(value) != -1) {
                        evaluateNode(child, 0);
                        return;
                    }
                }
            }
    
            // If this node has children then wait 10ms and then retry the 
            // evaluation of this function if we've tried it less than 10 times.
            if (node.n.length > 0 && iterations < 10) {
                setTimeout(function () {
                    evaluateNode(node, iterations + 1)
                }, 10);
            }
    
            // There child that have matched. Therefore return the Profile
            // Id of the node passed.
            complete(node.x);
        }
    
        // Evaluates the children of the node until a Profile Id is found.
        // @param node to be evaluated.
        // @return the profile Id of the best node found.
        function evaluateNode(node, iterations) {
    
            // If there is a function then execute it, get the result and
            // then find the matching item in the list.
            if (node.m) {
    
                // Get the value from the function.
                var result = node.m(node);
    
                // If this isn't a promise then resolve the value returned. If it
                // is a promise it's up to the evaluation method to handle
                // processing the promise once it's resolved.
                if (result || result === '') {
                    if (!result.then) {
                        resolveNode(node, result, iterations);
                    }
                }
                else if (node.x) {
                    complete(node.x);
                }
            }
    
            // There is no method so return the Profile Id.
            else {
                complete(node.x);
            }
        }
    
        // Evaluate the root node of the tree.
        evaluateNode(nodes[0], 0);
        complete('done');
    }

    function test() {
        let results = [];
        function getPrime() {
            return largest_prime_factor(100000000000);
        }
        function factors(n) {
            var i;
            var out = [];
            var sqrt_n = Math.sqrt(n);
            for (i = 2; i <= sqrt_n; i++) {
                if (n % i === 0) {
                    out.push(i);
                }
            }
            return out;
        }
        function primep(n) {
            return factors(n).length === 0;
        }
        function largest_prime_factor(n) {
            return factors(n).filter(primep).pop();
        }

        for (let i = 0; i < 3; i++) {
            let time = performance.now();
            getPrime();
            results.push((performance.now() - time) * 10);
        }

        results.sort((a, b) => a - b);
        return results[0];
    }

    function fallbackTest() { //https://yesviz.com/iphones.php
        let res = Math.min(screen.width, screen.height) + 'x' + Math.max(screen.width, screen.height);
        let time = test();
        switch (res) {
            case '320x480': //old
                Device.graphics.webgl.gpu = 'legacy';
                break;

            case '320x568': //iphone 5/5s/6se
                if (time <= 400) Device.graphics.webgl.gpu = 'apple a8';
                else if (time <= 500) Device.graphics.webgl.gpu = 'apple a7';
                else Device.graphics.webgl.gpu = 'legacy';
                break;

            case '375x812': //iphone x / 11 pro
            case '414x896': //iphone xs plus // iphone 11 / 11 pro max
                if (time <= 150) Device.graphics.webgl.gpu = 'apple a13';
                else if (time <= 180) Device.graphics.webgl.gpu = 'apple a12';
                else Device.graphics.webgl.gpu = 'apple a11';
                break;

            case '414x736': //iphone 6/7/8+
            case '375x667': //iphone 6/6s/7/8
                if (time <= 220) Device.graphics.webgl.gpu = 'apple a11';
                else if (time <= 250) Device.graphics.webgl.gpu = 'apple a10';
                else if (time <= 360) Device.graphics.webgl.gpu = 'apple a9';
                else if (time <= 400) Device.graphics.webgl.gpu = 'apple a8';
                else if (time <= 600) Device.graphics.webgl.gpu = 'apple a7';
                else Device.graphics.webgl.gpu = 'legacy';
                break;

            default: //catchall
            case '768x1024': //ipad mini of all gens, ipad 9.7"
                if (time <= 140) Device.graphics.webgl.gpu = 'apple a14';
                else if (time <= 160) Device.graphics.webgl.gpu = 'apple a13';
                else if (time <= 180) Device.graphics.webgl.gpu = 'apple a12';
                else if (time <= 220) Device.graphics.webgl.gpu = 'apple a11';
                else if (time <= 250) Device.graphics.webgl.gpu = 'apple a10';
                else if (time <= 360) Device.graphics.webgl.gpu = 'apple a9';
                else if (time <= 400) Device.graphics.webgl.gpu = 'apple a8';
                else if (time <= 600) Device.graphics.webgl.gpu = 'apple a7';
                else Device.graphics.webgl.gpu = 'legacy';
                break;

            case '834x1112': //ipad 2019
                if (time <= 160) Device.graphics.webgl.gpu = 'apple a13';
                else if (time <= 180) Device.graphics.webgl.gpu = 'apple a12';
                else if (time <= 220) Device.graphics.webgl.gpu = 'apple a11';
                else Device.graphics.webgl.gpu = 'apple a10';
                break;

            case '834x1194': //ipad pro 11"
                if (time <= 140) Device.graphics.webgl.gpu = 'apple m1 gpu';
                else if (time <= 160) Device.graphics.webgl.gpu = 'apple a13';
                else if (time <= 180) Device.graphics.webgl.gpu = 'apple a12';
                break;

            case '810x1080': //ipad 10.2"
                if (time <= 160) Device.graphics.webgl.gpu = 'apple a13';
                else if (time <= 220) Device.graphics.webgl.gpu = 'apple a11';
                else if (time <= 250) Device.graphics.webgl.gpu = 'apple a10';
                break;

            case '820x1180': //ipad air 4
                Device.graphics.webgl.gpu = 'apple a14';
                break;

            case '428x926': //iphone 13
            case '390x844': //iphone 13
                Device.graphics.webgl.gpu = 'apple a15';
                break;

            case '1024x1366': //ipad pro
                if (time <= 140) Device.graphics.webgl.gpu = 'apple m1 gpu';
                else if (time <= 160) Device.graphics.webgl.gpu = 'apple a13';
                else if (time <= 180) Device.graphics.webgl.gpu = 'apple a12';
                else if (time <= 220) Device.graphics.webgl.gpu = 'apple a11';
                else if (time <= 250) Device.graphics.webgl.gpu = 'apple a10';
                else Device.graphics.webgl.gpu = 'apple a9';
                break;
        }
    }

    this.exports = function() {
        let promise = Promise.create();
        let _value;
        getRenderer(value => {
            if (value == 'done') {
                if (!_value) {
                  fallbackTest();
                  return promise.resolve();
                }
                if (_value.includes('|')) {
                    try {
                        let split = _value.split('|');
                        if (split.length == 1 && split[0].includes('Apple M')) {
                            Device.graphics.webgl.gpu = 'apple m1 gpu';
                        } else {
                            let output = split.filter(v => !v.includes('Apple M')).map(v => Number(v.replace('Apple', '').replace('X', '').replace('Z', '').split('A')[1].split(' ')[0]))
                            
                            output.sort((a,b) => a - b);
                            if (output[output.length-1] - output[0] > 2) fallbackTest();
                            else Device.graphics.webgl.gpu = split[0].toLowerCase();

                            if (Device.graphics.webgl.gpu == 'apple a14 gpu') {
                                let res = Math.min(screen.width, screen.height) + 'x' + Math.max(screen.width, screen.height);
                                if (res == '428x926' || res == '390x844') Device.graphics.webgl.gpu = 'apple a15 gpu';
                            }
                        }
                            

                    } catch(e) {
                        fallbackTest();
                    }
                } else {
                    Device.graphics.webgl.gpu = _value.toLowerCase();
                }
                promise.resolve();
            } else {
                _value = value;
            }
        });
        return promise;
    }
});
Module(function GPUBlocklist() {
    this.exports = {
        match: function() {
            if (!Device.graphics.gpu) return true;

            return Device.graphics.gpu.detect([
                'radeon hd 6970m',
                'radeon hd 6770m',
                'radeon hd 6490m',
                'radeon hd 6630m',
                'radeon hd 6750m',
                'radeon hd 5750',
                'radeon hd 5670',
                'radeon hd 4850',
                'radeon hd 4870',
                'radeon hd 4670',
                'geforce 9400m',
                'geforce 320m',
                'geforce 330m',
                'geforce gt 130',
                'geforce gt 120',
                'geforce gtx 285',
                'geforce 8600',
                'geforce 9600m',
                'geforce 9400m',
                'geforce 8800 gs',
                'geforce 8800 gt',
                'quadro fx 5',
                'quadro fx 4',
                'radeon hd 2600',
                'radeon hd 2400',
                'radeon hd 2600',
                'mali-4',
                'mali-3',
                'mali-2',
                'swiftshader',
                'basic render driver',
                'generic renderer',
                'sgx543',
                'legacy',
                'sgx 543'
            ]);
        }
    }
});

Class(function Initializer3D() {
    Inherit(this, Component);
    const _this = this;
    let _loader, _working;

    let _promises = [];
    let _queue = [];

    this.READY = 'initializer_ready';

    async function resolve() {
        await Promise.all(_promises);
        clearTimeout(_this.fire);
        _this.fire = _this.delayedCall(_ => {
            _this.events.fire(_this.READY);
            _this.resolved = true;
            Utils3D.onTextureCreated = null;
            if (_loader) _loader.trigger(50);
        }, 100);
    }

    async function workQueue() {
        clearTimeout(_this.warningTimer);
        _working = true;
        let promise = _queue.shift();
        if (!promise) return _working = false;
        promise.resolve(workQueue);

        if (Hydra.LOCAL) {
            _this.warningTimer = _this.delayedCall(_ => {
                console.warn('Long running queue has taken more than 5 seconds.');
            }, 5000);
        }
    }

    function incCompleted() {
        if (_loader) _loader.trigger(1);
    }

    //*** Event handlers

    //*** Public methods
    this.bundle = function() {
        function PromiseBundler() {
            const promises = [];
            const ready = Promise.create();
            let timer;

            function run(){
                clearTimeout(timer);
                timer = _this.delayedCall(_ => {
                    Promise.all(promises).then(_ => ready.resolve());
                }, 100);
            }

            this.capture = function(promise) {
                promises.push(promise);
                run();
            };

            this.ready = function() {
                run();
                return ready;
            };
        }

        return new PromiseBundler();
    };

    this.promise = this.capture = function(promise) {
        if (_loader) _loader.add(1);
        promise.then(incCompleted);
        _promises.push(promise);
        clearTimeout(_this.timer);
        _this.timer = _this.delayedCall(resolve, 100);
        return promise;
    };

    this.ready = this.loaded = function() {
        return _this.wait(_this, 'resolved');
    };

    this.createWorld = async function() {
        await Promise.all([
            AssetLoader.waitForLib('zUtils3D'),
            Shaders.ready(),
            GPU.ready(),
            UILStorage.ready()
        ]);
        World.instance();
    };

    this.linkSceneLayout = function(loader) {
        _this.captureTextures();
        SceneLayout.initializer = _this.capture;
        _loader = loader;
    };

    this.queue = function(immediate) {
        if (immediate) return Promise.resolve(_ => {});

        let promise = Promise.create();
        _queue.push(promise);
        if (!_working) workQueue();
        return promise;
    };

    this.captureTextures = function() {
        Utils3D.onTextureCreated = texture => {
            _this.promise(texture.promise);
        };
    };

    this.uploadAll = async function(group) {
        if (!group) throw 'Undefined passed to uploadAll';

        let sceneLayout;
        if (group instanceof SceneLayout || (window.StageLayout && group instanceof StageLayout)) {
            sceneLayout = group;
            if (sceneLayout.uploaded) return;
            sceneLayout.uploaded = true;
            await sceneLayout.loadedAllLayers();
            group = group.group;
        }

        let promises = [];
        let layouts = [];
        let textures = [];
        if (sceneLayout) {
            sceneLayout.textures = textures;
            for (let key in sceneLayout.layers) {
                let layer = sceneLayout.layers[key];
                if (layer.uploadSync) layer.uploadSync();
            }
        }

        group.traverse(obj => {
            if (obj.sceneLayout && obj != group) layouts.push(obj.sceneLayout);
            if (obj.stageLayout && obj != group) layouts.push(obj.stageLayout);
            if (obj.uploadIgnore || obj.visible == false) return;
            if (obj.shader) {
                for (let key in obj.shader.uniforms) {
                    let uniform = obj.shader.uniforms[key];
                    if (uniform && uniform.value && uniform.value.promise) {
                        textures.push(uniform.value);
                        promises.push( uniform.value.promise.then(uniform.value.upload.bind(uniform.value)).catch(e => {}) );
                    }
                }
            }

            if (obj.asyncPromise) promises.push(obj.asyncPromise.then(obj.upload.bind(obj)));
            else if (obj.upload) obj.upload();
        });

        await Promise.catchAll(promises);

        textures.forEach(t => t.upload());

        for (let i = 0; i < layouts.length; i++) {
            await _this.uploadAll(layouts[i]);
        }

        if (sceneLayout && sceneLayout._completeInitialization) sceneLayout._completeInitialization(true);

        if (sceneLayout) delete sceneLayout.textures;
    };

    this.uploadAllDistributed = this.uploadAllAsync = async function(group, releaseQueue) {
        if (!group) throw 'Undefined passed to uploadAllDistributed';

        if(!releaseQueue && typeof releaseQueue != 'boolean') releaseQueue = await _this.queue();

        let sceneLayout;
        if (group instanceof SceneLayout || (window.StageLayout && group instanceof StageLayout)) {
            sceneLayout = group;
            if (sceneLayout.uploaded) return typeof releaseQueue == 'function' ? releaseQueue() : undefined;
            sceneLayout.uploaded = true;
            await sceneLayout.loadedAllLayers();
            group = group.group;
        }

        let uploads = [];
        let _async = [];
        let promises = [];
        let layouts = [];
        let textures = [];
        if (sceneLayout) {
            sceneLayout.textures = textures;
            for (let key in sceneLayout.layers) {
                let layer = sceneLayout.layers[key];
                if (layer.upload && !layer.uploadIgnore) layer.upload();
            }
        }

        group.traverse(obj => {
            if (obj.sceneLayout && obj != group) layouts.push(obj.sceneLayout);
            if (obj.stageLayout && obj != group) layouts.push(obj.stageLayout);
            if (obj.uploadIgnore || obj.visible == false) return;
            if (obj.shader) {
                for (let key in obj.shader.uniforms) {
                    let uniform = obj.shader.uniforms[key];
                    if (uniform && uniform.value && uniform.value.promise) {
                        textures.push(uniform.value);
                        promises.push( uniform.value.promise.then(_ => uploads.push(uniform.value.upload.bind(uniform.value))).catch(e => {}) );
                    }
                }
            }

            if (obj.asyncPromise) {
                promises.push(obj.asyncPromise.then(_ => {
                    if (obj.geometry) obj.geometry.distributeBufferData = true;
                    uploads.push(obj.upload.bind(obj));
                    if (obj.geometry) _async.push(obj.geometry.uploadBuffersAsync.bind(obj.geometry));
                }));
            } else if (obj.upload) {
                if (obj.geometry) {
                    if (obj.geometry.uploaded) return;
                    obj.geometry.distributeBufferData = true;
                }
                uploads.push(obj.upload.bind(obj));
                if (obj.geometry) _async.push(obj.geometry.uploadBuffersAsync.bind(obj.geometry));
            }
        });

        let canFinish = false;
        let promise = Promise.create();

        let cleanUp = async _ => {
            for (let i = 0; i < _async.length; i++) {
                await _async[i]();
            }
            for (let i = 0; i < layouts.length; i++) {
                await _this.uploadAllAsync(layouts[i], !!releaseQueue);
            }
            if(typeof releaseQueue == 'function') releaseQueue();
            promise.resolve();
        };

        let worker = new Render.Worker(_ => {
            let upload = uploads.shift();
            if (upload) upload();
            else {
                if (!canFinish) worker.pause();
                else {
                    cleanUp();
                    worker.stop();
                }
            }
        }, 1);

        Promise.catchAll(promises).then(_ => {
            worker.resume();
            canFinish = true;
        });

        if (sceneLayout && sceneLayout._completeInitialization) sceneLayout._completeInitialization(false);

        if (sceneLayout) {
            promise.then(_ => {
                delete sceneLayout.textures;
            });
        }

        return promise;
    };

    this.detectUploadAll = function(group, sync, releaseQueue) {
        return sync ? _this.uploadAll(group) : _this.uploadAllDistributed(group, releaseQueue);
    };

    this.detectUploadNuke = function(nuke, sync) {
        return sync ? _this.uploadNukeAsync(nuke) : _this.uploadNuke(nuke);
    }

    this.uploadNuke = async function(nuke) {
        for (let i = 0; i < nuke.passes.length; i++) {
            let pass = nuke.passes[i];
            let uniforms = pass.uniforms;
            for (let key in uniforms) {
                if (uniforms[key].value && uniforms[key].value.promise) await uniforms[key].value.promise;
                if (uniforms[key].value && uniforms[key].value.upload) uniforms[key].value.upload();
            }
            pass.upload();
        }
        if (!Nuke.defaultPass.uploaded) {
            Nuke.defaultPass.upload();
        }
    }

    this.uploadNukeAsync = function(nuke) {
        return this.uploadNuke(nuke);
    }

    this.destroyAll = function(scene) {
        scene.traverse(obj => {
            if (obj.geometry && obj.shader) {
                for (let key in obj.shader.uniforms) {
                    let uniform = obj.shader.uniforms[key];
                    if (uniform && uniform.value instanceof Texture) uniform.value.destroy();
                }
                obj.destroy();
            }
        });
    }

    this.set('loader', loader => {
        _loader = loader;
    });

}, 'static');

/*
    Line3D

    Uses LineGeometry to build a mesh line from a set of vertices.
    Can be dynamically updated to add vertices (i.e. drawing).

    let line = new Line3D({
        width: 1,
        color: '#ffffff'
    });
    _this.add(line);

    let count = 400;
    for (let i = 0; i < count; i++) {
        let angle = Math.PI * 20 / count * i;
        let pos = new Vector3();
        let r = 2;
        pos.x = Math.cos(angle) * r * Math.sin(i/count * Math.PI);
        pos.y = i/count * r * 2 - r;
        pos.z = Math.sin(angle) * r * Math.sin(i/count * Math.PI);
        line.draw(pos);
    }
*/

Class(function Line3D(_params = {}) {
    Inherit(this, Object3D);
    const _this = this;
    let _geometry, _shader, _mesh, _vs, _fs, _prevPoint;

    let _index = _params.index || 0;
    let _points = _params.points || [];
    let _pressure = _params.pressure || [];
    let _defaultTaper = () => { return 1. };
    let _taperFunction = _params.taperFunction || _defaultTaper;
    let _dynamic = _params.dynamic || false;

    //*** Constructor
    (function () {
        initGeometry();
        if (!window.THREAD) {
            initShader();
            initMesh();
            if (Hydra.LOCAL) initHotReload();
        }
    })();

    function initGeometry() {
        _geometry = _this.initClass(LineGeometry, {
            index: _index,
            points: _points,
            pressure: _pressure,
            taperFunction: _taperFunction,
            dynamic: _dynamic
        });
    }

    function initShader() {
        const shaderName = _params.customShader || 'Line';
        _shader = _this.initClass(Shader, shaderName, {
            uLineWidth: { value: _params.width || Line3D.defaultLineWidth, ignoreUIL: true },
            uBaseWidth: Line3D.BASE_WIDTH,
            uColor: { value: new Color(_params.color || Line3D.defaultColor), ignoreUIL: true },
            uOpacity: { value: _params.opacity || Line3D.defaultOpacity, ignoreUIL: true },
            transparent: true,
            depthWrite: _params.depthWrite === false ? false : true,
            depthTest: _params.depthTest === false ? false : true
        });
        _vs = _shader.vertexShader;
        _fs = _shader.fragmentShader;

        if (_vs) {
            Line3D.vertexShader = _shader.vertexShader;
            Line3D.vsName = _shader.vsName;
            Line3D.fragmentShader = _shader.fragmentShader;
            Line3D.fsName = _shader.fsName;
        }

        _this.shader = _shader;
    }

    function initMesh() {
        if (_points.length < 2 || _mesh) return;

        _mesh = new Mesh(_geometry.geometry, _shader);
        _mesh.frustumCulled = false;
        if (typeof _params.renderOrder === 'number') {
            _mesh.renderOrder = _params.renderOrder;
        }
        _this.add(_mesh);
        _this.mesh = _mesh;

        _geometry.mesh = _mesh;
    }

    function initHotReload() {
        _this.events.sub(ShaderUIL.SHADER_UPDATE, ({ shader }) => {
            let updateCustom = false;
            if (shader.includes(Line3D.vsName)) {
                // The base shader has changed.
                let newBaseShader = new Shader(Line3D.vsName, Line3D.fsName);
                newBaseShader.resetProgram();
                _vs = Line3D.vertexShader = newBaseShader.vertexShader;
                _fs = Line3D.fragmentShader = newBaseShader.fragmentShader;
                if (_shader.vsName === newBaseShader.vsName) {
                    return;
                }
                updateCustom = true;
            }
            if (shader.includes(_shader.vsName) || updateCustom) {
                // Re-merge the custom shader.
                let newShader = new Shader(_shader.vsName, _shader.fsName, _shader.params);
                _this.useShader(newShader);
                Shader.renderer.hotReloadClearProgram(_shader.customCompile);
            }
        });
    }

    //*** Event handlers

    //*** Public methods
    this.get('data', () => {
        let geometry = {
            points: _points,
            pressure: _pressure,
            index: _index
        };

        let meta = {
            fs: _shader.fsName,
            vs: _shader.vsName,
            width: _shader.uniforms.uLineWidth.value,
            opacity: _shader.uniforms.uOpacity.value,
            color: _shader.uniforms.uColor.value.getHex(),
        };
        return { geometry, meta };
    });

    this.get('lineGeometry', () => {
        return _geometry;
    });

    this.get('geometry', () => {
        return _geometry.geometry;
    });

    this.set('lineWidth', v => {
        _shader.set('uLineWidth', v);
    });

    this.set('color', hex => {
        _shader.uniforms.uColor.value.set(hex);
    });

    this.set('opacity', value => {
        _shader.uniforms.uOpacity.value = value;
    });

    this.useShader = function (shader) {
        _shader.vertexShader = _vs;
        _shader.fragmentShader = _fs;
        _shader = Line3D.mergeShaders(shader, _shader);
        _this.shader = _shader;

        if (_mesh) _mesh.shader = _shader;
    };

    this.draw = function (pos, pressure = 1) {
        _points.push(pos.x, pos.y, pos.z || 0);
        _pressure.push(pressure);
        if (_points.length < 2) return;

        _geometry.update(_points, true);
        if (!_mesh) initMesh();
    };

    this.moveTo = function (pos, subdivisions = 30) {
        if(_prevPoint) {
            let v = new Vector3();
            for(let i =0; i< subdivisions; i++) {
                 v.copy(_prevPoint).lerp(pos, i/(subdivisions - 1), false);
                 _points.push(v.x, v.y, v.z || 0);
                 _pressure.push(1);
            }
        }
        _prevPoint = pos;

        if (_points.length < 2) return;
        _geometry.update(_points, true);
        if (!_mesh) initMesh();
    }

    /**
     * Optimization: if you just want to clear so you can redraw the line via
     * lineTo() and friends, call clear(false) to skip the expensive (and wasted)
     * LineGeometry.clear() call.
     * @param clearGeometry pass false to skip calling LineGeometry.clear() when
     *   you don’t need a usable cleared LineGeometry.
     */
    this.clear = function (clearGeometry = true) {
        _points.length = 0;
        _prevPoint = null;
        if (clearGeometry) _geometry.clear();
    }

    this.fromCurve = function(curve, subdivisions = 30) {
        _this.clear();
        for (let i = 0; i <= subdivisions; i++) {
            let pct = i / subdivisions;
            let pos = curve.getPoint(pct);
            _points.push(pos.x, pos.y, pos.z || 0);
            _pressure.push(1);
        }
        _geometry.update(_points, true);
        if (!_mesh) initMesh();
    }

    this.onDestroy = function () {
        if (_this.parent && _this.parent.group) _this.parent.group.remove(_this.group);
        _mesh && _mesh.destroy && _mesh.destroy();
    };

}, () => {
    Line3D.defaultLineWidth = 1;
    Line3D.defaultOpacity = 1;
    Line3D.defaultColor = '#ffffff';
    Line3D.BASE_WIDTH = { value: 0.005, ignoreUIL: true };
    Line3D.MAX_LINE_LENGTH = 500;

    Line3D.mergeShaders = function (s0, s1) {
        s0.customCompile = `${s0.vsName}|${s0.fsName}|Line3D`;
        s1.copyUniformsTo(s0);

        // Copy material properties
        for (let key in s1.properties) {
            s0.properties[key] = s1.properties[key];
        }

        if (s0.lineFormat || !s0.vertexShader) {
            s0.lineFormat = true;
            return s0;
        }

        if (!s1.fragmentShader) {
            s1.fragmentShader = Line3D.fragmentShader;
            s1.vertexShader = Line3D.vertexShader;
        }

        let vs = s0.vertexShader.split('__ACTIVE_THEORY_LIGHTS__')[1];
        let fs = s0.fragmentShader.split('__ACTIVE_THEORY_LIGHTS__')[1];
        let split = vs.split('void main() {');

        let fsParams = s1.fragmentShader.split('__ACTIVE_THEORY_LIGHTS__')[1].split('void main')[0];
        s0.fragmentShader = s0.fragmentShader.split('__ACTIVE_THEORY_LIGHTS__').join(fsParams);

        s1.vertexShader = s1.vertexShader.replace('//params', split[0]);
        s1.vertexShader = s1.vertexShader.replace('//main', split[1].split('}')[0]);

        if (s0.vertexShader.includes('customMatrix')) {
            let content = s0.vertexShader.split('customMatrix() {')[1];
            content = content.split('}')[0];
            let matrix = s1.vertexShader.split('//startMatrix')[1].split('//endMatrix')[0];
            s1.vertexShader = s1.vertexShader.replace(matrix, content);
        }

        if (s0.vertexShader.includes('customDirection')) {
            let content = s0.vertexShader.split('customDirection() {')[1];
            content = content.split('}')[0];
            s1.vertexShader = s1.vertexShader.replace('//direction', content);
        }

        split = fs.split('void main() {');
        s1.fragmentShader = s1.fragmentShader.replace('//fsmain', split[1].split('}')[0]);
        s1.fragmentShader = s1.fragmentShader.replace('//fsparams', split[0]);

        s0.vertexShader = s1.vertexShader;
        s0.fragmentShader = s1.fragmentShader;

        return s0;
    }
});

Class(function Line3DLayer(_input, _group) {
    Inherit(this, Object3D);
    const _this = this;
    var _shader, _line, _config;

    //*** Constructor
    (function () {
        let config = InputUIL.create(_input.prefix + 'line3d', _group);
        config.add('json').add('subdivisions', 100)
            .addColor('color', new Color()).add('width', 10)
            .setLabel('Spline');

        let json = config.get('json');
        if (json) {
            let subdivisions = _this.parent.data && _this.parent.data.line3DSubdivisions ?
                _this.parent.data.line3DSubdivisions : config.getNumber('subdivisions');
            load(json, subdivisions, config.get('color'), config.getNumber('width'));
        }

        _config = config;

        initShader();
    })();

    function initShader() {
        let shader = _input.get('shader');
        if (shader && shader.length) {
            _this.shader = _shader = _this.initClass(Shader, shader, {
                transparent: true,
                unique: _input.prefix
            });

            completeShader(_shader);

            if (window[shader]) _this.initClass(window[shader], _this, _shader);

            ShaderUIL.add(_shader, _group).setLabel('Shader');
        }
    }

    function completeShader(shader) {
        let transparent = _input.get('transparent');
        let depthWrite = _input.get('depthWrite');
        let depthTest = _input.get('depthTest');
        let blending = _input.get('blending');
        let castShadow = _input.get('castShadow');
        let receiveShadow = _input.get('receiveShadow');

        if (typeof depthWrite === 'boolean') shader.depthWrite = depthWrite;
        if (typeof depthTest === 'boolean') shader.depthTest = depthTest;
        if (typeof transparent === 'boolean') shader.transparent = transparent;
        if (typeof castShadow === 'boolean') defer(_ => _this.mesh.castShadow = castShadow);
        if (typeof receiveShadow === 'boolean') shader.receiveShadow = receiveShadow;
        if (blending) shader.blending = blending;
    }

    async function load(json, subdivisions, color, width) {
        if (!json.includes('assets/geometry')) json = `assets/geometry/${json}`;
        if (!json.includes('.json')) json += '.json';

        let merged = await LineUtil.loadFromSplines(Assets.getPath(json), subdivisions, color, width);
        _line = merged;
        _this.add(merged);

        if (_shader) merged.useShader(_shader);
        _this.flag('loaded', true);
    }

    //*** Event handlers

    //*** Public methods
    this.ready = function () {
        return _this.wait('loaded');
    }

    this.getRandomPosition = async function () {
        let positions = _line.geometry.attributes.position.array;
        let index = Math.random(0, positions.length / 3, 0) * 3.;
        return new Vector3(positions[index], positions[index + 1], positions[index + 2])
    }

    this.loadFile = function(path) {
        if (_line) {
            _this.flag('loaded', false);
            _this.group.remove(_line.group);
            _line.destroy();
        }

        if (typeof path === 'string') {
            load(path, _config.getNumber('subdivisions'), _config.get('color'), _config.getNumber('width'));
        } else {
            let merged = path;
            _line = merged;
            _this.add(merged);

            if (_shader) merged.useShader(_shader);
            _this.flag('loaded', true);
        }
    }

});

// TODO: drawRange
// TODO: merge pressure with width

Class(function LineGeometry({
                                index = 0,
                                points = [],
                                // pressure = [],
                                taperFunction = () => {return 1},
                                defaultCount = 512, // size of buffer used if no points passed in
                                dynamic = false
                            }) {
    Inherit(this, Component);
    const _this = this;

    _this.index = index;
    _this.points = points;
    _this.taperFunction = taperFunction;
    const _geometry = _this.geometry = new Geometry();
    const _attr = _geometry.attributes;

    let _prev = new Vector3();
    let _curr = new Vector3();
    let _length = 0;
    let _count = 0;
    let _defaultPoints = [];

    //*** Constructor
    (function () {
        initBuffers(points.length ? points.length / 3 : defaultCount);
        for(let i = 0; i < defaultCount; i ++) _defaultPoints.push(0, 0, 0);
        if (points.length) update(points, true);
    })();

    function initBuffers(count) {
        _geometry.addAttribute('position',  new GeometryAttribute(new Float32Array(count * 3 * 2), 3, false, dynamic));
        _geometry.addAttribute('previous',  new GeometryAttribute(new Float32Array(count * 3 * 2), 3, false, dynamic));
        _geometry.addAttribute('next',      new GeometryAttribute(new Float32Array(count * 3 * 2), 3, false, dynamic));
        _geometry.addAttribute('side',      new GeometryAttribute(new Float32Array(count * 1 * 2), 1, false, dynamic));
        _geometry.addAttribute('lineIndex', new GeometryAttribute(new Float32Array(count * 1 * 2), 1, false, dynamic));
        _geometry.addAttribute('width',     new GeometryAttribute(new Float32Array(count * 1 * 2), 1, false, dynamic));
        // _geometry.addAttribute('pressure',  new GeometryAttribute(new Float32Array(count * 1 * 2), 1, false, dynamic));
        _geometry.addAttribute('uv',        new GeometryAttribute(new Float32Array(count * 2 * 2), 2, false, dynamic));
        _geometry.addAttribute('uv2',       new GeometryAttribute(new Float32Array(count * 2 * 2), 2, false, dynamic));
        _geometry.setIndex(                 new GeometryAttribute(new Uint16Array((count - 1) * 3 * 2), 1, false, dynamic));

        // Stop from rendering unset vertices
        // TODO: add this when supported
        // _geometry.drawRange.count = 0;
        _length = 0;
        _count = 0;

        setStaticBuffers(count);
    }

    function setStaticBuffers(count) {
        for (let i = 0; i < count; i++) {
            _attr.side.setXY(i * 2, 1, -1);
            _attr.lineIndex.setXY(i * 2, _this.index, _this.index);
            if (i === count - 1) continue;
            let ind = i * 2;

            // _geometry.index.setXYZ((ind + 0) * 3, ind + 0, ind + 1, ind + 2);
            // _geometry.index.setXYZ((ind + 1) * 3, ind + 2, ind + 1, ind + 3);

            _geometry.index[(ind + 0) * 3 + 0] = ind + 0;
            _geometry.index[(ind + 0) * 3 + 1] = ind + 1;
            _geometry.index[(ind + 0) * 3 + 2] = ind + 2;

            _geometry.index[(ind + 1) * 3 + 0] = ind + 2;
            _geometry.index[(ind + 1) * 3 + 1] = ind + 1;
            _geometry.index[(ind + 1) * 3 + 2] = ind + 3;
        }

    }

    function increaseBuffers() {
        let count = _attr.position.count / 2 + defaultCount;
        initBuffers(count);
    }

    function getPos(index) {
        let i = index * 3;
        return [points[i], points[i + 1], points[i + 2]];
    }

    function clear() {
        update(_defaultPoints, true);
        _length = 0;
        _count = 0;
    }

    function update( p = points, force = false ) {
        if (_this.points == p && !force) return;
        _this.points = points = p;
        let newLength = points.length / 3;
        if (newLength * 2 > _attr.position.count) increaseBuffers();
        let oldLength = _count;

        if (oldLength && !force ) {

            // Update old end of line with new next value
            let nxt = getPos(oldLength);

            _attr.next.setXYZ((oldLength - 1) * 2 + 0, nxt[0], nxt[1], nxt[2]);
            _attr.next.setXYZ((oldLength - 1) * 2 + 1, nxt[0], nxt[1], nxt[2]);
        }

        // Start at the end of old array and increment through new points only
        for (let i = force ? 0 : oldLength; i < newLength; i++) {
            _attr.position.setXYZ(i * 2 + 0, points[i * 3 + 0], points[i * 3 + 1], points[i * 3 + 2]);
            _attr.position.setXYZ(i * 2 + 1, points[i * 3 + 0], points[i * 3 + 1], points[i * 3 + 2]);

            let prv = getPos(Math.max(0, i - 1));
            _attr.previous.setXYZ(i * 2 + 0, prv[0], prv[1], prv[2]);
            _attr.previous.setXYZ(i * 2 + 1, prv[0], prv[1], prv[2]);

            let nxt = getPos(Math.min(newLength - 1, i + 1));
            _attr.next.setXYZ(i * 2 + 0, nxt[0], nxt[1], nxt[2]);
            _attr.next.setXYZ(i * 2 + 1, nxt[0], nxt[1], nxt[2]);

            _prev.fromArray(prv);
            _curr.fromArray(getPos(i));
            _length += _prev.distanceTo(_curr);

            // Set U value to current length
            _attr.uv2.setX(i * 2 + 0, _length);
            _attr.uv2.setX(i * 2 + 1, _length);

            // _attr.pressure.setXY(i * 2, pressure[i], pressure[i]);
            // _attr.pressure.setXY(i * 2, 1, 1);
        }

        // Loop through all for attributes that need to be completely updated
        for (let i = 0; i < newLength; i++) {

            // Update UVs to be 0 > 1 along length
            _attr.uv.setXY(i * 2 + 0, i / newLength, 0);
            _attr.uv.setXY(i * 2 + 1, i / newLength, 1);

            // Set V value to total length
            _attr.uv2.setY(i * 2 + 0, _length);
            _attr.uv2.setY(i * 2 + 1, _length);

            // Update tapering with new length
            let w = _this.taperFunction(i / (newLength - 1), i, newLength);
            _attr.width.setXY(i * 2, w, w);
        }

        _attr.position.needsUpdate = true;
        _attr.previous.needsUpdate = true;
        _attr.next.needsUpdate = true;
        _attr.width.needsUpdate = true;
        // _attr.pressure.needsUpdate = true;
        _attr.uv.needsUpdate = true;
        _attr.uv2.needsUpdate = true;

        // _geometry.drawRange.count = (newLength - 1) * 6;
        _count = newLength;
        _this.points = points;
    }

    //*** Event handlers

    //*** Public methods
    this.update = update;
    this.clear = clear;

});

Class(function MergedLine(_geometry, _lineCount) {
    Inherit(this, Object3D);
    const _this = this;
    var _shader, _mesh;
    var _vs, _fs;

    this.geometry = _geometry;

    //*** Constructor
    (function () {
        initShader();
        createMesh();
        if (Hydra.LOCAL) initHotReload();
    })();

    function initShader() {
        _shader = _this.initClass(Shader, 'Line', {
            uBaseWidth: Line3D.BASE_WIDTH,
            uLineCount: { type: 'f', value: _lineCount || 1, ignoreUIL: true },
            transparent: true,
        });

        if (!_shader.vertexShader) {
            _shader.vertexShader = Line3D.vertexShader;
            _shader.fragmentShader = Line3D.fragmentShader;
        } else {
            Line3D.vertexShader = _shader.vertexShader;
            Line3D.vsName = _shader.vsName;
            Line3D.fragmentShader = _shader.fragmentShader;
            Line3D.fsName = _shader.fsName;
        }

        if (!_shader.vertexShader || !_shader.vertexShader.length) _shader.vertexShader = Shaders.getShader('Line.vs');
        if (!_shader.fragmentShader || !_shader.fragmentShader.length) _shader.fragmentShader = Shaders.getShader('Line.fs');
        _this.shader = _shader;
        updateShader(_shader);
    }

    function updateShader(shader) {
        shader.customCompile = `${shader.vsName}|${shader.fsName}|MergedLine`;
        shader.resetProgram();

        shader.vertexShader = shader.vertexShader.replace('uniform float uLineWidth;', 'attribute float thickness;');
        shader.vertexShader = shader.vertexShader.replace('uLineWidth', 'thickness');
        shader.fragmentShader = shader.fragmentShader.replace('uniform float uLineWidth;', '');

        shader.vertexShader = shader.vertexShader.replace('uniform vec3 uColor;', 'attribute vec3 aColor;');
        shader.vertexShader = shader.vertexShader.replace('vColor = uColor;', 'vColor = aColor;');

        shader.vertexShader = shader.vertexShader.replace('uniform float uOpacity;', 'attribute float aOpacity;');
        shader.vertexShader = shader.vertexShader.replace('vOpacity = uOpacity;', 'vOpacity = aOpacity;');

        _vs = shader.vertexShader;
        _fs = shader.fragmentShader;
        if (_shader !== shader) _shader.copyUniformsTo(shader, true);
    }

    function createMesh() {
        _mesh = new Mesh(_geometry, _shader);
        _mesh.frustumCulled = false;
        _this.add(_mesh);
        _this.mesh = _mesh;
    }

    function initHotReload() {
        _this.events.sub(ShaderUIL.SHADER_UPDATE, ({ shader }) => {
            let updateCustom = false;
            if (shader.includes(Line3D.vsName)) {
                // The base shader has changed.
                let newBaseShader = new Shader(Line3D.vsName, Line3D.fsName);
                if (newBaseShader.vertexShader) {
                    Line3D.vertexShader = newBaseShader.vertexShader;
                    Line3D.fragmentShader = newBaseShader.fragmentShader;
                }
                updateShader(newBaseShader);
                Shader.renderer.hotReloadClearProgram(newBaseShader.customCompile);
                if (_shader.vsName === newBaseShader.vsName) {
                    newBaseShader.upload(_mesh, _geometry);
                    if (_shader._gl) _shader._gl = newBaseShader._gl;
                    if (_shader._gpu) _shader._gpu = newBaseShader._gpu;
                    if (_shader._metal) _shader._metal = newBaseShader._metal;
                    return;
                }
                updateCustom = true;
            }
            if (shader.includes(_shader.vsName) || updateCustom) {
                // Re-merge the updated custom shader.
                let newShader = new Shader(_shader.vsName, _shader.fsName, _shader.params);
                _this.useShader(newShader);
                Shader.renderer.hotReloadClearProgram(_shader.customCompile);
            }
        });
    }

    //*** Event handlers

    //*** Public methods
    this.useShader = function (shader) {
        _shader.vertexShader = _vs;
        _shader.fragmentShader = _fs;
        _shader = Line3D.mergeShaders(shader, _shader);
        _shader.customCompile = `${_shader.customCompile}|MergedLine`;
        _this.shader = _shader;

        shader.uniforms.uBaseWidth.ignoreUIL = shader.uniforms.uLineCount.ignoreUIL = true;
        shader.transparent = true;

        if (_mesh) _mesh.shader = _shader;
    }

    this.onDestroy = function () {
        _this.events.fire(MergedLine.DESTROY);
        _mesh.destroy();
        if(_this.group && _this.group.parent) _this.group.parent.remove(_this.group);
    }

    this.clone = function () {
        return new MergedLine(_geometry, _fs);
    }

    this.set('widthMultiplier', v => {
        _shader.set('uBaseWidth', 1.8 * v);
    });

    this.set('color', hex => {
        _shader.uniforms.uColor.value.set(hex);
    });
}, _ => {
    MergedLine.DESTROY = 'merged_line_destroy';
});

Class(function MergedLineGroup() {
    Inherit(this, Object3D);
    const _this = this;

    this.lines = [];

    //*** Public methods
    this.add = function(line) {
        line.freezeMatrix();
        line.mergedGroup = this;
        this.lines.push(line);
        this.group.add(line.group);
    }

    this.onDestroy = function() {
        _this.events.fire(MergedLine.DESTROY);
        this.lines.forEach(line => line.destroy());
        _this.group.parent.remove(_this.group);
    }
});
Class(function LineBuilder() {
    const _this = this;
    var _cache = {};
    var _taperFunctions, _color;

    function merge(geom, line) {
        if (!geom.attributes.position) {
            copyAttributes(geom, line);
        } else {
            mergeAttributes(geom, line);
        }
    }

    function copyAttributes(geom, line) {
        for (let key in line.attributes) {
            geom.attributes[key] = line.attributes[key];
        }

        geom.index = line.index;
    }

    function mergeAttributes(geom, line) {
        for (let key in line.attributes) {
            geom.attributes[key] = new GeometryAttribute(Float32ArrayConcat(geom.attributes[key].array, line.attributes[key].array), geom.attributes[key].itemSize);
        }

        let indexArray = Array.prototype.slice.call(geom.index);
        let startIndex = indexArray[indexArray.length - 1] + 1;

        for (let i = 0; i < line.index.length; i++) {
            indexArray.push(startIndex + line.index[i]);
        }

        geom.index = new (Geometry.arrayNeedsUint32(indexArray) ? Uint32Array : Uint16Array)(indexArray);
    }

    function Float32ArrayConcat(first, second) {
        var firstLength = first.length,
            result = new Float32Array(firstLength + second.length);

        result.set(first);
        result.set(second, firstLength);

        return result;
    }

    function geomToObj(geom) {
        let obj = {};
        let buffers = [];
        for (let key in geom.attributes) {
            obj[key] = geom.attributes[key].array;
            buffers.push(obj[key].buffer);
        }

        obj.index = geom.index;
        buffers.push(obj.index.buffer);

        return { obj, buffers };
    }

    function createExtraAttrib(geom, key, value) {
        let len = geom.attributes.position.count;
        if (typeof value === 'number') {
            let array = new Float32Array(len);
            for (let i = 0; i < array.length; i++) array[i] = value;
            geom.addAttribute(key, new GeometryAttribute(array, 1));
        } else {
            let array = new Float32Array(len * value.length);
            for (let i = 0; i < len; i++) {
                for (let j = 0; j < value.length; j++) {
                    array[i * value.length + j] = value[j];
                }
            }
            geom.addAttribute(key, new GeometryAttribute(array, value.length));
        }
    }

    function parseData(data, e) {
        if (typeof data === 'string') data = JSON.parse(JSON.parse(data));
        let mergedGeom = new Geometry();
        data.forEach(d => {
            let lineGeom = new LineGeometry(d.geometry.index, d.geometry.points, d.geometry.pressure);

            createExtraAttrib(lineGeom.geometry, 'thickness', d.meta.width);

            if (d.meta.color) {
                if (!_color) _color = new Color();
                _color.set(d.meta.color);
                createExtraAttrib(lineGeom.geometry, 'aColor', _color.toArray());
            }
            if (d.meta.opacity) createExtraAttrib(lineGeom.geometry, 'aOpacity', d.meta.opacity);

            merge(mergedGeom, lineGeom.geometry, d.meta);
        });

        return geomToObj(mergedGeom);
    }

    //*** Event handlers
    function parseGroups(data, e, callback, promise) {
        let groups = [];
        let cached = [];
        for (let i = 0; i < data.length; i++) {
            let meta = data[i].meta;
            let key = `${meta.fs || 'fs'}_${meta.vs || 'vs'}`;
            if (!cached[key]) {
                cached[key] = true;
                groups.push({ fs: meta.fs || 'fs', vs: meta.vs || 'vs' });
            }
        }

        if (typeof callback === 'undefined') {
            promise.resolve(groups);
        } else {
            resolve(groups, callback);
        }
    }

    //*** Public methods
    this.parse = function (e, callback) {
        if (window.taper) Line3D.taperFunction = taper;
        let promise = Promise.create();
        get(e.file).then(data => {
            if (data.data) {
                let meta = data;
                data = data.data;
                delete meta.data;
                if (window.emit) emit('meta', meta);
                else _this.onMeta && _this.onMeta(meta);
            }

            _cache[e.file] = data;

            parseGroups(data, e, callback, promise);
        });
        return promise;
    }

    this.createLine = function (e, callback) {
        let data = e.data || _cache[e.file];
        let selected = [];
        for (let i = 0; i < data.length; i++) {
            let meta = data[i].meta;
            if (meta.fs == e.group.fs && (!meta.vs || meta.vs == e.group.vs)) {
                selected.push(data[i]);
            }
        }

        let meta = selected[0].meta;
        if (_taperFunctions) {
            let key = meta.vs;
            if (_taperFunctions[key]) Line3D.taperFunction = _taperFunctions[key];
        }

        let { obj, buffers } = parseData(selected, e);
        obj.meta = meta;
        obj.lineCount = selected.length;

        if (typeof callback === 'undefined') {
            return Promise.resolve(obj);
        } else {
            resolve(obj, callback, buffers);
        }
    }

    this.parseFromData = function (e, callback) {
        if (window.taper) Line3D.taperFunction = taper;
        let data = e.data;
        let promise = Promise.create();
        parseGroups(data, e, callback, promise);
        return promise;
    }

    this.release = function (e) {
        delete _cache[e.file];
    }

    this.uploadTaperFunctions = function (e) {
        _taperFunctions = e.fns;
        for (let key in _taperFunctions) {
            eval(`_taperFunctions['${key}'] = ${_taperFunctions[key]}`);
        }
    }

    this.changeTaperFunction = function (e) {
        Line3D.taperFunction = _taperFunctions[e.fn];
    }

    this.loadFromSplines = function ({ url, subdivisions, width, color, type }, id) {
        (async function () {

            let mergedGeom = new Geometry();
            let array = await get(url);
            let curves = array.curves.map(array => new Curve(array, type));
            let total = 0;

            let maxLength = 0;
            array.curves.forEach(c => {
                maxLength = Math.max(c.length, maxLength);
            });

            curves.forEach((curve, i) => {
                let points = [];
                let count = Math.max(10, Math.round(subdivisions * (array.curves[i].length / maxLength)));
                for (let i = 0; i <= count; i++) {
                    let pct = i / count;
                    let pos = curve.getPoint(pct);
                    points.push(pos.x, pos.y, pos.z);
                }

                let line = new Line3D({
                    width,
                    color,
                    index: total++,
                    points
                });

                createExtraAttrib(line.geometry, 'thickness', width);
                createExtraAttrib(line.geometry, 'aColor', new Color(color || '#ffffff').toArray());
                createExtraAttrib(line.geometry, 'aOpacity', 1);

                merge(mergedGeom, line.geometry);
            });

            let { obj, buffers } = geomToObj(mergedGeom);
            obj.lineCount = total;
            resolve(obj, id, buffers);

        })();
    }

    this.fromCurve = function ({ curvePoints, subdivisions, width, color, type }, id) {
        let curve = new Curve(curvePoints.map(p => new Vector3(p.x, p.y, p.z)), type);


        let points = [];
        for (let i = 0; i <= subdivisions; i++) {
            let pct = i / subdivisions;
            let pos = curve.getPoint(pct);
            points.push(pos.x, pos.y, pos.z);
        }

        let line = new Line3D({
            width,
            color,
            points
        });

        createExtraAttrib(line.geometry, 'thickness', width);
        createExtraAttrib(line.geometry, 'aColor', new Color(color || '#ffffff').toArray());
        createExtraAttrib(line.geometry, 'aOpacity', 1);

        let { obj, buffers } = geomToObj(line.geometry);
        resolve(obj, id, buffers);
    }
});

Class(function LineUtil() {
    Inherit(this, Component);
    const _this = this;
    var _builder, _meta, _queue;

    this.useThread = true;
    this.precision = 3;

    var _processing = false;
    var _queue = [];

    function createGeometry(attributes) {
        let geom = new Geometry();
        for (let key in attributes) {
            if (key == 'index' || !attributes[key].length) continue;
            let comp = attributes[key].length / attributes.width.length;
            geom.addAttribute(key, new GeometryAttribute(attributes[key], comp));
        }

        geom.setIndex(new GeometryAttribute(new (Geometry.arrayNeedsUint32(attributes.index) ? Uint32Array : Uint16Array)(attributes.index), 1));
        return geom;
    }

    function initBuilder() {
        if (_this.useThread) {
            _builder = _this.initClass(Thread, LineBuilder);
            Utils3D.loadEngineOnThread(_builder);
            _builder.importClass(LineGeometry, Line3D, Object3D);
            if (window.Curve) Curve.loadOnThread(_builder);
            _builder.on('meta', receiveMeta);
            if (Line3D.taperFunction) _builder.loadFunction(Line.taperFunction);
        } else {
            _builder = _this.initClass(LineBuilder);
            _builder.onMeta = receiveMeta;
        }
    }

    function trim(value, precision) {
        let p = Math.pow(10, precision);
        return Math.round(value * p) / p;
    }

    function build(groups, file, data) {
        let promise = Promise.create();
        let promises = [];
        let group = null;

        groups.forEach(group => {
            promises.push(_builder.createLine({ file, data, group }));
        });

        Promise.all(promises).then(array => {
            array.forEach(attributes => {
                let merged = new MergedLine(createGeometry(attributes), attributes.lineCount);
                merged.meta = attributes.meta;
                merged.lineCount = attributes.lineCount;

                if (array.length == 1) {
                    promise.resolve(merged);
                } else {
                    if (!group) group = new MergedLineGroup();
                    group.add(merged);
                }
            });


            promise.resolve(group);
        });

        return promise;
    }

    async function runQueue() {
        let obj = _queue.shift();
        if (!obj) return;

        _processing = true;

        let data;
        if (obj.file) data = await load(obj.file);
        else data = await loadFromData(obj.data);

        obj.promise.resolve(data);
        _processing = false;
        runQueue();
    }

    function load(file) {
        let promise = Promise.create();
        if (!_builder) initBuilder();
        file = Thread.absolutePath(file);

        _builder.parse({ file }).then(groups => {

            build(groups, file, null).then(merged => {
                merged.fileMeta = _meta;
                promise.resolve(merged);
                _builder.release({ file });
                _meta = null;
            });

        });
        return promise;
    }

    function loadFromData(data) {
        if (!_builder) initBuilder();

        let promise = Promise.create();
        _builder.parseFromData({ data }).then(groups => {

            build(groups, null, data).then(merged => {
                promise.resolve(merged);
            });

        });

        return promise;
    }

    //*** Event handlers
    function receiveMeta(e) {
        _meta = e;
    }

    //*** Public methods
    this.load = function (file) {
        let promise = Promise.create();

        _queue.push({ file, promise });
        if (!_processing) runQueue();

        return promise;
    }

    this.loadFromData = function (data) {
        let promise = Promise.create();

        _queue.push({ data, promise });
        if (!_processing) runQueue();

        return promise;
    }

    this.outputFromArray = function (array) {
        let output = [];
        array.forEach(l => {
            let data = l.data;
            for (let key in data.geometry) {
                if (Array.isArray(data.geometry[key])) {
                    data.geometry[key].forEach((v, i) => {
                        data.geometry[key][i] = trim(v, _this.precision);
                    });
                }
            }

            output.push(data);
        });

        return output;
    }

    this.trim = trim;

    this.uploadTaperFunctions = function (fn) {
        if (!_this.useThread) return;
        if (!_builder) initBuilder();
        let upload = { fns: {} };
        for (let key in fn) {
            let code = fn[key].toString();
            upload.fns[key] = code;
        }
        _builder.uploadTaperFunctions(upload);
    }

    this.changeTaperFunction = function (fn) {
        _builder.changeTaperFunction({ fn });
    }

    this.loadFromSplines = async function (url, subdivisions, color, width, type) {
        if (!_builder) initBuilder();
        let data = await _builder.loadFromSplines({ url: Thread.absolutePath(url), subdivisions, width, color, type });

        let merged = new MergedLine(createGeometry(data), data.lineCount);

        return merged;
    }

    this.fromCurve = async function (curve, config) {
        if (!_builder) initBuilder();
        config.curvePoints = curve.points;
        let data = await _builder.fromCurve(config);
        let merged = new MergedLine(createGeometry(data), data.lineCount);

        return merged;
    }
}, 'static');

Class(function MetalRenderer() {
    Inherit(this, Component);
    const _this = this;
    var _dpr, _width, _height, _depth;
    var _projScreenMatrix, _vector3, _frustum, _ubo;

    this.autoClear = true;
    this.shadows = Renderer.SHADOWS_MED;

    var _m0 = new Matrix4();
    var _m1 = new Matrix4();
    var _resolution = new Vector2();
    var _time = {value: 0};
    var _canvas = new Vector2();

    //*** Constructor
    (function () {
        Renderer.extensions = {pvrtc: true};
        MetalRenderer.instance = _this;
        Renderer.CLEAR = [0, 0, 0, 1];
        initMath();
        initRenderers();
        _this.startRender(loop, RenderManager.FRAME_BEGIN);
        RenderManager.schedule(startFrame, RenderManager.FRAME_BEGIN);
    })();

    function initCameraUBO(camera) {
        camera._ubo = new MetalUBO();
        camera._ubo.push({value: camera.projectionMatrix});
        camera._ubo.push({value: camera.matrixWorldInverse});
        camera._ubo.push({value: camera.worldPos});
        camera._ubo.push({value: _resolution});
        camera._ubo.push(_time);
        camera._ubo.push(Render.timeScaleUniform);
        camera._ubo.upload();
    }

    function initMath() {
        _projScreenMatrix = new Matrix4();
        _vector3 = new Vector3();
        _frustum = new Frustum();
    }

    function sortOpaque(array) {
        for (let i = array.length-1; i > -1; i--) {
            let obj = array[i];
            if (!obj.shader._metal) obj.shader.upload(obj);
        }
        array.sort((a, b) => {
            if (a.renderOrder !== b.renderOrder) return a.renderOrder - b.renderOrder;
            let aid = a.shader._metal._id;
            let bid = b.shader._metal._id;
            if (aid !== bid) return aid - bid;
            return a.id - b.id;
        });
    }

    function sortTransparent(array) {
        RenderStats.update('SortTransparent', array.length);
        array.sort((a, b) => {
            if (a.renderOrder !== b.renderOrder) return a.renderOrder - b.renderOrder;
            if (a.worldPos.z !== b.worldPos.z) return a.worldPos.z - b.worldPos.z;
            return a.id - b.id;
        });
    }

    function projectObject(object, camera, scene) {
        if (object.shader !== undefined) {
            let visible = object.determineVisible() && object.shader.visible && !object.shader.neverRender;
            if (visible) {
                object.modelViewMatrix.multiplyMatrices(camera.matrixWorldInverse, object.matrixWorld);
                object.normalMatrix.getNormalMatrix(object.modelViewMatrix);
            }

            if (scene.displayNeedsUpdate || (object.shader.transparent && !scene.disableAutoSort && visible)) object.getWorldPosition(object.worldPos);
            if (scene.displayNeedsUpdate) scene.toRender[object.shader.transparent ? 1 : 0].push(object);
        }

        if (object.visible === true || scene.displayNeedsUpdate) {
            for (let i = object.childrenLength - 1; i > -1; i--) {
                projectObject(object.children[i], camera, scene);
            }
        }
    }

    function initRenderers() {
        Geometry.renderer = new GeometryRendererMetal();
        Texture.renderer = new TextureRendererMetal();
        Shader.renderer = new ShaderRendererMetal();
        RenderTarget.renderer = new FBORendererMetal();
    }

    function loop(t, dt) {
        _time.value += dt * 0.001;
    }

    function startFrame() {
        _this.commandBuffer = Metal.commandBuffer;
        _this.renderPassDescriptor = Metal.renderPassDescriptor;

        let depth = _this.renderPassDescriptor.getDepthAttachment();
        depth.setTexture(_depth);
        depth.setLoadAction(_this.autoClear ? 'clear' : 'dontcare');
        depth.setStoreAction('dontcare');
    }

    function render(scene, camera, rt) {
        if (rt) {
            _resolution.set(rt.width, rt.height);
        } else {
            _resolution.set(_width * _dpr, _height * _dpr);
        }

        if (!camera._ubo) initCameraUBO(camera);
        else camera._ubo.update();

        _this.globalUBO = camera._ubo;

        if (!camera.parent) camera.updateMatrixWorld();
        camera.getWorldPosition(camera.worldPos);
        _frustum.setFromCamera(camera);

        for (let l = 0; l < 2; l++) {
            let len = scene.toRender[l].length;
            for (let i = 0; i < len; i++) {
                let object = scene.toRender[l][i];
                object.onBeforeRender && object.onBeforeRender();
                if (!object.determineVisible() || !object.shader.visible || object.shader.neverRender) continue;

                if (object.frustumCulled === false || _frustum.intersectsObject(object) === true) {
                    object.shader.draw(object, object.geometry, camera);
                    if (_this.shadows && object.shader.receiveShadow && !_this.overridePreventShadows) attachShadowUniforms(object, scene, camera);
                    object.geometry.draw(object, object.shader);
                }
            }
        }
    }

    function attachShadowUniforms(object, scene, camera) {
        let lights = Lighting.getShadowLights();
        if (!object._metal.shadowData) object._metal.shadowData = {combined: []};

        for (let i = 0; i < lights.length; i++) {
            let light = lights[i];
            _m1.multiplyMatrices(light.shadow.camera.matrixWorldInverse, object.matrixWorld);
            _m0.multiplyMatrices(light.shadow.camera.projectionMatrix, _m1);
            _m0.toArray(object._metal.shadowData.combined, i * 16);
        }

        if (scene._shadowData && scene._shadowData.count) {
            object.shader.uniforms.shadowMap.value = scene._shadowData[_this.overridePreventShadows ? 'emptyMaps' : 'maps'];
            if (!object._metal.shadowData.applied) {
                object._metal.shadowData.applied = true;
                object._metal.ubo.set('shadowMatrix', {type: 'm4v', value: object._metal.shadowData.combined});
                object._metal.ubo.set('shadowLightPos', {components: 3, type: 'v3v', value: scene._shadowData.pos});
                object._metal.ubo.set('shadowSize', {components: 1, type: 'fv', value: scene._shadowData.size});
                object._metal.ubo.update();
            }
        }
    }

    function prepareShadowUniforms(object, scene, light) {
        if (!object._light) {
            object._light = {};
            object._light.mvm = new Matrix4();
            object._light.nm = new Matrix3();
        }

        object._light.mvm.multiplyMatrices(light.shadow.camera.matrixWorldInverse, object.matrixWorld);
        object._light.nm.getNormalMatrix(object.modelViewMatrix);

        let ubo = object._metal.ubo;
        if (!ubo.shadowUniforms) {
            ubo.addShadowUniforms({
                'normalMatrix': {value: object._light.nm},
                'modelViewMatrix': {value: object._light.mvm}
            });
        }
    }

    function renderFromLight(light, scene, camera) {
        RenderTarget.renderer.bind(light.shadow.rt);

        let commandBuffer = _this.commandBuffer;
        let renderPassDescriptor = light.shadow.rt._metal.renderPassDescriptor;
        let commandEncoder = _this.commandEncoder = commandBuffer.makeRenderCommandEncoder(renderPassDescriptor);

        light.shadow.camera.updateMatrixWorld();
        camera.getWorldPosition(camera.worldPos);
        _frustum.setFromCamera(camera);

        if (!light.shadow.camera._ubo) initCameraUBO(light.shadow.camera);
        else light.shadow.camera._ubo.update();

        _this.globalUBO = light.shadow.camera._ubo;

        for (let l = 0; l < 2; l++) {
            for (let i = 0; i < scene.toRender[l].length; i++) {
                let object = scene.toRender[l][i];

                if (object.castShadow !== true || !object.determineVisible() || !object.shader.visible || object.shader.neverRender) continue;

                if (object.frustumCulled === false || _frustum.intersectsObject(object) === true) {
                    if (!object.shader.shadow) Lighting.initShadowShader(object);
                    object.shader.shadow.draw(object, object.geometry);
                    prepareShadowUniforms(object, scene, light);
                    object._metal.ubo.useShadowUniforms();
                    object.geometry.draw(object, object.shader.shadow);
                    object._metal.ubo.useDefaultUniforms();
                }
            }
        }

        commandEncoder.endEncoding();
        Shader.renderer.clearState();
        Geometry.renderer.clearState();
    }

    function renderShadows(scene, camera) {
        let lights = Lighting.getShadowLights();
        if (!scene._shadowData) scene._shadowData = {maps: [], emptyMaps: [], size: [], pos: [], count: lights.length};
        if (scene._shadowData.count != lights.length) {
            scene._shadowData.size = [];
            scene._shadowData.pos = [];
            scene._shadowData.count = lights.length;
        }
        for (let i = 0; i < lights.length; i++) {
            let light = lights[i];
            light.prepareRender();
            scene._shadowData.maps[i] = light.shadow.rt.depth;
            scene._shadowData.emptyMaps[i] = Utils3D.getEmptyTexture();
            scene._shadowData.size[i] = light.shadow.size;
            light.position.toArray(scene._shadowData.pos, i * 3);
        }

        for (let i = 0; i < lights.length; i++) {
            let light = lights[i];
            if (!light.shadow.frozen && light.determineVisible()) renderFromLight(light, scene, camera);
        }
    }

    function prepareScene(scene, camera) {
        if (scene.displayNeedsUpdate) {
            scene.toRender[0].length = 0;
            scene.toRender[1].length = 0;
        }

        scene.updateMatrixWorld();

        projectObject(scene, camera, scene);

        if (scene.displayNeedsUpdate) sortOpaque(scene.toRender[0]);
        if (scene.displayNeedsUpdate || (scene.toRender[1].length && !scene.disableAutoSort)) sortTransparent(scene.toRender[1]);

        // if (!rt && _this.vrRenderingPath && !forceToScreen) _this.vrRenderingPath(scene, camera, _projScreenMatrix, _frustum, attachSceneUniforms);
        // else if (!rt && _this.arRenderingPath && !forceToScreen) _this.arRenderingPath(render, scene, camera);
        // else render(scene, camera, rt);

        scene.displayNeedsUpdate = false;
    }

    //*** Event handlers

    //*** Public methods
    this.render = function(scene, camera, rt, _, callback) {
        prepareScene(scene, camera);

        if (_this.shadows && !_this.overridePreventShadows && !_this.pauseShadowRendering && scene.hasShadowLight) {
            renderShadows(scene, camera);
        }

        if (rt) RenderTarget.renderer.bind(rt);

        let commandBuffer = _this.commandBuffer;
        let renderPassDescriptor = rt ? rt._metal.renderPassDescriptor : _this.renderPassDescriptor;

        let commandEncoder = _this.commandEncoder = commandBuffer.makeRenderCommandEncoder(renderPassDescriptor);

        if (!rt && _this.arRenderingPath) _this.arRenderingPath(render, scene, camera);
        else render(scene, camera, rt);

        if (typeof callback === 'function') {
            callback((depScene, depCamera) => {
                prepareScene(depScene, depCamera);
                render(depScene, depCamera);
            });
        }

        commandEncoder.endEncoding();
        Shader.renderer.clearState();
        Geometry.renderer.clearState();
    }

    this.renderSingle = function(object, camera, rt, callback) {
        if (rt) RenderTarget.renderer.bind(rt);

        let commandBuffer = _this.commandBuffer;
        let renderPassDescriptor = rt ? rt._metal.renderPassDescriptor : _this.renderPassDescriptor;

        let commandEncoder = _this.commandEncoder = commandBuffer.makeRenderCommandEncoder(renderPassDescriptor);

        if (!object.noMatrices) {
            camera.getWorldPosition(camera.worldPos);
            object.modelViewMatrix.multiplyMatrices(camera.matrixWorldInverse, object.matrixWorld);
            object.normalMatrix.getNormalMatrix(object.modelViewMatrix);
            object.getWorldPosition(object.worldPos);
        }

        if (!camera._ubo) initCameraUBO(camera);
        _this.globalUBO = camera._ubo;

        object.shader.draw(object, object.geometry, camera);
        object.geometry.draw(object, object.shader);

        if (typeof callback === 'function') {
            callback((depScene, depCamera) => {
                prepareScene(depScene, depCamera);
                render(depScene, depCamera);
            });
        }

        commandEncoder.endEncoding();
        Shader.renderer.clearState();
        Geometry.renderer.clearState();
    }

    this.setClearColor = function(color, alpha = 1) {
        _this.clearColor = new Color(color);
        Renderer.CLEAR = [_this.clearColor.r, _this.clearColor.g, _this.clearColor.b, alpha];
    }

    this.setClearAlpha = function(alpha) {
        Renderer.CLEAR[3] = alpha;
    }

    this.getClearColor = function() {
        if (!_this.clearColor) _this.clearColor = new Color(0, 0, 0);
        return _this.clearColor;
    }

    this.getClearAlpha = function() {
        return Renderer.CLEAR[3];
    }

    this.setPixelRatio = function(dpr) {
        _dpr = dpr;
        this.setSize(_width, _height);
    }

    this.setSize = function(width, height) {
        _width = width;
        _height = height;
        _canvas.width = width * _dpr;
        _canvas.height = height * _dpr;
        _resolution.set(width * _dpr, height * _dpr);

        if (_dpr !== undefined) {
            let descriptor = Metal.device.makeTextureDescriptor();
            descriptor.setTextureType('2d');
            descriptor.setPixelFormat('float_depth');
            descriptor.setWidth(width * _dpr);
            descriptor.setHeight(height * _dpr);
            descriptor.setIsRenderTarget();

            _depth = Metal.device.makeTexture();
            _depth.fromDescriptor(descriptor);
        }
    }

    this.getMaxAnisotropy = function() {

    }

    this.readPixels = function(rt, x = 0, y = 0, width, height) {

    }

    this.blit = function(input, output) {
        if (Device.system.version < 13) return false;
        if (!input._metal) RenderTarget.renderer.upload(input);
        if (!output._metal) RenderTarget.renderer.upload(output);
        let commandEncoder = _this.commandBuffer.makeBlitCommandEncoder();
        Metal.blit(commandEncoder.key, input.texture._metal.key, output.texture._metal.key);
        return true;
    }

    this.get('resolution', _ => {
        return _resolution;
    });

    this.get('time', _ => {
        return _time;
    });
});
Class(function MetalARRenderer(_renderer, _nuke) {
    Inherit(this, Component);
    const _this = this;
    var _session, _arCamera, _callback, _frame, _frameOfRef;

    //*** Constructor
    (function () {
        defer(setup);
    })();

    async function setup() {
        try {
            _session = await XRDeviceManager.getARSession();
            _session.baseLayer = new XRMetalLayer(_session);
            _session.updateRenderState({baseLayer: _session.baseLayer});
            Render.useRAF(rAFOverride);

            _arCamera = RenderManager.camera;
            _frameOfRef = await _arCamera.getFrameOfReference();

            ARUtils.frameOfReference = _frameOfRef;

            _session.requestAnimationFrame(rAF);

            _renderer.arRenderingPath = renderAR;

            _this.events.fire(XRDeviceManager.SESSION_START);
        } catch(e) {
            console.log(e.stack.toString());
        }
    }

    function renderAR(render, scene, camera) {
        if (!_nuke.passes.length) _session.baseLayer.drawCameraTexture(_renderer.commandEncoder);
        render(scene, camera);
    }

    function rAFOverride(callback) {
        _callback = callback;
    }

    function rAF(t, frame) {
        let pose = frame.getDevicePose(_frameOfRef);
        if (pose) {
            ARUtils.pose = pose;
            let view = pose.views[0];
            _arCamera.getRenderCamera(view, pose);
        }

        _session.requestAnimationFrame(rAF);
        _frame = frame;
        _this.flag('raf', true);
        if (_callback) _callback(t);
    }

    //*** Event handlers

    //*** Public methods
    this.render = function(scene, camera, na, nb, callback) {
        if (!_frame) return;
        if (_nuke.passes.length) {
            _nuke.render(callback);
        } else {
            _renderer.render(scene, camera, )
        }
    }

    this.setSize = function(width, height) {
        _renderer.setPixelRatio(RenderManager.DPR);
        _renderer.setSize(width, height);
    }

    this.getCameraTexture = async function(texture) {
        await _this.wait('raf');
        texture._metal = _session.getCameraTexture();
    }
});
Class(function FBORendererMetal() {
    const _this = this;

    //*** Constructor
    (function () {

    })();

    //*** Event handlers

    //*** Public methods
    this.upload = function(rt) {
        let texture = rt.texture;
        if (texture._metal) texture._metal.dispose();
        texture._metal = Metal.device.makeTexture();

        {
            let descriptor = Metal.device.makeTextureDescriptor();
            descriptor.setTextureType('2d');
            descriptor.setPixelFormat(texture.format + texture.type);
            descriptor.setWidth(rt.width);
            descriptor.setHeight(rt.height);
            descriptor.setIsRenderTarget();
            texture._metal.fromDescriptor(descriptor);
        }

        {
            let descriptor = Metal.device.makeSamplerDescriptor();
            descriptor.setMinFilter(texture.minFilter);
            descriptor.setMagFilter(texture.magFilter);
            if (texture.generateMipmaps) descriptor.setMipFilter(texture.minFilter);
            descriptor.setWrapping(texture.wrapS, texture.wrapT);
            texture._metal.sampler = Metal.device.makeSamplerState(descriptor);
        }

        rt._metal = {};
        let renderPass = rt._metal.renderPassDescriptor = Metal.device.makeRenderPassDescriptor();

        let storeDepth = !!rt.depth;
        if (!storeDepth) rt.depth = new Texture();
        let descriptor = Metal.device.makeTextureDescriptor();
        descriptor.setTextureType('2d');
        descriptor.setPixelFormat('float_depth');
        descriptor.setWidth(rt.width);
        descriptor.setHeight(rt.height);
        descriptor.setIsRenderTarget();

        rt.depth._metal = Metal.device.makeTexture();
        rt.depth._metal.fromDescriptor(descriptor);

        let depth = renderPass.getDepthAttachment();
        depth.setTexture(rt.depth._metal);
        depth.setLoadAction('clear');
        depth.setStoreAction(storeDepth ? 'store' : 'dontcare');

        if (rt.multi) {
            for (let i = 0; i < rt.attachments.length; i++) {
                let attachment = renderPass.getColorAttachment(i);
                let texture = rt.attachments[i];

                let descriptor = Metal.device.makeTextureDescriptor();
                descriptor.setTextureType('2d');
                descriptor.setWidth(rt.width);
                descriptor.setHeight(rt.height);
                descriptor.setPixelFormat(texture.format + texture.type);
                descriptor.setIsRenderTarget();

                texture._metal = Metal.device.makeTexture();
                texture._metal.fromDescriptor(descriptor);
                attachment.setTexture(texture._metal);
                attachment.setClearColor(0, 0, 0, 1);
                attachment.setLoadAction('clear');
                attachment.setStoreAction('store');
            }
        } else {
            let attachment = renderPass.getColorAttachment(0);
            attachment.setTexture(texture._metal);
            attachment.setStoreAction('store');
            attachment.setLoadAction(rt.autoClear === false ? 'dontcare' : 'clear');
        }
    }

    this.bind = function(rt) {
        if (!rt._metal) this.upload(rt);

        let attachment = rt._metal.renderPassDescriptor.getColorAttachment(0);
        attachment.setClearColor(Renderer.CLEAR[0], Renderer.CLEAR[1], Renderer.CLEAR[2], Renderer.CLEAR[3]);
        attachment.setLoadAction(World.RENDERER.autoClear ? 'clear' : 'dontcare');
    }

    this.resize = function(rt) {
        this.destroy(rt);
        this.upload(rt);
    }

    this.destroy = function(rt) {
        if (rt.depth && rt.depth._metal) rt.depth._metal.dispose();
    }
});
Class(function GeometryRendererMetal() {
    const _this = this;
    var _lastGeom, _lastShader;

    function getMode(mesh) {
        if (mesh.isPoints) return 'point';
        if (mesh.isLine) return 'line';
        return 'triangle';
    }

    function updateBuffer(attrib) {
        attrib.needsUpdate = false;
        let array = attrib.array;
        attrib._metal.buffer.subData(array, array.byteLength);
    }

    //*** Event handlers

    //*** Public methods
    this.draw = function(geom, mesh, shader) {
        if (!geom._metal || geom.needsUpdate) this.upload(geom);

        for (let key in geom.attributes) {
            let attrib = geom.attributes[key];
            if (attrib.needsUpdate || attrib.dynamic) updateBuffer(attrib);
        }

        let mode = getMode(mesh);
        let globalUBO = MetalRenderer.instance.globalUBO;
        let commandEncoder = MetalRenderer.instance.commandEncoder;

        if (_lastGeom != geom || _lastShader != shader) {
            _lastGeom = geom;
            _lastShader = shader;
            let bufferIndex = 0;
            for (let key in shader._metal.attributes) {
                if (!geom.attributes[key]) continue;
                let shaderIndex = shader._metal.attributes[key];
                if (shaderIndex > -1) {
                    bufferIndex++;
                    Metal.setVertexBuffer(commandEncoder.key, geom.attributes[key]._metal.buffer.key, 0, shaderIndex);
                }
            }

            Metal.setVertexBuffer(commandEncoder.key, globalUBO.buffer.key, 0, bufferIndex++);
            geom._metal.lastBufferIndex = bufferIndex++;

            Metal.setFragmentBuffer(commandEncoder.key, globalUBO.buffer.key, 0, 0);
            if (Lighting.activeScene && Lighting.activeScene.ubo && Lighting.activeScene.ubo.buffer && shader.receiveLight) Metal.setFragmentBuffer(commandEncoder.key, Lighting.activeScene.ubo.buffer.key, 0, 2);
        }

        Metal.setFragmentBuffer(commandEncoder.key, mesh._metal.ubo.buffer.key, 0, 1);
        Metal.setVertexBuffer(commandEncoder.key, mesh._metal.ubo.buffer.key, 0, geom._metal.lastBufferIndex);

        let drawStart = geom.drawRange.start || 0;
        let drawEnd = geom.drawRange.end || geom.attributes.position.count;

        if (geom.isInstanced) {
            if (geom.index) Metal.drawIndexedPrimitivesInstanced(commandEncoder.key, mode, geom.index.length, 'uint16', geom._metal.index.key, 0, geom.maxInstancedCount);
            else Metal.drawPrimitivesInstanced(commandEncoder.key, mode, drawStart, drawEnd, geom.maxInstancedCount);
        } else {
            if (geom.index) Metal.drawIndexedPrimitives(commandEncoder.key, mode, geom.index.length, 'uint16', geom._metal.index.key, 0);
            else Metal.drawPrimitives(commandEncoder.key, mode, drawStart, drawEnd);
        }
    }

    this.upload = this.uploadBuffersAsync = function(geom) {
        geom._metal = {};

        if (!geom.attributes.uv) geom.addAttribute('uv', new GeometryAttribute(new Float32Array(geom.attributes.position.count * 2), 2));
        if (!geom.attributes.normal) geom.addAttribute('normal', new GeometryAttribute(new Float32Array(geom.attributes.position.count * 3), 3));

        for (let key in geom.attributes) {
            let attrib = geom.attributes[key];

            if (attrib._metal) continue;
            attrib._metal = {};
            attrib._metal.buffer = Metal.device.makeBuffer(attrib.array, attrib.array.byteLength);
            attrib._metal.bufferUploaded = true;
        }

        if (geom.index && !geom._metal.index) {
            geom._metal.index = Metal.device.makeBuffer(geom.index, geom.index.byteLength);
        }
    }

    this.destroy = function(geom) {
        for (let key in geom.attributes) {
            let attrib = geom.attributes[key];
            if (attrib._metal) {
                attrib._metal.buffer.dispose();
                delete attrib._metal;
            }
        }
    }

    this.resetMeshGeom = function() {

    }

    this.clearState = function() {
        _lastGeom = null;
        _lastShader = null;
    }
});
Class(function ShaderRendererMetal() {
    const _this = this;

    const convert = require('MetalShaderConverter');

    var _pool = {};
    var _cached = {};
    var _pipelineID = 0;

    var _lastPipelineState = '';

    function emptyArray(count) {
        let array = [];
        for (let i = 0; i < count; i++) array[i] = 0;
        return array;
    }

    function findUniformType(uniform) {
        if (typeof uniform.type === 'string') {
            if (uniform.type == 'v2v') uniform.components = 2;
            if (uniform.type == 'v3v') uniform.components = 3;
            if (uniform.type == 'v4v') uniform.components = 4;
            return uniform.type;
        }
        if (uniform.value === null || uniform.value instanceof Texture || uniform.value.texture || uniform.value.rt && uniform.value.rt.texture) return 't';
        if (uniform.value instanceof Vector2) return 'v2';
        if (uniform.value instanceof Vector3) return 'v3';
        if (uniform.value instanceof Vector3D) return 'v3';
        if (uniform.value instanceof Vector4) return 'v4';
        if (uniform.value instanceof Matrix4) return 'm4';
        if (uniform.value instanceof Matrix3) return 'm3';
        if (uniform.value instanceof Color) return 'c';
        if (uniform.value instanceof Quaternion) return 'q';

        if (Array.isArray(uniform.value)) {
            if (uniform.value[0] instanceof Texture) return 'tv';
        }

        return 'f';
    }

    function createComputePipeline(shader) {
        if (shader._metal.pipeline) shader._metal.pipeline.dispose();
        shader._metal.pipeline = Metal.device.makeComputePipelineState(shader._metal.library.compute);
    }

    function updatePipelineState(shader) {
        if (shader._metal.pipeline) shader._metal.pipeline.dispose();

        let pipelineDescriptor = Metal.device.makeRenderPipelineDescriptor();
        pipelineDescriptor.setVertexFunction(shader._metal.library.vertex);
        pipelineDescriptor.setFragmentFunction(shader._metal.library.fragment);
        pipelineDescriptor.setDepthAttachmentPixelFormat('depth32float');

        let attachmentData = shader._attachmentData || {attachments: 1};
        let {format, type, attachments} = attachmentData;
        for (let i = 0; i < attachments; i++) {
            let attachment = pipelineDescriptor.getColorAttachment(i);
            attachment.setPixelFormat(format ? format + type : 'bgra8Unorm');
            attachment.setColorWriteMask(shader.colorMask);
            attachment.setTransparent(shader.transparent);
            attachment.setBlending(shader.blending);
        }

        shader._metal.pipeline = Metal.device.makeRenderPipelineState(pipelineDescriptor);

        shader._metal.colorMask = shader._metal.pipeline.colorMask = shader.colorMask;
        shader._metal.blending = shader._metal.pipeline.blending = shader.blending;
        shader._metal.transparent = shader._metal.pipeline.transparent = shader.transparent;
        shader._metal.tag = shader._metal.pipeline.tag = `${shader.vsName}|${shader.fsName}|${shader.customCompile}`;
    }

    function createLibrary(shader) {
        let vsCode = shader.onBeforeCompile(shader.vertexShader, 'vs');
        let fsCode = shader.onBeforeCompile(shader.fragmentShader, 'fs');
        let source = convert(vsCode, fsCode, shader);

        let library = shader._metal.library = Metal.device.makeLibrary(source);
        if (shader.compute) {
            shader._metal.library.compute = library.makeFunction('computeShader');
        } else {
            shader._metal.library.vertex = library.makeFunction('vertexShader');
            shader._metal.library.fragment = library.makeFunction('fragmentShader');
        }
    }

    function setupUBO(shader, mesh) {
        if (!mesh) mesh = shader;
        if (mesh.transient) mesh._metal = shader._metal;
        if (!mesh._metal) mesh._metal = {};

        if (!mesh._metal.ubo) {
            mesh._metal.ubo = new MetalUBO();
            let prependUniforms = {
                normalMatrix: {value: mesh.normalMatrix || new Matrix3()},
                modelMatrix: {value: mesh.matrixWorld || new Matrix4()},
                modelViewMatrix: {value: mesh.modelViewMatrix || new Matrix4()}
            };

            for (let key in prependUniforms) {
                let uniform = prependUniforms[key];
                uniform.type = findUniformType(uniform);
                mesh._metal.ubo.set(key, uniform);
                shader._metal[key] = 'U';
            }

            shader._metal.uniforms.forEach(uni => {
                if (uni.includes('sampler')) return;
                let [type, name] = uni.split(' ');
                let array = false;
                if (name.includes('[')) {
                    let split = name.split('[');
                    name = split[0];
                    array = Number(split[1].split(']')[0]);
                }

                let placeHolder = (function () {
                    switch (type) {
                        case 'float':
                            return 0;
                            break;
                        case 'vec2':
                            if (array) return emptyArray(2 * array);
                            return new Vector2();
                            break;
                        case 'vec3':
                            if (array) return emptyArray(3 * array);
                            return new Vector3();
                            break;
                        case 'vec4':
                            if (array) return emptyArray(4 * array);
                            return new Vector4();
                            break;
                        case 'mat3':
                            return new Matrix3();
                            break;
                        case 'mat4':
                            if (array) return emptyArray(16 * array);
                            return new Matrix4();
                            break;
                    }
                })();
                mesh._metal.ubo.set(name, {value: placeHolder});
            });
        }

        for (let key in shader.uniforms) {
            let uniform = shader.uniforms[key];
            if (typeof shader._metal[key] !== 'undefined') continue;

            if (!uniform) continue;
            uniform.type = findUniformType(uniform);

            if (uniform.type != 't' && uniform.type != 'tv') {
                mesh._metal.ubo.set(key, uniform);
            } else {
                if (typeof uniform.samplerIndex === 'undefined') uniform.samplerIndex = shader._metal.samplers.indexOf(key);
            }
            shader._metal[key] = 'U';
        }

        mesh._metal.ubo.upload();
    }

    function updateDepthStencil(shader) {
        if (shader._metal.depthStencil) shader._metal.depthStencil.dispose();

        let descriptor = Metal.device.makeDepthStencilDescriptor();
        descriptor.setDepthWrite(shader.depthWrite);
        descriptor.setDepthTest(shader.depthTest);
        shader._metal.depthStencil = Metal.device.makeDepthStencilState(descriptor);
        shader._metal.depthStencil.depthWrite = shader.depthWrite;
        shader._metal.depthStencil.depthTest = shader.depthTest;
    }

    //*** Event handlers

    //*** Public methods
    this.clearState = function() {
        _lastPipelineState = null;
    }

    this.draw = function(shader, mesh) {
        if (shader._metal === undefined || mesh._metal === undefined) this.upload(shader, mesh);
        if (mesh.transient) mesh._metal = shader._metal;

        if (!mesh._metal.ubo) {
            this.upload(shader, mesh);
            if (mesh.transient) mesh._metal = shader._metal;
        }

        mesh._metal.ubo.update();

        let commandEncoder;
        if (shader.compute) {

            commandEncoder = MetalRenderer.instance.commandEncoderCompute
            commandEncoder.prepareCompute(shader._metal.pipeline);

        } else {

            commandEncoder = MetalRenderer.instance.commandEncoder;

            if (shader.depthWrite != shader._metal.depthStencil.depthWrite
                || shader.depthTest != shader._metal.depthStencil.depthTest) updateDepthStencil(shader);

            if (shader.colorMask != shader._metal.colorMask
                || shader.blending != shader._metal.blending
                || shader.transparent != shader._metal.transparent) updatePipelineState(shader);

            // commandEncoder.prepareShader(shader._metal.pipeline, shader.side, shader._metal.depthStencil);
            let currentKey =  commandEncoder.key + shader._metal.pipeline.key + shader.side + shader._metal.depthStencil.key;
            if (_lastPipelineState != currentKey) {
                Metal.bindShader(commandEncoder.key, shader._metal.pipeline.key, shader.side, shader._metal.depthStencil.key);
                _lastPipelineState = currentKey;
            }

        }

        for (let key in shader.uniforms) {
            let uniform = shader.uniforms[key];
            if (!shader._metal[key]) setupUBO(shader, mesh);

            if (uniform.metalIgnore) continue;

            if (uniform.type == 't' && uniform.value) {
                if (uniform.samplerIndex == -1) continue;
                let texture = uniform.value;

                if (!texture.isTexture) {
                    if (uniform.value.rt) texture = uniform.value.rt.overrideTexture || uniform.value.rt.texture;
                    if (uniform.value.texture) texture = uniform.value.texture;
                }
                if (texture.loaded === false) texture = Utils3D.getEmptyTexture();

                Texture.renderer.draw(texture, uniform.samplerIndex, commandEncoder);
            } else if (uniform.type == 'tv') {
                if (uniform.samplerIndex == -1) continue;
                let array = shader._metal.texArray || [];
                array.length = 0;
                shader._metal.texArray = array;
                for (let i = 0; i < uniform.value.length; i++) {
                    let texture = uniform.value[i];
                    if (texture.loaded === false) texture = Utils3D.getEmptyTexture();
                    array.push(texture);
                }
                Texture.renderer.drawArray(array, uniform.samplerIndex, commandEncoder);
            }
        }
    }

    this.upload = function(shader, mesh) {
        if (!shader._metal) {
            shader._metal = {};
            let key = `${shader.vsName}_${shader.fsName}_${shader.customCompile}`;
            let cached = _pool[key];

            if (cached) {
                shader._metal.library = cached.library;
                shader._metal.pipeline = cached.pipeline;
                shader._metal.attributes = cached.attributes;
                shader._metal.uniforms = cached.uniforms;
                shader._metal.samplers = cached.samplers;
                shader._metal._id = cached.id;
                cached.count++;
            } else {
                createLibrary(shader);
                shader._metal._id = _pipelineID++;
                _pool[key] = {
                    count: 1,
                    library: shader._metal.library,
                    id: shader._metal._id,
                    attributes: shader._metal.attributes,
                    uniforms: shader._metal.uniforms,
                    samplers: shader._metal.samplers
                };
            }

            if (shader.compute) {
                createComputePipeline(shader);
            } else {
                updatePipelineState(shader);
                updateDepthStencil(shader);
            }
            shader.vertexShader = shader.fragmentShader = '';
        }

        setupUBO(shader, mesh);
        shader._gl = shader._metal;
    }

    this.destroy = function(shader) {
        if (shader.mesh && shader.mesh._metal) {
            shader.mesh._metal.ubo.destroy();
        }

        if (shader._metal) {
            shader._metal.depthStencil.dispose();
            shader._metal.pipeline.dispose();
        }

        delete shader._metal;
    }

    this.findCachedProgram = function(shader) {
        return false;
    }
});
Class(function TextureRendererMetal() {
    const _this = this;

    var _tempArray0 = [];
    var _tempArray1 = [];
    var _tempArray2 = [];

    //*** Event handlers

    //*** Public methods
    this.draw = function(texture, index, commandEncoder) {
        if (texture._metal === undefined || texture._metal.sampler === undefined || texture.needsReupload) this.upload(texture);
        else if (texture.dynamic || texture.needsUpdate) {
            if (texture.isDataTexture || texture.type.includes('float')) {
                if (texture.data) {
                    let region = Metal.device.makeRegion2D(0, 0, texture.width, texture.height);
                    texture._metal.subData(region, 0, texture.data, texture.width * 4 * 4);
                }
            }
            texture.needsUpdate = false;
        }

        if (index > -1) Metal.bindTexture(commandEncoder.key, texture._metal.key, texture._metal.sampler.key, index);
    }

    this.drawArray = function(array, index, commandEncoder) {
        _tempArray0.length = 0;
        _tempArray1.length = 0;
        _tempArray2.length = 0;
        for (let i = 0; i < array.length; i++) {
            let texture = array[i];
            if (texture._metal === undefined || texture._metal.sampler === undefined || texture.needsReupload) this.upload(texture);
            _tempArray0.push(texture._metal);
            _tempArray1.push(texture._metal.sampler);
        }
        _tempArray2[0] = index;
        _tempArray2[1] = index + array.length;
        commandEncoder.bindTextureArray(_tempArray0, _tempArray1, _tempArray2);
    }

    this.upload = this.uploadAsync =  function(texture) {
        if (!texture.needsReupload && !texture.needsUpdate) return;

        if (texture._metal === undefined) {
            texture._metal = Metal.device.makeTexture();

            if (texture.isDataTexture || texture.type.includes('float')) {
                if (!texture.width || !texture.height) throw `Must define data texture width and height`;
                texture.format = Texture.RGBAFormat;
                let descriptor = Metal.device.makeTextureDescriptor();
                descriptor.setTextureType('2d');
                descriptor.setPixelFormat(texture.format + texture.type);
                descriptor.setWidth(texture.width);
                descriptor.setHeight(texture.height);
                texture._metal.fromDescriptor(descriptor);

                let region = Metal.device.makeRegion2D(0, 0, texture.width, texture.height);
                texture._metal.subData(region, 0, texture.data, texture.width * 4 * 4);

            } else if (texture.compressed) {

                let descriptor = Metal.device.makeTextureDescriptor();
                descriptor.setTextureType('2d');
                descriptor.setPixelFormat('pvrtc');
                descriptor.setWidth(texture.image.sizes[0]);
                descriptor.setHeight(texture.image.sizes[0]);
                texture._metal.fromDescriptor(descriptor);

                let data = texture.image.compressedData;
                for (let i = 0; i < data.length; i++) {
                    let size = texture.image.sizes[i];
                    let region = Metal.device.makeRegion2D(0, 0, size, size);
                    texture._metal.subData(region, i, data[i], 0);
                }
                data.length = 0;

            } else if (texture.image) {
                texture._metal.upload(texture.image.backing, texture.generateMipmaps);
            } else if (texture.cube) {
                let descriptor = Metal.device.makeTextureDescriptor();
                descriptor.setPixelFormat(texture.format);
                descriptor.setTextureType('cube');
                descriptor.setWidth(texture.cube[0].width);
                descriptor.setHeight(texture.cube[0].hight);

                texture._metal.fromDescriptor(descriptor);

                let region = Metal.device.makeRegion2D(0, 0, texture.cube[0].width, texture.cube[0].height);
                for (let i = 0; i < texture.cube.length; i++) {
                    texture._metal.cubeData(region, i, texture.cube[i]._backing);
                }
            } else {
                texture._metal.makeEmpty();
            }
        }

        if (texture._metal.sampler === undefined) {
            let descriptor = Metal.device.makeSamplerDescriptor();
            descriptor.setMinFilter(texture.minFilter);
            descriptor.setMagFilter(texture.magFilter);
            if (texture.generateMipmaps) descriptor.setMipFilter(texture.minFilter);
            descriptor.setWrapping(texture.wrapS, texture.wrapT);
            texture._metal.sampler = Metal.device.makeSamplerState(descriptor);
        }
    }

    this.destroy = function(texture) {
        if (texture._metal) {
            texture._metal.dispose();
            texture._metal.sampler && texture._metal.sampler.dispose();
        }
        delete texture._metal;
    }
});
Class(function GLSLLinter() {
    Inherit(this, Component);
    const _this = this;

    this.convertMetal = Utils.query('compat');

    //*** Constructor
    (function () {
        if (Hydra.LOCAL) Thread.upload(metalGLSLLint);
    })();

    function metalGLSLLint({string, name}) {
        return;
        const bypassBody = ['vec3 color = calculatePBR', 'vec3 lColor = lightColor', 'color += lightPoint(', 'color += lightArea(', 'color += phong(', 'color += lightCone(', 'color += lightDirectional'];
        const bypassHead = ['void setupPBR(', 'void setupLight(', 'getCombinedColor', 'getPointLightColor', 'getAreaLightColor', 'getSpotLightColor', 'getDirectionalLightColor', 'getStandardColor'];

        let attributes = [];
        let uniforms = [];
        let varyings = [];
        let methods = [];

        string = string.split('\n');

        string.forEach((line, i) => {
            if (line.includes('attribute')) {
                attributes.push(line.split('attribute ')[1].split(' ')[1].replace(';', '').trim());
            }

            if (line.includes('varying')) {
                varyings.push(line.split('varying ')[1].split(' ')[1].replace(';', '').trim());
            }

            if (line.includes('uniform') && !line.includes('uniforms')) {
                if (!(line.includes('light') && line.includes('['))) uniforms.push(line.split('uniform ')[1].split(' ')[1].replace(';', '').trim());
            }

            if ((line.includes(') {') && !line.includes('main(')) && !line.includes('struct') && !line.includes(['if', 'for'])) {
                let method = line + '\n';
                let end = false;
                let index = i;
                while (!end) {
                    let nextLine = string[++index];
                    method += nextLine + '\n';
                    if (nextLine == '}' || nextLine == '};') end = true;
                }

                methods.push(method);
            }

            if ((line.slice(0, 3).includes(['vec', 'mat']) || line.slice(0, 5).includes('float')) && !line.includes('(')) {
                console.error(`GLSL Linter: Don't declare global variables. Must either be const or use a struct to pass data around`);
                console.error(line);
                console.log('-------');
            }
        });

        methods.forEach(method => {
            let header = method.slice(0, method.indexOf('{'));
            let body = method.slice(method.indexOf('{'));

            uniforms.forEach(u => {
                if (body.includes(u) && !header.includes(u)) {
                    if (body.includes(bypassBody) || header.includes(bypassHead)) return;
                    if (body.charAt(body.indexOf(u)-1) != ' ') return;
                    console.error(`GLSL Linter: Don't use uniforms from the global scope, they must be passed as a method parameter`);
                    console.error(name + ': ' + u);
                    console.error(method);
                    console.log('-------');
                }
            });

            varyings.forEach(u => {
                if (body.includes(u) && !header.includes(u)) {
                    if (body.includes(bypassBody) || header.includes(bypassHead)) return;
                    if (body.charAt(body.indexOf(u)-1) != ' ') return;
                    console.error(`GLSL Linter: Don't use varyings from the global scope, they must be passed as a method parameter`);
                    console.error(name + ': ' + u);
                    console.error(method);
                    console.log('-------');
                }
            });

            attributes.forEach(u => {
                if (body.includes(u) && !header.includes(u)) {
                    if (body.includes(bypassBody) || header.includes(bypassHead)) return;
                    if (body.charAt(body.indexOf(u)-1) != ' ') return;
                    console.error(`GLSL Linter: Don't use attributes from the global scope, they must be passed as a method parameter`);
                    console.error(name + ': ' + u);
                    console.error(method);
                    console.log('-------');
                }
            });

            if (method.includes(['texture(', 'texture2D', 'textureCube'])) {
                if (!method.includes(['Sampler*', 'tLTC', 'getData'])) {
                    console.warn(`GLSL Linter: Avoid texture samples outside of main(), they won't have mipmapping!`);
                    console.error(name, method);
                    console.log('-------');
                }
            }
        });

    }

    //*** Event handlers

    //*** Public methods
    this.lint = function(shader, vsCode, fsCode) {
        if (this.convertMetal) {
            if (Utils.query('log')) {
                shader._metal = {};
                require('MetalShaderConverter')(vsCode, fsCode, shader);
            }

            Thread.shared().metalGLSLLint({string: vsCode, name: shader.vsName + '.vs'});
            Thread.shared().metalGLSLLint({string: fsCode, name: shader.fsName + '.fs'});
        }
    }

}, 'static');
Module(function MetalShaderConverter() {

    const LIGHTS = ['getCombinedColor', 'getAreaLightColor', 'getDirectionalLightColor', 'getSpotLightColor', 'getPointLightColor'];
    const globalUniforms = ['projectionMatrix', 'viewMatrix', 'cameraPosition', 'resolution', 'time', 'timeScale'];
    const localUniforms = ['normalMatrix', 'modelMatrix', 'modelViewMatrix'];
    const globalLights = ['lightPos', 'lightColor', 'lightData', 'lightData2', 'lightData3', 'lightProperties'];

    function checkForMatch(array, str) {
        if (!str.length) return false;
        for (let i = 0; i < array.length; i++) {
            if (str.includes(array[i])) return true;
        }
        return false;
    }

    function isolateMain(string) {
        let split = string.split('void main() {')[1];
        let lastIndex = split.lastIndexOf('}');
        let amt = split.length - lastIndex;
        return split.slice(0, -amt);
    }

    function findIsolatedFunction(line, index) {
        let openParenth = 0;
        let closeParenth = 0;
        let isolated = '';
        for (let i = index; i < line.length; i++) {
            let char = line[i];
            isolated += char;
            if (char == '(') openParenth++;
            if (char == ')') closeParenth++;
            if (openParenth > 0 && openParenth == closeParenth) return isolated;
        }

    }

    function checkForMatchIdentical(array, str) {
        str = str.replace(';', '').replace('\n', '').replace(',', '').replace(' ', '').trim();
        if (str.includes('[')) str = str.split('[')[0];
        if (str.includes('-')) str = str.split('-')[1];
        if (str.includes('.')) str = str.split('.')[0];
        if (str.includes('*')) str = str.split('*')[0];
        for (let i = 0; i < array.length; i++) {
            let v = array[i];
            if (!v.includes(' ')) {
                if (v == str) return true;
            } else {
                let word = v.split(' ')[1];
                if (!word) continue;
                word = word.replace(';', '').replace(' ', '');
                if (word.includes('[')) word = word.split('[')[0];
                if (word == str) return true;
            }
        };
        return false;
    }

    function deconstruct(string) {
        let split = string.split(' ');
        let name = split[split.length-1].replace(';', '');
        let type = split[0].replace(/ /g, '');
        return {name, type};
    }

    function getSamplerString(array, types) {
        if (!array.length) return '';
        let str = ',\n';
        let added = [];
        array.forEach((name, i) => {
            if (name.includes('[')) {
                if (added.indexOf(name) == -1) {
                    added.push(name);
                    let split = name.split('[');
                    let label = split[0];
                    let count = split[1].split(']')[0];
                    str += `array<texture2d<float>, ${count}> ${label} [[ texture(${i}) ]],\n`;
                    str += `array<sampler, ${count}> ${label}Sampler [[ sampler(${i}) ]],\n`;
                }
            } else {
                let type = types && types[i] ? types[i].toLowerCase().replace('sampler', 'texture') : 'texture2d';
                str += `${type}<float> ${name} [[ texture(${i}) ]],\n`;
                str += `sampler ${name}Sampler [[ sampler(${i}) ]],\n`
            }
        });
        return str.slice(0, -2);
    }

    function customFragment(string, fs) {
        if (string.includes('getShadow') && fs.includes('#define SHADOW_MAP')) {
            let index = string.indexOf('getShadow');
            let isolated = findIsolatedFunction(string, index);
            let params = isolated.split('(')[1].split(')')[0].split(',');
            params.push('uniforms', 'globalUniforms', 'shadowMap[0]');
            string = string.replace(isolated, `getShadow(${params.join(',')})`);
        }

        if (string.includes('getPBR')) {
            let inputParams = 'globalUniforms.cameraPosition, globalUniforms.viewMatrix, vUv, inFrag.vNormal, inFrag.vMPos, uniforms.uEnv, uniforms.uMRO, uniforms.uNormalScale, uniforms.uHDR, uniforms.uLight, tBaseColor, tBaseColorSampler, tMRO, tMROSampler, tNormal, tNormalSampler, tLUT, tLUTSampler, tEnvDiffuse, tEnvDiffuseSampler, tEnvSpecular, tEnvSpecularSampler';
            let params = string.split('getPBR(')[1].split(')')[0].trim();
            let origin = 'getPBR' + string.split('getPBR')[1].split(')')[0] + ')';
            let output = `getPBR(${params} ${params.length ? ',' : ''} ${inputParams})`;
            string = string.replace(origin, output);
        }

        if (string.includes(LIGHTS)) {


            LIGHTS.forEach(name => {
                if (string.includes(name)) {
                    let inputParams = 'lights, inFrag.vPos, inFrag.vWorldPos, inFrag.vViewDir, uniforms.modelViewMatrix, globalUniforms.viewMatrix';
                    if (name.includes(['getCombinedColor', 'getAreaLightColor'])) inputParams += ', tLTC1, tLTC2';
                    let params = string.split(`${name}(`)[1].split(')')[0].trim();
                    let origin = name + string.split(name)[1].split(')')[0] + ')';
                    let output = `${name}(${params} ${params.length ? ',' : 'inFrag.vNormal,'} ${inputParams})`;
                    string = string.replace(origin, output);
                }
            });
        }
        return string;
    }

    function getSamplerCompute(array) {
        let str = ',\n';
        let added = [];
        array.forEach((name, i) => {
            str += `texture2d<float, access::read> ${name} [[ texture(${i}) ]],\n`;
        });

        str += `texture2d<float, access::write> tOut [[ texture(${array.length}) ]],\n`;

        return str;
    }

    function getDefinedMethods(string) {
        let out = '';
        if (string.includes('inversesqrt')) {
            out += `float inversesqrt(float num) {
                return 1.0 / sqrt(num);
            }\n`
        }

        if (string.includes('degrees(')) {
            out += `float degrees(float r) {
                return r * (180.0 / 3.14159265359);
            }
            
            vec2 degrees(vec2 r) {
                vec2 op;
                op.x = r.x * (180.0 / 3.14159265359);
                op.y = r.y * (180.0 / 3.14159265359);
                return op;
            }
            
            vec3 degrees(vec3 r) {
                vec3 op;
                op.x = r.x * (180.0 / 3.14159265359);
                op.y = r.y * (180.0 / 3.14159265359);
                op.z = r.z * (180.0 / 3.14159265359);
                return op;
            }\n`;
        }

        if (string.includes('radians(')) {
            out += `float radians(float d) {
                return d * (3.14159265359 / 180.0);
            }
            
            vec2 radians(vec2 d) {
                vec2 op;
                op.x = d.x * (3.14159265359 / 180.0);
                op.y = d.y * (3.14159265359 / 180.0);
                return op;
            }
            
            vec2 radians(vec3 d) {
                vec3 op;
                op.x = d.x * (3.14159265359 / 180.0);
                op.y = d.y * (3.14159265359 / 180.0);
                op.z = d.z * (3.14159265359 / 180.0);
                return op;
            }\n`;
        }

        return out;
    }

    function findUV(string) {
        string = string.replace(/ /g, '').slice(string.indexOf(',')+1);
        return string.slice(0, string.lastIndexOf(')')).replace(/,/g, ', ');
    }

    function replaceSampler(string, sampler) {
        let samplerMatch = ['texture2D', 'texture3D', 'textureCube'];
        if (!string.includes(samplerMatch)) return string;
        let lines = string.split('\n');
        lines.forEach((line, i) => {
            if (line.includes(samplerMatch)) {
                let half = line.split('=');
                let condensed = line.replace(/ /g, '');
                let index = line.indexOf('texture');
                let isolated = findIsolatedFunction(line, index);
                let uv = findUV(isolated);
                let components = isolated.replace(')', '').replace(';', '').split('(')[1].split(',');
                if (!sampler) sampler = `${components[0]}Sampler`;

                if (line.includes('[')) {
                    let split = components[0].split('[');
                    let name = split[0];
                    let count = split[1].split(']')[0];
                    lines[i] = line.replace(isolated, `${name}[${count}].sample(${name}Sampler[${count}], ${uv})`);
                } else {
                    lines[i] = line.replace(isolated, `${components[0]}.sample(${sampler}, ${uv})`)
                }
            }
        });
        return lines.join('\n');
    }

    function replaceSamplerCompute(string) {
        let lines = string.split('\n');
        let samplerMatch = ['texture2D', 'texture3D', 'textureCube'];
        lines.forEach((line, i) => {
            if (line.includes(samplerMatch)) {
                let half = line.split('=');
                line = line.replace(/ /g, '');
                let components = line.replace(')', '').replace(';', '').split('(')[1].split(',');
                lines[i] = `${half[0]} = ${components[0]}.read(${components[1]});\n`;
            }
        });
        return lines.join('\n');
    }

    function inlineMain(vs) {
        let split = vs.split('inlinemain');
        let fn = split[0].split('\n').pop().split(' ')[1].split('(')[0].replace(' ', '');
        let code = split[1].split('}')[0];

        let main = vs.split('void main() {')[1].split('\n');
        main.forEach(line => {
            if (line.includes(fn)) {
                let params = line.split('(')[1].split(')')[0].replace(' ', '').split(',');
                code = code.replace(/p0/g, params[0]);
                if (params[1]) code = code.replace(/p1/g, params[1]);
                if (params[2]) code = code.replace(/p2/g, params[2]);
                vs = vs.replace(line, code);
            }
        });

        return vs;
    }

    function wrapMethod(string) {
        if (string.includes('sampler2D')) string = string.replace(/sampler2D/g, 'texture2d<float>');
        if (string.includes('sampler3D')) string = string.replace(/sampler3D/g, 'texture3d<float>');
        if (string.includes('samplerCube')) string = string.replace(/samplerCube/g, 'texturecube<float>');
        if (string.includes('texture')) {
            string = replaceSampler(string, 'defaultSampler');
            let sIndex = string.indexOf('{')+1;
            let pre = string.slice(0, sIndex);
            let post = string.slice(sIndex);
            string = pre + '\n constexpr sampler defaultSampler;\n' + post;
        }
        return string;
    }

    function fixUndeclaredUniformsVaryings(src, methods, uniforms, varyings, attributes) {
        //TODO: Deal with functions that already take [uva] as a parameter

        let combined = [...uniforms, ...varyings, ...attributes];

        let uniforms2 = [
            ...uniforms.map(string => string.split(' ')[1].replace(';', '')),
            ...varyings.map(string => string.split(' ')[1].replace(';', '')),
            ...attributes.map(string => string.split(' ')[1].replace(';', ''))
        ];

        const getType = str => {
            for (let i = 0; i < combined.length; i++) {
                let a = combined[i];
                if (a.includes(str)) {
                    return a.replace(';', '');
                }
            }

            return str;
        };

        const prepend = str => {
            for (let i = 0; i < uniforms.length; i++) {
                if (uniforms[i].includes(str)) {
                    return 'uniforms.' + str;
                }
            }

            for (let i = 0; i < varyings.length; i++) {
                if (varyings[i].includes(str)) {
                    return 'inFrag.' + str;
                }
            }

            for (let i = 0; i < attributes.length; i++) {
                if (attributes[i].includes(str)) {
                    return `VertexIn${str.capitalize()}.` + str;
                }
            }

            return str;
        };

        let vs = src.split('VertexOut out;')[1].split('return out;')[0];
        let fs = src.split('float4 gl_FragColor;\n')[1].split('return gl_FragColor;')[0];

        let fs2 = fs;
        let vs2 = vs;

        let omethods = methods;
        let methods2 = methods;
        while (methods2.includes('{')) {
            let [declaration, body] = methods2.split('{');
            declaration = declaration.split('\n');
            declaration = declaration[declaration.length-1];
            let params = declaration.split('(')[1].split(')')[0];
            body = body.split('}')[0];
            if (params.includes(',')) params = params.split(',');
            else params = [params];

            if (params[0] == '') params.splice(0, 1);

            uniforms2.forEach((u, i) => {
                if (body.includes(u) && !declaration.includes(u)) {
                    params.push(getType(uniforms2[i]).replace(';', ''));
                    let split = declaration.trim().split(' ');
                    let name;
                    split.forEach(s => {
                        if (s.includes('(')) name = s.split('(')[0];
                    });

                    if (fs2.includes(name)) {
                        let startIndex = fs2.indexOf(name);
                        let str = fs2.substr(startIndex, name.length + fs2.split(name)[1].indexOf(')')+1);
                        let split = str.replace(/ /g, '').split(',');
                        let call = split[0].substr(str.indexOf('(')+1, str.lastIndexOf(')')).split(',');
                        if (call[0] == '' || call[0] == ')') call.shift();
                        call.push(u);

                        let prevent = false;
                        for (let i = 0; i < call.length; i++) {
                            if (call[i].includes(u)) prevent = true;
                        }

                        call.forEach((c, i) => {
                            if (c.includes(')') && !c.includes('vec') && !c.includes('mat')) {
                                call[i] = c.replace(')', '');
                            }
                        });

                        let replace = str.split('(')[0] + '(' + call.map(prepend).join(',') + (call.length == 1 ? ')' : '') + (split[1] ? ',' + split[1] : '');

                        if (!replace.includes(')')) replace += ')';
                        replace += (split[1] ? ',' + split[1] : '');
                        fs2 = fs2.replace(str, replace);
                    }
                }
            });

            let declaration2 = declaration.split('(')[0] + '(' + params.join(',') + ') ';
            methods = methods.replace(declaration, declaration2);

            methods2 = methods2.replace('{', '^');
        }

        src = src.replace(fs, fs2);
        src = src.replace(omethods, methods);

        return src;
    }

    this.exports = function(vs, fs, shader) {
        let attributes = [];
        let uniforms = [];
        let varyings = [];
        let samplers = [];
        let samplerTypes = [];

        const hasLights = fs.includes('NUM_LIGHTS') ? fs.split('NUM_LIGHTS ')[1].split('\n')[0] : false;

        // if (shader.compute) console.log(fs);

        if (vs.includes('inlinemain')) vs = inlineMain(vs);

        function customOverride(string) {
            if (string.includes(' and(')) string = string.replace(/ and\(/g, ' _and(');
            if (string.includes(' or(')) string = string.replace(/ or\(/g, ' _or(');

            if (string.includes('getPBR')) {
                string = string.replace(/\/\*/g, '');
                string = string.replace(/\*\//g, '');
                samplers.forEach(name => {
                    string = string.replace(new RegExp(name + '\\.sample\\(defaultSampler', 'g'), name + '.sample(' + name + 'Sampler');
                });
                let inputParams = 'vec3 cameraPosition, mat4 viewMatrix, vec2 vUv, vec3 vNormal, vec3 vMPos, float2 uEnv, float3 uMRO, float2 uNormalScale, float uHDR, float4 uLight, texture2d<float> tBaseColor, sampler tBaseColorSampler, texture2d<float> tMRO, sampler tMROSampler, texture2d<float> tNormal, sampler tNormalSampler, texture2d<float> tLUT, sampler tLUTSampler, texture2d<float> tEnvDiffuse, sampler tEnvDiffuseSampler, texture2d<float> tEnvSpecular, sampler tEnvSpecularSampler';

                string = string.split('\n');
                string.forEach((line, i) => {
                    if (line.includes('vec4 getPBR(')) {
                        line = line.split(')')[0];
                        line += ', ' + inputParams + ') {\n';
                        string[i] = line.replace('(,', '(');
                    }
                });
                string = string.join('\n');
                string = string.replace('getNormal(uNormalScale, tNormal, vUv, vNormal, vMPos)', 'getNormal(uNormalScale, tNormal, tNormalSampler, vUv, vNormal, vMPos)');
            }

            if (string.includes('getAreaLight')) {
                string = string.replace(/config.normal = vNormal;/g, '');
                string = string.replace('normalize( uniforms.normalMatrix * p1 );', 'normalize( uniforms.normalMatrix * inNormal.normal.xyz );');

                string = string.replace(/LightConfig config, vec3 vPos/g, 'LightConfig config, Lights lights, vec3 vPos');
                string = string.replace(/config, vPos/g, 'config, lights, vPos');
                string = string.replace(/vec3 normal, vec3 vPos/g, 'vec3 normal, Lights lights, vec3 vPos');

                string = string.replace(/lightColor\[i\]/g, 'lights.lightColor[i]');
                string = string.replace(/lightPos\[i\]/g, 'lights.lightPos[i]');
                string = string.replace(/lightData\[i\]/g, 'lights.lightData[i]');
                string = string.replace(/lightData2\[i\]/g, 'lights.lightData2[i]');
                string = string.replace(/lightData3\[i\]/g, 'lights.lightData3[i]');
                string = string.replace(/lightProperties\[i\]/g, 'lights.lightProperties[i]');
            }

            return string;
        }

        let getAttribComponents = str => {
            for (let i = 0; i < attributes.length; i++) {
                let val = attributes[i];
                if (val.includes(str)) {
                    let {type, name} = deconstruct(val);
                    switch (type) {
                        case 'float': case 'int': return ''; break;
                        case 'float2': case 'vec2': case 'int2': return '.xy'; break;
                        case 'float3': case 'vec3': case 'int3': return '.xyz'; break;
                        case 'float4': case 'vec4': case 'int4': return '.xyzw'; break;
                    }
                }
            }
        }

        let replaceVertex = string => {
            string = replaceSampler(string);
            string = string.replace(/gl_PointSize/g, 'out.pointSize');
            string = string.replace(/\(/g, '( ').replace(/\)/g, ' )');
            let split = string.split(' ');
            split.forEach((w, i) => {
                if (checkForMatchIdentical(globalUniforms, w)) split[i] = split[i].replace(w, 'globalUniforms.' + w);
                if (checkForMatchIdentical(localUniforms, w) || checkForMatchIdentical(uniforms, w)) split[i] = split[i].replace(w, 'uniforms.' + w);
                if (checkForMatchIdentical(varyings, w) || checkForMatch(varyings, w)) split[i] = split[i].replace(w, 'out.' + w);
                if (checkForMatchIdentical(attributes, w)) {
                    let swizzle;
                    if (w.includes('.')) {
                        let split = w.split('.');
                        swizzle = '.' + split[1];
                        w = split[0];
                    }
                    let w2 = w.replace(';', '').replace(',', '').replace('\n', '').trim();
                    split[i] = w.replace(w2, `in${w2.capitalize()}.${w2}${swizzle || getAttribComponents(w2)}`);
                }
            });
            return split.join(' ');
        };

        let replaceFragment = (string, compute) => {
            string = string.replace(/return;/g, 'return gl_FragColor;');
            string = compute ? replaceSamplerCompute(string) : replaceSampler(string);
            string = string.replace(/\(/g, '( ').replace(/\)/g, ' )');
            let split = string.split(' ');
            split.forEach((w, i) => {
                if (hasLights && checkForMatchIdentical(globalLights, w)) split[i] = split[i].replace(w, 'lights.' + w);
                if (checkForMatchIdentical(globalUniforms, w)) split[i] = split[i].replace(w, 'globalUniforms.' + w);
                if (checkForMatchIdentical(localUniforms, w) || checkForMatchIdentical(uniforms, w)) split[i] = split[i].replace(w, 'uniforms.' + w);
                if (!shader.compute && checkForMatchIdentical(varyings, w) && !w.includes('vUv')) split[i] = split[i].replace(w, 'inFrag.' + w);
            });
            return customFragment(split.join(' '), fs);
        };

        let replaceFragmentMultiRT = string => {
            string = replaceFragment(string);
            while (string.includes('gl_FragData')) {
                let num = Number(string.split('gl_FragData[')[1].split(']')[0]);
                string = string.replace(`gl_FragData[${num}]`, `out.color${num}`);
            }
            return string;
        };

        let multiRenderTarget = (function() {
            if (!fs.includes('gl_FragData')) return false;

            let count = 0;
            let tmp = fs.split('void main()')[1];
            while (tmp.includes('gl_FragData')) {
                let num = tmp.split('gl_FragData[')[1].split(']')[0];
                count = Math.max(count, Number(num)+1);
                tmp = tmp.replace('gl_FragData', '%');
            }

            return count;
        })();

        let isInstanced = vs.includes(['attribute vec3 offset', 'transformPosition', 'getUVFromIndex']);

        let getIDType = function(key) {
            if (isInstanced && key.includes(['offset', 'orientation', 'quaternion', 'rotation', 'scale', 'random', 'cNumber'])) return 'iid';
            return 'vid';
        }

        let definedMethods = getDefinedMethods(vs + fs);

        vs = vs.split('\n');
        fs = fs.split('\n');

        let constants = '';
        let methods = '';

        vs.forEach((line, i) => {
            if (line.includes('precision')) vs[i] = '';

            if (line.includes('attribute')) {
                attributes.push(line.split('attribute ')[1].trim());
                vs[i] = '';
            }

            if (line.includes('varying')) {
                varyings.push(line.split('varying ')[1].trim());
                vs[i] = '';
            }

            if (line.includes('uniform') && !line.includes('uniforms')) {
                if (!checkForMatch(globalUniforms, line) && !checkForMatch(localUniforms, line)) {
                    if (line.includes('sampler')) {
                        if (!checkForMatch(samplers, line.split(')')[0])) {
                            if (line.includes('[')) {
                                let count = Number(line.split('[')[1].split(']')[0]);
                                for (let i = 0; i < count; i++) {
                                    samplers.push(line.split('sampler2D ')[1].replace(';', ''));
                                    samplerTypes.push('sampler2D');
                                }
                            } else {
                                let keyWord = line.includes('Cube') ? 'samplerCube' : 'sampler2D';
                                samplers.push(line.split(keyWord+' ')[1].replace(';', ''));
                                samplerTypes.push(keyWord);
                            }
                        }
                    }
                    else {
                        if (!(line.includes('light') && line.includes('['))) uniforms.push(line.split('uniform ')[1]);
                    }
                }
                vs[i] = '';
            }

            if ((line.includes([') {', '){']) && !line.includes(['main(', 'if (', 'for (', 'for(', 'if('])) || line.includes('struct')) {
                let method = line + '\n';
                let end = false;
                let index = i;
                while (!end) {
                    let nextLine = vs[++index];
                    let checkLine = nextLine.trim();
                    method += nextLine + '\n';
                    if (checkLine == '}' || checkLine == '};') end = true;
                }

                if (!method.includes('inlinemain')) {
                    methods += wrapMethod(method) + '\n';
                }
            }

            if (line.slice(0, 5) == 'const') {
                if (line.includes('=')) {
                    constants += line.replace('const', 'constant') + '\n';
                }
            }

            if (line.includes('#define') && !constants.includes(line)) constants += line+'\n';
        });

        fs.forEach((line, i) => {
            if (line.includes('precision')) fs[i] = '';
            if (line.includes('varying')) fs[i] = '';

            if (line.includes('uniform') && !line.includes('uniforms')) {
                if (!checkForMatch(uniforms, line) && !checkForMatch(globalUniforms, line) && !checkForMatch(localUniforms, line)) {
                    if (line.includes('sampler')) {
                        if (!checkForMatch(samplers, line)) {
                            if (line.includes('[')) {
                                let count = Number(line.split('[')[1].split(']')[0]);
                                for (let i = 0; i < count; i++) samplers.push(line.split('sampler2D ')[1].replace(';', ''));
                            } else {
                                samplers.push(line.split('sampler2D ')[1].replace(';', ''));
                            }
                        }
                    }
                    else {
                        let uni = line.split('uniform ')[1];
                        if (uni && !(line.includes('light') && line.includes('['))) uniforms.push(uni);
                    }
                }
                fs[i] = '';
            }

            if ((line.includes([') {', '){']) && !line.includes(['main(', 'if (', 'for (', 'for(', 'if('])) || line.includes('struct')) {
                let method = line + '\n';

                let end = false;
                let index = i;
                while (!end) {
                    let nextLine = fs[++index];
                    let checkLine = nextLine.trim();
                    method += nextLine + '\n';
                    if (checkLine == '}' || checkLine == '};') end = true;
                }

                if (!methods.includes(method)) {
                    methods += wrapMethod(method) + '\n';
                }
            }

            if (line.slice(0, 5) == 'const') {
                if (line.includes('=')) {
                    constants += line.replace('const', 'constant') + '\n';
                }
            }

            if (line.includes('#define') && !constants.includes(line)) constants += line+'\n';
        });

        let src = '#include <metal_stdlib>\n';
        src += 'using namespace metal;\n';

        src += `struct GlobalUniforms {
            mat4 projectionMatrix;
            mat4 viewMatrix;
            vec3 cameraPosition;
            vec2 resolution;
            float time;
            float timeScale;
        };\n`;

        src += 'struct Uniforms {\n';
        src += 'mat3 normalMatrix;\n';
        src += 'mat4 modelMatrix;\n';
        src += 'mat4 modelViewMatrix;\n';
        uniforms.forEach(u => src += u + '\n');
        src += '};\n';

        src += definedMethods;

        src += constants;

        if (!shader.compute) {
            shader._metal.attributes = {};
            attributes.forEach((attr, i) => {
                let {type, name} = deconstruct(attr);
                shader._metal.attributes[name] = i;
                let packed = type == 'vec3' ? 'packed_' : '';
                src += `
            struct VertexIn${name.capitalize()} {
                ${packed}${type} ${name};
            };\n`;
            });
        }

        if (hasLights) {
            src += `struct Lights {
                vec4 lightPos[${hasLights}];
                vec4 lightColor[${hasLights}];
                vec4 lightData[${hasLights}];
                vec4 lightData2[${hasLights}];
                vec4 lightData3[${hasLights}];
                vec4 lightProperties[${hasLights}];
            };\n`;
        }

        let bufferIndex = shader.compute ? 0 : attributes.length;
        let globalUniformIndex = bufferIndex++;
        let uniformIndex = bufferIndex++;

        let samplerString = shader.compute ? getSamplerCompute(samplers) : getSamplerString(samplers, samplerTypes);

        vs = vs.join('\n');
        fs = fs.join('\n');

        src += methods;

        if (!shader.compute) {
            src += 'struct VertexOut {\n';
            src += 'float2 FragCoord;\n';
            varyings.forEach(v => {
                src += v + '\n';
            });
            src += 'float4 pos [[position]];\n';
            if (vs.includes('gl_PointSize')) src += 'float pointSize [[point_size]];\n';
            src += '};\n';

            src += 'vertex VertexOut vertexShader(\n';
            for (let key in shader._metal.attributes) {
                src += `const device VertexIn${key.capitalize()} *${key}Array [[buffer(${shader._metal.attributes[key]})]],\n`;
            }
            src += `constant GlobalUniforms &globalUniforms [[buffer(${globalUniformIndex})]],\n`;
            src += `constant Uniforms &uniforms [[buffer(${uniformIndex})]],\n`;
            src += 'unsigned int vid [[vertex_id]]\n';
            if (isInstanced) src += ', unsigned int iid [[instance_id]]\n';
            src += samplerString;
            src += ') {\n';

            for (let key in shader._metal.attributes) {
                src += `VertexIn${key.capitalize()} in${key.capitalize()} = ${key}Array[${getIDType(key)}];\n`;
            }

            src += 'VertexOut out;\n';
            src += replaceVertex(isolateMain(vs));
            src += 'out.pos.z = (out.pos.z + out.pos.w) / 2.0f;\n';
            src += 'out.FragCoord = ((out.pos.xyz / out.pos.w) * 0.5 + 0.5).xy;\n';
            src += 'return out;\n';
            src += '}\n';
        }

        if (multiRenderTarget) {
            src += 'struct FragmentOut {\n';
            for (let i = 0; i < multiRenderTarget; i++) {
                src += `float4 color${i} [[ color(${i}) ]];\n`;
            }
            src += '};\n';
        }

        if (shader.compute) {
            src += 'kernel void computeShader(\n';
        } else {
            src += `fragment ${multiRenderTarget ? 'FragmentOut' : 'float4'} fragmentShader(VertexOut inFrag [[stage_in]],\n`;
        }

        src += `constant GlobalUniforms &globalUniforms [[buffer(0)]],\n`;
        src += `constant Uniforms &uniforms [[buffer(1)]]\n`;
        if (hasLights) src += `, constant Lights &lights [[buffer(2)]]\n`;
        src += samplerString;

        if (shader.compute) src += 'uint2 vUv [[ thread_position_in_grid ]]\n';

        src += ') {\n';

        if (fs.includes('gl_FragCoord')) {
            src += 'vec2 gl_FragCoord = inFrag.FragCoord.xy;\n';
            src += 'gl_FragCoord.x *= globalUniforms.resolution.x;\n';
            src += 'gl_FragCoord.y = (1.0 - gl_FragCoord.y) * globalUniforms.resolution.y;\n';
        }

        if (fs.includes('vUv')) {
            src += `vec2 vUv = inFrag.vUv.xy;\n`;
            if (!fs.includes('NO_UV_FLIP')) src += `vUv.y = 1.0 - vUv.y;\n`;
        }

        if (!multiRenderTarget) {
            src += 'float4 gl_FragColor;\n';
            src += replaceFragment(isolateMain(fs), shader.compute);
            if (shader.compute) src += 'tOut.write(gl_FragColor, vUv);\n';
            else src += 'return gl_FragColor;\n';
        } else {
            src += 'FragmentOut out;\n';
            src += replaceFragmentMultiRT(isolateMain(fs));
            src += 'return out;\n'
        }

        src += '}\n';

        if (src.includes(['( inout', '(inout'])) throw 'MetalShaderConverter :: Cannot convert inout';

        src = customOverride(src);
        src = fixUndeclaredUniformsVaryings(src, methods, uniforms, varyings, attributes);

        src = src.replace(/gl_Position/g, 'out.pos');
        src = src.replace(/vec2/g, 'float2');
        src = src.replace(/vec3/g, 'float3');
        src = src.replace(/vec4/g, 'float4');
        src = src.replace(/mat3/g, 'float3x3');
        src = src.replace(/mat4/g, 'float4x4');
        src = src.replace(/mod\(/g, 'fmod(');
        src = src.replace(/atan\(/g, 'atan2(');
        src = src.replace(/highp/g, '');
        src = src.replace(/mediump/g, '');
        src = src.replace(/lowp/g, '');
        src = src.replace(/\(in /g, '(');
        src = src.replace(/ in /g, '');
        src = src.replace(/ out /g, '');
        src = src.replace(/\(out /g, '(');
        src = src.replace(/#pragma unroll_loop/g, '');
        src = src.replace(/dFdx/g, 'dfdx');
        src = src.replace(/dFdy/g, 'dfdy');
        src = src.replace(/discard;/g, 'discard_fragment();');

        if (!Device.mobile) console.log(shader.vsName, src);

        shader._metal.uniforms = uniforms.map(m => m.replace(';', ''));
        shader._metal.samplers = samplers.map(m => m.replace(';', '').split('[')[0]);
        return src;
    }
});
class MetalUBO {
    constructor() {
        this.arrays = [];
        for (let i = 0; i < 30; i++) this.arrays.push([]);
        this.arrayIndex = 0;

        this.list = [];
        this.objects = [];
        this.data = null;
    }

    _getSize(uniform) {
        let obj = uniform.value;
        if (Array.isArray(obj)) {
            if (uniform.components) return (obj.length/uniform.components) * 16;
            return obj.length * 16;
        }
        if (obj instanceof Vector2) return 8;
        if (obj instanceof Vector3) return 16;
        if (obj instanceof Vector4) return 16;
        if (obj instanceof Color) return 16;
        if (obj instanceof Matrix4) return 16*4;
        if (obj instanceof Matrix3) return 16*3;
        if (obj instanceof Quaternion) return 16;
        return 4;
    }

    _getValues(uniform) {
        let obj = uniform.value;
        if (Array.isArray(obj)) return this._padArray(obj, uniform.type);
        if (obj instanceof Vector2) return this._array(obj.x, obj.y);
        if (obj instanceof Vector3) return this._array(obj.x, obj.y, obj.z);
        if (obj instanceof Vector4) return this._array(obj.x, obj.y, obj.z, obj.w);
        if (obj instanceof Matrix4) return obj.elements;
        if (obj instanceof Matrix3) return this._padMatrix3(obj.elements);
        if (obj instanceof Color) return this._array(obj.r, obj.g, obj.b);
        if (obj instanceof Quaternion) return this._array(obj.x, obj.y, obj.z, obj.w);
        return this._array(obj);
    }

    _padArray(elements, type) {
        if (type == 'v4v' || type == 'm4v' || type == 'fv') return elements;

        let array = this._array();
        let components, pad;

        if (type == 'v3v') {
            components = 3;
            pad = 1;
        } else if (type == 'v2v') {
            components = 2;
            pad = 2;
        } else if (type == 'fv') {
            components = 1;
            pad = 0;
        }

        let count = elements.length / components;
        for (let i = 0; i < count; i++) {
            for (let j = 0; j < components; j++) {
                array.push(elements[i * components + j]);
            }
            if (i < count-1) for (let j = 0; j < pad; j++) {
                array.push(0);
            }
        }

        return array;
    }

    _padMatrix3(elements) {
        let array = this._array(0);
        array[0] = elements[0];
        array[1] = elements[1];
        array[2] = elements[2];
        array[3] = 0;
        array[4] = elements[3];
        array[5] = elements[4];
        array[6] = elements[5];
        array[7] = 0;
        array[8] = elements[6];
        array[9] = elements[7];
        array[10] = elements[8];
        return array;
    }

    _array() {
        if (this.arrayIndex++ >= this.arrays.length-1) this.arrayIndex = 0;
        let array = this.arrays[this.arrayIndex];
        array.length = 0;
        array.push.apply(array, arguments);
        return array;
    }

    clear() {
        for (let i = 0; i < this.arrays.length; i++) this.arrays[i].length = 0;
    }

    calculate() {
        let len = this.objects.length;

        let chunk = 16;
        let tsize = 0;
        let offset = 0;
        let size = 0;

        for (let i = 0; i < len; i++) {
            let obj = this.objects[i];
            size = this._getSize(obj);

            tsize = chunk - size;

            if (tsize < 0 && chunk < 16) {
                offset += chunk;
                if (i > 0) this.objects[i-1].chunkLen += chunk;
                chunk = 16;
            } else if (tsize < 0 && chunk == 16) {

            } else if (tsize == 0) {
                chunk = 16;
            } else {
                chunk -= size;
            }

            obj.offset = offset / 4;
            obj.chunkLen = size / 4;
            obj.dataLen = size / 4;

            offset += size;
        }

        if (offset % 16 != 0) {
            this.objects[this.objects.length-1].chunkLen += chunk / 4;
            offset += chunk;
        }

        return offset / 4;
    }

    compileData() {
        let array = this._array();
        let len = this.calculate();

        let i;

        for (i = 0; i < len; i++) array[i] = 0;

        for (i = 0; i < this.objects.length; i++) {
            let obj = this.objects[i];
            let values = this._getValues(obj);

            for (let j = 0; j < values.length; j++) {
                array[obj.offset + j] = values[j];
            }
        }

        return array;
    }

    upload() {
        if (this.data) return;

        let array = this.compileData();
        if (!array.length) return;

        this.data = new Float32Array(array);
        this.buffer = Metal.device.makeBuffer(this.data, this.data.byteLength);
    }

    update() {
        if (!this.data) this.upload();

        let array = this.compileData();

        this.data.set(array);
        this.buffer.subData(this.data, this.data.byteLength);

        this.needsUpdate = false;
    }

    set(name, uniform) {
        let index = this.list.indexOf(name);
        if (index > -1) {
            this.objects[index] = uniform;
        } else {
            this.list.push(name);
            this.objects.push(uniform);
        }

        if (this.data) {
            this.data = null;
            this.upload();
        }
    }

    get(name) {
        return this.objects[this.list.indexOf(name)];
    }

    push() {
        for (let i = 0; i < arguments.length; i++) {
            this.objects.push(arguments[i]);
        }

        if (this.data) {
            this.data = null;
            this.upload();
        }
    }

    destroy() {
        if (this.buffer) {
            this.buffer.dispose();
            this.buffer = null;
        }
    }

    addShadowUniforms(obj) {
        this.defaultUniforms = {};
        this.shadowUniforms = {};

        for (let key in obj) {
            this.defaultUniforms[key] = this.get(key);
            this.shadowUniforms[key] = obj[key];
        }
    }

    useShadowUniforms() {
        for (let key in this.shadowUniforms) {
            this.set(key, this.shadowUniforms[key]);
        }
        this.update();
    }

    useDefaultUniforms() {
        for (let key in this.defaultUniforms) {
            this.set(key, this.defaultUniforms[key]);
        }
    }
}
Class(function Performance() {
    Inherit(this, Component);
    const _this = this;

    var _overrides = Storage.get('performance_override') || {};
    const PLATFORM_ALLOWED_KEYS = [
        'desktopVRAvailable',
        'enableWorldNukeMSAA',
        'msaaSamples',
        'forceWebGL1',
        'blurFX'
    ];

    (async function() {
        if ((Utils.query('performance') && Utils.query('edit')) || Utils.query('custom')) {
            await Hydra.ready();
            for (let key in _overrides) {
                let override = _overrides[key];
                let obj, value;
                if (!override?.obj) {
                    obj = 'Tests';
                    value = override;
                } else {
                    ({ obj, value } = override);
                }
                if (window[obj]) window[obj][key] = _ => value;
            }
        }
    })();

    function save(obj, key, value) {
        _overrides[key] = { obj: Utils.getConstructorName(obj), value };
        Storage.set('performance_override', _overrides);
    }

    function convert(tier) {
        if (GPU.BLOCKLIST) return 'F';
        switch (tier) {
            case 5: return 'A++'; break;
            case 4: return 'A+'; break;
            case 3: return 'A'; break;
            case 2: return 'B'; break;
            case 1: return 'C'; break;
            case 0: return 'D'; break;
        }
    }

    //*** Event handlers

    //*** Public methods
    this.displayResults = async function() {
        let editing = Utils.query('edit');

        await GPU.ready();
        __body.bg('#000');
        Stage.bg('#000');

        let $results = __body.create('PerformanceResults');
        __body.css({overflowY: 'scroll', background: '#000' });
        $results.fontStyle('Arial', 16, '#fff').css({marginLeft: 50, marginRight: 50, 'user-select': 'auto'});

        Mobile.allowNativeScroll();

        HydraCSS.style('.PerformanceResults *', {position: 'relative', 'user-select': 'auto'});

        let code = Tests.constructor.toString();
        let tests = '';
        let keys = [];
        let addTest = (obj, key) => {
            let result = obj[key]();
            tests += `<p><b>${key}:</b> `;

            if (editing) {
                if (typeof result === 'number') {
                    tests += `<input class="${key}" value="${result.toString()}" /></p>`;
                } else if (typeof result === 'boolean') {
                    tests += `<input class="${key}" type="checkbox" ${result ? 'checked' : ''}/></p>`;
                } else {
                    tests += `<input class="${key}" value="${result}" type="text"></p>`;
                }
            } else {
                tests += result + '</p>';
            }
            keys.push({ obj, key });
        };
        for (let key in Tests) {
            addTest(Tests, key);
        }
        if (window.Platform) {
            for (let key in Platform) {
                if (key.startsWith('use') || key.startsWith('using') || PLATFORM_ALLOWED_KEYS.includes(key)) {
                    addTest(Platform, key);
                }
            }
        }

        let compressionExtensions = [
            'compressed_texture',
            'texture_compression',
        ];
        let enabledExtensions = Device.graphics.webgl?.extensions || [];
        let otherExtensions = enabledExtensions.filter(ext => !compressionExtensions.find(n => ext.includes(n))).join(', ');
        let dedupe = {};
        compressionExtensions = enabledExtensions
            .map(ext => (
                compressionExtensions.map(name => {
                    let index = ext.indexOf(name);
                    if (index < 0) return;
                    index += name.length;
                    if (ext.charAt(index) === '_') index += 1;
                    return ext.substring(index);
                }).find(Boolean)
            ))
            .filter(ext => {
                if (!ext || dedupe[ext]) return false;
                return dedupe[ext] = true;
            })
            .join(', ');

        let html = `<h1>Performance Results</h1>
                    <button id="copy">Copy to clipboard</button>
                    <p><b>Time:</b> ${new Date()}</p>
                    <p><b>GPU:</b> ${Device.graphics.webgl ? Device.graphics.webgl.gpu : 'WEBGL UNAVAILABLE'}</p>
                    <p><b>WebGL Version:</b> ${Device.graphics.webgl ? Device.graphics.webgl.version : 'WEBGL UNAVAILABLE'}</p>
                    <p><b>GPU Tier:</b> ${Device.mobile ? convert(GPU.M_TIER) : convert(GPU.TIER)} [${Device.mobile ? GPU.M_TIER : GPU.TIER}]</p>
                    <p><b>Mobile:</b> ${Device.mobile ? Object.keys(Device.mobile).filter(key => Device.mobile[key]) : 'false'} </p>
                    <p><b>User Agent:</b> ${Device.agent}</p>
                    <p><b>OS:</b> ${Device.system.os}</p>${Device.system.version !== -1 ? `
                    <p><b>OS Version:</b> ${Device.system.version}` : ''}
                    <p><b>DPR:</b> ${Device.pixelRatio}</p>
                    <p><b>Screen Size:</b> ${screen.width} x ${screen.height}</p>
                    <p><b>Stage Size:</b> ${Stage.width} x ${Stage.height}</p>
                    <p><b>Browser:</b> ${Device.system.browser}</p>
                    <p><b>Browser Version:</b> ${Device.system.browserVersion}</p>
                    <p><b>Compressed textures:</b> ${compressionExtensions}</p>
                    <p><b>WebGL extensions:</b> ${otherExtensions}</p>
                    <p><b>Media Devices w/ Permissions Granted:</b>${await navigator?.mediaDevices?.enumerateDevices?.().then(devices => devices?.filter?.(device => device.label !== "")?.map(device => ` ${device.label}`))}</p>
                    
                    <h2>Project-Specific Tests</h2>
                    ${editing ? '<button class="resetBtn">Reset All</button>' : ''}
                    ${tests}
        `;

        $results.html(html);

        let copy = $(document.getElementById('copy'));
        copy.bind('click', _ => {
            let text = `${$results.div.innerText.split('\n').slice(2).join('\n').trim()}`;
            Utils.copyToClipboard( text );
            copy.text('Results copied!');
            clearTimeout( _this.copyTimer );
            _this.copyTimer = _this.delayedCall( _ => {
                copy.text('Copy to clipboard');
            }, 3000 );
        });

        if (editing) {
            await defer();

            let btn = document.querySelector('.resetBtn');
            btn.onclick = _ => {
                Storage.set('performance_override', null);
                location.reload();
            };

            for (let { obj, key } of keys) {
                let div = document.querySelector(`.${key}`);

                if (div) {
                    div.onchange = _ => {
                        let value = div.value;
                        if (isNaN(value)) {
                            value = div.checked;
                        } else {
                            value = Number(value);
                        }

                        save(obj, key, value);
                    };
                }
            }
        }
    }
}, 'static');

Class(function RenderManager() {
    Inherit(this, Component);
    const _this = this;
    const _evt = {stage: null, camera: null};
    var _hasGLUI, _hasMetal;

    var _dpr = null;
    var _stringSchedules = new Map();
    var _objectSchedules = new WeakMap();
    var _firingEvt;

    this.NORMAL = 'normal';
    this.MAGIC_WINDOW = 'magic_window';
    this.VR = this.WEBVR = 'webvr';
    this.AR = this.WEBAR = 'webar';

    this.RENDER = 'RenderManager_render';
    this.BEFORE_RENDER = 'RenderManager_before_render';
    this.POST_RENDER = this.FRAME_END = 'RenderManager_post_render';
    this.EYE_RENDER = 'RenderManager_eye_render';
    this.FRAME_BEGIN = 'RenderManager_frame_begin';
    this.AFTER_LOOPS = 'RenderManager_after_loops';
    this.NATIVE_FRAMERATE = 'RenderManager_native_framerate';
    this.READY = 'render_gl_ready';

    this.initialized = Promise.create();

    //*** Constructor
    (function() {
        _this.events.sub(Events.RESIZE, resizeHandler);
        Render.startFrame = startFrame;

        Hydra.ready(_ => {
            _hasGLUI = !!window.GLUI;
            _hasMetal = !!window.Metal;
        });
    })();

    function getSchedulesMap(evt) {
        return (typeof evt === 'string' ? _stringSchedules : _objectSchedules);
    }

    function getSchedule(evt) {
        return getSchedulesMap(evt).get(evt);
    }

    function fire(evt, data) {
        let array = getSchedule(evt);
        if (array) {
            let len = array.length;
            for (let i = 0; i < len; i++) {
                let cb = array[i];
                if (array.markedForDeletion.has(cb)) continue;
                _firingEvt = evt;
                if (data) cb(data);
                else cb(Render.TIME, Render.DELTA);
            }
            _firingEvt = undefined;
            if (array.markedForDeletion.size) {
                array.markedForDeletion.forEach((_, cb) => {
                    array.remove(cb);
                });
                array.markedForDeletion.clear();
            }
        }
    }

    function startFrame() {
        fire(_this.FRAME_BEGIN);
    }

    //*** Event handlers

    function resizeHandler() {
        _this.renderer && _this.renderer.setSize(Stage.width, Stage.height);
    }

    function getDPR() {
        if (window.AURA) return Device.pixelRatio;
        if (GPU.OVERSIZED) return 1;
        if (GPU.lt(0)) return Math.min(1.3, Device.pixelRatio);
        if (GPU.lt(1)) return Math.min(1.8, Device.pixelRatio);
        if (GPU.mobileLT(2)) return Math.min(2, Device.pixelRatio);
        if (GPU.gt(4)) return Math.max(1.5, Device.pixelRatio);
        return Math.max(1.25, Device.pixelRatio);
    }

    function directRenderCallback(render) {
        if (_hasGLUI && _hasMetal) GLUI.renderDirect(render);
    }

    //*** Public methods
    this.get('DPR', v => {
        return getDPR();
    });

    this.initialize = function(type, params = {}) {
        if (_this.camera) _this.camera.destroy();
        if (_this.renderer) _this.renderer.destroy();

        if (type == _this.WEBVR || type == _this.WEBAR) {
            params.xrCompatible = true;
            params.alpha = false;
        }

        if (!_this.gl) {
            let camera = new PerspectiveCamera(45, Stage.width / Stage.height, 0.01, 200);

            _this.gl = (function() {
                if (Device.system.browser == 'safari' && Device.system.browserVersion < 13) delete params.powerPreference;
                if (Utils.query('compat')) params.forceWebGL1 = true;
                const RendererClass = window.Metal ? MetalRenderer : Renderer;
                let renderer = new RendererClass(params);
                renderer.setSize(Stage.width, Stage.height);
                renderer.setPixelRatio(getDPR());
                return renderer;
            })();

            _this.scene = new Scene();

            _this.nuke = _this.initClass(Nuke, Stage, Object.assign({renderer: _this.gl, scene: _this.scene, camera: camera, dpr: World.DPR}, params));
        }

        _dpr = _dpr || World.DPR || 1;
        switch (type) {
            case _this.WEBVR:
                _this.renderer = _this.initClass(VRRenderer, _this.gl, _this.nuke);
                _this.camera = _this.initClass(VRCamera);
                break;

            case _this.WEBAR:
                _this.renderer = _this.initClass(window.Metal ? MetalARRenderer : ARRenderer, _this.gl, _this.nuke);
                _this.camera = _this.initClass(ARCamera);
                break;

            case _this.MAGIC_WINDOW:
                _this.renderer = _this.initClass(MagicWindowRenderer, _this.gl, _this.nuke);
                _this.camera = _this.initClass(VRCamera);
                break;

            case _this.NORMAL:
                _this.renderer = _this.initClass(RenderManagerRenderer, _this.gl, _this.nuke);
                _this.camera = _this.initClass(RenderManagerCamera);
                break;
        }

        _this.type = type;
        _this.nuke.camera = _this.camera.worldCamera;

        _this.initialized.resolve();
    }

    this.render = function(scene, camera, renderTarget, forceClear) {
        fire(_this.AFTER_LOOPS);
        if (_this.type == _this.VR) fire(World.NUKE);
        fire(_this.BEFORE_RENDER);
        _this.renderer.render(scene || _this.scene, _this.nuke.camera, renderTarget, forceClear, directRenderCallback);
        _this.events.fire(_this.POST_RENDER);
        fire(_this.POST_RENDER);
    }

    this.schedule = function(callback, slot) {
        let schedules = getSchedulesMap(slot);
        let array = schedules.get(slot);
        if (!array) {
            array = [];
            array.markedForDeletion = new Map();
            schedules.set(slot, array);
        }
        let index = array.indexOf(callback);
        if (index >= 0) {
            array.markedForDeletion.delete(callback);
            return;
        }
        array.push(callback);
    }

    this.scheduleOne = function(callback, slot) {
        let result;
        if (typeof callback !== 'function') {
            slot = callback;
            result = Promise.create();
            callback = result.resolve;
        }

        let array = getSchedule(slot);
        if (array) {
            let existing = array.find(h => h.scheduleOneCallback === callback);
            if (existing) return;
        }

        let handler = function() {
            _this.unschedule(handler, slot);
            return callback.apply(this, arguments);
        };

        handler.scheduleOneCallback = callback;

        _this.schedule(handler, slot);
        return result;
    }

    this.unschedule = function(callback, slot) {
        const array = getSchedule(slot);
        if (!array) return;
        const index = array.indexOf(callback);
        if (index < 0) return;
        if (_firingEvt) {
            array.markedForDeletion.set(callback, true);
        } else {
            array.splice(index, 1);
        }
    }

    this.setSize = function(width, height) {
        _this.events.unsub(Events.RESIZE, resizeHandler);
        _this.renderer.setSize(width, height);
    }

    this.fire = fire;
}, 'static');

Class(function RenderManagerCamera() {
    Inherit(this, Component);
    const _this = this;

    this.worldCamera = window.THREE ? new THREE.PerspectiveCamera(30, Stage.width / Stage.height, 0.1, 1000) : new PerspectiveCamera(30, Stage.width / Stage.height, 0.1, 1000);

    _this.events.sub(Events.RESIZE, () => {
        _this.worldCamera.aspect = Stage.width / Stage.height;
        _this.worldCamera.updateProjectionMatrix();
    });
});
Class(function RenderManagerRenderer(_renderer, _nuke) {
    Inherit(this, Component);
    const _this = this;
    var _evt = {};

    _nuke.onBeforeProcess = _ => {
        _evt.stage = Stage;
        _evt.camera = _nuke.camera;
        _this.events.fire(RenderManager.RENDER, _evt);
    };

    //*** Event handlers

    //*** Public methods
    this.render = function(scene, camera, _1, _2, directRender) {
        _nuke.camera = camera;

        if (_nuke) {
            _nuke.render(directRender);
        } else {
            _renderer.render(scene, camera, null, null, directRender);
        }
    };

    this.setSize = function(width, height) {
        _renderer.setSize(width, height);
    };
});
Class(function Frag3D(_name) {
    Inherit(this, Object3D);
    
    this.layout = this.initClass(SceneLayout, _name);

    this.uploadSync = function() {
        return Initializer3D.uploadAll(_this.layout);
    }
    
});
Class(function FragFXScene(_name) {
    Inherit(this, FXScene);
    const _this = this;
    //*** Event handlers

    this.layout = this.initClass(SceneLayout, _name);
    this.group = this.scene;
    this.scene.add(this.layout.group);
    
    //*** Public methods
    this._initFXScene = function(nuke, rtPool, options) {
        for (let key in options) {
            if (!options[key]) delete options[key];
        }

        if (rtPool) _this.create(nuke, rtPool(), options);
        else _this.create(nuke, options);
    }

    this.uploadSync = function() {
        return Initializer3D.uploadAll(_this.layout);
    }
});
Class(function SceneLayout(_name, _options = {}) {
    Inherit(this, Object3D);
    const _this = this;
    var _dataStore, _data, _timeline, _breakpoint, _gizmo;

    const ZERO = new Vector3();

    var _initializers = [];
    var _promises = [];
    var _breakpoints = [];
    var _folders = {};
    var _groups = {};
    var _custom = {};
    var _meshes = {};
    var _exists = {};
    var _layers = {};
    var _uil = UIL.sidebar;
    var _graph;
    var _config;
    var _groupIndex = 0;
    var _groupsSynced = Promise.create();

    this.isSceneLayout = true;
    this.name = _name;

    //*** Constructor
    (async function () {
        _this.group.sceneLayout = _this;
        await initialize(defer());
        if (!SceneLayout.getTexture) SceneLayout.getTexture = Utils3D.getTexture;
        initGraph();
        initParams();
        initialize(initConfig());
        initData();
        addListeners();
        ready();
        if (UIL.global) initGizmo();
    })();

    function initialize(promise) {
        _promises.push(promise);
    }

    function initGizmo() {
        if (_options.noGizmo || Utils.query('nogizmo')) return;

        _gizmo = _this.initClass(SceneLayoutGizmo);
    }

    function createFolder(name) {
        let folder = new UILFolder(`sl_${_name}_${name}`, {label: name, closed:true});
        folder.hide();
        _folders[`sl_${_name}_${name}`] = folder;
        return folder;
    }

    async function initConfig() {
        let input = InputUIL.create(`CONFIG_sl_${_name}`, _uil);
        input.add('Animation');
        input.add('Layout');
        input.add('Cinema Config');

        _graph && _graph.addSpecial('Config', `Config (${_name})`, 'Config');

        input.setLabel(`Config`);

        let animation = input.get('Animation');
        let layout = input.get('Layout');
        if (animation) {
            await ready();
            _groupsSynced.then(async () => {
                animation = animation.replace(/^\//g, '');
                _this.animation = _this.initClass(HierarchyAnimation, animation, linkObjects);

                if (!_timeline) {
                    if (_uil) {
                        let range = new UILControlRange('Animation', {min: 0, max: 1, step: 0.001});
                        range.onChange(val => {
                            _this.animation.elapsed = val;
                            _this.animation.update();
                        });
                        _uil.add(range);
                    }
                } else {
                    _this.startRender(_ => {
                        _this.animation.elapsed = _timeline.elapsed;
                        _this.animation.update();
                    });
                }

                await _this.animation.ready();
                _this.animation.update();
            });
        }

        if (layout) {
            await ready();
            _this.layout = _this.initClass(HierarchyLayout, layout, linkObjects);
            await _this.layout.ready();
        }

        _config = input;
        await defer();
        _this.configured = true;
    }

    async function linkObjects(data) {
        let array = [];
        for (let i = 0; i < data.length; i++) {
            let name = data[i].name;
            let exists = _this.exists(name);
            if (!exists && name.toLowerCase() != 'null') console.warn(`linkAnimation :: ${name} does not exist`);

            let group = new Group();
            let mesh = exists ? await _this.getLayer(name) : null;

            if (mesh) {
                if (_this.layout && mesh instanceof Mesh) {
                    mesh._parent.add(group);
                    group.add(mesh);
                } else {
                    group = mesh.group || mesh;
                }
            }

            group.name = name;
            array.push(group);
        }
        return array;
    }

    async function initGraph() {
        if (_options.noGraph || !window.UILGraph || SceneLayout.noGraph) {
            _uil = null;
            _groupsSynced.resolve();
            return;
        }

        _graph = UILGraph.instance().getGraph(_name, _this);

        if (_graph) {
            UIL.sidebar.element.show();
            await _this.ready();
            _graph.syncVisibility(_layers);
            _graph.syncGroupNames(_groups, _folders);
            _groupsSynced.resolve();
            if (Global.PLAYGROUND && (Utils.getConstructorName(_this.parent) == Global.PLAYGROUND)) _graph.open();
        } else {
            _groupsSynced.resolve();
        }

    }

    function initParams() {
        if (!_options.rootPath) _options.rootPath = '';
        else {
            if (_options.rootPath.charAt(_options.rootPath.length-1) != '/') _options.rootPath += '/';
        }

        _this.timeline = _timeline = _options.timeline;
        if (_timeline) {
            _timeline.add({v: 0}, {v: 1}, 100, 'linear');

            if (_uil) {
                let range = new UILControlRange('Timeline', {min: 0, max: 1, step: 0.001});
                range.onChange(val => {
                    _timeline.elapsed = val;
                    _timeline.update();
                });
                _uil.add(range);
                range.hide();

                _graph && _graph.addSpecial('Timeline', 'Timeline');
            }
        }

        _this.baseRenderOrder = _options.baseRenderOrder || 0;
        _this.data = _options.data;
        _breakpoint = _options.breakpoint || SceneLayout.breakpoint;
        if (_options.breakpoint) _this.localBreakpoint = true;

        if (_options.uil) _uil = _options.uil;
    }

    async function initData() {
        await UILStorage.ready();
        _dataStore = InputUIL.create(`scenelayout_${_name}`, null);
        _data = JSON.parse(_dataStore.get('data') || '{}');
        if (typeof _data.layers === 'undefined') _data.layers = -1;

        if (!_options.perFrame) {
            for (let i = 0, c = _data.layers + 1; i < c; i++) initialize(createLayer(i));
            _this.loaded = true;
        } else {
            if (_data.layers > 0) {
                createLayers();
            }else{
                _this.loaded = true;
            }
        }
    }

    function createLayers() {
        let index = 0;
        let renderWorker = new Render.Worker(function() {
            initialize(createLayer(index));
            if (index++ == _data.layers) {
                renderWorker.stop();
                _this.loaded = true;
            }
        }, _options.perFrame);
    }

    function getGroup(name) {
        if (!name) return _this.group;
        if (name == _name) return _this.group;
        if (!_groups[name]) {
            let uilGroup = _uil ? createFolder(name) : null;
            if (uilGroup) {
                uilGroup.setLabel(`${name} (Group)`);
                _uil.add(uilGroup);
                _graph && _graph.addGroup(uilGroup.id, name);
            }

            let config = InputUIL.create(`GROUP_${_name}_${name}`, uilGroup);
            config.setLabel('Parameters');
            if (_timeline) config.add('tween');
            config.addToggle('billboard');
            config.add('breakpoints');
            config.add('name', 'hidden');

            let breakpoints = config.get('breakpoints');
            if (breakpoints) breakpoints = breakpoints.replace(/ /g, '').split(',');
            let breakpoint = breakpoints && _breakpoint ? '-'+_breakpoint : '';
            if (breakpoint.charAt(breakpoint.length-1) == '-') breakpoint = '';

            let group = new Group();
            _groups[name] = group;
            _layers[name] = group;
            _exists[name] = 'group';
            group.prefix = `${name}_${_name}${breakpoint}`;
            let meshUIL = MeshUIL.add(group, uilGroup);
            meshUIL.setLabel('Mesh');
            _this.add(group);
            if (UIL.global) group._meshUIL = meshUIL;

            if (uilGroup) uilGroup.params = config;

            if (breakpoints) _breakpoints.push(group);

            if (config.get('billboard')) updateBillboard(true, mesh);
        }

        _groupIndex++;

        return _groups[name];
    }

    //*** Event handlers
    async function createLayer(index, groupName, returnName) {
        let created = false;
        let input;
        let id = typeof index === 'number' ? index : ++_data.layers;

        let graphGroupName = groupName;
        if (graphGroupName) {
            let nameLabel = UILStorage.get(`INPUT_GROUP_${_name}_${groupName}_name`);
            if (nameLabel) {
                groupName = nameLabel;
            }
        }

        if (UILStorage.get(`sl_${_name}_${id}_deleted`)) return;

        if (_this.preventLayerCreation) {
            if (_this.preventLayerCreation(UILStorage.get(`INPUT_Config_${id}_${_name}_name`))) return;
        }

        let group = _uil ? createFolder(id) : null;
        let shader, mesh;

        if (Hydra.LOCAL) {
            _this.delayedCall(_ => {
                if (!created) console.error(`SceneLayout :: 5 second timer expired creating ${_name} ${input.get('name')}`)
            }, 5000);
        }

        input = InputUIL.create(`Config_${id}_${_name}`, group);
        input.setLabel('Parameters');
        input.add('name', 'hidden')
            .addFile('geometry', {relative: 'assets/geometry'})
            .addToggle('visible', true).addToggle('transparent').addToggle('depthWrite', true).addToggle('depthTest', true)
            .addToggle('castShadow').addToggle('receiveShadow').addToggle('receiveLight').addToggle('billboard').addToggle('animates', true)
            .add('shader').add('custom').add('script').add('wildcard').add('renderOrder', 'hidden').add('group', 'hidden').add('breakpoints')
            .addSelect('side', [
                {label: 'Front Side', value: 'shader_front_side'},
                {label: 'Back Side', value: 'shader_back_side'},
                {label: 'Double Side', value: 'shader_double_side'},
                {label: 'Double Side Transparent', value: 'shader_double_side_trasparency'},
            ])
            .addSelect('blending', [
                {label: 'Normal', value: 'shader_normal_blending'},
                {label: 'Additive', value: 'shader_additive_blending'},
                {label: 'Premultiplied Alpha', value: 'shader_premultiplied_alpha_blending'},
            ]);

        if(window.FX && FX.ScreenSpaceGI) input.addToggle('globalIllumination');

        input.name = _name;
        input.prefix = `Element_${id}_${_name}`;
        input.id = id;

        if (group) group.params = input;

        if (_timeline) input.addToggle('tween');
        if (_options.physics) {
            input.addToggle('physics');
            input.add('physicsCode');
            input.addFile('physicsBounds', { relative: 'assets/geometry' });
        }

        let name = input.get('name') || id;
        let shaderName = input.get('shader') || 'SceneLayout';
        let geomPath = input.getFilePath('geometry');
        let visible = input.get('visible');
        let transparent = input.get('transparent');
        let depthWrite = input.get('depthWrite');
        let depthTest = input.get('depthTest');
        let billboard = input.get('billboard');
        let animates = input.get('animates');
        let doTween = input.get('tween');
        let renderOrder = input.getNumber('renderOrder');
        let blending = input.get('blending');
        let side = input.get('side');
        let physics = input.get('physics');
        let castShadow = input.get('castShadow');
        let receiveShadow = input.get('receiveShadow');
        let receiveLight = input.get('receiveLight');

        let breakpoints = input.get('breakpoints');
        if (breakpoints) breakpoints = breakpoints.replace(/ /g, '').split(',');
        let breakpoint = breakpoints && _breakpoint ? '-'+_breakpoint : '';
        if (breakpoint.charAt(breakpoint.length-1) == '-') breakpoint = '';

        if (name && group) group.setLabel(name);

        if (groupName) input.setValue('group', groupName);
        let groupParent = getGroup(input.get('group'));
        if (group) {
            let groupName = input.get('group');
            let groupId = groupName ? `sl_${_name}_${graphGroupName || groupName}` : undefined;
            _graph && _graph.addLayer(group.id, name || id + '', groupId);
        }

        if (_uil) _uil.add(group);

        if (name == 'ignore') return created = true;

        let customClass = input.get('custom');
        let scriptClass = input.get('script');

        let customCompile;
        if (shaderName.includes('|')) {
            [shaderName, customCompile] = shaderName.split('|');
        }

        _exists[name] = customClass ? 'custom' : 'mesh';

        if (customClass) {
            if (customClass === _this.parent.constructor.name) return console.warn(`Tried to recursively initialize ${customClass}`);
            if (!window[customClass]) return console.warn(`Tried to initialize ${customClass} but it doesn't  exist!`);
            let obj = _this.initClass(window[customClass], input, group, id, null);
            mesh = obj.group;
            obj.wildcard = input.get('wildcard');
            obj.animates = input.get('animates');
            if (typeof visible === 'boolean' && mesh) mesh.visible = visible;

            _custom[name] = obj;
            _layers[name] = obj;
            if (_this.onCreateLayer) {
                let capture = cb => {
                    _this.delayedCall(_ => cb(obj, name), 32);
                    return true;
                };
                if (_this.onCreateLayer(name, group, capture) === true) return;
            }
            if (obj.group) groupParent.add(obj.group);

            obj.renderOrder = _this.baseRenderOrder + renderOrder;

            if (mesh) {
                let meshUIL;
                if (!obj.camera) {
                    mesh.prefix = `Element_${id}_${_name}${breakpoint}`;
                    meshUIL = MeshUIL.add(mesh, group);
                    meshUIL.setLabel('Mesh');
                    if (UIL.global) mesh._meshUIL = meshUIL;
                }
                _breakpoints.push(mesh);

                if (scriptClass && visible !== false) {
                    if (scriptClass.includes(',')) {
                        scriptClass = scriptClass.replace(/ /g, '').split(',');
                        scriptClass.forEach(script => {
                            if (!window[script]) {
                                console.warn(`scriptClass ${script} not found`);
                            } else {
                                mesh.scriptClass = mesh.scriptClass || [];
                                mesh.scriptClass.push(_this.initClass(window[script], mesh, shader, group, input));
                            }
                        });
                    } else {
                        if (!window[scriptClass]) {
                            console.warn(`scriptClass ${scriptClass} not found`);
                        } else {
                            mesh.scriptClass = _this.initClass(window[scriptClass], mesh, shader, group, input);
                        }
                    }
                }

                if (UIL.global) {
                    mesh._sceneLayout = input._sceneLayout = {
                        meshUIL,
                        // shaderUIL,
                        mesh,
                        shader,
                        name,
                        input
                    };
                }
            }

            created = true;
            return input;
        }

        if (_this.onCreateLayer) {
            let capture = cb => {
                let mesh = new Group();
                let shader = {uniforms: {uAlpha: {value: 1}}};
                mesh.prefix = `Element_${id}_${_name}${breakpoint}`;
                MeshUIL.add(mesh, group);
                _meshes[name] = mesh;
                _layers[name] = mesh;
                _this.delayedCall(_ => cb(mesh, name), 32);
                created = true;
                return true;
            }
            if (_this.onCreateLayer(name, group, capture) === true) return created = true;
        }

        let geom = World.PLANE;
        if (geomPath && geomPath.includes(['World', 'SceneLayout'])) {
            geom = eval(geomPath);
            geomPath = null;
        }

        if (shaderName.includes('.shader')) {
            shader = await resolveShaderRef(shaderName, name);
            if (!shader) shaderName = 'SceneLayout';
        }
        if (!shader) {
            if (shaderName.includes('PBR')) {
                shader = _this.initClass(PBRShader, shaderName, {
                    unique: `Element_${id}_${_name}`,
                });
            } else {

                let texturePath = input.getImage('texture');
                if (!texturePath) texturePath = 'assets/images/_scenelayout/uv.jpg';
                else if (!texturePath.includes('assets/images')) texturePath = _options.rootPath + texturePath;

                shader = _this.initClass(Shader, shaderName, {
                    unique: `Element_${id}_${_name}`,
                    customCompile
                });

                if (shaderName == 'SceneLayout' || !window[shaderName]) {
                    shader.addUniforms({
                        tMap: {value: Utils3D.getTexture(texturePath)},
                        uAlpha: {value: 1}
                    });
                }

                defer(_ => {
                    for (let key in shader.uniforms) {
                        let uniform = shader.uniforms[key];
                        if (uniform && uniform.value instanceof Texture) {
                            initialize(uniform.value.promise);
                        }
                    }
                });
            }
        }

        if (typeof depthWrite === 'boolean') shader.depthWrite = depthWrite;
        if (typeof depthTest === 'boolean') shader.depthTest = depthTest;
        if (typeof transparent === 'boolean') shader.transparent = transparent;

        if (_this.onCreateGeometry) geomPath = _this.onCreateGeometry(geomPath, input.get('wildcard'));

        let gltfNodes = null;

        if (geomPath) {

            if(String(geomPath).indexOf(".glb") > 0 || String(geomPath).indexOf(".gltf") > 0) {

                let loader = new GLTFLoader();
                gltfNodes =  await loader.parse(geomPath, _this, name);
                geom = new PlaneGeometry(0, 0);

            } else {

                geom = await GeomThread.loadGeometry(geomPath);

            }

        }

        mesh = new Mesh(geom, shader);

        if(gltfNodes) for(let i = 0; i < gltfNodes.length; i ++) mesh.add(gltfNodes[i]);

        if (typeof _options.frustumCulled === 'boolean') mesh.frustumCulled = _options.frustumCulled;
        if (typeof visible === 'boolean') mesh.visible = visible;
        groupParent.add(mesh);

        mesh.prefix = `Element_${id}_${_name}${breakpoint}`;
        mesh.uilName = name;
        mesh.uilGroup = group;
        mesh.uilGraph = _graph;
        mesh.wildcard = input.get('wildcard');
        mesh.animates = input.get('animates');
        let meshUIL = MeshUIL.add(mesh, group);
        meshUIL.setLabel('Mesh');
        if (UIL.global) mesh._meshUIL = meshUIL;

        if (physics) {
            let path = input.getFilePath('physicsBounds');
            let obj;
            if (path) {
                const shapes = await PhysicsBounds.parsePhysicsBoundsShapes(Assets.getPath(path));
                if (shapes) obj = Physics.instance().createFromShapes(shapes, {}, mesh);
            }
            if (!obj) {
                obj = Physics.instance().create(mesh);
            }
            obj.prefix = `Physics_${id}_${_name}`;
            PhysicsUIL.add(obj, group).setLabel('Physics');
            let physicsCodeClassName = input.get('physicsCode');
            let physicsCodeClass;
            if (physicsCodeClassName) {
                physicsCodeClass = window[physicsCodeClassName];
                if (!physicsCodeClass) console.warn(`physicsCode class ${physicsCodeClassName} not found`);
            }
            if (physicsCodeClass) _this.initClass(physicsCodeClass, obj, mesh, group, input);
        }

        _meshes[name] = mesh;
        _layers[name] = mesh;

        if (breakpoints) _breakpoints.push(mesh);

        mesh.renderOrder = _this.baseRenderOrder + (renderOrder || 0);

        if (billboard) updateBillboard(true, mesh);

        if (shaderName != 'SceneLayout' && window[shaderName]) mesh.shaderClass = _this.initClass(window[shaderName], mesh, shader, group, input);

        if (!shader._copied && (shader === mesh.shader || shaderName.includes('PBR'))) ShaderUIL.add(shader, group).setLabel('Shader');
        if (shader._copied) {
            if (shader._copied.shaderClass && shader._copied.shaderClass.applyClone) shader._copied.shaderClass.applyClone(mesh);
        }

        if (typeof index !== 'number') _dataStore.setValue('data', JSON.stringify(_data));
        if (blending) shader.blending = blending;
        if (side) shader.side = side;
        if (castShadow) mesh.castShadow = castShadow;
        receiveShadow = receiveShadow || Shader.shouldReceiveShadow(shader);
        if (receiveShadow) {
            shader.receiveShadow = receiveShadow;
        }
        if (receiveLight) shader.receiveLight = receiveLight;

        if (scriptClass) {
            if (scriptClass.includes(',')) {
                scriptClass = scriptClass.replace(/ /g, '').split(',');
                scriptClass.forEach(script => {
                    if (!window[script]) {
                        console.warn(`scriptClass ${script} not found`);
                    } else {
                        mesh.scriptClass = mesh.scriptClass || [];
                        mesh.scriptClass.push(_this.initClass(window[script], mesh, shader, group, input));
                    }
                });
            } else {
                if (!window[scriptClass]) {
                    console.warn(`scriptClass ${scriptClass} not found`);
                } else {
                    mesh.scriptClass = _this.initClass(window[scriptClass], mesh, shader, group, input);
                }
            }
        }

        input.onUpdate = key => {
            switch (key) {
                case 'name': group.setLabel(input.get(key)); break;
                case 'visible': mesh.visible = input.get(key); break;
                case 'renderOrder': mesh.renderOrder = _this.baseRenderOrder + input.getNumber(key); break;
                case 'transparent': shader.transparent = input.get(key); break;
                case 'depthWrite': shader.depthWrite = input.get(key); break;
                case 'depthTest': shader.depthTest = input.get(key); break;
                case 'side': shader.side = input.get(key); break;
                case 'blending': shader.blending = input.get(key); break;
                case 'geometry': updateGeometry(input.getFilePath(key), mesh); break;
                case 'shader': updateShader(input.get(key), mesh, id, group, input); break;
                case 'scriptClass': updateScriptClass(input.get(key), mesh, group, input); break;
                case 'receiveShadow': updateShadow(input.get(key), mesh); break;
                case 'receiveLight': updateLighting(input.get(key), mesh); break;
                case 'billboard': updateBillboard(input.get(key), mesh); break;
            }

            // Force transparent/opaque sorting and more
            if (UIL.global) {
                World.SCENE.displayNeedsUpdate = true;

                if (window?.view?.scene) {
                    view.scene.displayNeedsUpdate = true;
                }
            }
        };

        if (Hydra.LOCAL && Global.PLAYGROUND) {
            _this.events.sub(SceneLayout.HOTLOAD_GEOMETRY, ({file}) => {
                if (mesh.geometry?._src?.includes(file)) {
                    updateGeometry(file, mesh);
                }
            });

            const scriptClassNeedsUpdate = (inst, file) => {
                if (!inst.__cacheName) inst.__cacheName = Utils.getConstructorName(inst);
                if (file.includes(inst.__cacheName)) return inst.__cacheName;
                else return false;
            };

            _this.events.sub(SceneLayout.HOTLOAD_SCRIPT, ({file}) => {
                if (file.includes(mesh.shader?.vsName)) {
                    shader.hotReloading = true;
                    if (shaderName !== 'SceneLayout' && window[shaderName]) mesh.shaderClass = _this.initClass(window[shaderName], mesh, shader, group, input);
                    group.remove(shader.UILPrefix);
                    delete ShaderUIL.exists[shader.UILPrefix];
                    ShaderUIL.add(shader, group).setLabel('Shader');
                    shader.hotReloading = false;
                }

                if (mesh.scriptClass) {
                    if (Array.isArray(mesh.scriptClass)) {
                        mesh.scriptClass.every((inst, index) => {
                            let name = scriptClassNeedsUpdate(inst, file);
                            if (name) {
                                mesh.scriptClass.remove(inst);
                                updateScriptClass(name, mesh, group, input);
                                return false;
                            }
                            return true;
                        });
                    } else {
                        let name = scriptClassNeedsUpdate(mesh.scriptClass, file);
                        if (name) updateScriptClass(name, mesh, group, input);
                    }
                }
            });
        }

        if (UIL.global) {
            mesh._sceneLayout = input._sceneLayout = {
                meshUIL,
                mesh,
                input,
                name,
                get shaderUIL() {
                    return this.mesh.shader.shaderUIL;
                }
            };
        }

        created = true;
        return returnName ? name : input;
    }

    async function updateGeometry(geomPath, mesh) {
        let geom = World.PLANE;
        if (geomPath && geomPath.includes(['World', 'SceneLayout'])) {
            geom = eval(geomPath);
            geomPath = null;
        } else {
            if (geomPath) geom = await GeomThread.loadGeometry(geomPath + '?' + Utils.timestamp());
        }

        mesh.geometry = geom;
    }

    async function resolveShaderRef(shaderName, layerName) {
        let shaderLayer = shaderName.split('.shader')[0];
        let promise = _this.getLayer(shaderLayer);
        if (Hydra.LOCAL) {
            promise = Promise.race([
                promise, (async () => {
                    await _this.loadedAllLayers();
                })()
            ]);
        }
        let layer = await promise;
        if (layer) {
            let shader = layer.shader;
            shader._copied = layer;
            return shader;
        } else if (Hydra.LOCAL) {
            console.error(`Couldn’t find shader “${shaderName}” for layer “${layerName}” in SceneLayout “${_name}”, because layer “${shaderLayer}” doesn't exist`);
        }
    }

    async function updateShader(shaderName = '', mesh, id, group, input) {
        let shader;
        if (shaderName.includes('.shader')) {
            shader = await resolveShaderRef(shaderName, mesh.uilName);
            if (!shader) shaderName = 'SceneLayout';
        }
        if (!shader) {
            if (shaderName.includes('PBR')) {
                shader = _this.initClass(PBRShader, shaderName, {
                    unique: `Element_${id}_${_name}`,
                });
            } else {
                shader = _this.initClass(Shader, shaderName, {
                    unique: `Element_${id}_${_name}`,
                });
            }
        }

        group.remove(mesh.shader.UILPrefix);

        for (let key in mesh.shader.uniforms) {
            let uniform = mesh.shader.uniforms[key];
            if (uniform.type === 't') {
                mesh.shader.shaderUIL.copyTexture(key, shader);
            }
        }

        mesh.shader = shader;
        if (shaderName !== 'SceneLayout' && window[shaderName]) mesh.shaderClass = _this.initClass(window[shaderName], mesh, shader, group, input);
        ShaderUIL.add(shader, group).setLabel('Shader');
    }

    function updateLighting(bool, mesh) {
        mesh.shader.customCompile = Utils.uuid();
        mesh.shader.receiveLight = bool;
        mesh.shader.resetProgram();
        mesh.shader.upload();
    }

    function updateShadow(bool, mesh) {
        mesh.shader.customCompile = Utils.uuid();
        mesh.shader.receiveShadow = bool;
        mesh.shader.resetProgram();
        mesh.shader.upload();
    }

    function updateBillboard(bool, mesh) {
        if (bool) {
            mesh._billboardLoop = _ => Utils3D.billboard(mesh);
            _this.startRender(mesh._billboardLoop);
        } else {
            mesh.rotation.set(0, 0, 0);
            _this.stopRender(mesh._billboardLoop);
        }
    }

    function updateScriptClass(scriptClass, mesh, group, input) {
        if (scriptClass) {
            if (scriptClass.includes(',')) {
                scriptClass = scriptClass.replace(/ /g, '').split(',');
                scriptClass.forEach(script => {
                    if (!window[script]) {
                        console.warn(`scriptClass ${script} not found`);
                    } else {
                        mesh.scriptClass = mesh.scriptClass || [];
                        mesh.scriptClass.push(_this.initClass(window[script], mesh, mesh.shader, group, input));
                    }
                });
            } else {
                if (!window[scriptClass]) {
                    console.warn(`scriptClass ${scriptClass} not found`);
                } else {
                    mesh.scriptClass = _this.initClass(window[scriptClass], mesh, mesh.shader, group, input);
                }
            }
        }
    }

    function addListeners() {
        _this.events.sub(SceneLayout.BREAKPOINT, e => _this.localBreakpoint ? null : setBreakpoint(e));
    }

    function setBreakpoint({value}) {
        if (value == _breakpoint) return;
        _breakpoint = value;
        _breakpoints.forEach(mesh => {
            if (!mesh.prefix) return;
            mesh.prefix = mesh.prefix.split('-')[0] + '-' + _breakpoint;
            if (mesh.prefix.charAt(mesh.prefix.length-1) == '-') mesh.prefix = mesh.prefix.slice(0, -1);
            let meshUIL = new MeshUILConfig(mesh);
            if (UIL.global) mesh._meshUIL = meshUIL;
        });
    }

    async function ready() {
        await _this.wait(_this, 'loaded');
        if (UIL.sidebar) UIL.sidebar.toolbar.hideAll();
    }

    //*** Public methods
    this.ready = async function(early) {
        await _this.wait(_this, 'loaded');
        await _this.wait(_this, 'configured');
        if (early) return true;
        await defer();
        await defer();
    }

    this.getLayer = async function(name) {
        let timer;
        if (Hydra.LOCAL) {
            timer = _this.delayedCall(_ => {
                if (!_exists[name]) console.warn(`${name} doesn't exist in SceneLayout ${_name}`);
            }, 1000);
        }
        await _this.wait(_layers, name);
        if (timer) clearTimeout(timer);
        return _layers[name];
    }

    this.getLayers = async function() {
        let array = [];
        for (let i = 0; i < arguments.length; i++) array.push(_this.getLayer(arguments[i]));
        return Promise.all(array);
    }

    this.getAllLayers = async function() {
        await this.ready();
        await this.loadedAllLayers();
        return _layers;
    }

    this.getAllMatching = async function(label) {
        let layers = await _this.getAllLayers();
        let array = [];
        for (let key in layers) {
            if (key.includes(label)) {
                layers[key].layerName = key;
                array.push(layers[key]);
            }
        }
        return array;
    }

    this.exists = function(name) {
        return _exists[name];
    }

    //*** UILGraph API
    this._createLayer = function(parentId, returnName = false) {
        return createLayer(null, parentId, returnName);
    };

    this._createGroup = function(parentId) {
        getGroup(`group_${_groupIndex}`, parentId);
    };

    this._rename = function(id, name, value) {
        let folder = _folders[id] || _folders[`sl_${_name}_${id}`];
        if (!folder) return;
        folder.setLabel(value);
        if (folder.params) folder.params.setValue('name', value);
        // Fix references
        [_groups, _custom, _meshes, _exists, _layers].forEach(function(store) {
            if (store[name]) {
                store[value] = store[name];
                store[name] = null;
                delete store[name];
            }
        });
    };

    this._deleteLayer = function(id, name, coded) {
        if (id.includes('_')) {
            id = id.split('_');
            id = id[id.length-1];
        }

        let folder = _folders[id] || _folders[`sl_${_name}_${id}`];
        let layer = _layers[id] || _layers[name];

        if (layer && layer.isGroup && layer.length > 1) {
            alert(`Can't delete a group that has nested layers.`);
            return false;
        }

        let sure = coded || confirm('Are you sure you want to delete this layer?');
        if (!sure) return false;

        if (layer && layer._parent) {
            layer._parent.remove(layer);
            layer._parent = null;
        }
        if (folder && folder.parent) {
            folder.parent.remove(folder);
        }

        UILStorage.set(`sl_${_name}_${id}_deleted`, true);
        return true;
    };

    this._changeParent = function(childId, childName, parentId, parentName) {
        let child = _layers[childId] || _layers[childName];
        let parent = _layers[parentId] || _layers[parentName] || _this;

        if (!child) return;

        let folder = _folders[childId] || _folders[`sl_${_name}_${childName}`];
        if (folder && folder.params) {
            folder.params.setValue('group', parentName || null);
        }

        let parentObject = parent.group || parent;
        let childObject = child.group || child;
        if (parentObject.isObject3D && childObject.isObject3D) {
            parentObject.add(childObject);
        }
        child.updateMatrix && child.updateMatrix();

        // =: for now only work with layer into group, not group into another group
    };

    this._visible = function(name, visible) {
        let mesh = _layers[name];
        if (!mesh) return;
        if (mesh.group) mesh = mesh.group;
        mesh.visible = visible;
    };

    this._focus = function(name) {
        UIL.sidebar.toolbar.filterSingle(name);
    };

    this._blur = function(name) {
        let folder = _folders[name] || _folders[`sl_${_name}_${name}`];
        if (folder && folder.forEachFolder) {
            folder.forEachFolder(f => f.close());
            folder.close();
        }
    };

    this._sort = function(order) {
        order.forEach((label, index) => {
            if (label.children) {
                label.children.forEach(function(child, j, all) {
                    let folder = _folders[child];
                    if (!folder || !folder.params) return;
                    let renderOrder = _this.baseRenderOrder + index + (j + 1) / (all.length + 1);
                    folder.params.setValue('renderOrder', renderOrder - _this.baseRenderOrder);
                    let mesh = _layers[child] || _layers[folder.label]
                    if (mesh) mesh.renderOrder = renderOrder;
                });
            }

            let folder = _folders[label];
            if (!folder || !folder.params) return;
            let renderOrder = _this.baseRenderOrder + index;
            folder.params.setValue('renderOrder', renderOrder - _this.baseRenderOrder);
            let mesh = _layers[label] || _layers[folder.label]
            if (mesh) mesh.renderOrder = renderOrder;
        });
    };

    function copyFolderProps(from, to) {
        let mesh, params, shader;
        to.forEachFolder(child => {
            switch (child.label) {
                case 'Parameters': params = child; break;
                case 'Mesh': mesh = child; break;
                case 'Shader': shader = child; break;
            }
        });

        let allowed = ['Parameters', 'Mesh', 'Shader'];
        from.forEachFolder(child => {
            if (allowed.indexOf(child.label) < 0) return;

            child.toClipboard();

            switch (child.label) {
                case 'Parameters': params.fromClipboard(); break;
                case 'Mesh': mesh.fromClipboard(); break;
                case 'Shader': shader.fromClipboard(); break;
            }
        });
    }

    this._duplicateLayer = function(id, parentId) {
        let folder = _folders[id] || _folders[`sl_${_name}_${id}`];
        if (!folder) return;

        createLayer(null, parentId);
        let copy = Object.values(_folders).last();

        // Manually set new shader, so triggers all the right events and create UILFolder, etc.
        let copyShader;

        folder.forEachControl(input => {
            if (input.label === 'shader') copyShader = input.value;
        })

        if (copyShader) {
            console.log(copyShader);
            copy.forEachControl(input => {
                if (input.label === 'shader') input.force(copyShader);
            });
        }

        copyFolderProps(folder, copy);
    };

    this._duplicateGroup = function(id, children) {
        let folder = _folders[id] || _folders[`sl_${_name}_${id}`];
        if (!folder) return;

        let copyId = `group_${_groupIndex + 1}`;
        getGroup(copyId);
        let copy = Object.values(_folders).last();
        copyFolderProps(folder, copy);

        children.forEach(childId => {
            _this._duplicateLayer(childId, copyId);
        });
    };

    this._getCinemaConfig = async function() {
        let _cinemaConfig = _config.get('Cinema Config').replace('.json', '');
        return await get(Assets.getPath(`assets/geometry/${_cinemaConfig}.json`));
    };

    this._applyCinemaConfig = function(id, params) {
        let folder = _folders[id] || _folders[`sl_${_name}_${id}`];
        if (!folder) return;

        let subfolders = folder.getAll();
        let mesh = subfolders.filter(sub => sub.label == 'Mesh')[0];

        if (params.geometry) folder.params.setValue('geometry', params.geometry.replace('assets/geometry/', ''));

        ['position', 'quaternion', 'scale'].forEach(transform => {
            if (params[transform]) {
                let value = JSON.parse(params[transform]);
                if (transform == 'quaternion') {
                    let quat = new Quaternion().fromArray(value);
                    let euler = new Euler().setFromQuaternion(quat);
                    value = euler.toArray().slice(0, 3).map(angle => angle * 180 / Math.PI);
                    transform = 'rotation';
                }
                let control = mesh.getAll().filter(control => control.label == transform)[0];
                control.force(value);
            }
        });

        if (params.visible && params.visible === 'false') {
            if (!params.geometry) {
                folder.params.setValue('geometry', 'World.PLANE');
                folder.params.setValue('side', 'shader_double_side');

                if (!Global.PLAYGROUND) {
                    let mesh = _meshes[folder.params.get('name')];
                    mesh.shader.neverRender = true;
                }
            }
        }

        if (params.shader) {
            folder.params.setValue('shader', params.shader);
        }
    };

    this.loadedAllLayers = async function() {
        await _this.ready();
        return Promise.all(_promises);
    }

    this.set('breakpoint', value => {
        _this.localBreakpoint = true;
        setBreakpoint({value});
    });

    this.get('breakpoint', _ => _breakpoint);

    this.get('layers', _ => _layers);

    this.get('layerCount', _ => _data.layers);

    this.onDestroy = function() {
        if (_this.textures && !_options.persistTextures) {
            _this.textures.forEach(t => {
                t.destroy && t.destroy();
            });
        }
    }

    this.addInitializer = function(callback) {
        _initializers.push(callback);
    }

    this._completeInitialization = async function(sync) {
        if (!_initializers.length) return true;
        for (let i = 0; i < _initializers.length; i++) {
            await _initializers[i](sync);
        }
        _initializers.length = 0;
    }
}, _ => {
    SceneLayout.BREAKPOINT = 'sl_breakpoint';
    SceneLayout.HOTLOAD_GEOMETRY = 'sl_hotload_geom';
    SceneLayout.HOTLOAD_SCRIPT = 'sl_hotload_script';
    SceneLayout.setBreakpoint = function(value) {
        if (SceneLayout.breakpoint !== value) {
            SceneLayout.breakpoint = value;
            Events.emitter._fireEvent(SceneLayout.BREAKPOINT, {value});
        }
    }
});

Class(function SceneLayoutGizmo() {
    Inherit(this, Object3D);
    const _this = this;
    var _controls, _update, _attached, _lastVal;

    this.isGizmo = true;

    //*** Constructor
    (function () {
        _controls = new TransformControls(findCamera(), World.ELEMENT.div);
        _controls.onChange = _controls.onMouseDown = _controls.onMouseUp = _controls.onObjectChange = e => {}
        _controls.onMouseDown = startMoving;
        _controls.onMouseUp = stopMoving;
        _controls.draggingChanged = e => {
            let activeControls = Playground.instance().activeControls;
            if (activeControls) activeControls.enabled = !e.value;
        };

        if (!SceneLayoutGizmo.initialized) {
            SceneLayoutGizmo.initialized = true;
        } else {
            _controls.visible = false;
        }

        _this.group.add(_controls);
        AppState.bind('playground_camera_active', playgroundEvent);
        addListeners();

        _this.delayedCall(_ => {
            _controls.camera = findCamera();
        }, 500);

        _this.group.traverse(obj => {
            obj.isGizmo = true;
        });
    })();

    function findCamera() {
        let camera = World.CAMERA;
        let p = _this.group._parent;
        while (p) {
            if (p instanceof Scene) {
                if (p.nuke) camera = p.nuke.camera;
            }
            p = p._parent;
        }
        return camera;
    }

    function same(a, b) {
        if (!a || !b) return false;
        if (Math.abs(a[0] - b[0]) > Base3D.DIRTY_EPSILON) return false;
        if (Math.abs(a[1] - b[1]) > Base3D.DIRTY_EPSILON) return false;
        if (Math.abs(a[2] - b[2]) > Base3D.DIRTY_EPSILON) return false;
        return true;
    }

    function update() {
        let uil = _attached._cameraUIL || _attached._meshUIL;

        let key = _controls.getMode() == 'translate' ? 'position' : 'scale';

        let value = _attached[key].toArray();
        if (same(value, _lastVal)) return;
        _lastVal = value;

        if (_attached._cameraUIL && key == 'position') key = 'groupPos';

        uil?.[`forceUpdate${key.toUpperCase()}`]?.(value);
    }

    //*** Event handlers
    function addListeners() {
        _this.events.sub(Keyboard.DOWN, keyDown);
        _this.events.sub(UILGraphNode.FOCUSED, nodeFocused);
    }

    function startMoving() {
        _update = setInterval(update, 250);
    }

    function stopMoving() {
        clearInterval(_update);
        update();
    }

    function keyDown(e) {
        if ( document.activeElement.tagName.toLowerCase().includes([ 'textarea', 'input' ])) return;
        if (e.key == '.') _controls.setMode('translate');
        // if (e.key == '.') _controls.setMode('rotate');
        if (e.key == '/') _controls.setMode('scale');
        if (e.key == '=' || e.key == '+') {
            _controls.visible = !_controls.visible;
        }
    }

    function playgroundEvent(camera) {
        if (!camera) {
            _controls.visible = false;
            camera = findCamera();
        }
        _controls.camera = camera;
    }

    async function nodeFocused(e) {
        _controls.visible = false;
        if (e.name == 'Config') return;
        if (e.layoutInstance == _this.parent) {
            let layer = await _this.parent.getLayer(e.name);
            let group = layer.group || layer;
            if (!group || !group.updateMatrixWorld) return;
            _controls.attach(group);
            _attached = group;
            _controls.visible = true;
        }
    }

    //*** Public methods
});

Class(function SceneLayoutPreloader(_name) {
    Inherit(this, Component);
    const _this = this;

    //NOTE: Have to enable assets/geometry && assets/images in Tools/asset.js for this to work

    function findMatch(src) {
        if (!src) return false;
        src = src.trim();
        for (let i = ASSETS.length-1; i > -1; i--) {
            if (ASSETS[i].includes(src)) return true;
        }
        return false;
    }

    //*** Public methods
    this.load = function(name) {
        let promise = Promise.create();
        let array = [];
        let settings = {dxt: !!Renderer.extensions.s3tc, etc: !!Renderer.extensions.etc1, pvrtc: !!Renderer.extensions.pvrtc, astc: !!Renderer.extensions.astc};
        let ext;
        if (settings.dxt) ext = 'dxt';
        else if (settings.etc) ext = 'astc';
        else if (settings.pvrtc) ext = 'pvrtc';
        else if (settings.astc) ext = 'astc';

        let keys = UILStorage.getKeys();
        let i = 0;
        let worker = new Render.Worker(_ => {
            let key = keys[i];
            if (!key) {
                worker.stop();
                Promise.all(array).then(promise.resolve);
                return;
            }

            if (key.includes(name)) {
                let val = UILStorage.get(key);
                if (!val || !val.includes) return i++;

                if (key.includes('geometry')) {
                    if (val.charAt(0) == '{') val = JSON.parse(val).src;
                    if (!val.includes('.json') && !val.includes('.bin')) val += '.json';
                    if (!val.includes('assets/')) val = 'assets/geometry/' + val;
                    array.push(GeomThread.loadGeometry(Assets.getPath(val), null, true));
                }

                if (val.includes('.json') || val.includes('.bin')) {
                    if (!val.includes('assets/')) val = 'assets/geometry/' + val;
                    if (findMatch(val.split('assets/')[1])) array.push(fetch(Assets.getPath(val)).catch(e => {}));
                } else if (val.includes('src')) {
                    let obj = JSON.parse(val);
                    let src = obj.src;
                    if (obj.compressed) {
                        let src0 = src.split('.')[0];
                        let src1 = src0.split('/');
                        src = src0 + '/' + src1[src1.length-1] + '-' + ext + '.ktx';
                    }
                    if (findMatch(src.split('assets/')[1])) {
                        array.push(fetch(Assets.getPath(src)).catch(e => {}));
                    }
                }
            }
            i++;
        }, 1);

        return promise;
    }
}, 'static');
/**
 * @name Shaders
 * */

Class(function Shaders() {
    Inherit(this, Component);
    var _this = this;

    //*** Constructor
    (function () {

    })();

    function parseSingleShader(code, fileName) {
        let uniforms = code.split('#!UNIFORMS')[1].split('#!')[0];
        let varyings = code.split('#!VARYINGS')[1].split('#!')[0];
        let attributes = code.split('#!ATTRIBUTES')[1].split('#!')[0];

        while (code.includes('#!SHADER')) {
            code = code.slice(code.indexOf('#!SHADER'));
            let split = code.split('#!SHADER')[1];
            let br = split.indexOf('\n');
            let name = split.slice(0, br).split(': ')[1];

            if (name.slice(0, 6).includes('Vertex')) name = fileName.split('.')[0] + '.vs';
            if (name.slice(0, 8).includes('Fragment')) name = fileName.split('.')[0] + '.fs';

            let glsl = split.slice(br);
            if (name.includes('.vs')) glsl = attributes + uniforms + varyings + glsl;
            else glsl = uniforms + varyings + glsl;

            // Have to do this weird thing for chrome on windows in dev mode
            let splitName = name.split('.');
            _this[splitName[0] + (splitName[1].includes('vs') ? '.vs' : '.fs')] = glsl;

            code = code.replace('#!SHADER', '$');
        }
    }

    function parseCompiled(shaders) {
        var split = shaders.split('{@}');
        split.shift();

        for (var i = 0; i < split.length; i += 2) {
            var name = split[i];
            var text = split[i+1];
            if (text.includes('#!UNIFORMS')) {
                parseSingleShader(text, name);
            } else {
                _this[name] = text;
            }
        }
    }

    function parseRequirements() {
        for (var key in _this) {
            var obj = _this[key];
            if (typeof obj === 'string') {
                _this[key] = require(obj);
            }
        }
    }

    function require(shader) {
        if (!shader.includes('require')) return shader;

        shader = shader.replace(/# require/g, '#require');
        while (shader.includes('#require')) {
            var split = shader.split('#require(');
            var name = split[1].split(')')[0];
            name = name.replace(/ /g, '');

            if (!_this[name]) throw 'Shader required '+name+', but not found in compiled shaders.\n'+shader;

            shader = shader.replace('#require('+name+')', _this[name]);
        }

        return shader;
    }

    //*** Event handlers

    //*** Public methods
    this.parse = function(code, file) {
        if (!code.includes('{@}')) {
            file = file.split('/');
            file = file[file.length-1]; 

            _this[file] = code;
        } else {
            parseCompiled(code);
            parseRequirements();
        }

        _this.shadersParsed = true;
    }

    this.parseSingle = parseSingleShader;

    this.onReady = this.ready = function(callback) {
        let promise = Promise.create();
        if (callback) promise.then(callback);
        _this.wait(() => promise.resolve(), _this, 'shadersParsed');
        return promise;
    }

    this.getShader = function(string) {
        if (_this.FALLBACKS) {
            if (_this.FALLBACKS[string]) {
                string = _this.FALLBACKS[string];
            }
        }

        var code = _this[string];

        if (code) {
            while (code.includes('#test ')) {
                try {
                    var test = code.split('#test ')[1];
                    var name = test.split('\n')[0];
                    var glsl = code.split('#test ' + name + '\n')[1].split('#endtest')[0];

                    if (!eval(name)) {
                        code = code.replace(glsl, '');
                    }

                    code = code.replace('#test ' + name + '\n', '');
                    code = code.replace('#endtest', '');
                } catch (e) {
                    throw 'Error parsing test :: ' + string;
                }
            }
        } else {
            throw `No shader ${string} found`;
        }

        return code;
    }
}, 'static');
class CubicBezierCurve2D extends Curve3D {
    constructor(v0, v1, v2, v3) {
        super();
        this.type = 'CubicBezierCurve';
        this.v0 = v0 || new Vector2();
        this.v1 = v1 || new Vector2();
        this.v2 = v2 || new Vector2();
        this.v3 = v3 || new Vector2();
        this.isCubicBezierCurve = true;
    }

    getPoint(t, optionalTarget) {
        var point = optionalTarget || new Vector2();
        var v0 = this.v0, v1 = this.v1, v2 = this.v2, v3 = this.v3;

        const {CubicBezier} = require('Shape2DInterpolations');

        point.set(
            CubicBezier( t, v0.x, v1.x, v2.x, v3.x ),
            CubicBezier( t, v0.y, v1.y, v2.y, v3.y )
        );

        return point;
    }

    copy(source) {
        Curve3D.prototype.copy.call(this, source);
        this.v0.copy( source.v0 );
        this.v1.copy( source.v1 );
        this.v2.copy( source.v2 );
        this.v3.copy( source.v3 );
        return this;
    }

    let() {
        var data = Curve3D.prototype.let.call(this);

        data.v0 = this.v0.toArray();
        data.v1 = this.v1.toArray();
        data.v2 = this.v2.toArray();
        data.v3 = this.v3.toArray();

        return data;
    }

    fromJSON(json) {
        Curve.prototype.fromJSON.call( this, json );

        this.v0.fromArray( json.v0 );
        this.v1.fromArray( json.v1 );
        this.v2.fromArray( json.v2 );
        this.v3.fromArray( json.v3 );

        return this;
    }
}
class EllipseCurve extends Base3D {
    constructor(aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation) {
        super();

        this.type = 'EllipseCurve';

        this.aX = aX || 0;
        this.aY = aY || 0;

        this.xRadius = xRadius || 1;
        this.yRadius = yRadius || 1;

        this.aStartAngle = aStartAngle || 0;
        this.aEndAngle = aEndAngle || 2 * Math.PI;

        this.aClockwise = aClockwise || false;

        this.aRotation = aRotation || 0;
        this.isEllipseCurve = true;
    }

    getPoint(t, optionalTarget) {
        let point = optionalTarget || new Vector2();

        let twoPi = Math.PI * 2;
        let deltaAngle = this.aEndAngle - this.aStartAngle;
        let samePoints = Math.abs( deltaAngle ) < Number.EPSILON;

        // ensures that deltaAngle is 0 .. 2 PI
        while ( deltaAngle < 0 ) deltaAngle += twoPi;
        while ( deltaAngle > twoPi ) deltaAngle -= twoPi;

        if ( deltaAngle < Number.EPSILON ) {

            if ( samePoints ) {

                deltaAngle = 0;

            } else {

                deltaAngle = twoPi;

            }

        }

        if ( this.aClockwise === true && ! samePoints ) {

            if ( deltaAngle === twoPi ) {

                deltaAngle = - twoPi;

            } else {

                deltaAngle = deltaAngle - twoPi;

            }

        }

        let angle = this.aStartAngle + t * deltaAngle;
        let x = this.aX + this.xRadius * Math.cos( angle );
        let y = this.aY + this.yRadius * Math.sin( angle );

        if ( this.aRotation !== 0 ) {

            let cos = Math.cos( this.aRotation );
            let sin = Math.sin( this.aRotation );

            let tx = x - this.aX;
            let ty = y - this.aY;

            // Rotate the point about the center of the ellipse.
            x = tx * cos - ty * sin + this.aX;
            y = tx * sin + ty * cos + this.aY;

        }

        return point.set( x, y );
    }

    copy() {
        Curve3D.prototype.copy.call( this, source );

        this.aX = source.aX;
        this.aY = source.aY;

        this.xRadius = source.xRadius;
        this.yRadius = source.yRadius;

        this.aStartAngle = source.aStartAngle;
        this.aEndAngle = source.aEndAngle;

        this.aClockwise = source.aClockwise;

        this.aRotation = source.aRotation;

        return this;
    }

    toJSON() {
        let data = Curve3D.prototype.toJSON.call( this );

        data.aX = this.aX;
        data.aY = this.aY;

        data.xRadius = this.xRadius;
        data.yRadius = this.yRadius;

        data.aStartAngle = this.aStartAngle;
        data.aEndAngle = this.aEndAngle;

        data.aClockwise = this.aClockwise;

        data.aRotation = this.aRotation;

        return data;
    }

    fromJSON() {
        Curve3D.prototype.fromJSON.call( this, json );

        this.aX = json.aX;
        this.aY = json.aY;

        this.xRadius = json.xRadius;
        this.yRadius = json.yRadius;

        this.aStartAngle = json.aStartAngle;
        this.aEndAngle = json.aEndAngle;

        this.aClockwise = json.aClockwise;

        this.aRotation = json.aRotation;

        return this;
    }
}

class LineCurve extends Curve3D {
    constructor(v1, v2) {
        super();
        this.type = 'LineCurve';
        this.v1 = v1 || new Vector3();
        this.v2 = v2 || new Vector3();
        this.isLineCurve = true;
    }

    getPoint(t, optionalTarget) {
        var point = optionalTarget || new Vector3();

        if (t === 1) {

            point.copy(this.v2);

        } else {

            point.copy(this.v2).sub(this.v1);
            point.multiplyScalar(t).add(this.v1);

        }

        return point;
    }

    getPointAt(u, optionalTarget) {
        return this.getPoint(u, optionalTarget);
    }

    getTangent() {
        var tangent = this.v2.clone().sub(this.v1);
        return tangent.normalize();
    }

    copy(source) {
        Curve3D.prototype.copy.call(this, source);

        this.v1.copy(source.v1);
        this.v2.copy(source.v2);

        return this;
    }

    toJSON() {
        var data = Curve3D.prototype.toJSON.call(this);

        data.v1 = this.v1.toArray();
        data.v2 = this.v2.toArray();

        return data;
    }

    fromJSON(json) {
        Curve.prototype.fromJSON.call(this, json);
        this.v1.fromArray(json.v1);
        this.v2.fromArray(json.v2);
        return this;
    }
}
class QuadraticBezierCurve extends Curve3D {
    constructor(v0, v1, v2) {
        super();
        this.type = 'QuadraticBezierCurve';
        this.v0 = v0 || new Vector2();
        this.v1 = v1 || new Vector2();
        this.v2 = v2 || new Vector2();
        this.isQuadraticBezierCurve = true;
    }

    getPoint(t, optionalTarget = new Vector2()) {
        let point = optionalTarget || new Vector2();
        let v0 = this.v0, v1 = this.v1, v2 = this.v2;

        const {QuadraticBezier} = require('Shape2DInterpolations');

        point.set(
            QuadraticBezier( t, v0.x, v1.x, v2.x ),
            QuadraticBezier( t, v0.y, v1.y, v2.y )
        );

        return point;
    }

    copy(source) {
        Curve3D.prototype.copy.call(this, source);

        this.v0.copy( source.v0 );
        this.v1.copy( source.v1 );
        this.v2.copy( source.v2 );

        return this;
    }

    toJSON() {
        let data = Curve3D.prototype.toJSON.call(this);

        data.v0 = this.v0.toArray();
        data.v1 = this.v1.toArray();
        data.v2 = this.v2.toArray();

        return data;
    }

    fromJSON(json) {
        Curve3D.prototype.fromJSON.call(this, json);

        this.v0.fromArray(json.v0);
        this.v1.fromArray(json.v1);
        this.v2.fromArray(json.v2);

        return this;
    }
}
class SplineCurve extends Curve3D {
    constructor() {
        super();
        this.type = 'SplineCurve';
        this.points = points || [];
        this.isSplineCurve = true;
    }

    getPoint(t, optionalTarget) {
        let point = optionalTarget || new Vector2();

        let points = this.points;
        let p = ( points.length - 1 ) * t;

        let intPoint = Math.floor( p );
        let weight = p - intPoint;

        let p0 = points[ intPoint === 0 ? intPoint : intPoint - 1 ];
        let p1 = points[ intPoint ];
        let p2 = points[ intPoint > points.length - 2 ? points.length - 1 : intPoint + 1 ];
        let p3 = points[ intPoint > points.length - 3 ? points.length - 1 : intPoint + 2 ];

        point.set(
            CatmullRom( weight, p0.x, p1.x, p2.x, p3.x ),
            CatmullRom( weight, p0.y, p1.y, p2.y, p3.y )
        );

        return point;
    }

    copy(source) {
        Curve3D.prototype.copy.call( this, source );

        this.points = [];

        for ( let i = 0, l = source.points.length; i < l; i ++ ) {
            let point = source.points[ i ];
            this.points.push( point.clone() );
        }

        return this;
    }

    toJSON() {
        let data = Curve.prototype.toJSON.call( this );

        data.points = [];

        for ( let i = 0, l = this.points.length; i < l; i ++ ) {

            let point = this.points[ i ];
            data.points.push( point.toArray() );

        }

        return data;
    }

    fromJSON(json) {
        Curve.prototype.fromJSON.call( this, json );

        this.points = [];

        for ( let i = 0, l = json.points.length; i < l; i ++ ) {

            let point = json.points[ i ];
            this.points.push( new Vector2().fromArray( point ) );

        }

        return this;
    }
}
class ExtrudeGeometry extends Geometry {
    constructor(shapes, options = {}) {
        super();

        var WorldUVGenerator = {

            generateTopUV: function ( geometry, vertices, indexA, indexB, indexC ) {

                var a_x = vertices[ indexA * 3 ];
                var a_y = vertices[ indexA * 3 + 1 ];
                var a_y = vertices[ indexA * 3 + 1 ];
                var b_x = vertices[ indexB * 3 ];
                var b_y = vertices[ indexB * 3 + 1 ];
                var c_x = vertices[ indexC * 3 ];
                var c_y = vertices[ indexC * 3 + 1 ];

                return [
                    new Vector2( a_x, a_y ),
                    new Vector2( b_x, b_y ),
                    new Vector2( c_x, c_y )
                ];

            },

            generateSideWallUV: function ( geometry, vertices, indexA, indexB, indexC, indexD ) {

                var a_x = vertices[ indexA * 3 ];
                var a_y = vertices[ indexA * 3 + 1 ];
                var a_z = vertices[ indexA * 3 + 2 ];
                var b_x = vertices[ indexB * 3 ];
                var b_y = vertices[ indexB * 3 + 1 ];
                var b_z = vertices[ indexB * 3 + 2 ];
                var c_x = vertices[ indexC * 3 ];
                var c_y = vertices[ indexC * 3 + 1 ];
                var c_z = vertices[ indexC * 3 + 2 ];
                var d_x = vertices[ indexD * 3 ];
                var d_y = vertices[ indexD * 3 + 1 ];
                var d_z = vertices[ indexD * 3 + 2 ];

                if ( Math.abs( a_y - b_y ) < 0.01 ) {

                    return [
                        new Vector2( a_x, 1 - a_z ),
                        new Vector2( b_x, 1 - b_z ),
                        new Vector2( c_x, 1 - c_z ),
                        new Vector2( d_x, 1 - d_z )
                    ];

                } else {

                    return [
                        new Vector2( a_y, 1 - a_z ),
                        new Vector2( b_y, 1 - b_z ),
                        new Vector2( c_y, 1 - c_z ),
                        new Vector2( d_y, 1 - d_z )
                    ];

                }

            }
        }

        shapes = Array.isArray( shapes ) ? shapes : [ shapes ];

        var scope = this;
        var xcount = 0;
        var vals = [0, 1, 0, 1, 1, 0];

        var verticesArray = [];
        var uvArray = [];

        for ( var i = 0, l = shapes.length; i < l; i ++ ) {

            var shape = shapes[ i ];
            addShape( shape );

        }

        // build geometry

        this.addAttribute( 'position', new GeometryAttribute( new Float32Array(verticesArray), 3 ) );
        this.addAttribute( 'uv', new GeometryAttribute( new Float32Array(uvArray), 2 ) );

        if ( options.computeNormals === true ) this.computeVertexNormals();

        function addShape( shape ) {

            var placeholder = [];

            // options

            var curveSegments = options.curveSegments !== undefined ? options.curveSegments : 12;
            var steps = options.steps !== undefined ? options.steps : 1;
            var depth = options.depth !== undefined ? options.depth : 100;

            var bevelEnabled = options.bevelEnabled !== undefined ? options.bevelEnabled : true;
            var bevelThickness = options.bevelThickness !== undefined ? options.bevelThickness : 6;
            var bevelSize = options.bevelSize !== undefined ? options.bevelSize : bevelThickness - 2;
            var bevelOffset = options.bevelOffset !== undefined ? options.bevelOffset : 0;
            var bevelSegments = options.bevelSegments !== undefined ? options.bevelSegments : 3;

            var extrudePath = options.extrudePath;

            var uvgen = options.UVGenerator !== undefined ? options.UVGenerator : WorldUVGenerator;

            var extrudePts, extrudeByPath = false;
            var splineTube, binormal, normal, position2;

            if ( extrudePath ) {

                extrudePts = extrudePath.getSpacedPoints( steps );

                extrudeByPath = true;
                bevelEnabled = false; // bevels not supported for path extrusion

                // SETUP TNB variables

                // TODO1 - have a .isClosed in spline?

                splineTube = extrudePath.computeFrenetFrames( steps, false );

                // console.log(splineTube, 'splineTube', splineTube.normals.length, 'steps', steps, 'extrudePts', extrudePts.length);

                binormal = new Vector3();
                normal = new Vector3();
                position2 = new Vector3();

            }

            // Safeguards if bevels are not enabled

            if ( ! bevelEnabled ) {

                bevelSegments = 0;
                bevelThickness = 0;
                bevelSize = 0;
                bevelOffset = 0;

            }

            // Variables initialization

            var ahole, h, hl; // looping of holes

            var shapePoints = shape.extractPoints( curveSegments );

            var vertices = shapePoints.shape;
            var holes = shapePoints.holes;

            var reverse = ! ExtrudeUtils.isClockWise( vertices );

            if ( reverse ) {

                vertices = vertices.reverse();

                // Maybe we should also check if holes are in the opposite direction, just to be safe ...

                for ( h = 0, hl = holes.length; h < hl; h ++ ) {

                    ahole = holes[ h ];

                    if ( ExtrudeUtils.isClockWise( ahole ) ) {

                        holes[ h ] = ahole.reverse();

                    }

                }

            }


            var faces = ExtrudeUtils.triangulateShape( vertices, holes );

            /* Vertices */

            var contour = vertices; // vertices has all points but contour has only points of circumference

            for ( h = 0, hl = holes.length; h < hl; h ++ ) {

                ahole = holes[ h ];

                vertices = vertices.concat( ahole );

            }


            function scalePt2( pt, vec, size ) {

                if ( ! vec ) console.error( "ExtrudeGeometry: vec does not exist" );

                return vec.clone().multiplyScalar( size ).add( pt );

            }

            var b, bs, t, z,
                vert, vlen = vertices.length,
                face, flen = faces.length;


            // Find directions for point movement


            function getBevelVec( inPt, inPrev, inNext ) {

                // computes for inPt the corresponding point inPt' on a new contour
                //   shifted by 1 unit (length of normalized vector) to the left
                // if we walk along contour clockwise, this new contour is outside the old one
                //
                // inPt' is the intersection of the two lines parallel to the two
                //  adjacent edges of inPt at a distance of 1 unit on the left side.

                var v_trans_x, v_trans_y, shrink_by; // resulting translation vector for inPt

                // good reading for geometry algorithms (here: line-line intersection)
                // http://geomalgorithms.com/a05-_intersect-1.html

                var v_prev_x = inPt.x - inPrev.x,
                    v_prev_y = inPt.y - inPrev.y;
                var v_next_x = inNext.x - inPt.x,
                    v_next_y = inNext.y - inPt.y;

                var v_prev_lensq = ( v_prev_x * v_prev_x + v_prev_y * v_prev_y );

                // check for collinear edges
                var collinear0 = ( v_prev_x * v_next_y - v_prev_y * v_next_x );

                if ( Math.abs( collinear0 ) > Number.EPSILON ) {

                    // not collinear

                    // length of vectors for normalizing

                    var v_prev_len = Math.sqrt( v_prev_lensq );
                    var v_next_len = Math.sqrt( v_next_x * v_next_x + v_next_y * v_next_y );

                    // shift adjacent points by unit vectors to the left

                    var ptPrevShift_x = ( inPrev.x - v_prev_y / v_prev_len );
                    var ptPrevShift_y = ( inPrev.y + v_prev_x / v_prev_len );

                    var ptNextShift_x = ( inNext.x - v_next_y / v_next_len );
                    var ptNextShift_y = ( inNext.y + v_next_x / v_next_len );

                    // scaling factor for v_prev to intersection point

                    var sf = ( ( ptNextShift_x - ptPrevShift_x ) * v_next_y -
                        ( ptNextShift_y - ptPrevShift_y ) * v_next_x ) /
                        ( v_prev_x * v_next_y - v_prev_y * v_next_x );

                    // vector from inPt to intersection point

                    v_trans_x = ( ptPrevShift_x + v_prev_x * sf - inPt.x );
                    v_trans_y = ( ptPrevShift_y + v_prev_y * sf - inPt.y );

                    // Don't normalize!, otherwise sharp corners become ugly
                    //  but prevent crazy spikes
                    var v_trans_lensq = ( v_trans_x * v_trans_x + v_trans_y * v_trans_y );
                    if ( v_trans_lensq <= 2 ) {

                        return new Vector2( v_trans_x, v_trans_y );

                    } else {

                        shrink_by = Math.sqrt( v_trans_lensq / 2 );

                    }

                } else {

                    // handle special case of collinear edges

                    var direction_eq = false; // assumes: opposite
                    if ( v_prev_x > Number.EPSILON ) {

                        if ( v_next_x > Number.EPSILON ) {

                            direction_eq = true;

                        }

                    } else {

                        if ( v_prev_x < - Number.EPSILON ) {

                            if ( v_next_x < - Number.EPSILON ) {

                                direction_eq = true;

                            }

                        } else {

                            if ( Math.sign( v_prev_y ) === Math.sign( v_next_y ) ) {

                                direction_eq = true;

                            }

                        }

                    }

                    if ( direction_eq ) {

                        // console.log("Warning: lines are a straight sequence");
                        v_trans_x = - v_prev_y;
                        v_trans_y = v_prev_x;
                        shrink_by = Math.sqrt( v_prev_lensq );

                    } else {

                        // console.log("Warning: lines are a straight spike");
                        v_trans_x = v_prev_x;
                        v_trans_y = v_prev_y;
                        shrink_by = Math.sqrt( v_prev_lensq / 2 );

                    }

                }

                return new Vector2( v_trans_x / shrink_by, v_trans_y / shrink_by );

            }


            var contourMovements = [];

            for ( var i = 0, il = contour.length, j = il - 1, k = i + 1; i < il; i ++, j ++, k ++ ) {

                if ( j === il ) j = 0;
                if ( k === il ) k = 0;

                //  (j)---(i)---(k)
                // console.log('i,j,k', i, j , k)

                contourMovements[ i ] = getBevelVec( contour[ i ], contour[ j ], contour[ k ] );

            }

            var holesMovements = [],
                oneHoleMovements, verticesMovements = contourMovements.concat();

            for ( h = 0, hl = holes.length; h < hl; h ++ ) {

                ahole = holes[ h ];

                oneHoleMovements = [];

                for ( i = 0, il = ahole.length, j = il - 1, k = i + 1; i < il; i ++, j ++, k ++ ) {

                    if ( j === il ) j = 0;
                    if ( k === il ) k = 0;

                    //  (j)---(i)---(k)
                    oneHoleMovements[ i ] = getBevelVec( ahole[ i ], ahole[ j ], ahole[ k ] );

                }

                holesMovements.push( oneHoleMovements );
                verticesMovements = verticesMovements.concat( oneHoleMovements );

            }


            // Loop bevelSegments, 1 for the front, 1 for the back

            for ( b = 0; b < bevelSegments; b ++ ) {

                //for ( b = bevelSegments; b > 0; b -- ) {

                t = b / bevelSegments;
                z = bevelThickness * Math.cos( t * Math.PI / 2 );
                bs = bevelSize * Math.sin( t * Math.PI / 2 ) + bevelOffset;

                // contract shape

                for ( i = 0, il = contour.length; i < il; i ++ ) {

                    vert = scalePt2( contour[ i ], contourMovements[ i ], bs );

                    v( vert.x, vert.y, - z );

                }

                // expand holes

                for ( h = 0, hl = holes.length; h < hl; h ++ ) {

                    ahole = holes[ h ];
                    oneHoleMovements = holesMovements[ h ];

                    for ( i = 0, il = ahole.length; i < il; i ++ ) {

                        vert = scalePt2( ahole[ i ], oneHoleMovements[ i ], bs );

                        v( vert.x, vert.y, - z );

                    }

                }

            }

            bs = bevelSize + bevelOffset;

            // Back facing vertices

            for ( i = 0; i < vlen; i ++ ) {

                vert = bevelEnabled ? scalePt2( vertices[ i ], verticesMovements[ i ], bs ) : vertices[ i ];

                if ( ! extrudeByPath ) {

                    v( vert.x, vert.y, 0 );

                } else {

                    // v( vert.x, vert.y + extrudePts[ 0 ].y, extrudePts[ 0 ].x );

                    normal.copy( splineTube.normals[ 0 ] ).multiplyScalar( vert.x );
                    binormal.copy( splineTube.binormals[ 0 ] ).multiplyScalar( vert.y );

                    position2.copy( extrudePts[ 0 ] ).add( normal ).add( binormal );

                    v( position2.x, position2.y, position2.z );

                }

            }

            // Add stepped vertices...
            // Including front facing vertices

            var s;

            for ( s = 1; s <= steps; s ++ ) {

                for ( i = 0; i < vlen; i ++ ) {

                    vert = bevelEnabled ? scalePt2( vertices[ i ], verticesMovements[ i ], bs ) : vertices[ i ];

                    if ( ! extrudeByPath ) {

                        v( vert.x, vert.y, depth / steps * s );

                    } else {

                        // v( vert.x, vert.y + extrudePts[ s - 1 ].y, extrudePts[ s - 1 ].x );

                        normal.copy( splineTube.normals[ s ] ).multiplyScalar( vert.x );
                        binormal.copy( splineTube.binormals[ s ] ).multiplyScalar( vert.y );

                        position2.copy( extrudePts[ s ] ).add( normal ).add( binormal );

                        v( position2.x, position2.y, position2.z );

                    }

                }

            }


            // Add bevel segments planes

            //for ( b = 1; b <= bevelSegments; b ++ ) {
            for ( b = bevelSegments - 1; b >= 0; b -- ) {

                t = b / bevelSegments;
                z = bevelThickness * Math.cos( t * Math.PI / 2 );
                bs = bevelSize * Math.sin( t * Math.PI / 2 ) + bevelOffset;

                // contract shape

                for ( i = 0, il = contour.length; i < il; i ++ ) {

                    vert = scalePt2( contour[ i ], contourMovements[ i ], bs );
                    v( vert.x, vert.y, depth + z );

                }

                // expand holes

                for ( h = 0, hl = holes.length; h < hl; h ++ ) {

                    ahole = holes[ h ];
                    oneHoleMovements = holesMovements[ h ];

                    for ( i = 0, il = ahole.length; i < il; i ++ ) {

                        vert = scalePt2( ahole[ i ], oneHoleMovements[ i ], bs );

                        if ( ! extrudeByPath ) {

                            v( vert.x, vert.y, depth + z );

                        } else {

                            v( vert.x, vert.y + extrudePts[ steps - 1 ].y, extrudePts[ steps - 1 ].x + z );

                        }

                    }

                }

            }

            /* Faces */

            // Top and bottom faces

            buildLidFaces();

            // Sides faces

            buildSideFaces();


            /////  Internal functions

            function buildLidFaces() {

                var start = verticesArray.length / 3;

                if ( bevelEnabled ) {

                    var layer = 0; // steps + 1
                    var offset = vlen * layer;

                    // Bottom faces

                    for ( i = 0; i < flen; i ++ ) {

                        face = faces[ i ];
                        f3( face[ 2 ] + offset, face[ 1 ] + offset, face[ 0 ] + offset );

                    }

                    layer = steps + bevelSegments * 2;
                    offset = vlen * layer;

                    // Top faces

                    for ( i = 0; i < flen; i ++ ) {

                        face = faces[ i ];
                        f3( face[ 0 ] + offset, face[ 1 ] + offset, face[ 2 ] + offset );

                    }

                } else {

                    // Bottom faces

                    for ( i = 0; i < flen; i ++ ) {

                        face = faces[ i ];
                        f3( face[ 2 ], face[ 1 ], face[ 0 ] );

                    }

                    // Top faces

                    for ( i = 0; i < flen; i ++ ) {

                        face = faces[ i ];
                        f3( face[ 0 ] + vlen * steps, face[ 1 ] + vlen * steps, face[ 2 ] + vlen * steps );

                    }

                }

                // scope.addGroup( start, verticesArray.length / 3 - start, 0 );

            }

            // Create faces for the z-sides of the shape

            function buildSideFaces() {

                var start = verticesArray.length / 3;
                var layeroffset = 0;
                sidewalls( contour, layeroffset );
                layeroffset += contour.length;

                for ( h = 0, hl = holes.length; h < hl; h ++ ) {

                    ahole = holes[ h ];
                    sidewalls( ahole, layeroffset );

                    //, true
                    layeroffset += ahole.length;

                }


                // scope.addGroup( start, verticesArray.length / 3 - start, 1 );


            }

            function sidewalls( contour, layeroffset ) {

                var j, k;
                i = contour.length;

                while ( -- i >= 0 ) {

                    j = i;
                    k = i - 1;
                    if ( k < 0 ) k = contour.length - 1;

                    //console.log('b', i,j, i-1, k,vertices.length);

                    var s = 0,
                        sl = steps + bevelSegments * 2;

                    for ( s = 0; s < sl; s ++ ) {

                        var slen1 = vlen * s;
                        var slen2 = vlen * ( s + 1 );

                        var a = layeroffset + j + slen1,
                            b = layeroffset + k + slen1,
                            c = layeroffset + k + slen2,
                            d = layeroffset + j + slen2;

                        f4( a, b, c, d );

                    }

                }

            }

            function v( x, y, z ) {

                placeholder.push( x );
                placeholder.push( y );
                placeholder.push( z );

            }


            function f3( a, b, c ) {

                addVertex( a );
                addVertex( b );
                addVertex( c );

                var nextIndex = verticesArray.length / 3;
                var uvs = uvgen.generateTopUV( scope, verticesArray, nextIndex - 3, nextIndex - 2, nextIndex - 1 );

                addUV( uvs[ 0 ] );
                addUV( uvs[ 1 ] );
                addUV( uvs[ 2 ] );

            }

            function f4( a, b, c, d ) {

                addVertex( a );
                addVertex( b );
                addVertex( d );

                addVertex( b );
                addVertex( c );
                addVertex( d );


                var nextIndex = verticesArray.length / 3;
                var uvs = uvgen.generateSideWallUV( scope, verticesArray, nextIndex - 6, nextIndex - 3, nextIndex - 2, nextIndex - 1 );

                addUV( uvs[ 0 ] );
                addUV( uvs[ 1 ] );
                addUV( uvs[ 3 ] );

                addUV( uvs[ 1 ] );
                addUV( uvs[ 2 ] );
                addUV( uvs[ 3 ] );

            }

            function addVertex( index ) {

                verticesArray.push( placeholder[ index * 3 + 0 ] );
                verticesArray.push( placeholder[ index * 3 + 1 ] );
                verticesArray.push( placeholder[ index * 3 + 2 ] );

            }


            function addUV( vector2 ) {
                let index = xcount++ % vals.length;

                uvArray.push( vals[index] );
                uvArray.push( vector2.y );

            }

        }
    }
}

Class(function ExtrudeUtils() {
    Inherit(this, Component);
    const _this = this;

    (async function() {
        if (!window.THREAD) {
            await Hydra.ready();
            Thread.shared(true).array.forEach(thread => {
                Curve.loadOnThread(thread);
                [
                    'CurvePath', 'Path', 'Shape', 'LineCurve', 'ExtrudeGeometry'
                ].forEach(name => {
                    thread.importES6Class(name);
                })

                thread.importClass(Curve);
                thread.importClass(LinkedList);
                thread.importCode(`Class(${_this.constructor.toString()}, 'static')`);
                thread.importCode(`Class(${Earcut.constructor.toString()}, 'static')`);
            });
        }
    })();


    function removeDupEndPts( points ) {

        let l = points.length;

        if ( l > 2 && points[ l - 1 ].equals( points[ 0 ] ) ) {

            points.pop();

        }

    }

    function addContour( vertices, contour ) {

        for ( let i = 0; i < contour.length; i ++ ) {

            vertices.push( contour[ i ].x );
            vertices.push( contour[ i ].y );

        }

    }


    //*** Event handlers

    //*** Public methods
    this.area = function(contour) {
        let n = contour.length;
        let a = 0.0;

        for ( let p = n - 1, q = 0; q < n; p = q ++ ) {

            a += contour[ p ].x * contour[ q ].y - contour[ q ].x * contour[ p ].y;

        }

        return a * 0.5;
    }

    this.isClockWise = function(pts) {
        return _this.area( pts ) < 0;
    }

    this.triangulateShape = function(contour, holes) {
        let vertices = []; // flat array of vertices like [ x0,y0, x1,y1, x2,y2, ... ]
        let holeIndices = []; // array of hole indices
        let faces = []; // final array of vertex indices like [ [ a,b,d ], [ b,c,d ] ]

        removeDupEndPts( contour );
        addContour( vertices, contour );

        //

        let holeIndex = contour.length;

        holes.forEach( removeDupEndPts );

        for ( let i = 0; i < holes.length; i ++ ) {

            holeIndices.push( holeIndex );
            holeIndex += holes[ i ].length;
            addContour( vertices, holes[ i ] );

        }

        //

        let triangles = Earcut.triangulate( vertices, holeIndices );

        //

        for ( let i = 0; i < triangles.length; i += 3 ) {

            faces.push( triangles.slice( i, i + 3 ) );

        }

        return faces;
    }
}, 'static');
class GLUIShape extends GLUIObject {
    constructor() {
        super(1, 1);

        if (!GLUIShape.emptyShape) GLUIShape.emptyShape = new Shape();
        if (!GLUIShape.antialias) GLUIShape.antialias = 1;

        let geom = new ShapeGeometry(GLUIShape.emptyShape, 24);
        this.geom = geom;
        this.msaa = 1;
        this.useGeometry(geom);

        this.fillColor = new Color();
        this.commands = [];
        this.holes = new GLUIShapeHoles();
        this.subdivisions = 24;

        let shader = new Shader('GLUIShape', {
            uColor: {value: this.fillColor}
        });
        this.useShader(shader);
    }

    beginPath() {
        this.commands.length = 0;
    }

    moveTo(x, y) {
        this.commands.push(['moveTo', x, -y]);
    }

    lineTo(x, y) {
        this.commands.push(['lineTo', x, -y]);
    }

    quadraticCurveTo(aCPx, aCPy, aX, aY) {
        this.commands.push(['quadraticCurveTo', aCPx, -aCPy, aX, -aY]);
    }

    bezierCurveTo(aCP1x, aCP1y, aCP2x, aCP2y, aX, aY) {
        this.commands.push(['bezierCurveTo', aCP1x, -aCP1y, aCP2x, -aCP2y, aX, -aY]);
    }

    arc(aX, aY, aRadius, aStartAngle, aEndAngle, aClockwise) {
        this.commands.push(['arc', aX, -aY, aRadius, aStartAngle, aEndAngle, aClockwise]);
    }

    endPath() {
        const _this = this;
        _this._promise = ShapeUtils.process(this).then(_ => {
            let shape;
            let p = _this.parent;
            while (p) {
                if (p instanceof GLUIShape) shape = p;
                p = p.parent;
            }
            shape && shape._notifyParentUpdate();
            if (_this.update) _this.update();
        });
        return _this._promise;
    }

    create() {
        let $obj = $glShape();
        this.add($obj);
        return $obj;
    }

    _notifyParentUpdate() {
        if (this._cacheAsBitmap) this.bitmap.update();
    }

    set cacheAsBitmap(bool) {
        this._cacheAsBitmap = bool;
        if (bool) {
            if (!this.bitmap) this.bitmap = new GLUIShapeBitmap(this);
            this.bitmap.show();
        } else {
            // if (this.bitmap) this.bitmap.hide();
        }
    }

    get mask() {
        if (!this._mask) {
            this._mask = new GLUIShapeMask(this);
            this.cacheAsBitmap = true;
            this.bitmap.mask = this._mask;
        }

        return this._mask;
    }

    async ready() {
        return this._promise;
    }

    async loaded() {
        return this._promise;
    }
}
class GLUIShapeBitmap {
    constructor(shape) {
        this.shape = shape;
        this.rt = Utils3D.createRT(100, 100, null, Texture.RGBAFormat);
        this.camera = new OrthographicCamera();
        this.scene = new Scene();
        this.wrapper = new Group();
        this.scene.add(this.wrapper);

        this.quad = $gl(100, 100, this.rt);
        this.shape.add(this.quad);

        this.shader = new Shader('GLUIShapeBitmap', {
            tMask: {value: Utils3D.getTexture('assets/images/_scenelayout/mask.jpg')}
        });
        this.quad.useShader(this.shader);
    }

    hide() {
        let _this = this;
        this.quad.hide();
        this.shape.children.forEach(child => {
            if (child != _this.quad) this.shape.group.add(child.group);
        });
    }

    show() {
        let _this = this;
        this.quad.show();
        this.shape.children.forEach(child => {
            if (child != _this.quad) this.wrapper.add(child.group);
        });
    }

    update() {
        this.scene.position.set(0, 0, 0);
        this.scene.updateMatrixWorld(true);

        let scale = World.DPR * GLUIShape.antialias;

        let bb = new Box3();
        bb.setFromObject(this.wrapper);
        let width = bb.max.x - bb.min.x;
        let height = -(bb.min.y - bb.max.y);
        this.rt.setSize(width * scale, height * scale);

        this.quad.width = width;
        this.quad.height = height;

        this.camera.setViewport(width, height);
        this.camera.position.x = width/2;
        this.camera.position.y = -height/2;
        this.camera.updateMatrixWorld(true);

        const _this = this;
        let x = 9999;
        let y = 9999;
        this.shape.children.forEach(child => {
            if (child == _this.quad) return;
            child.mesh.onBeforeRender && child.mesh.onBeforeRender();
            let worldPos = child.mesh.getWorldPosition();
            x = Math.min(x, worldPos.x);
            y = Math.min(y, -worldPos.y);
        });

        this.scene.position.set(-x, y, 0);

        this.quad.x = x;
        this.quad.y = -y;

        let clearAlpha = World.RENDERER.getClearAlpha();
        World.RENDERER.setClearAlpha(0);
        World.RENDERER.render(this.scene, this.camera, this.rt);
        World.RENDERER.setClearAlpha(clearAlpha);

        if (this.mask) this.mask.update();
    }
}
class GLUIShapeHoles {
    constructor() {
        this.commands = [];
    }

    beginPath() {
        this.commands.length = 0;
    }

    moveTo(x, y) {
        this.commands.push(['moveTo', x, -y]);
    }

    lineTo(x, y) {
        this.commands.push(['lineTo', x, -y]);
    }

    quadraticCurveTo(aCPx, aCPy, aX, aY) {
        this.commands.push(['quadraticCurveTo', aCPx, -aCPy, aX, -aY]);
    }

    bezierCurveTo(aCP1x, aCP1y, aCP2x, aCP2y, aX, aY) {
        this.commands.push(['bezierCurveTo', aCP1x, -aCP1y, aCP2x, -aCP2y, aX, -aY]);
    }

    arc(aX, aY, aRadius, aStartAngle, aEndAngle, aClockwise) {
        this.commands.push(['arc', aX, -aY, aRadius, aStartAngle, aEndAngle, aClockwise]);
    }

    endPath() {
        this.commands.push(['endPath']);
    }
}
class GLUIShapeMask extends GLUIShape {
    constructor(shape) {
        super();
        this.shape = shape;
        this.rt = Utils3D.createRT(100, 100, null, Texture.RGBAFormat);
        this.scene = new Scene();
        this.scene.add(this.group);

        this.mesh.frustumCulled = false;

        this.__internalDirty = this.update;
    }

    update() {
        let {x, y} = this.shape.bitmap.quad;

        this.scene.position.set(0, 0, 0);
        this.scene.updateMatrixWorld(true);

        this.rt.setSize(this.shape.bitmap.rt.width, this.shape.bitmap.rt.height);

        this.scene.position.set(-x, 0, 0);

        let clearAlpha = World.RENDERER.getClearAlpha();
        World.RENDERER.setClearAlpha(0);
        World.RENDERER.render(this.scene, this.shape.bitmap.camera, this.rt);
        World.RENDERER.setClearAlpha(clearAlpha);

        this.shape.bitmap.shader.set('tMask', this.rt);
    }

    clear() {
        this.shape.bitmap.shader.set('tMask', Utils3D.getTexture('assets/images/_scenelayout/mask.jpg'));
        this.rt.destroy();
        this.shape._mask = null;
    }
}
class CurvePath extends Curve3D {
    constructor() {
        super();
        this.curves = [];
        this.autoClose = false;
    }

    add(curve) {
        this.curves.push(curve);
    }

    closePath() {
        let startPoint = this.curves[0].getPoint(0);
        let endPoint = this.curves[this.curves.length - 1].getPoint(1);

        if (!startPoint.equals(endPoint)) {
            this.curves.push(new LineCurve(endPoint, startPoint));
        }
    }

    getPoint(t) {
        let d = t * this.getLength();
        let curveLengths = this.getCurveLengths();
        let i = 0;

        while ( i < curveLengths.length ) {

            if ( curveLengths[ i ] >= d ) {

                let diff = curveLengths[ i ] - d;
                let curve = this.curves[ i ];

                let segmentLength = curve.getLength();
                let u = segmentLength === 0 ? 0 : 1 - diff / segmentLength;

                return curve.getPointAt( u );

            }

            i ++;

        }

        return null;
    }

    getLength() {
        let lens = this.getCurveLengths();
        return lens[ lens.length - 1 ];
    }

    updateArcLengths() {
        this.needsUpdate = true;
        this.cacheLengths = null;
        this.getCurveLengths();
    }

    getCurveLengths() {
        if ( this.cacheLengths && this.cacheLengths.length === this.curves.length ) {
            return this.cacheLengths;
        }

        let lengths = [], sums = 0;

        for ( let i = 0, l = this.curves.length; i < l; i ++ ) {

            sums += this.curves[ i ].getLength();
            lengths.push( sums );

        }

        this.cacheLengths = lengths;

        return lengths;
    }

    getSpacedPoints(divisions) {
        if ( divisions === undefined ) divisions = 40;

        let points = [];

        for ( let i = 0; i <= divisions; i ++ ) {

            points.push( this.getPoint( i / divisions ) );

        }

        if ( this.autoClose ) {

            points.push( points[ 0 ] );

        }

        return points;
    }

    getPoints(divisions = 12) {
        let points = [], last;

        for ( let i = 0, curves = this.curves; i < curves.length; i ++ ) {

            let curve = curves[ i ];
            let resolution = ( curve && curve.isEllipseCurve ) ? divisions * 2
                : ( curve && ( curve.isLineCurve || curve.isLineCurve3 ) ) ? 1
                    : ( curve && curve.isSplineCurve ) ? divisions * curve.points.length
                        : divisions;

            let pts = curve.getPoints( resolution );

            for ( let j = 0; j < pts.length; j ++ ) {

                let point = pts[ j ];

                if (!point.z) point.z = 0;

                if ( last && last.equals( point ) ) continue; // ensures no consecutive points are duplicates

                points.push( point );
                last = point;

            }

        }

        if ( this.autoClose && points.length > 1 && ! points[ points.length - 1 ].equals( points[ 0 ] ) ) {

            points.push( points[ 0 ] );

        }

        return points;
    }

    copy(source) {
        Curve3D.prototype.copy.call( this, source );

        this.curves = [];

        for ( let i = 0, l = source.curves.length; i < l; i ++ ) {

            let curve = source.curves[ i ];

            this.curves.push( curve.clone() );

        }

        this.autoClose = source.autoClose;

        return this;
    }

    toJSON() {
        let data = Curve3D.prototype.toJSON.call( this );

        data.autoClose = this.autoClose;
        data.curves = [];

        for ( let i = 0, l = this.curves.length; i < l; i ++ ) {

            let curve = this.curves[ i ];
            data.curves.push( curve.toJSON() );

        }

        return data;
    }

    fromJSON(json) {
        Curve3D.prototype.fromJSON.call( this, json );

        this.autoClose = json.autoClose;
        this.curves = [];

        for ( let i = 0, l = json.curves.length; i < l; i ++ ) {

            let curve = json.curves[ i ];
            this.curves.push( new Curves[ curve.type ]().fromJSON( curve ) );

        }

        return this;
    }
}

class Path extends CurvePath {
    constructor(points) {
        super();
        this.type = 'Path';
        this.currentPoint = new Vector2();
        if (points) this.setFromPoints(points);
    }

    setFromPoints(points) {
        this.moveTo( points[ 0 ].x, points[ 0 ].y );
        for ( let i = 1, l = points.length; i < l; i ++ ) {
            this.lineTo( points[ i ].x, points[ i ].y );
        }
    }

    moveTo(x, y) {
        this.currentPoint.set( x, y );
    }

    lineTo(x, y) {
        let curve = new LineCurve( this.currentPoint.clone(), new Vector2( x, y ) );
        this.curves.push( curve );
        this.currentPoint.set( x, y );
    }

    quadraticCurveTo(aCPx, aCPy, aX, aY) {
        let curve = new QuadraticBezierCurve(
            this.currentPoint.clone(),
            new Vector2( aCPx, aCPy ),
            new Vector2( aX, aY )
        );

        this.curves.push( curve );
        this.currentPoint.set( aX, aY );
    }

    bezierCurveTo(aCP1x, aCP1y, aCP2x, aCP2y, aX, aY) {
        let curve = new CubicBezierCurve2D(
            this.currentPoint.clone(),
            new Vector2( aCP1x, aCP1y ),
            new Vector2( aCP2x, aCP2y ),
            new Vector2( aX, aY )
        );

        this.curves.push( curve );
        this.currentPoint.set( aX, aY );
    }

    splineThru(pts) {
        let npts = [ this.currentPoint.clone() ].concat( pts );

        let curve = new SplineCurve( npts );
        this.curves.push( curve );

        this.currentPoint.copy( pts[ pts.length - 1 ] );
    }

    arc(aX, aY, aRadius, aStartAngle, aEndAngle, aClockwise) {
        let x0 = this.currentPoint.x;
        let y0 = this.currentPoint.y;

        this.absarc( aX + x0, aY + y0, aRadius,
            aStartAngle, aEndAngle, aClockwise );
    }

    absarc(aX, aY, aRadius, aStartAngle, aEndAngle, aClockwise) {
        this.absellipse( aX, aY, aRadius, aRadius, aStartAngle, aEndAngle, aClockwise );
    }

    ellipse(aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation) {
        let x0 = this.currentPoint.x;
        let y0 = this.currentPoint.y;
        this.absellipse( aX + x0, aY + y0, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation );
    }

    absellipse(aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation) {
        let curve = new EllipseCurve( aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation );

        if ( this.curves.length > 0 ) {
            // if a previous curve is present, attempt to join
            let firstPoint = curve.getPoint( 0 );
            if ( ! firstPoint.equals( this.currentPoint ) ) {
                this.lineTo( firstPoint.x, firstPoint.y );

            }
        }

        this.curves.push( curve );

        let lastPoint = curve.getPoint( 1 );
        this.currentPoint.copy( lastPoint );
    }

    copy(source) {
        CurvePath.prototype.copy.call( this, source );
        this.currentPoint.copy( source.currentPoint );
        return this;
    }

    toJSON() {
        let data = CurvePath.prototype.toJSON.call( this );
        data.currentPoint = this.currentPoint.toArray();
        return data;
    }

    fromJSON(json) {
        CurvePath.prototype.fromJSON.call( this, json );
        this.currentPoint.fromArray( json.currentPoint );
        return this;
    }
}
class Shape extends Path {
    constructor(points) {
        super(points);
        this.type = 'Shape';
        this.holes = [];
    }

    getPointsHoles(divisions) {
        let holesPts = [];
        for ( let i = 0, l = this.holes.length; i < l; i ++ ) {
            holesPts[ i ] = this.holes[ i ].getPoints( divisions );
        }

        return holesPts;
    }

    extractPoints(divisions) {
        return {
            shape: this.getPoints( divisions ),
            holes: this.getPointsHoles( divisions )
        };
    }

    copy(source) {
        Path.prototype.copy.call( this, source );

        this.holes = [];

        for ( let i = 0, l = source.holes.length; i < l; i ++ ) {

            let hole = source.holes[ i ];

            this.holes.push( hole.clone() );

        }

        return this;
    }

    toJSON() {
        let data = Path.prototype.toJSON.call( this );

        data.holes = [];

        for ( let i = 0, l = this.holes.length; i < l; i ++ ) {

            let hole = this.holes[ i ];
            data.holes.push( hole.toJSON() );

        }

        return data;
    }

    fromJSON(json) {
        Path.prototype.fromJSON.call( this, json );

        this.holes = [];

        for ( let i = 0, l = json.holes.length; i < l; i ++ ) {

            let hole = json.holes[ i ];
            this.holes.push( new Path().fromJSON( hole ) );

        }

        return this;
    }
}


class ShapeGeometry extends Geometry {
    constructor(shapes, curveSegments) {
        super();
        this.type = 'ShapeGeometry';
        this.parameters = {
            shapes: shapes,
            curveSegments: curveSegments
        };

        let indices = [];
        let vertices = [];
        // let normals = [];

        // helper letiables


        // allow single and array values for "shapes" parameter

        if ( Array.isArray( shapes ) === false ) {

            addShape( shapes );

        } else {

            for ( let i = 0; i < shapes.length; i ++ ) {

                addShape( shapes[ i ] );

            }

        }

        // build geometry

        this.index = new (Geometry.arrayNeedsUint32(indices) ? Uint32Array : Uint16Array)(indices);
        this.addAttribute( 'position', new GeometryAttribute( new Float32Array(vertices), 3 ) );
        // this.addAttribute( 'normal', new GeometryAttribute( new Float32Array(normals), 3 ) );


        // helper functions

        function addShape( shape ) {

            let i, l, shapeHole;

            let indexOffset = vertices.length / 3;
            let points = shape.extractPoints( curveSegments );

            let shapeVertices = points.shape;
            let shapeHoles = points.holes;

            // check direction of vertices

            if ( ShapeUtils.isClockWise( shapeVertices ) === false ) {

                shapeVertices = shapeVertices.reverse();

            }

            for ( i = 0, l = shapeHoles.length; i < l; i ++ ) {

                shapeHole = shapeHoles[ i ];

                if ( ShapeUtils.isClockWise( shapeHole ) === true ) {

                    shapeHoles[ i ] = shapeHole.reverse();

                }

            }

            let faces = ShapeUtils.triangulateShape( shapeVertices, shapeHoles );

            // join vertices of inner and outer paths to a single array

            for ( i = 0, l = shapeHoles.length; i < l; i ++ ) {

                shapeHole = shapeHoles[ i ];
                shapeVertices = shapeVertices.concat( shapeHole );

            }

            // vertices, normals, uvs

            for ( i = 0, l = shapeVertices.length; i < l; i ++ ) {

                let vertex = shapeVertices[ i ];

                vertices.push( vertex.x, vertex.y, 0 );
                // normals.push( 0, 0, 1 );

            }

            // incides

            for ( i = 0, l = faces.length; i < l; i ++ ) {

                let face = faces[ i ];

                let a = face[ 0 ] + indexOffset;
                let b = face[ 1 ] + indexOffset;
                let c = face[ 2 ] + indexOffset;

                indices.push( a, b, c );

            }

        }
    }
}
Class(function Earcut() {
    Inherit(this, Component);
    const _this = this;

    function linkedList( data, start, end, dim, clockwise ) {

        var i, last;

        if ( clockwise === ( signedArea( data, start, end, dim ) > 0 ) ) {

            for ( i = start; i < end; i += dim ) last = insertNode( i, data[ i ], data[ i + 1 ], last );

        } else {

            for ( i = end - dim; i >= start; i -= dim ) last = insertNode( i, data[ i ], data[ i + 1 ], last );

        }

        if ( last && equals( last, last.next ) ) {

            removeNode( last );
            last = last.next;

        }

        return last;

    }

// eliminate colinear or duplicate points
    function filterPoints( start, end ) {

        if ( ! start ) return start;
        if ( ! end ) end = start;

        var p = start,
            again;
        do {

            again = false;

            if ( ! p.steiner && ( equals( p, p.next ) || area( p.prev, p, p.next ) === 0 ) ) {

                removeNode( p );
                p = end = p.prev;
                if ( p === p.next ) break;
                again = true;

            } else {

                p = p.next;

            }

        } while ( again || p !== end );

        return end;

    }

// main ear slicing loop which triangulates a polygon (given as a linked list)
    function earcutLinked( ear, triangles, dim, minX, minY, invSize, pass ) {

        if ( ! ear ) return;

        // interlink polygon nodes in z-order
        if ( ! pass && invSize ) indexCurve( ear, minX, minY, invSize );

        var stop = ear,
            prev, next;

        // iterate through ears, slicing them one by one
        while ( ear.prev !== ear.next ) {

            prev = ear.prev;
            next = ear.next;

            if ( invSize ? isEarHashed( ear, minX, minY, invSize ) : isEar( ear ) ) {

                // cut off the triangle
                triangles.push( prev.i / dim );
                triangles.push( ear.i / dim );
                triangles.push( next.i / dim );

                removeNode( ear );

                // skipping the next vertex leads to less sliver triangles
                ear = next.next;
                stop = next.next;

                continue;

            }

            ear = next;

            // if we looped through the whole remaining polygon and can't find any more ears
            if ( ear === stop ) {

                // try filtering points and slicing again
                if ( ! pass ) {

                    earcutLinked( filterPoints( ear ), triangles, dim, minX, minY, invSize, 1 );

                    // if this didn't work, try curing all small self-intersections locally

                } else if ( pass === 1 ) {

                    ear = cureLocalIntersections( ear, triangles, dim );
                    earcutLinked( ear, triangles, dim, minX, minY, invSize, 2 );

                    // as a last resort, try splitting the remaining polygon into two

                } else if ( pass === 2 ) {

                    splitEarcut( ear, triangles, dim, minX, minY, invSize );

                }

                break;

            }

        }

    }

// check whether a polygon node forms a valid ear with adjacent nodes
    function isEar( ear ) {

        var a = ear.prev,
            b = ear,
            c = ear.next;

        if ( area( a, b, c ) >= 0 ) return false; // reflex, can't be an ear

        // now make sure we don't have other points inside the potential ear
        var p = ear.next.next;

        while ( p !== ear.prev ) {

            if ( pointInTriangle( a.x, a.y, b.x, b.y, c.x, c.y, p.x, p.y ) &&
                area( p.prev, p, p.next ) >= 0 ) return false;
            p = p.next;

        }

        return true;

    }

    function isEarHashed( ear, minX, minY, invSize ) {

        var a = ear.prev,
            b = ear,
            c = ear.next;

        if ( area( a, b, c ) >= 0 ) return false; // reflex, can't be an ear

        // triangle bbox; min & max are calculated like this for speed
        var minTX = a.x < b.x ? ( a.x < c.x ? a.x : c.x ) : ( b.x < c.x ? b.x : c.x ),
            minTY = a.y < b.y ? ( a.y < c.y ? a.y : c.y ) : ( b.y < c.y ? b.y : c.y ),
            maxTX = a.x > b.x ? ( a.x > c.x ? a.x : c.x ) : ( b.x > c.x ? b.x : c.x ),
            maxTY = a.y > b.y ? ( a.y > c.y ? a.y : c.y ) : ( b.y > c.y ? b.y : c.y );

        // z-order range for the current triangle bbox;
        var minZ = zOrder( minTX, minTY, minX, minY, invSize ),
            maxZ = zOrder( maxTX, maxTY, minX, minY, invSize );

        var p = ear.prevZ,
            n = ear.nextZ;

        // look for points inside the triangle in both directions
        while ( p && p.z >= minZ && n && n.z <= maxZ ) {

            if ( p !== ear.prev && p !== ear.next &&
                pointInTriangle( a.x, a.y, b.x, b.y, c.x, c.y, p.x, p.y ) &&
                area( p.prev, p, p.next ) >= 0 ) return false;
            p = p.prevZ;

            if ( n !== ear.prev && n !== ear.next &&
                pointInTriangle( a.x, a.y, b.x, b.y, c.x, c.y, n.x, n.y ) &&
                area( n.prev, n, n.next ) >= 0 ) return false;
            n = n.nextZ;

        }

        // look for remaining points in decreasing z-order
        while ( p && p.z >= minZ ) {

            if ( p !== ear.prev && p !== ear.next &&
                pointInTriangle( a.x, a.y, b.x, b.y, c.x, c.y, p.x, p.y ) &&
                area( p.prev, p, p.next ) >= 0 ) return false;
            p = p.prevZ;

        }

        // look for remaining points in increasing z-order
        while ( n && n.z <= maxZ ) {

            if ( n !== ear.prev && n !== ear.next &&
                pointInTriangle( a.x, a.y, b.x, b.y, c.x, c.y, n.x, n.y ) &&
                area( n.prev, n, n.next ) >= 0 ) return false;
            n = n.nextZ;

        }

        return true;

    }

// go through all polygon nodes and cure small local self-intersections
    function cureLocalIntersections( start, triangles, dim ) {

        var p = start;
        do {

            var a = p.prev,
                b = p.next.next;

            if ( ! equals( a, b ) && intersects( a, p, p.next, b ) && locallyInside( a, b ) && locallyInside( b, a ) ) {

                triangles.push( a.i / dim );
                triangles.push( p.i / dim );
                triangles.push( b.i / dim );

                // remove two nodes involved
                removeNode( p );
                removeNode( p.next );

                p = start = b;

            }

            p = p.next;

        } while ( p !== start );

        return p;

    }

// try splitting polygon into two and triangulate them independently
    function splitEarcut( start, triangles, dim, minX, minY, invSize ) {

        // look for a valid diagonal that divides the polygon into two
        var a = start;
        do {

            var b = a.next.next;
            while ( b !== a.prev ) {

                if ( a.i !== b.i && isValidDiagonal( a, b ) ) {

                    // split the polygon in two by the diagonal
                    var c = splitPolygon( a, b );

                    // filter colinear points around the cuts
                    a = filterPoints( a, a.next );
                    c = filterPoints( c, c.next );

                    // run earcut on each half
                    earcutLinked( a, triangles, dim, minX, minY, invSize );
                    earcutLinked( c, triangles, dim, minX, minY, invSize );
                    return;

                }

                b = b.next;

            }

            a = a.next;

        } while ( a !== start );

    }

// link every hole into the outer loop, producing a single-ring polygon without holes
    function eliminateHoles( data, holeIndices, outerNode, dim ) {

        var queue = [],
            i, len, start, end, list;

        for ( i = 0, len = holeIndices.length; i < len; i ++ ) {

            start = holeIndices[ i ] * dim;
            end = i < len - 1 ? holeIndices[ i + 1 ] * dim : data.length;
            list = linkedList( data, start, end, dim, false );
            if ( list === list.next ) list.steiner = true;
            queue.push( getLeftmost( list ) );

        }

        queue.sort( compareX );

        // process holes from left to right
        for ( i = 0; i < queue.length; i ++ ) {

            eliminateHole( queue[ i ], outerNode );
            outerNode = filterPoints( outerNode, outerNode.next );

        }

        return outerNode;

    }

    function compareX( a, b ) {

        return a.x - b.x;

    }

// find a bridge between vertices that connects hole with an outer ring and and link it
    function eliminateHole( hole, outerNode ) {

        outerNode = findHoleBridge( hole, outerNode );
        if ( outerNode ) {

            var b = splitPolygon( outerNode, hole );
            filterPoints( b, b.next );

        }

    }

// David Eberly's algorithm for finding a bridge between hole and outer polygon
    function findHoleBridge( hole, outerNode ) {

        var p = outerNode,
            hx = hole.x,
            hy = hole.y,
            qx = - Infinity,
            m;

        // find a segment intersected by a ray from the hole's leftmost point to the left;
        // segment's endpoint with lesser x will be potential connection point
        do {

            if ( hy <= p.y && hy >= p.next.y && p.next.y !== p.y ) {

                var x = p.x + ( hy - p.y ) * ( p.next.x - p.x ) / ( p.next.y - p.y );
                if ( x <= hx && x > qx ) {

                    qx = x;
                    if ( x === hx ) {

                        if ( hy === p.y ) return p;
                        if ( hy === p.next.y ) return p.next;

                    }

                    m = p.x < p.next.x ? p : p.next;

                }

            }

            p = p.next;

        } while ( p !== outerNode );

        if ( ! m ) return null;

        if ( hx === qx ) return m.prev; // hole touches outer segment; pick lower endpoint

        // look for points inside the triangle of hole point, segment intersection and endpoint;
        // if there are no points found, we have a valid connection;
        // otherwise choose the point of the minimum angle with the ray as connection point

        var stop = m,
            mx = m.x,
            my = m.y,
            tanMin = Infinity,
            tan;

        p = m.next;

        while ( p !== stop ) {

            if ( hx >= p.x && p.x >= mx && hx !== p.x &&
                pointInTriangle( hy < my ? hx : qx, hy, mx, my, hy < my ? qx : hx, hy, p.x, p.y ) ) {

                tan = Math.abs( hy - p.y ) / ( hx - p.x ); // tangential

                if ( ( tan < tanMin || ( tan === tanMin && p.x > m.x ) ) && locallyInside( p, hole ) ) {

                    m = p;
                    tanMin = tan;

                }

            }

            p = p.next;

        }

        return m;

    }

// interlink polygon nodes in z-order
    function indexCurve( start, minX, minY, invSize ) {

        var p = start;
        do {

            if ( p.z === null ) p.z = zOrder( p.x, p.y, minX, minY, invSize );
            p.prevZ = p.prev;
            p.nextZ = p.next;
            p = p.next;

        } while ( p !== start );

        p.prevZ.nextZ = null;
        p.prevZ = null;

        sortLinked( p );

    }

// Simon Tatham's linked list merge sort algorithm
// http://www.chiark.greenend.org.uk/~sgtatham/algorithms/listsort.html
    function sortLinked( list ) {

        var i, p, q, e, tail, numMerges, pSize, qSize,
            inSize = 1;

        do {

            p = list;
            list = null;
            tail = null;
            numMerges = 0;

            while ( p ) {

                numMerges ++;
                q = p;
                pSize = 0;
                for ( i = 0; i < inSize; i ++ ) {

                    pSize ++;
                    q = q.nextZ;
                    if ( ! q ) break;

                }

                qSize = inSize;

                while ( pSize > 0 || ( qSize > 0 && q ) ) {

                    if ( pSize !== 0 && ( qSize === 0 || ! q || p.z <= q.z ) ) {

                        e = p;
                        p = p.nextZ;
                        pSize --;

                    } else {

                        e = q;
                        q = q.nextZ;
                        qSize --;

                    }

                    if ( tail ) tail.nextZ = e;
                    else list = e;

                    e.prevZ = tail;
                    tail = e;

                }

                p = q;

            }

            tail.nextZ = null;
            inSize *= 2;

        } while ( numMerges > 1 );

        return list;

    }

// z-order of a point given coords and inverse of the longer side of data bbox
    function zOrder( x, y, minX, minY, invSize ) {

        // coords are transformed into non-negative 15-bit integer range
        x = 32767 * ( x - minX ) * invSize;
        y = 32767 * ( y - minY ) * invSize;

        x = ( x | ( x << 8 ) ) & 0x00FF00FF;
        x = ( x | ( x << 4 ) ) & 0x0F0F0F0F;
        x = ( x | ( x << 2 ) ) & 0x33333333;
        x = ( x | ( x << 1 ) ) & 0x55555555;

        y = ( y | ( y << 8 ) ) & 0x00FF00FF;
        y = ( y | ( y << 4 ) ) & 0x0F0F0F0F;
        y = ( y | ( y << 2 ) ) & 0x33333333;
        y = ( y | ( y << 1 ) ) & 0x55555555;

        return x | ( y << 1 );

    }

// find the leftmost node of a polygon ring
    function getLeftmost( start ) {

        var p = start,
            leftmost = start;
        do {

            if ( p.x < leftmost.x || ( p.x === leftmost.x && p.y < leftmost.y ) ) leftmost = p;
            p = p.next;

        } while ( p !== start );

        return leftmost;

    }

// check if a point lies within a convex triangle
    function pointInTriangle( ax, ay, bx, by, cx, cy, px, py ) {

        return ( cx - px ) * ( ay - py ) - ( ax - px ) * ( cy - py ) >= 0 &&
            ( ax - px ) * ( by - py ) - ( bx - px ) * ( ay - py ) >= 0 &&
            ( bx - px ) * ( cy - py ) - ( cx - px ) * ( by - py ) >= 0;

    }

// check if a diagonal between two polygon nodes is valid (lies in polygon interior)
    function isValidDiagonal( a, b ) {

        return a.next.i !== b.i && a.prev.i !== b.i && ! intersectsPolygon( a, b ) &&
            locallyInside( a, b ) && locallyInside( b, a ) && middleInside( a, b );

    }

// signed area of a triangle
    function area( p, q, r ) {

        return ( q.y - p.y ) * ( r.x - q.x ) - ( q.x - p.x ) * ( r.y - q.y );

    }

// check if two points are equal
    function equals( p1, p2 ) {

        return p1.x === p2.x && p1.y === p2.y;

    }

// check if two segments intersect
    function intersects( p1, q1, p2, q2 ) {

        if ( ( equals( p1, p2 ) && equals( q1, q2 ) ) ||
            ( equals( p1, q2 ) && equals( p2, q1 ) ) ) return true;
        return area( p1, q1, p2 ) > 0 !== area( p1, q1, q2 ) > 0 &&
            area( p2, q2, p1 ) > 0 !== area( p2, q2, q1 ) > 0;

    }

// check if a polygon diagonal intersects any polygon segments
    function intersectsPolygon( a, b ) {

        var p = a;
        do {

            if ( p.i !== a.i && p.next.i !== a.i && p.i !== b.i && p.next.i !== b.i &&
                intersects( p, p.next, a, b ) ) return true;
            p = p.next;

        } while ( p !== a );

        return false;

    }

// check if a polygon diagonal is locally inside the polygon
    function locallyInside( a, b ) {

        return area( a.prev, a, a.next ) < 0 ?
            area( a, b, a.next ) >= 0 && area( a, a.prev, b ) >= 0 :
            area( a, b, a.prev ) < 0 || area( a, a.next, b ) < 0;

    }

// check if the middle point of a polygon diagonal is inside the polygon
    function middleInside( a, b ) {

        var p = a,
            inside = false,
            px = ( a.x + b.x ) / 2,
            py = ( a.y + b.y ) / 2;
        do {

            if ( ( ( p.y > py ) !== ( p.next.y > py ) ) && p.next.y !== p.y &&
                ( px < ( p.next.x - p.x ) * ( py - p.y ) / ( p.next.y - p.y ) + p.x ) )
                inside = ! inside;
            p = p.next;

        } while ( p !== a );

        return inside;

    }

// link two polygon vertices with a bridge; if the vertices belong to the same ring, it splits polygon into two;
// if one belongs to the outer ring and another to a hole, it merges it into a single ring
    function splitPolygon( a, b ) {

        var a2 = new Node( a.i, a.x, a.y ),
            b2 = new Node( b.i, b.x, b.y ),
            an = a.next,
            bp = b.prev;

        a.next = b;
        b.prev = a;

        a2.next = an;
        an.prev = a2;

        b2.next = a2;
        a2.prev = b2;

        bp.next = b2;
        b2.prev = bp;

        return b2;

    }

// create a node and optionally link it with previous one (in a circular doubly linked list)
    function insertNode( i, x, y, last ) {

        var p = new Node( i, x, y );

        if ( ! last ) {

            p.prev = p;
            p.next = p;

        } else {

            p.next = last.next;
            p.prev = last;
            last.next.prev = p;
            last.next = p;

        }

        return p;

    }

    function removeNode( p ) {

        p.next.prev = p.prev;
        p.prev.next = p.next;

        if ( p.prevZ ) p.prevZ.nextZ = p.nextZ;
        if ( p.nextZ ) p.nextZ.prevZ = p.prevZ;

    }

    function Node( i, x, y ) {

        // vertex index in coordinates array
        this.i = i;

        // vertex coordinates
        this.x = x;
        this.y = y;

        // previous and next vertex nodes in a polygon ring
        this.prev = null;
        this.next = null;

        // z-order curve value
        this.z = null;

        // previous and next nodes in z-order
        this.prevZ = null;
        this.nextZ = null;

        // indicates whether this is a steiner point
        this.steiner = false;

    }

    function signedArea( data, start, end, dim ) {

        var sum = 0;
        for ( var i = start, j = end - dim; i < end; i += dim ) {

            sum += ( data[ j ] - data[ i ] ) * ( data[ i + 1 ] + data[ j + 1 ] );
            j = i;

        }

        return sum;

    }

    //*** Event handlers

    //*** Public methods
    this.triangulate = function ( data, holeIndices, dim ) {

        dim = dim || 2;

        var hasHoles = holeIndices && holeIndices.length,
            outerLen = hasHoles ? holeIndices[ 0 ] * dim : data.length,
            outerNode = linkedList( data, 0, outerLen, dim, true ),
            triangles = [];

        if ( ! outerNode || outerNode.next === outerNode.prev ) return triangles;

        var minX, minY, maxX, maxY, x, y, invSize;

        if ( hasHoles ) outerNode = eliminateHoles( data, holeIndices, outerNode, dim );

        // if the shape is not too simple, we'll use z-order curve hash later; calculate polygon bbox
        if ( data.length > 80 * dim ) {

            minX = maxX = data[ 0 ];
            minY = maxY = data[ 1 ];

            for ( var i = dim; i < outerLen; i += dim ) {

                x = data[ i ];
                y = data[ i + 1 ];
                if ( x < minX ) minX = x;
                if ( y < minY ) minY = y;
                if ( x > maxX ) maxX = x;
                if ( y > maxY ) maxY = y;

            }

            // minX, minY and invSize are later used to transform coords into integers for z-order calculation
            invSize = Math.max( maxX - minX, maxY - minY );
            invSize = invSize !== 0 ? 1 / invSize : 0;

        }

        earcutLinked( outerNode, triangles, dim, minX, minY, invSize );

        return triangles;

    }
}, 'static');
Module(function Shape2DInterpolations() {
    function QuadraticBezierP0( t, p ) {

        let k = 1 - t;
        return k * k * p;

    }

    function QuadraticBezierP1( t, p ) {

        return 2 * ( 1 - t ) * t * p;

    }

    function QuadraticBezierP2( t, p ) {

        return t * t * p;

    }

    function QuadraticBezier( t, p0, p1, p2 ) {

        return QuadraticBezierP0( t, p0 ) + QuadraticBezierP1( t, p1 ) +
            QuadraticBezierP2( t, p2 );

    }

    function CubicBezierP0( t, p ) {

        let k = 1 - t;
        return k * k * k * p;

    }

    function CubicBezierP1( t, p ) {

        let k = 1 - t;
        return 3 * k * k * t * p;

    }

    function CubicBezierP2( t, p ) {

        return 3 * ( 1 - t ) * t * t * p;

    }

    function CubicBezierP3( t, p ) {

        return t * t * t * p;

    }

    function CubicBezier( t, p0, p1, p2, p3 ) {

        return CubicBezierP0( t, p0 ) + CubicBezierP1( t, p1 ) + CubicBezierP2( t, p2 ) +
            CubicBezierP3( t, p3 );

    }

    function CatmullRom( t, p0, p1, p2, p3 ) {

        let v0 = ( p2 - p0 ) * 0.5;
        let v1 = ( p3 - p1 ) * 0.5;
        let t2 = t * t;
        let t3 = t * t2;
        return ( 2 * p1 - 2 * p2 + v0 + v1 ) * t3 + ( - 3 * p1 + 3 * p2 - 2 * v0 - v1 ) * t2 + v0 * t + p1;

    }

    this.exports = {QuadraticBezier, CubicBezier, CatmullRom};
});
Class(function ShapeUtils() {
    Inherit(this, Component);
    const _this = this;

    (async function() {
        if (!window.THREAD) {
            await Hydra.ready();
            Thread.shared(true).array.forEach(thread => {
                thread.loadFunction(commandsToShapeGeom);
                thread.importModule('Shape2DInterpolations');

                [
                    'ShapeGeometry', 'Curve3D', 'CurvePath', 'EllipseCurve', 'Path',
                    'CubicBezierCurve2D', 'LineCurve', 'Shape', 'SplineCurve'
                ].forEach(name => {
                    thread.importES6Class(name);
                })

                thread.importCode(`Class(${_this.constructor.toString()}, 'static')`);
                thread.importCode(`Class(${Earcut.constructor.toString()}, 'static')`);
            });

            Thread.upload(getShapeGeom);
        }
    })();

    function getShapeGeom({commands, holes, subdivisions}, id) {
        let geom = commandsToShapeGeom(commands, holes, subdivisions);
        let position = geom.attributes.position.array;
        let index = geom.index;
        let bb = geom.boundingBox;

        resolve({position, index, bb}, id, [position.buffer, index.buffer]);
    }

    function commandsToShapeGeom(commands, holes, curveSegments) {
        let shape = new Shape();

        commands.forEach(array => {
            let cmd = array.shift();
            shape[cmd].apply(shape, array);
        });

        let path = new Path();
        holes.forEach(array => {
            let cmd = array.shift();
            if (cmd === 'endPath') {
                shape.holes.push(path);
                path = new Path();
            } else {
                path[cmd].apply(path, array);
            }
        });
        if (path.curves.length) {
            shape.holes.push(path);
        }

        let geom = new ShapeGeometry(shape, curveSegments);
        geom.computeBoundingBox();
        return geom;
    }

    function removeDupEndPts( points ) {

        let l = points.length;

        if ( l > 2 && points[ l - 1 ].equals( points[ 0 ] ) ) {

            points.pop();

        }

    }

    function addContour( vertices, contour ) {

        for ( let i = 0; i < contour.length; i ++ ) {

            vertices.push( contour[ i ].x );
            vertices.push( contour[ i ].y );

        }

    }


    //*** Event handlers

    //*** Public methods
    this.area = function(contour) {
        let n = contour.length;
        let a = 0.0;

        for ( let p = n - 1, q = 0; q < n; p = q ++ ) {

            a += contour[ p ].x * contour[ q ].y - contour[ q ].x * contour[ p ].y;

        }

        return a * 0.5;
    }

    this.isClockWise = function(pts) {
        return _this.area( pts ) < 0;
    }

    this.triangulateShape = function(contour, holes) {
        let vertices = []; // flat array of vertices like [ x0,y0, x1,y1, x2,y2, ... ]
        let holeIndices = []; // array of hole indices
        let faces = []; // final array of vertex indices like [ [ a,b,d ], [ b,c,d ] ]

        removeDupEndPts( contour );
        addContour( vertices, contour );

        //

        let holeIndex = contour.length;

        holes.forEach( removeDupEndPts );

        for ( let i = 0; i < holes.length; i ++ ) {

            holeIndices.push( holeIndex );
            holeIndex += holes[ i ].length;
            addContour( vertices, holes[ i ] );

        }

        //

        let triangles = Earcut.triangulate( vertices, holeIndices );

        //

        for ( let i = 0; i < triangles.length; i += 3 ) {

            faces.push( triangles.slice( i, i + 3 ) );

        }

        return faces;
    }

    this.process = async function(shape) {
        let {geom, commands, subdivisions} = shape;
        let holes = shape.holes.commands;
        let data = await Thread.shared().getShapeGeom({commands, holes, subdivisions});
        geom.attributes.position.array = data.position;
        geom.attributes.position.needsUpdate = true;
        geom.attributes.position.needsNewBuffer = true;
        geom.attributes.position.count = data.position.length / 3;
        geom.boundingBox = data.bb;

        geom.index = data.index;
        geom.indexNeedsUpdate = true;
    }

    window.$glShape = function() {
        return new GLUIShape();
    }
}, 'static');
class Skin extends Mesh {
    constructor(geometry, shader, bones = geometry.bones) {
        super(geometry, shader);

        this.isSkin = true;

        this.createBones(bones);
        this.createBoneTexture();
        this.animations = [];
        this.pingPong = -1;

        Object.assign(this.shader.uniforms, {
            boneTexture: {value: this.boneTextureA},
            boneTextureSize: {value: this.boneTextureSize},
        });
    }

    createBones(bonesData) {

        // Create root so that can simply update world matrix of whole skeleton
        this.root = new Base3D();

        // Create bones
        this.bones = [];
        bonesData.forEach(data => {
            const bone = new Base3D();
            bone.name = data.name;

            // Set initial values (bind pose)
            bone.position.set(...data.pos);
            bone.quaternion.set(...data.rot);
            bone.quaternion.normalize();
            bone.scale.set(...data.scl);
            this.bones.push(bone);
        });

        // Once created, set the hierarchy
        bonesData.forEach((data, i) => {
            if (data.parent === -1) return this.root.add(this.bones[i]);
            this.bones[data.parent].add(this.bones[i]);
        });

        // Then update to calculate world matrices
        this.root.updateMatrixWorld(true);

        // Store inverse of bind pose to calculate differences
        this.bones.forEach(bone => {
            bone.bindInverse = new Matrix4().copy(bone.matrixWorld);
            bone.bindInverse = bone.bindInverse.getInverse(bone.bindInverse);
        });
    }

    createBoneTexture() {
        const size = Math.max(4, Math.pow(2, Math.ceil(Math.log(Math.sqrt(this.bones.length * 4)) / Math.LN2)));
        this.boneMatrices = new Float32Array(size * size * 4);
        this.boneTextureSize = size;

        this.boneTextureA = new DataTexture(this.boneMatrices, size, size);
        this.boneTextureB = new DataTexture(this.boneMatrices, size, size);
        this.boneTextureC = new DataTexture(this.boneMatrices, size, size);
        // this.boneTextureD = new DataTexture(this.boneMatrices, size, size);
    }

    addAnimation(data) {
        const animation = new SkinAnimation(this, data);
        this.animations.push(animation);
        return animation;
    }

    async loadAnimation(path) {
        if (!path.includes('assets/geometry/')) path = 'assets/geometry/' + path;
        if (!path.includes('.')) path += '.json';
        path = Thread.absolutePath(Assets.getPath(path));

        const data = await get(path);
        return this.addAnimation(data);
    }

    update() {

        // Calculate combined animation weight
        let total = 0;
        this.animations.forEach(animation => total += animation.weight);

        this.animations.forEach((animation, i) => {

            // force first animation to set in order to reset frame
            animation.update(total || 1, i === 0);
        });
    }

    updateMatrixWorld(force) {
        super.updateMatrixWorld(force);

        // Update world matrices manually, as not part of scene graph
        this.root.updateMatrixWorld(true);

        // Update bone texture
        this.bones.forEach((bone, i) => {

            // Find difference between current and bind pose
            Skin.tempMat4.multiplyMatrices(bone.matrixWorld, bone.bindInverse);
            this.boneMatrices.set(Skin.tempMat4.elements, i * 16);
        });

        this.pingPong++;
        if (this.pingPong > 2) this.pingPong = 0;

        switch (this.pingPong) {
            case 0:
                this.shader.uniforms.boneTexture.value = this.boneTextureA;
                Texture.renderer.manualUpdateDynamic(this.boneTextureB);
                break;

            case 1:
                this.shader.uniforms.boneTexture.value = this.boneTextureB;
                Texture.renderer.manualUpdateDynamic(this.boneTextureC);
                break;

            case 2:
                this.shader.uniforms.boneTexture.value = this.boneTextureC;
                Texture.renderer.manualUpdateDynamic(this.boneTextureA);
                break;
        }
    }
}

Skin.tempMat4 = new Matrix4();

class SkinAnimation {
    constructor(skin, data) {
        this.skin = skin;
        this.data = data;
        this.elapsed = 0;
        this.weight = 1;
        this.duration = data.duration;

        // normalize rotations to fix export precision errors
        this.data.skeleton.forEach((d) => {
            for (let j = 0; j < d.keys.length; j++) {
                SkinAnimation.tempRot.set(...d.keys[j].rot);
                SkinAnimation.tempRot.normalize();
                d.keys[j].rot = SkinAnimation.tempRot.toArray();
            }
        });
    }

    update(totalWeight, isSet) {
        const animationWeight = isSet ? 1 : this.weight / totalWeight;
        const numberKeys = this.duration + 1;
        const elapsed = this.elapsed % numberKeys;
        let prevKey, nextKey;

        this.data.skeleton.forEach((d, i) => {
            const prev = Math.floor(elapsed);
            const next = Math.floor(elapsed + 1) % numberKeys;
            const weight = elapsed - prev;

            prevKey = d.keys[prev];
            nextKey = d.keys[next];

            SkinAnimation.tempPos.set(...prevKey.pos);
            SkinAnimation.tempRot.set(...prevKey.rot);
            SkinAnimation.tempScl.set(...prevKey.scl);

            SkinAnimation.tempPos2.set(...nextKey.pos);
            SkinAnimation.tempRot2.set(...nextKey.rot);
            SkinAnimation.tempScl2.set(...nextKey.scl);

            SkinAnimation.tempPos.lerp(SkinAnimation.tempPos2, weight, false);
            SkinAnimation.tempRot.slerp(SkinAnimation.tempRot2, weight, false);
            SkinAnimation.tempScl.lerp(SkinAnimation.tempScl2, weight, false);

            this.skin.bones[i].position.lerp(SkinAnimation.tempPos, animationWeight, false);
            this.skin.bones[i].quaternion.slerp(SkinAnimation.tempRot, animationWeight, false);
            this.skin.bones[i].scale.lerp(SkinAnimation.tempScl, animationWeight, false);
        });
    }
}

SkinAnimation.tempPos = new Vector3();
SkinAnimation.tempRot = new Quaternion();
SkinAnimation.tempScl = new Vector3();

SkinAnimation.tempPos2 = new Vector3();
SkinAnimation.tempRot2 = new Quaternion();
SkinAnimation.tempScl2 = new Vector3();

/**
 * UIL GUI
 * Exposes UILPanel and UILWindow instances
 */
Class(function UIL() {
    Inherit(this, Component);
    const _this = this;
    let _style;
    let _ui = {};
    let $el;

    //*** Constructor
    Hydra.ready(async _ => {
        if (!Utils.query('editMode') &&
            !(Hydra.LOCAL && window.Platform && window.Platform.isDreamPlatform && Utils.query('uil')) &&
            (!Hydra.LOCAL || Device.mobile || window._BUILT_ || !(Utils.query('uil') || Device.detect('hydra')))) return doNotLoad();
        init();
        _this.loaded = true;
    });

    function doNotLoad() {
        if (Hydra.LOCAL && Utils.query('remoteUIL')) _this.sidebar = _this.global = new UILPanel('null');
    }

    function init() {
        initContainer();
        initStyle();
        initSidebar();
        initGraph();
    }

    function initContainer() {
        $el = $('UIL');
        $el.css({position:'fixed', contain:'strict'}).size('100%', '100%').mouseEnabled(false);
        document.body.insertAdjacentElement('beforeend', $el.div);
        $el.setZ(100000);
    }

    function initStyle() {
         let initial = `
            .UIL ::-webkit-scrollbar { width:2px; }
            .UIL ::-webkit-scrollbar-track { background:#161616; }
            .UIL ::-webkit-scrollbar-thumb { background:#37A1EF; }
        `;
        let style = document.head.appendChild(document.createElement('style'));
        style.type = `text/css`;
        style.id = `uil-style`;
        style.appendChild(document.createTextNode(initial));
        _style = style;
    }

    function initGraph() {
        if (!_this.sidebar) return;

        let parent = _ui.sidebar.element.div;
        parent.insertBefore(UILGraph.instance().element.div, parent.firstChild);

    }

    function initSidebar() {
        _this.add(new UILPanel('sidebar'));
        _this.add(new UILPanel('global', {
            side: 'left'
        }));
    }

    //*** Event handlers

    //*** Public methods

    this.ready = function() {
        return _this.wait(_this, 'loaded');
    }

    /**
     * Add a new panel.
     * @param {(UILControl|UILFolder)} panel
     */
    this.add = function(panel) {
        _ui[panel.id] = panel;
        _this[panel.id] = panel;
        $el.add(panel);
        return _this;
    }

    /**
     * Remove panel.
     * @param {(UILControl|UILFolder)} id
     */
    this.remove = function(id) {
        let $panel = _ui[id];
        $panel.eliminate && $panel.eliminate();
        $panel.destroy();
        delete _ui[id];
        delete _this[id];
        return _this;
    }

    /**
     * Get a nested child by searching all UI panels requrisvely.
     * Find a control no matter where it's added.
     * @param {String} id ID of child.
     * @returns {[(UILControl|UILFolder)]} array of matching children.
     */
    this.find = function(id) {
        return Object.values(_ui).reduce((acc, el) => acc.concat(el.find(id)), []);
    }

    /**
     * Make child of ID sortable.
     * @param {String} id ID of child.
     * @param {Boolean} enable turn sorting on/off.
     * @returns {Object} this.
     */
    this.enableSorting = function(id, enable) {
        let el = _this.find(id)[0];
        el && el.enableSorting && el.enableSorting(enable);
        return _this;
    }

    /**
     * Append Style to UIL style tag.
     * @param {(UILControl|UILFolder)} control Element you're styling.
     * @param {String} style Style as CSS String.
     */
    this.addCSS = function(control, style) {
        if (control.styled) return;
        let node = document.createTextNode(style);
        if ( _style ) _style.appendChild(node);
        control.styled = true;
        return _this;
    }

    this.REORDER = `uil_reorder`;

}, 'static');
Class(function CameraUIL() {
    const _this = this;

    this.UPDATE = 'camera_uil_update';

    //*** Public methods
    this.add = function(light, group) {
        return new CameraUILConfig(light, group === null ? null : group || UIL.global);
    }
}, 'static');
Class(function CameraUILConfig(_camera, _uil) {
    const _this = this;

    if (!_camera.prefix) throw 'camera.prefix required when using MeshUIL';

    var prefix = 'CAMERA_'+_camera.prefix;
    var _group = _uil ? createFolder() : null;
    var _dynamicFOVCallback = null;

    //*** Constructor
    (function () {
        initType();
        if (_camera.position) initVec('position');
        if (_camera.group) {
            _camera.groupPos = _camera.group.position;
            initVec('groupPos');
            initRotation('rotation', (value, key) => {
                _camera.group[key].fromArray(value);
            });
        }
        initFOV('fov');
        initNumber('zoom');
        initNumber('near');
        initNumber('far');
        if (_camera.moveXY) {
            initVec('moveXY');
            initVec('lookAt');
            initRotation('cameraRotation', (value, key) => {
                _camera[key].fromArray(value);
            });
            initVec('viewportFocus');
            initNumber('lerpSpeed');
            initNumber('lerpSpeed2');
            initNumber('deltaRotate');
            initNumber('deltaLerp');
            initNumber('wobbleSpeed');
            initNumber('wobbleStrength');
            initNumber('wobbleZ');
        }
        initDynamicFOV('dynamicFOV');
        if ( _group ) addListeners();
    })();

    function createFolder() {
        if (!UIL.sidebar) return null;
        let folder = new UILFolder(prefix, {label: _camera.prefix, closed:true});
        _uil.add(folder);
        return folder;
    }

    function initFOV(key) {
        let initValue = UILStorage.get(`${prefix}${key}`) || _camera.camera.fov || 9999;
        if (_group) {
            let number = new UILControlNumber(`${prefix}${key}`, {label: key, value: initValue, step: 0.05});
            number.onFinishChange(e => {
                if (_group) {
                    Events.emitter._fireEvent(CameraUIL.UPDATE, {prefix, key, val: e, fov: true, group: _this});
                    _this['tweenUIL_'+key]?.(e);
                }
                _camera.setFOV(e);
                UILStorage.set(`${prefix}${key}`, e);
            });
            _group.add(number);
        }

        defer(_ => {
            _camera.setFOV(initValue);
        });
    }

    function initVec(key) {
        let initValue = UILStorage.get(`${prefix}${key}`) || _camera[key]?.toArray();
        if (!initValue) return;
        if (_group) {
            let vector = new UILControlVector(`${prefix}${key}`, {label: key, value: initValue, step: 0.05});
            vector.onChange(e => {
                if (_group) {
                    Events.emitter._fireEvent(CameraUIL.UPDATE, {prefix, key, val: e, vec: true, group: _this});
                    _this['tweenUIL_'+key]?.(e);
                }
                _camera[key].fromArray(e);
            });
            vector.onFinishChange(e => UILStorage.set(`${prefix}${key}`, e));
            _group.add(vector);

            _this['forceUpdate' + key.toUpperCase()] = _ => {
                let val = _camera[key].toArray();
                if (_this['tweenUIL_'+key]) _this['tweenUIL_'+key](val);
                else vector.force(_camera[key].toArray(), true);
            };
        }

        _camera[key].fromArray(initValue);
    }

    function initNumber(key) {
        let initValue = UILStorage.get(`${prefix}${key}`) || (_camera[key] === undefined ? 9999 : _camera[key]);
        if (_group) {
            let number = new UILControlNumber(`${prefix}${key}`, {label: key, value: initValue, step: 0.05});
            number.onChange(e => {
                _camera[key] = e;
                if (_group) {
                    Events.emitter._fireEvent(CameraUIL.UPDATE, {prefix, key, val: e, number: true, group: _this});
                    _this['tweenUIL_'+key]?.(e);
                }
            });
            number.onFinishChange(e => UILStorage.set(`${prefix}${key}`, e));
            _group.add(number);
        }

        _camera[key] = initValue;
    }

    function initRotation(key, applyValue) {
        let toRadians = array => {
            if (!array) return [0, 0, 0];
            array.length = 3;
            return array.map(x => Math.radians(x));
        };

        let toDegrees = array => {
            if (!array) return [0, 0, 0];
            array.length = 3;
            return array.map(x => Math.degrees(x));
        };

        let initValue = toRadians(UILStorage.get(`${prefix}${key}`));

        if (_group) {
            let vector = new UILControlVector(`${prefix}${key}`, {label: key, value: toDegrees(initValue)});
            vector.onChange(e => {
                if (_group) {
                    Events.emitter._fireEvent(CameraUIL.UPDATE, {prefix, key, val: toRadians(e), rotation: true, group: _this});
                    _this['tweenUIL_'+key]?.(toRadians(e));
                }
                applyValue(toRadians(e), key);
            });
            vector.onFinishChange(e => UILStorage.set(`${prefix}${key}`, e));
            _group.add(vector);
        }

        applyValue(initValue, key);
    }

    function initDynamicFOV(key) {
        let defaultCode = ``;
        let code = UILStorage.get(`${prefix}${key}Code`) || defaultCode;

        let evalCode = value => {
            let method = value.includes('return') ?
                `(function(){ return function getFOV() { ${value}}})()`:
                `(function(){ return function getFOV() { return ${value}}})()`;
            _camera._getDynamicFOV = eval(method);
        }

        let editCode = _ => {
            let editor = new UILExternalEditor( `${prefix}${key}`, 400, 900);
            editor.setCode( code, 'c' );
            editor.onSave = value => {
                UILStorage.set(`${prefix}${key}Code`, value );
                evalCode( value );
                code = value;
                _camera.dynamicFOV();
            }
        }

        let btn = new UILControlButton( 'btn', {
            actions: [{ title: 'Dynamic FOV', callback: editCode }],
            hideLabel: true
        });

        if ( _group ) _group.add( btn );
        defer( _ => {
            evalCode( code );
            _camera.dynamicFOV = _ => {
                if (_camera.camera.isOrthographicCamera) return;
                let fov = _camera._getDynamicFOV?.() || _camera.camera.fov;
                if ( isNaN( fov )) return console.warn(`${prefix} Dynamic FOV requires a float value`);
                _camera.setFOV( fov );
            };
            _camera.onResize( _ => _camera.dynamicFOV());
        });

    }

    function initType() {
        let initValue = UILStorage.get(`${prefix}type`) || 'perspective';
        if (_group) {
            let control = new UILControlSelect(`${prefix}type`, {
                label: 'Type',
                value: initValue,
                options: [
                    { label: 'Perspective', value: 'perspective' },
                    { label: 'Orthographic', value: 'orthographic' },
                ]
            });
            control.onChange(e => {
                if (e === 'orthographic') {
                    _camera.useOrthographic();
                } else {
                    _camera.usePerspective();
                }
                if (_group) Events.emitter._fireEvent(CameraUIL.UPDATE, { prefix, key: 'type', val: e, type: true, group: _this });
            });
            control.onFinishChange(e => UILStorage.set(`${prefix}type`, e));
            _group.add(control);
        }
        if (initValue === 'orthographic') {
            _camera.useOrthographic();
        }
    }

    //*** Event handlers
    function addListeners() {
        Events.emitter._addEvent(CameraUIL.UPDATE, update, _this);
    }

    function update(e) {
        if (e.prefix != prefix || e.group == _this) return;
        if (e.fov) _camera.setFOV(e.val);
        if (e.number) _camera[e.key] = e.val;
        if (e.rotation) _camera.group[e.key].fromArray(e.val);
        if (e.vec) _camera[e.key].fromArray(e.val);
    }

    //*** Public methods
    this.setLabel = function(name) {
        if (_group) _group.setLabel(name);
    }
});

Class(function InputUIL() {

    this.UPDATE = 'inputUil_Update';

    this.create = function(name, group, decoupled) {
        return new InputUILConfig(name, group === null ? null : group || UIL.global, decoupled);
    }
}, 'static');
Class(function InputUILConfig(_name, _uil, _decoupled, _slim) {
    var _this = this;
    var _cache;

    const prefix = 'INPUT_'+_name;

    var _group = _uil ? createFolder() : null;
    var _fields = _uil ? {} : null;
    _this.group = _group;

    if (_uil) addListeners();

    function createFolder() {
        if (!UIL.sidebar) return null;
        let folder = new UILFolder(_name, {closed:true});
        if (!_decoupled) {
            _uil.add(folder);
            if (_uil == UIL.sidebar) folder.hide();
        }
        return folder;
    }

    function addListeners() {
        Events.emitter._addEvent(InputUIL.UPDATE, externalUpdate, _this);
    }

    function externalUpdate(e) {
        if (e.prefix != prefix || e.group == _this) return;
        UILStorage.set(`${prefix}_${e.key}`, e.value);
        _this.onUpdate && _this.onUpdate(e.key);
    }

    //*** Event handlers

    //*** Public methods
    this.get = function(key) {
        if (_cache && _cache[key] !== undefined) return _cache[key];

        let val = UILStorage.get(`${prefix}_${key}`);
        if (typeof val === 'boolean') return val;
        if (!val || val == '') return undefined;
        if (val === 'true') return true;
        if (val === 'false') return false;
        if (val.charAt && val.charAt(0) == '[') return JSON.parse(val);

        if (!UIL.global) {
            if (!_cache) _cache = {};
            if (!_cache[key]) _cache[key] = val;
        }

        return val;
    }

    this.getFilePath = function(key) {
        let data = this.get(key);
        if (data?.charAt(0) === '{') {
            data = JSON.parse(data);
            if (data.relative.includes('.')) return data.relative;
            return data.src;
        } else {
            return data;
        }
    }

    this.getNumber = function(key) {
        let number = Number(this.get(key));
        if ( isNaN( number )) number = 0;
        return number;
    }

    if (_slim) return;

    this.add = function(key, initValue, uil = window.UILControlText, options, params = {}) {
        if (!_group || initValue == 'hidden' || !UIL.sidebar) return this;

        let value = UILStorage.get(`${prefix}_${key}`);
        if (value === 'true') value = true;
        if (value === 'false') value = false;
        if (uil == UILControlVector && typeof value === 'string') value = JSON.parse(value);

        if (value === undefined) value = initValue;
        if (typeof value === 'string' && (uil == UILControlImage || uil == UILControlFile)) {
            try {
                value = JSON.parse(value);
            } catch(e) {

            }
        }

        let change = (val, fromInit) => {
            val = typeof val === 'string' ? val : JSON.stringify(val);
            UILStorage.set(`${prefix}_${key}`, val);
            if (_this.onUpdate) _this.onUpdate(key, val);
            if (!fromInit) {
                Events.emitter._fireEvent(InputUIL.UPDATE, {prefix, key, value: val, group: _this});
            }

        };

        if ((typeof initValue === 'string' || typeof initValue === 'number' || uil == UILControlVector) && !UILStorage.get(`${prefix}_${key}`)) {
            change(initValue, true);
        }

        let opts = Utils.mergeObject(params, {label: key, value, options});
        if (uil == window.UILControlButton) opts = options;

        let config = new uil(`${prefix}_${key}`, opts);
        config.onFinishChange(change);
        if (uil == UILControlVector || uil == UILControlRange) config.onChange(change);
        _group.add(config);
        _fields[key] = config;

        return this;
    }

    this.addToggle = function(key, initValue) {
        if (!UIL.sidebar) return this;
        return this.add(key, initValue, UILControlCheckbox);
    }

    this.addSelect = function(key, options) {
        if (!UIL.sidebar) return this;
        return this.add(key, null, UILControlSelect, options);
    }

    this.addImage = function(key, options) {
        if (!UIL.sidebar) return this;
        return this.add(key, null, UILControlImage, null, options);
    }

    this.addFile = function(key, options) {
        if (!UIL.sidebar) return this;

        let existing = this.get(key);
        if (existing?.length > 3 && !existing.includes('{')) return this.add(key);

        return this.add(key, null, UILControlFile, null, options);
    }

    this.addRange = function(key, initValue, options) {
        if (!UIL.sidebar) return this;
        return this.add(key, initValue, UILControlRange, null, options);
    }

    this.addNumber = function(key, initValue, step) {
        if (!UIL.sidebar) return this;
        return this.add(key, initValue, UILControlNumber, null, {step});
    }

    this.addColor = function(key, initValue = new Color()) {
        if (!UIL.sidebar) return this;
        return this.add(key, initValue.getHexString(), UILControlColor);
    }

    this.addTextarea = function(key, initValue) {
        if (!UIL.sidebar) return this;
        return this.add(key, initValue, UILControlTextarea, null, {monospace: true, rows: 4});
    }

    this.addButton = function(key, options) {
        if (!UIL.sidebar) return this;
        return this.add(key, null, UILControlButton, options);
    }

    this.addVector = function(key, initValue, options) {
        if (!UIL.sidebar) return this;
        if (!options) options = {step: 0.05};
        return this.add(key, initValue, UILControlVector, null, options);
    }

    this.getImage = function(key) {
        let data = this.get(key);
        if (!data) return;
        return JSON.parse(data).src;
    }

    this.setValue = function(key, value) {
        UILStorage.set(`${prefix}_${key}`, value);
        if (_this.onUpdate) _this.onUpdate(key);

        if (_fields) {
            let field = _fields[key];
            if (field) {
                field.value = value;
                field.update && field.update();
            }
        }

        return this;
    }

    this.copyFrom = function(input, fields) {
        fields.forEach(key => {
            let val = input.get(key);
            if (val !== undefined) {
                if (typeof val !== 'string') val = JSON.stringify(val);
                _this.setValue(key, val);
            }
        });
    }

    this.setLabel = function(name) {
        if (_group) _group.setLabel(name);
    }

    this.getField = function(key) {
        if (_fields) return _fields[key];
    }

    this.setDescription = function(key, desc) {
        _this.getField(key)?.setDescription(desc);
    }
});

Class(function ListUIL() {
    Inherit(this, Component);
    const _this = this;
    var _panel;

    var _data = {};
    var _created = {};

    //*** Constructor
    (function () {

    })();

    //*** Event handlers

    function removePanel() {
        if ( !_panel || !_panel.destroy ) return;
        _this.events.unsub(_panel, Events.COMPLETE, removePanel);
        _panel = _panel.destroy();
    }

    //*** Public methods

    this.create = function ( id, version = 1, group ) {
        if (typeof version != 'number') {
            group = version;
            version = 1;
        }

        group = group === null ? null : group || UIL.global;

        let config = new ListUILConfig( id, version, UIL.global && !_created[id]);

        if (UIL.global) {
            if (!_created[id]) {
                _created[id] = config;
                if (group != null) config.appendUILGroup(group || UIL.global);
            }
        }

        return config;
    }

    this.openPanel = function( id, name, template  ) {
        removePanel();
        _panel = new ListUILEditor( id, name, template );
        _this.events.sub(_panel, Events.COMPLETE, removePanel);
        return _panel;
    }

    this.set = function () {

    }

    this.get = function () {

    }

    this.getPanel = function() {
        return _panel;
    }

}, 'static');
Class(function ListUILConfig(_id, _version = 1, _store) {
    Inherit(this, Component);
    const _this = this;
    var _items, _folder;
    var _config, _template = {onSort: _ => {}, onAdd: _ => {}, onRemove: _ => {}};
    var _name = '';

    //*** Constructor
    (function () {
        if (_store) _items = [];
        initConfig();
    })();

    function initConfig() {
        _config = UILStorage.get( name());
        if (_config) {
            if (_config.version != _version) {
                updateConfig();
                UILStorage.clearMatch( name().split('_config')[0]);
            }
        } else {
            _config = {};
            updateConfig();
        }
    }

    function name() {
        return `LIST_${_id}_config`;
    }

    function updateConfig() {
        _config.version = _version;
        UILStorage.setWrite( name(), _config);
    }

    function edit() {
        let panel = ListUIL.openPanel( _id, _name, _this.template );
        _this.events.bubble( panel, Events.UPDATE );
        _this.events.fire(ListUIL.OPEN);
    }

    //*** Event handlers

    //*** Public methods

    this.add = function ( item ) {
        _items && _items.push( item );
        return item;
    }

    this.template = function ( config ) {
        if ( typeof config === 'function' ) _template = config;
        return _template;
    }

    this.appendUILGroup = function(uil) {
        let folder = new UILFolder('LIST_'+_id, {closed: true});
        let button = new UILControlButton('button', {actions: [
                {title: 'Edit List', callback: edit},
            ], hideLabel:true});

        folder.add(button);
        uil.add(folder);
        _folder = folder;
    }

    this.setLabel = function(name) {
        if (_folder) _folder.setLabel(name);
        _name = name;
    }

    this.onAdd = function(cb) {
        _template.onAdd = cb;
    }

    this.onRemove = function(cb) {
        _template.onRemove = cb;
    }

    this.onSort = function(cb) {
        _template.onSort = cb;
    }

    this.internalAddItems = function(count) {
        if (!count) return;

        let array = [];
        for (let i = 0; i < count; i++) {
            let id = `${_id}_${Utils.timestamp()}`;
            array.push(id);
        }

        UILStorage.set(`${_id}_list_items`, JSON.stringify(array));
    }
}, _ => {
    ListUIL.OPEN = 'list_uil_open';
});
Class(function ListUILEditor( _id,_name, _template ) {
    Inherit(this, Component);
    const _this = this;
    const PANEL_CONFIG = { label: _name ? _name : 'List', width: '400px', height: 'auto', drag: true };
    var _gui, _static, _list, _add;
    var _tabs = [];
    var _items;
    var _index = 0;

    //*** Constructor
    (function () {
        initPanel();
        refresh();
    })();

    function initPanel() {
        _this.gui = _gui = new UILWindow( _id, PANEL_CONFIG );
        _this.gui.onClose = close;
        UIL.add(_gui);
    }

    function initList() {
        read();

        _list = new UILFolder( `${_id}_list`, { hideTitle: true });
        _list.enableSorting( _id );
        _gui.add(_list);

        for ( let id of _items ) {
            let view = new ListUILItem( id, _list, _template, _index++ );
            _this.events.sub( view, Events.UPDATE, reorder );
            _this.events.sub( view, Events.END, remove );
            _tabs.push( view );
        }
    }

    function initAdd() {
        initButton( 'Add Item', add );
    }

    function initButton( title, callback ) {
        let hideLabel = true;
        let actions = [{ title, callback }];
        _add = new UILControlButton( 'button', { actions, hideLabel });
        _gui.add(_add);
    }

    //*** Event handlers

    function add() {
        let id = `${_id}_${Utils.timestamp()}`;
        let view = new ListUILItem( id, _list, _template, _index++ );
        _this.events.sub( view, Events.UPDATE, reorder );
        _this.events.sub( view, Events.END, remove );
        _tabs.push( view );
        _items.push( id );
        write();
    }

    function reorder( e ) {
        let order = [];
        for ( let item of e.order ) order.push( item.split('_folder')[0] );
        _items = order;
        _template().onSort(_items);
        write();
        _this.events.fire(Events.UPDATE, { order });
    }

    function close() {
        _this.events.fire(Events.COMPLETE);
    }

    function remove( e ) {
        _items.remove( e.id );
        write();
        refresh();
    }
    
    function read() {
        let data = UILStorage.get(`${_id}_list_items`);
        if ( typeof data === 'undefined' ) data = '[]';
        _items = JSON.parse( data );
    }
    
    function write() {
        let data = JSON.stringify( _items );
        UILStorage.set(`${_id}_list_items`, data );
    }

    function refresh() {
        _index = 0;
        if ( _list && _list.destroy ) _list = _list.destroy();
        if ( _add && _add.destroy ) _add = _add.destroy();
        initList();
        initAdd();
    }

    //*** Public methods

    this.onDestroy = function() {
        _gui.destroy();
    }

    this.add = function() {
        add();
    }

});
Class(function ListUILItem( _id, _parent, _template, _index ) {
    Inherit(this, Component);
    const _this = this;
    var $this;
    var _folder;

    //*** Constructor
    (function () {
        initFolder();
        initTemplate();
        initUI();
    })();

    async function initFolder() {
        _folder = InputUIL.create( `${_id}_folder`, _parent );
        _folder.setLabel( 'Item' );
        _folder.group.draggable( true );
        _this.events.sub( _folder.group, UIL.REORDER, onReorder );
        _folder.listUILItem = _this;
    }

    function initTemplate() {
        let id = _id;
        let init = _template().onAdd;
        init( id, _folder, _index );
    }

    function initUI() {
        let title = 'Delete';
        let callback = onDelete;
        let actions = [{ title, callback }]
        let hideLabel = true;
        _folder.addButton( 'delete', { actions, hideLabel });
    }

    //*** Event handlers

    function onDelete() {
        if (!confirm('You sure you want to delete this?')) return;
        let id = _id;
        _template().onRemove(id);
        _this.events.fire( Events.END, { id });
    }

    function onReorder( e ) {
        _this.events.fire( Events.UPDATE, e );
    }

    //*** Public methods
    this.setLabel = function(label) {
        _folder.setLabel(label);
    }

    this.forceSort = function(index) {
        _folder.group.forceSort(index);
    }

    this.open = function() {
        _folder.group.open();
        _folder.group.openChildren();
    }

    this.close = function() {
        _folder.group.close();
    }
});
Class(function MeshUIL() {
    Inherit(this, Component);
    const _this = this;

    this.exists = {};

    this.UPDATE = 'mesh_uil_update';

    //*** Public methods
    this.add = function(mesh, group) {
        return new MeshUILConfig(mesh, group === null ? null : group || UIL.global);
    }
}, 'static');
Class(function MeshUILConfig(_mesh, _uil) {
    const _this = this;

    if (!_mesh.prefix) throw 'mesh.prefix required when using MeshUIL';

    var prefix = 'MESH_'+_mesh.prefix;
    var _group = _uil && !MeshUIL.exists[prefix] ? createFolder() : null;
    var _controls = _group ? {} : null;

    this.group = _group;

    //*** Constructor
    (function () {
        MeshUIL.exists[prefix] = true;
        initVec('position');
        initVec('scale');
        initRotation();
        if (_group) addListeners();
    })();

    function createFolder() {
        if (!UIL.sidebar) return null;
        let folder = new UILFolder(prefix, {label: _mesh.prefix, closed:true});
        _uil.add(folder);
        return folder;
    }

    function initVec(key) {
        let initValue = UILStorage.get(`${prefix}${key}`) || _mesh[key].toArray();
        if (_group) {
            let vector = new UILControlVector(`${prefix}${key}`, {label: key, value: initValue, step: 0.05});
            vector.onChange(e => {
                _mesh[key].fromArray(e);
                if (_group) {
                    Events.emitter._fireEvent(MeshUIL.UPDATE, {prefix, key, val: e, group: _this});
                    _this['tweenUIL_'+key]?.(e);
                }
            });
            vector.onFinishChange(save);
            _group.add(vector);

            _this['forceUpdate' + key.toUpperCase()] = _ => {
                let val = _mesh[key].toArray();
                if (_this['tweenUIL_'+key]) _this['tweenUIL_'+key](val);
                else vector.force(_mesh[key].toArray(), true);
            };

            _controls[key] = vector;
        }

        _mesh[key].fromArray(initValue);
    }

    function initRotation() {
        let key = 'rotation';
        let toRadians = array => {
            if (!array) return [0, 0, 0];
            array.length = 3;
            return array.map(x => Math.radians(x));
        };

        let toDegrees = array => {
            if (!array) return [0, 0, 0];
            array.length = 3;
            return array.map(x => Math.degrees(x));
        };

        let initValue = toRadians(UILStorage.get(`${prefix}${key}`));

        if (_group) {
            let vector = new UILControlVector(`${prefix}${key}`, {label: key, value: toDegrees(initValue)});
            vector.onChange(e => {
                _mesh[key].fromArray(toRadians(e));
                if (_group) {
                    Events.emitter._fireEvent(MeshUIL.UPDATE, {prefix, key, val: toRadians(e), group: _this});
                    _this['tweenUIL_'+key]?.(e);
                }
            });
            vector.onFinishChange(save);
            _group.add(vector);

            _controls[key] = vector;
        }

        _mesh[key].fromArray(initValue);
        let rotationEuler = new Euler().fromArray(initValue);
        _mesh.customRotation = new Quaternion().setFromEuler(rotationEuler);
    }

    function save() {
        for (let key in _controls) {
            let value = _controls[key].value;
            UILStorage.set(`${prefix}${key}`, value);
        }
    }

    //*** Event handlers
    function addListeners() {
        Events.emitter._addEvent(MeshUIL.UPDATE, update, _this);
    }

    function update(e) {
        if (e.prefix != prefix || e.group == _this) return;
        _mesh[e.key].fromArray(e.val);
    }

    //*** Public methods
    this.setLabel = function(name) {
        if (_group) _group.setLabel(name);
    }

    this.forceUpdate = function(key, val) {
        _mesh[key].fromArray(val);
        _this['forceUpdate' + key.toUpperCase()]?.();
    }
});
Class(function ShaderUIL() {
    this.exists = {};
    this.UPDATE = 'shader_update';
    this.TEXTURE_UPDATE = 'shader_texture_update';
    this.SHADER_UPDATE = 'shader_shader_update';

    //*** Public methods
    this.add = function(shader, group) {
        return new ShaderUILConfig(shader.shader || shader, group === null ? null : group || UIL.global);
    }

    this.createOverride = function(prefix, obj, group, shaderOnly) {
        let uniforms = {};
        if (Array.isArray(obj)) {
            obj.forEach(o => {
                o = o.uniforms || o;
                for (let key in o) {
                    if (!o[key].ignoreUIL) uniforms[key] = o[key];
                }
            });
        } else {
            uniforms = obj.uniforms || obj;
        }
        let shader = Utils3D.getTestShader();
        shader.vertexShader = shader.fragmentShader = '';
        for (let key in uniforms) shader.uniforms[key] = uniforms[key];
        shader.UILPrefix = prefix;
        if (shaderOnly === null) return shader;
        else return this.add(shader, group);
    }

    this.createDecorator = function(shader, prefix, obj, group) {
        let uniforms = {};
        for (let key in obj) {
            uniforms[key] = shader.uniforms[key];
        }

        let nShader = Utils3D.getTestShader();
        nShader.vertexShader = shader.fragmentShader = '';
        nShader.uniforms = uniforms;
        nShader.UILPrefix = prefix;
        return this.add(nShader, group);
    }

    this.createClone = function(prefix, obj) {
        let uniforms = obj.uniforms || obj;
        let shader = Utils3D.getTestShader();
        for (let key in uniforms) {
            let value = uniforms[key].value;
            let ignoreUIL = uniforms[key].ignoreUIL || value === null;
            if (!ignoreUIL && !!value.clone) value = value.clone();
            shader.uniforms[key] = {value, ignoreUIL};
        }
        shader.UILPrefix = prefix;
        return shader;
    }

    this.lerpShader = function(from, to, alpha, hz, uniformsFilter) {
        from = from.uniforms || from;
        to = to.uniforms || to;

        for (let key in from) {
            let f = from[key];
            let t = to[key];

            if (!f || !t) continue;
            if (uniformsFilter && uniformsFilter.indexOf(key) === -1) continue;

            if (typeof t.value === 'number') {
                f.value = Math.lerp(t.value, f.value, alpha, hz);
            } else if (f.type === 'c') {
                f.value.r = Math.lerp(t.value.r, f.value.r, alpha, hz);
                f.value.g = Math.lerp(t.value.g, f.value.g, alpha, hz);
                f.value.b = Math.lerp(t.value.b, f.value.b, alpha, hz);
            } else if (f.type === 'v3') {
                f.value.x = Math.lerp(t.value.x, f.value.x, alpha, hz);
                f.value.y = Math.lerp(t.value.y, f.value.y, alpha, hz);
                f.value.z = Math.lerp(t.value.z, f.value.z, alpha, hz);
            } else if (f.type === 'v2') {
                f.value.x = Math.lerp(t.value.x, f.value.x, alpha, hz);
                f.value.y = Math.lerp(t.value.y, f.value.y, alpha, hz);
            } else if (f.value && f.value.lerp) {
                f.value.lerp(t.value, alpha, hz);
            }
        }
    }
}, 'static');

Class(function ShaderUILConfig(_shader, _uil) {
    var _this = this;
    var _textures;

    const prefix = _shader.UILPrefix;

    var _group = _uil && !ShaderUIL.exists[prefix] ? createFolder() : null;

    this.group = _group;
    this.shader = _shader;

    //*** Constructor
    (function () {
        if (_group) _shader.shaderUIL = _this;
        ShaderUIL.exists[_shader.UILPrefix] = true;
        initItems();
        if (_group) addListeners();
    })();

    function getName() {
        let split = _shader.UILPrefix.split('/');
        if (split.length > 2) return split[0] + '_' + split[2];
        let name = split[0];
        return name;
    }

    function createFolder() {
        if (!UIL.sidebar) return null;
        let label = getName();
        if (label.charAt(label.length-1) == '_') label = label.slice(0, -1);
        let folder = new UILFolder(prefix + label, {label, closed:true});
        _uil.add(folder);
        return folder;
    }

    function initItems() {
        for (var key in _shader.uniforms) {
            let obj = _shader.uniforms[key];
            if (!obj || obj.ignoreUIL) continue;

            if (obj.options && Array.isArray( obj.options )) createSelect(obj, key);
            else {
                if (typeof obj.value === 'number') createNumber(obj, key);
                if (obj.value instanceof Color) createColor(obj, key);
                if (obj.value === null || obj.value instanceof Texture) createTexture(obj, key);
                if (obj.value instanceof Vector2) createVector(obj, key);
                if (obj.value instanceof Vector3) createVector(obj, key);
                if (obj.value instanceof Vector4) createVector(obj, key);
            }
        }
    }

    function createVector(obj, key) {
        let initValue = UILStorage.get(`${prefix}${key}`) || obj.value.toArray();
        if (_group) {
            let vector = new UILControlVector(`${prefix}${key}`, {
                label: key,
                value: initValue,
                step: 0.05,
                description: obj.description
            });
            vector.onChange(val => {
                obj.value.fromArray(val);
                if (_shader.ubo) _shader.ubo.needsUpdate = true;
                Events.emitter._fireEvent(ShaderUIL.UPDATE, {prefix, key, val, group: _this, vector: true});
            });
            _this['forceUpdate' + key.toUpperCase()] = _ => {
                let val = _shader.get(key).toArray();
                vector.force(val, true);
            };
            vector.onFinishChange(e => UILStorage.set(`${prefix}${key}`, e));
            _group.add(vector);
        }

        obj.value.fromArray(initValue);
    }

    function createTexture(obj, key) {
        if (_group && !_textures) _textures = {};

        let getTexture;
        if (obj.cube) {
            getTexture = obj.getTexture || ShaderUIL.getCubeTexture || Utils3D.getCubeTexture;
        } else {
            getTexture = obj.getTexture || ShaderUIL.getTexture || Utils3D.getTexture;
        }
        const set = _shader.parent && _shader.parent.setOverride ? _shader.parent.setOverride : _shader.set || _shader.setUniform;
        const get = _shader.get || _shader.getUniform;

        let prefix = _shader.UILPrefix + '_tx';
        let data = UILStorage.get(`${prefix}_${key}`);
        if (data) data = JSON.parse(data);
        let value = data ? data.src : null;

        let change = data => {
            let val = data.src;
            let cleanPath = val.includes('?') && !data.hotreload ? val.split('?')[0] : val;
            if (!!data.compressed) {
                val += '-compressedKtx';
                if (data.compressed === 'ktx2') val += '2';
            }

            if (_textures) _textures[cleanPath] = change;

            data.src = cleanPath;

            UILStorage.set(`${prefix}_${key}`, JSON.stringify(data));
            set(key, getTexture(val, {premultiplyAlpha: obj.premultiplyAlpha, scale: obj.scale}), _shader);
            if (_group) Events.emitter._fireEvent(ShaderUIL.UPDATE, {prefix: _shader.UILPrefix, key, val, texture: get(key, _shader), group: _this});
        };

        if (value && value.length) change(data);

        if (_group) {
            let compressOptions = {};
            if (obj.cube) {
                compressOptions.cube = true;
            }
            let img = new UILControlImage(prefix+key, {
                label: key,
                value: data,
                description: obj.description,
                compressOptions
            });
            img.onFinishChange(change);
            _group.add(img);

            _this['forceUpdate' + key.toUpperCase()] = _ => {
                img.force(_shader.get(key), true);
            };
        }
    }

    function createNumber(obj, key) {
        let initValue = UILStorage.get(`${prefix}${key}`);
        if (initValue === undefined) initValue = obj.value;

        if (_group) {
            let number = new UILControlNumber(`${prefix}${key}`, {
                label: key,
                value: initValue,
                step: 0.05,
                description: obj.description
            });
            number.onChange(val => {
                if (_shader.ubo) _shader.ubo.needsUpdate = true;
                Events.emitter._fireEvent(ShaderUIL.UPDATE, {prefix, key, val, group: _this});
                obj.value = val;
            });
            number.onFinishChange(e => UILStorage.set(`${prefix}${key}`, e));
            _group.add(number);
            _this['forceUpdate' + key.toUpperCase()] = _ => {
                number.forceUpdate(_shader.get(key), true);
            };
        }

        obj.value = initValue;
    }

    function createColor(obj, key) {
        let initValue = UILStorage.get(`${prefix}${key}`) || obj.value.getHexString();
        if (_group) {
            let color = new UILControlColor(`${prefix}${key}`, {
                label: key,
                value: initValue,
                description: obj.description
            });
            color.onChange(val => {
                obj.value.set(val);
                if (_shader.ubo) _shader.ubo.needsUpdate = true;
                if (_group) Events.emitter._fireEvent(ShaderUIL.UPDATE, {prefix, key, val, color: true, group: _this});
            });
            color.onFinishChange(e => UILStorage.set(`${prefix}${key}`, e));
            _group.add(color);
            _this['forceUpdate' + key.toUpperCase()] = _ => {
                color.force(_shader.get(key).getHexString(), true);
            };
        }

        if (initValue) obj.value.set(initValue);
    }

    function createSelect(obj, key) {
        let initValue = UILStorage.get(`${prefix}${key}`);
        if ( _group ) {
            let { options, description } = obj;
            let select = new UILControlSelect(`${prefix}${key}`, { label: key, value: initValue, options, description });
            select.onChange( val => {
                if ( _group ) Events.emitter._fireEvent(ShaderUIL.UPDATE, {prefix, key, val, group: _this});
                obj.value = val;
                UILStorage.set(`${prefix}${key}`, val);
            });
            _group.add(select);
        }

        if (initValue) obj.value = initValue;
    }

    //*** Event handlers
    function addListeners() {
        Events.emitter._addEvent(ShaderUIL.UPDATE, update, _this);
        Events.emitter._addEvent(ShaderUIL.TEXTURE_UPDATE, textureUpdate, _this);
    }

    function textureUpdate(e) {
        if (!_textures) return;
        let cleanPath = e.file.split('?')[0];
        for (let key in _textures) {
            let testKey = key.includes('?') ? key.split('?')[0] : key;
            if (cleanPath == testKey) {
                _textures[key]({src: e.file, hotreload: true});
            }
        }
    }

    function update(e) {
        if (e.prefix != _shader.UILPrefix || e.group == _this) return;
        if (e.color) {
            let val = e.val;
            let obj = _shader.uniforms[e.key];
            if (Array.isArray(val)) obj.value.setRGB(val[0], val[1], val[2]);
            else obj.value.set(val);
        } else if (e.texture) {
            if (e.texture != 'remote') _shader.set(e.key, e.texture);
        } else if (e.vector) {
            _shader.uniforms[e.key].value.fromArray(e.val);
        } else {
            _shader.uniforms[e.key].value = e.val;
        }
    }

    this.setLabel = function(name) {
        if (_group) _group.setLabel(name);
    }

    this.forceUpdate = function(e) {
        e.prefix = _shader.UILPrefix;
        update(e);
        _this['forceUpdate' + e.key.toUpperCase()]?.();
    }

    this.copyTexture = function(key, shader) {
        let newPrefix = shader.UILPrefix + '_tx';
        let prefix = _shader.UILPrefix + '_tx';
        let data = UILStorage.get(`${prefix}_${key}`);
        if (data) UILStorage.set(`${newPrefix}_${key}`, data);
    }
});

Class(function ShadowUIL() {
    const _this = this;

    //*** Public methods
    this.add = function(light, group) {
        return new ShadowUILConfig(light, group === null ? null : group || UIL.global);
    }
}, 'static');
Class(function ShadowUILConfig(_light, _uil) {
    const _this = this;

    if (!_light.prefix) throw 'light.prefix required when using MeshUIL';

    var prefix = 'SHADOW_'+_light.prefix;
    var _group = _uil ? createFolder() : null;

    //*** Constructor
    (function () {
        _light.target = _light.shadow.target;
        initVec('position');
        initVec('target');
        initNumber('fov');
        initNumber('size');
        initNumber('area');
        initNumber('near');
        initNumber('far');
        initTick('static');
    })();

    function createFolder() {
        if (!UIL.sidebar) return null;
        let folder = new UILFolder(prefix, {label: _light.prefix, closed:true});
        _uil.add(folder);
        return folder;
    }

    function initNumber(key) {
        let initValue = UILStorage.get(`${prefix}${key}`) || _light.shadow[key];
        if (_group) {
            let number = new UILControlNumber(`${prefix}${key}`, {label: key, value: initValue, step: 0.05});
            number.onFinishChange(e => {
                _light.shadow[key] = e;
                UILStorage.set(`${prefix}${key}`, e);
            });
            _group.add(number);
        }

        _light.shadow[key] = initValue;
    }

    function initVec(key) {
        let initValue = UILStorage.get(`${prefix}${key}`) || _light[key].toArray();
        if (_group) {
            let vector = new UILControlVector(`${prefix}${key}`, {label: key, value: initValue, step: 0.05});
            vector.onChange(e => {
                _light[key].fromArray(e);
                if (key == 'target') _light.shadow.camera.lookAt(_light.target);
            });
            vector.onFinishChange(e => UILStorage.set(`${prefix}${key}`, e));
            _group.add(vector);
        }

        _light[key].fromArray(initValue);
    }

    function initTick(key) {
        let initValue = UILStorage.get(`${prefix}${key}`);
        if (_group) {
            let tick = new UILControlCheckbox(`${prefix}${key}`, {label: key, value: initValue});
            tick.onFinishChange(e => {
                _light[key] = e;
                UILStorage.set(`${prefix}${key}`, e)
            });
            _group.add(tick);
        }

        _light[key] = initValue;
    }

    //*** Event handlers

    //*** Public methods
    this.setLabel = function(name) {
        if (_group) _group.setLabel(name);
    }
});
Class(function TimelineUIL() {
    Inherit(this, Component);
    const _this = this;
    var _panel;

    var _data = {};
    var _created = {};

    //*** Constructor
    (function () {

    })();

    //*** Event handlers

    function removePanel() {
        if ( !_panel || !_panel.destroy ) return;
        _this.events.unsub(_panel, Events.COMPLETE, removePanel);
        _panel = _panel.destroy();
    }

    //*** Public methods

    this.create = function ( id, version = 1, group ) {
        if (typeof version != 'number') {
            group = version;
            version = 1;
        }

        group = group === null ? null : group || UIL.global;

        let config = new TimelineUILConfig( id, version, UIL.global && !_created[id]);

        if (UIL.global) {
            if (!_created[id]) {
                _created[id] = config;
                if (group != null) config.appendUILGroup(group || UIL.global);
            }
        }

        return config;
    }

    this.openPanel = function( id, name, template  ) {
        removePanel();
        _panel = new TimelineUILEditor( id, name, template );
        _this.events.sub(_panel, Events.COMPLETE, removePanel);
        return _panel;
    }

    this.set = function () {

    }

    this.get = function () {

    }

}, 'static');
Class(function TimelineUILConfig(_id, _version = 1, _store) {
    Inherit(this, Component);
    const _this = this;
    var _items, _folder;
    var _config, _template = {onSort: _ => {}, onAdd: _ => {}, onRemove: _ => {}};
    var _name = '';

    this.model = new TimelineUILModel(name());

    //*** Constructor
    (function () {
        if (_store) _items = [];
        initConfig();
    })();

    function initConfig() {
        _config = UILStorage.get( name());
        if (_config) {
            if (_config.version != _version) {
                updateConfig();
                UILStorage.clearMatch( name().split('_config')[0]);
            }
        } else {
            _config = {};
            updateConfig();
        }
    }

    function name() {
        return `TL_${_id}_config`;
    }

    function updateConfig() {
        _config.version = _version;
        UILStorage.setWrite( name(), _config);
    }

    function edit() {
        let panel = TimelineUIL.openPanel( name(), _name, _this.template );
        _this.events.bubble( panel, Events.UPDATE );
        _this.events.fire(TimelineUIL.OPEN);
    }

    //*** Event handlers

    //*** Public methods

    this.add = function ( item ) {
        _items && _items.push( item );
        return item;
    }

    this.template = function ( config ) {
        if ( typeof config === 'function' ) _template = config;
        return _template;
    }

    this.appendUILGroup = function(uil) {
        let folder = new UILFolder('TL_'+_id, {closed: true});
        let button = new UILControlButton('button', {actions: [
                {title: 'Edit Timeline', callback: edit},
            ], hideLabel:true});

        folder.add(button);
        uil.add(folder);
        _folder = folder;
    }

    this.setLabel = function(name) {
        if (_folder) _folder.setLabel(name);
        _name = name;
    }

    this.onAdd = function(cb) {
        _template.onAdd = cb;
    }

    this.onRemove = function(cb) {
        _template.onRemove = cb;
    }

    this.onSort = function(cb) {
        _template.onSort = cb;
    }

    this.internalAddItems = function(count) {
        if (!count) return;

        let array = [];
        for (let i = 0; i < count; i++) {
            let id = `${_id}_${Utils.timestamp()}`;
            array.push(id);
        }

        UILStorage.set(`${_id}_list_items`, JSON.stringify(array));
    }
}, _ => {
    TimelineUIL.OPEN = 'list_uil_open';
});
Class(function TimelineUILEditor( _id, _name, _template ) {
    Inherit(this, Component);
    const _this = this;
    const PANEL_CONFIG = { label: 'Timeline Editor', width: '800px', height: 'auto', drag: true };
    var _gui, _static, _list, _add, _config;
    var _tabs = [];
    var _items;
    var _index = 0;

    //*** Constructor
    (function () {
        _this.config = _config = JSON.parse(UILStorage.get(`${_id}_config`) || '{}');
        initPanel();
        refresh();
    })();

    function initPanel() {
        _this.gui = _gui = new UILWindow( _id, PANEL_CONFIG );
        UIL.add(_gui);
    }

    function initList() {
        read();

        _list = new UILFolder( `${_id}_list`, { hideTitle: true });
        // if (!_config.lock) _list.enableSorting( _id );
        _gui.add(_list);

        for ( let id of _items ) {
            let view = _this.initClass(TimelineUILItem, id, _list, _template, _index++);
            _this.events.sub( view, Events.UPDATE, reorder );
            _this.events.sub( view, Events.END, remove );
            _tabs.push( view );
        }

        if (_config.rails) attachRails();
    }

    function attachRails() {
        _tabs.forEach((t, i) => {
            t.onUpdate = v => {
                _tabs.forEach((t2, j) =>{
                    if (t2 == t) return;
                    if (j < i && t.getValue() < t2.getValue()) {
                        t2.setValue(t.getValue());
                    }

                    if (j > i && t.getValue() > t2.getValue()) {
                        t2.setValue(t.getValue());
                    }
                });
            };
        });
    }

    function initAdd() {
        if (!_config.lock) {
            _add = initButton('Add Item', add);
            _add.element.css({width: '20%'});
        }

        let space = initButton('Space Evenly', spaceEvenly);
        space.element.css({width: '20%'});
    }

    function initButton( title, callback ) {
        let hideLabel = true;
        let actions = [{ title, callback }];
        let btn = new UILControlButton( 'button', { actions, hideLabel });
        _gui.add(btn);
        return btn;
    }

    //*** Event handlers
    function spaceEvenly() {
        _tabs.forEach((t, i) => {
            let perc = Math.range(i, 0, _tabs.length-1, 0, 1);
            t.setValue(perc);
        });
    }

    function add() {
        let id = `${_id}_${Utils.timestamp()}`;
        let view = new TimelineUILItem( id, _list, _template, _index++ );
        _this.events.sub( view, Events.UPDATE, reorder );
        _this.events.sub( view, Events.END, remove );
        _tabs.push( view );
        _items.push( id );
        write();
    }

    function reorder( e ) {
        let order = [];
        for ( let item of e.order ) order.push( item.split('_folder')[0] );
        _items = order;
        _template().onSort(_items);
        write();
        _this.events.fire(Events.UPDATE, { order });
    }

    function close() {
        _this.events.fire(Events.COMPLETE);
    }

    function remove( e ) {
        _items.remove( e.id );
        write();
        refresh();
    }

    function read() {
        let data = UILStorage.get(`${_id}_list_items`);
        if ( typeof data === 'undefined' ) data = '[]';
        _items = JSON.parse( data );
    }

    function write() {
        let data = JSON.stringify( _items );
        UILStorage.set(`${_id}_list_items`, data );
    }

    function refresh() {
        _index = 0;
        if ( _list && _list.destroy ) _list = _list.destroy();
        if ( _add && _add.destroy ) _add = _add.destroy();
        initList();
        initAdd();
    }

    //*** Public methods

    this.onDestroy = function() {
        _gui.destroy();
    }

});
Class(function TimelineUILItem( _id, _parent, _template, _index ) {
    Inherit(this, Component);
    const _this = this;
    var $this;
    var _folder;

    //*** Constructor
    (function () {
        initFolder();
        initTemplate();
        initUI();
    })();

    async function initFolder() {
        _folder = InputUIL.create( `${_id}_folder`, _parent );
        _folder.setLabel( 'Item' );
        if (!_this.parent || !_this.parent.config.lock) _folder.group.draggable( true );
        _this.events.sub( _folder.group, UIL.REORDER, onReorder );

        _folder.group.open();
    }

    function initTemplate() {
        let id = _id;
        let init = _template().onAdd;
        init( id, _folder, _index );
    }

    function initUI() {
        _folder.add('label', _this.parent && _this.parent.config.lock ? 'hidden' : undefined);
        _folder.addRange('keyframe');
        _folder.add('percent', 'hidden');

        _folder.getField('keyframe').force(Math.round(_folder.getNumber('percent') * 100) || 0);

        _folder.onUpdate = key => {
            if (key == 'keyframe') {
                let val = _folder.getNumber(key) / 100;
                _folder.setValue('percent', val);
                _this.onUpdate && _this.onUpdate(val);
            }
        };

        let label = _folder.get('label');
        if (label) _folder.setLabel(label);

        if (!_this.parent || !_this.parent.config.lock) {
            let title = 'Delete';
            let callback = onDelete;
            let actions = [{title, callback}]
            let hideLabel = true;
            let del = _folder.addButton('delete', {actions, hideLabel});

            let btn = _folder.getField('delete');
            if (btn) btn.$content.css({width: '20%'});
        }
    }

    //*** Event handlers

    function onDelete() {
        if (!confirm('You sure you want to delete this?')) return;
        let id = _id;
        _template().onRemove(id);
        _this.events.fire( Events.END, { id });
    }

    function onReorder( e ) {
        _this.events.fire( Events.UPDATE, e );
    }

    //*** Public methods
    this.setLabel = function(label) {
        _folder.setLabel(label);
    }

    this.getValue = function(value) {
        return _folder.getNumber('percent');
    }

    this.setValue = function(value) {
        _folder.setValue('percent', value);
        _folder.getField('keyframe').force(Math.round(value * 100) || 0);
    }
});
Class(function TimelineUILModel(_id) {
    const _this = this;
    var _items, _config;

    var _data = [];
    var _map = {};

    //*** Constructor
    (function () {
        initItems();
        initData();
    })();

    function initItems() {
        _config = JSON.parse(UILStorage.get(`${_id}_config`) || '{}');
        _items = JSON.parse(UILStorage.get(`${_id}_list_items`) || '[]');
    }

    function initData() {
        _items.forEach((item, i) => {
            let input = InputUIL.create(`${item}_folder`, null, null, !!UIL.global);

            let data = {};
            data.label = input.get('label') || 'Item';
            data.value = input.getNumber('percent') || 0;
            data.arbitrary = input.get('arbitrary');

            _data.push(data);
            _map[data.label] = data;

            if (UIL.global) {
                Render.start(_ => {
                    data.label = input.get('label') || 'Item';
                    data.value = input.getNumber('percent') || 0;
                }, 10);
            }
        });
    }

    //*** Event handlers

    //*** Public methods
    this.setState = function(array) {
        for (let i = 0; i < array.length; i++) {
            if (!_items[i]) _items.push(`${_id}_${Utils.timestamp()}`);
        }

        if (_items.length > array.length) _items = _items.slice(0, array.length);

        _items.forEach((item, i) => {
            let data = array[i];
            let input = InputUIL.create(`${item}_folder`, null);
            input.setValue('label', data.label);
            if (data.percent) input.setValue('percent', data.percent);
            if (data.arbitrary) input.setValue('percent', data.arbitrary);
        });

        UILStorage.set(`${_id}_list_items`, JSON.stringify(_items));
    }

    this.lock = function() {
        if (_config.lock) return this;
        _config.lock = true;
        if (UIL.global) UILStorage.set(`${_id}_config`, JSON.stringify(_config));
        return this;
    }

    this.rails = function() {
        if (_config.rails) return this;
        _config.rails = true;
        if (UIL.global) UILStorage.set(`${_id}_config`, JSON.stringify(_config));
        return this;
    }

    this.getData = function() {
        return _data;
    }

    this.get = function(key) {
        return _map[key];
    }
});
Class(function CameraLookAtHelper() {
    Inherit(this, Component);
    const _this = this;

    let _camera;
    let _object;
    let _tweener = {
        alpha: 0
    };
    let _defaultLookAt;
    let _lookAt = new Vector3();

    //*** Constructor
    (function () {
    })();

    //*** Event handlers
    function update() {
        _lookAt.copy(_defaultLookAt);
        if (_tweener.alpha > 0) {
            _lookAt.lerp(_object.position, _tweener.alpha, false);
        }
    }

    //*** Public methods
    _this.get('tweener', () => _tweener);

    _this.create = async function(camera, object, tween) {
        _camera = camera;
        _object = object;
        _defaultLookAt = _camera.lookAt;
        await tween.loaded();
        _camera.lookAt = _lookAt;
        _this.events.sub(tween, TweenUIL.UPDATED, update);
    };
});

Class(function TweenUIL() {
    Inherit(this, Component);
    const _this = this;
    var _folders = {};
    var _activeFolder = 'Tweens';

    var _cache = {};
    var _counters = {};
    var _synchronizedTweens = [];
    var _getServerTime;

    _this.jsons = {};

    this.TOGGLE = 'tweenuil_toggle';

    // NOTE: currently using theatre.js fork at https://bitbucket.org/activetheory/theatrejs-fork/src/at-main/
    // Set a non-ticking ticker, to disable the default rAF ticker.
    Theatre.core.setCoreTicker(new Theatre.core.Ticker());

    function initFolder() {
        if (UIL.global) {
            let folder = new UILFolder(_activeFolder, { label: _activeFolder, closed: true });
            _folders[_activeFolder] = folder;
            UIL.global.add(folder);
        }
    }

    //*** Event handlers
    function synchronizedPlaybackLoop() {
        let serverTime = _getServerTime();
        let i = _synchronizedTweens.length - 1;
        while (i >= 0) {
            let tween = _synchronizedTweens[i];
            if (!tween.seekImmediate) {
                _synchronizedTweens.splice(i, 1);
                if (_synchronizedTweens.length === 0) {
                    _this.stopRender(synchronizedPlaybackLoop);
                    break;
                }
            } else {
                let duration = tween.duration * 1000;
                let time = serverTime % duration;
                let progress = time / duration;
                tween.seekImmediate(progress);
                i -= 1;
            }
        }
    }

    //*** Public methods
    this.create = function(name, config, group) {
        if (typeof group === 'boolean') {
            group = undefined;
        }

        let noCache = false;
        if (group == 'nocache') {
            _counters[name] = (_counters[name] || 0) + 1;

            noCache = true;
            group = undefined;
        }

        let folderName = _activeFolder;
        if (typeof group === 'string') {
            folderName = group;
            group = null;
        }

        if (!_folders[folderName]) initFolder();
        if (!_cache[name] || noCache) {
            let tween = new TweenUILConfig(name, config, group || _folders[folderName], _counters[name]);
            tween._bindOnDestroy(_ => {
                delete _cache[name];
            });
            _cache[name] = tween;
        }
        return _cache[name];
    }

    this.setFolder = function(name) {
        _activeFolder = name;
    }

    this.setServerTimeGetter = function(getServerTime) {
        _getServerTime = getServerTime;
    };

    this.playSynchronized = async function(tween) {
        if (!_getServerTime) {
            console.error('Need to call TweenUIL.setServerTimeGetter(() => time) before using TweenUIL.playSynchronized()');
            return;
        }
        await tween.preload();
        tween.progress; // ensure duration has been calculated
        tween.manualRender = true;
        _synchronizedTweens.unshift(tween);
        _this.startRender(synchronizedPlaybackLoop);
    };

    this.stopSynchronized = function(tween) {
        _synchronizedTweens.remove(tween);
        if (_synchronizedTweens.length === 0) _this.stopRender(synchronizedPlaybackLoop);
    };
}, 'static');

Class(function TweenUILAnchor() {
    Inherit(this, Object3D);
    const _this = this;

    this.isTweenAnchor = true;
    
    //*** Event handlers
    
    //*** Public methods
    
});
Class(function TweenUILConfig(_name, _config, _group, _noCache) {
    Inherit(this, Component);
    const _this = this;
    var _input, _editor, _promise, _project, _meshes, _keyframes;
    var _pathVisualization, _layersWithWarnings = {};
    var _flatMap = {};
    var _sheets = {};
    var _projectInstanceId;
    var _duration = 0;
    var _objectsWithTracks;
    var _savedState;
    var _ticker;
    var _manualRender = false;
    var _changedKeys = {};
    var _cameras = [];
    var _editorPosition = 0;

    //*** Constructor
    (async function() {
        initTicker();
        _input = InputUIL.create(_name + '_tween', _group);
        _input.setLabel(_name);
        _input.addButton('edit', {
            label: 'Edit',
            actions: [
                { title: 'Editor', callback: openEditor }
            ]
        });

        try {
            _savedState = TweenUIL.jsons[_name];
            if (_savedState?.then) _savedState = await _savedState; // another fetch is in progress, wait for it
            if (!_savedState) {
                let promise = get(Assets.getPath(`assets/data/timeline-${_name}.json`));
                if (_noCache) TweenUIL.jsons[_name] = promise; // share the promise to ensure only one simultaneous fetch
                _savedState = await promise;
            }
            if (_noCache) {
                _projectInstanceId = `instance_${_noCache}`;
                TweenUIL.jsons[_name] = _savedState;
            }
        } catch {
            if (Hydra.LOCAL) console.warn(`No saved TweenUIL timeline “timeline-${_name}.json”, create one with the Editor`);
            // Provide a valid empty state object to suppress Theatre.js error message.
            _savedState = {
                sheetsById: {},
                definitionVersion: '0.4.0',
                revisionHistory: []
            };
        }
        _project = Theatre.core.getProject(_name, { state: _savedState });
        _this._bindOnDestroy(_ => {
            // Remove the project from the theatre.js cache, which will force to it be recreated
            // in case the same project name is requested again.
            // TODO the Project/TheatreProject does not seem to be garbage collected.
            _project.destroy();
        });

        await _project.ready;
        for (let key in _savedState.sheetsById) {
            _sheets[key] = _project.sheet(key, { instanceId: _projectInstanceId, ticker: _ticker });
            let state = _savedState.sheetsById[key];
            if (!_group) initObjectsWithTracks(state);
            _sheets[key].length = findTrueDuration(state.sequence);
        }

        _input.addButton('play', {
            label: 'Play',
            actions: [
                { title: 'Play', callback: play }
            ]
        });

        _input.addRange('Scrub', 0, { min: 0, max: 1, step: 0.0005 });
        _input.onUpdate = async key => {
            if (key == 'Scrub') {
                if (!_config.sheets) await play();
                let value = _input.getNumber('Scrub');
                _this.seek(value);
            }
        };

        _this.flag('ready', true);
    })();

    function initTicker() {
        _ticker = new Theatre.core.Ticker();
        _this.startRender(loop);
    }

    function loop() {
        _this.events.fire(TweenUIL.BEFORE_UPDATE);
        Object.keys(_flatMap).forEach(key => _changedKeys[key] = false);
        _ticker.tick(Render.TIME);
        _this.events.fire(TweenUIL.UPDATED, { changed: _changedKeys });
        _cameras.forEach(camera => camera.update());
    }

    function initObjectsWithTracks(state) {
        if (!_objectsWithTracks) _objectsWithTracks = {};
        let tables = [state.staticOverrides?.byObject, state.sequence?.tracksByObject].filter(Boolean);
        tables.forEach(table => {
            Object.keys(table).forEach(key => {
                let parts = key.split(' » ');
                let name = parts.length > 1 ? parts.last() : key;
                let matches = /(.*)_(shader|behavior)$/.exec(name);
                if (matches) {
                    name = matches[1];
                }
                _objectsWithTracks[name] = true;
            });
        });
    }

    function ignoreObject(name, layoutName) {
        if (!_objectsWithTracks) return false;
        if (_objectsWithTracks[name]) return false;
        return true;
    }

    function findTrueDuration(sequence) {
        let duration = 0;
        let tracks = sequence.tracksByObject;

        for (let k1 in tracks) {
            let obj = tracks[k1];
            if (k1 == 'tween_anchor') findAnchorKeyframes(obj);
            for (let k2 in obj.trackData) {
                let trackData = obj.trackData[k2];
                for (let k3 in trackData.keyframes) {
                    let keyframe = trackData.keyframes[k3];
                    if (keyframe.position) duration = Math.max(duration, keyframe.position);
                }
            }
        }

        return duration;
    }

    function checkDuration() {
        if (_duration === 0) {
            for (let key in _sheets) {
                _duration = Math.max(_duration, _sheets[key].length);
            }
        }
    }

    function findAnchorKeyframes(obj) {
        for (let k1 in obj) {
            for (let k2 in obj[k1]) {
                let keyframes = obj[k1][k2].keyframes;
                if (keyframes) {
                    _keyframes = keyframes;
                }
            }
        }
    }

    async function play(options = {}) {
        if (!_config.sheets) {
            await prepareConfig();
            linkLocally();
        }

        checkDuration();

        for (let key in _sheets) {
            if (!options.disableAutoPosition) {
                _sheets[key].sequence.position = options?.direction === 'reverse' ? _duration : 0;
            }

            _sheets[key].sequence.play(options);
        }
        return _promise = _this.wait(_duration * 1000);
    }

    function linkLocally() {
        makeSendable().sheets.forEach(obj => {
            const sheet = _sheets[_config.mergedSheetName];
            if (!sheet) return;

            for (let key in obj) {
                for (let key2 in obj[key]) {
                    let finalObj = obj[key][key2];
                    if (
                        typeof finalObj.r === 'number' &&
                        typeof finalObj.g === 'number' &&
                        typeof finalObj.b === 'number'
                    ) {
                        Object.assign(finalObj, Theatre.core.types.rgba(finalObj));
                    }
                }

                const timelineObject = sheet.object(getTrackNameFromKey(key), obj[key]);
                timelineObject.onValuesChange(newValue => {
                    _changedKeys[key] = true;
                    completeDataLink(newValue, _flatMap[key]);
                });
            }
        });
    }

    function getTrackNameFromKey(key, disambiguate = false) {
        let name = key.split('&');
        let prefix = name[0];
        name.shift();
        name = name.join('_');
        if (disambiguate) {
            name = `${prefix} » ${name}`;
        }
        return name;
    }

    async function prepareConfig() {
        let array = Array.isArray(_config) ? _config : [_config];
        _config = {};
        _config.nudgeMultiplier = 0.05;
        let sheet = {};
        _config.sheets = [sheet];
        for (let i = 0; i < array.length; i++) {
            let objects = array[i];
            let layoutName;
            let options = {};
            if (objects instanceof SceneLayout) {
                layoutName = objects.name;
                options.isSceneLayout = true;
                objects = await getObjectsFromLayout(objects);
            } else if (typeof objects === 'object') {
                if (i === 0) {
                    // name based on type of objects for backward compatibility
                    let obj0 = objects[Object.keys(objects)[0]];
                    if (obj0 instanceof Mesh) {
                        layoutName = 'Scene';
                    } else if (obj0.uniforms) {
                        layoutName = 'Shader';
                    } else if (isElement(obj0)) {
                        layoutName = 'Elements';
                    }
                }
            } else {
                throw `TweenUIL :: Type not supported`;
            }
            if (!layoutName) {
                layoutName = `Scene${i + 1}`;
            }
            mergeSheets(sheet, createSheetFromObjects(objects, layoutName, options));
            if (i === 0) {
                _config.mergedSheetName = layoutName;
            }
        }
        _this.flag('isLoaded', true);
    }

    function mergeSheets(sheet1, sheet2) {
        let usedNames = {};
        Object.keys(sheet1).forEach(key => {
            usedNames[getTrackNameFromKey(key)] = true;
        });
        Object.keys(sheet2).forEach(key => {
            let name = getTrackNameFromKey(key);
            let newKey = key;
            if (usedNames[name]) {
                // Same layer name used in multiple layouts/objects; need to
                // disambiguate.
                name = getTrackNameFromKey(key, true);
                newKey = `${key.split('&')[0]}&${name}`;
                _flatMap[newKey] = _flatMap[key];
                delete _flatMap[key];
            }
            usedNames[name] = true;
            sheet1[newKey] = sheet2[key];
        });
        return sheet1;
    }

    function makeEulerLink(layer, key) {
        return {
            copy: obj => {
                layer[key].set(
                    Math.radians(obj.x),
                    Math.radians(obj.y),
                    Math.radians(obj.z)
                );
            },

            get x() {
                return Math.degrees(layer[key].x);
            },

            get y() {
                return Math.degrees(layer[key].y);
            },

            get z() {
                return Math.degrees(layer[key].z);
            }
        };
    }

    function getMeshObject(layer, parent, layerName) {
        if (parent?.isTweenAnchor) {
            let obj = {};
            obj.anchor = {
                anchor: 0,
                link: {
                    copy() {} // no need to do anything with this.
                }
            };
            return obj;
        }

        layer.rotationLink = makeEulerLink(layer, 'rotation');

        let obj = {
            position: {x: layer.position.x, y: layer.position.y, z: layer.position.z, link: layer.position},
            scale: {x: layer.scale.x, y: layer.scale.y, z: layer.scale.z, link: layer.scale},
            rotation: {x: Math.degrees(layer.rotation.x), y: Math.degrees(layer.rotation.y), z: Math.degrees(layer.rotation.z), link: layer.rotationLink},
        };
        if (layer._cameraUIL) {
            obj.cameraPos = {
                x: parent.position.x,
                y: parent.position.y,
                z: parent.position.z,
                link: {
                    copy(from) {
                        // Don't use GazeCamera.position.copy() because that clobbers the interactive gaze
                        // functionality.
                        parent.move(from);
                    }
                }
            };
            obj.zoom = {
                zoom: parent.zoom,
                link: {
                    copy(from) {
                        parent.zoom = from.zoom;
                    }
                }
            };
            obj.lookAt = {
                x: parent.lookAt.x,
                y: parent.lookAt.y,
                z: parent.lookAt.z,
                link: parent.lookAt
            };
            obj.moveXY = {
                x: parent.moveXY.x,
                y: parent.moveXY.y,
                link: parent.moveXY
            };
            obj.cameraRotation = {
                x: Math.degrees(parent.cameraRotation.x),
                y: Math.degrees(parent.cameraRotation.y),
                z: Math.degrees(parent.cameraRotation.z),
                link: makeEulerLink(parent, 'cameraRotation')
            };
            obj.viewportFocus = {
                x: parent.viewportFocus.x,
                y: parent.viewportFocus.y,
                link: parent.viewportFocus
            };
            let camera = layer.classRef;
            camera.manualRender = true;
            _cameras.push(camera);
        }

        if (UIL.global) {
            if (!_meshes) _meshes = [];
            layer._uilLayerName = layerName;
            _meshes.push(layer);
        }

        if (parent?.tweenToggle) {
            obj.toggle = {on: 0, link: {copy: e => {
                if (e.on == 0 && parent.flag('tweenToggle')) {
                    parent.flag('tweenToggle', false);
                    parent.events.fire(TweenUIL.TOGGLE, {on: false});
                } else if (e.on == 1 && !parent.flag('tweenToggle')) {
                    parent.events.fire(TweenUIL.TOGGLE, {on: true});
                    parent.flag('tweenToggle', true);
                }
            }}};
        }

        return obj;
    }

    function getShaderObject(shader) {
        let obj = {};
        for (let key in shader.uniforms) {
            let uniform = shader.uniforms[key];
            let value = uniform.value;
            if (typeof value === 'undefined' || uniform.ignoreUIL || key == 'HZ') continue;

            if (typeof value === 'number') {
                obj[key] = {value, link: uniform};
            } else if (value instanceof Vector2) {
                obj[key] = {x: value.x, y: value.y, link: value};
            } else if (value instanceof Vector3) {
                obj[key] = {x: value.x, y: value.y, z: value.z, link: value};
            } else if (value instanceof Vector4) {
                obj[key] = {x: value.x, y: value.y, z: value.z, w: value.w, link: value};
            } else if (value instanceof Color) {
                obj[key] = {r: value.r, g: value.g, b: value.b, a: 1, link: value};
            }
        }

        return obj;
    }

    function isElement(object) {
        if (object?.div?.hydraObject) return true;
        if (typeof GLUIObject === 'undefined') return false;
        if (object instanceof GLUIObject) return true;
        if (object instanceof GLUIText) return true;
        return false;
    }

    function getElementObject($element) {
        let obj = {
            _config: {
                nudgeMultiplier: 1
            }
        };

        if (typeof $element.x !== 'undefined') obj.x = {value: $element.x, link: $element};
        if (typeof $element.y !== 'undefined') obj.y = {value: $element.y, link: $element};
        if (typeof $element.z !== 'undefined') obj.z = {value: $element.z, link: $element};
        if (typeof $element.scale !== 'undefined') obj.scale = {value: $element.scale, link: $element};
        if (typeof $element.scaleX !== 'undefined') obj.scaleX = {value: $element.scaleX, link: $element};
        if (typeof $element.scaleY !== 'undefined') obj.scaleY = {value: $element.scaleY, link: $element};
        if (typeof $element.rotation !== 'undefined') obj.rotation = {value: $element.rotation, link: $element};
        if (typeof $element.rotationX !== 'undefined') obj.rotationX = {value: $element.rotationX, link: $element};
        if (typeof $element.rotationY !== 'undefined') obj.rotationY = {value: $element.rotationY, link: $element};
        if (typeof $element.rotationZ !== 'undefined') obj.rotationZ = {value: $element.rotationZ, link: $element};
        if (typeof $element.alpha !== 'undefined') obj.alpha = {value: $element.alpha, link: $element};

        return obj;
    }

    function getPlainObject(object) {
        let obj = {};
        for (let key in object) {
            let value = object[key];
            if (typeof value === 'number') {
                obj[key] = {value, link: object};
            } else if (value instanceof Vector2) {
                obj[key] = {x: value.x, y: value.y, link: value};
            } else if (value instanceof Vector3) {
                obj[key] = {x: value.x, y: value.y, z: value.z, link: value};
            } else if (value instanceof Vector4) {
                obj[key] = {x: value.x, y: value.y, z: value.z, w: value.w, link: value};
            } else if (value instanceof Color) {
                obj[key] = {r: value.r, g: value.g, b: value.b, a: 1, link: value};
            }
        }
        if (Object.keys(obj).length) return obj;
    }

    async function getObjectsFromLayout(layout) {
        let layers = await layout.getAllLayers();
        let objects = {};
        for (let key in layers) {
            let layer = layers[key];
            if (ignoreObject(key, layout.name)) continue;
            if (layer.animates === false) continue;
            if (layer.ready && !layer.disabled) await layer.ready();
            objects[key] = layer;
        }
        return objects;
    }

    function createSheetFromObjects(objects, layoutName, { isSceneLayout }) {
        let sheet = {};
        for (let name in objects) {
            let object = objects[name];
            let key = `${layoutName}&${name}`;
            if (ignoreObject(name, layoutName)) continue;
            let matched = false;
            if (object.uniforms) {
                _flatMap[key] = sheet[key] = getShaderObject(object);
                continue;
            }
            if (isElement(object)) {
                _flatMap[key] = sheet[key] = getElementObject(object);
                continue;
            }
            if (object instanceof Mesh || object instanceof Group) {
                _flatMap[key] = sheet[key] = getMeshObject(object, null, key);
                matched = true;
            }
            if (object.shader) {
                _flatMap[`${key}&shader`] = sheet[`${key}&shader`] = getShaderObject(object.shader);
                matched = true;
            }
            if (object.behavior) {
                _flatMap[`${key}&behavior`] = sheet[`${key}&behavior`] = getShaderObject(object.behavior);
                matched = true;
            }
            if (object.group) {
                _flatMap[key] = sheet[key] = getMeshObject(object.group, object, key);
                matched = true;
            }
            if (!matched && !isSceneLayout) {
                // None of the above: animate properties of a plain object
                let obj = getPlainObject(object);
                if (obj) {
                    _flatMap[key] = sheet[key] = obj;
                } else {
                    console.warn(`Unclear how to animate object ${key}`, object);
                }
            }
        }
        return sheet;
    }

    function makeSendable() {
        const cleanObject = obj => {
            let newObj = {};
            for (let key in obj) {
                if (key == 'link') continue;
                newObj[key] = obj[key];
            }
            return newObj;
        };

        let obj = {sheets: [], nudgeMultiplier: _config.nudgeMultiplier};
        obj.filePath = Assets.getPath(`assets/data/timeline-${_name}.json`);
        if (!obj.filePath.includes('http')) obj.filePath = Hydra.absolutePath(obj.filePath);

        _config.sheets.forEach(sheet => {
            let newSheet = {};
            for (let key in sheet) {
                let top = sheet[key];
                newSheet[key] = {};
                for (let key2 in top) {
                    newSheet[key][key2] = cleanObject(top[key2]);
                }
            }
            obj.sheets.push(newSheet);
        });

        return obj;
    }

    function completeDataLink(dataObj, realObj) {
        let transform;
        for (let key2 in realObj) {
            if (key2 === '_config') continue;
            let valueObj = dataObj[key2];
            let link = realObj[key2].link;
            if (typeof valueObj.value !== 'undefined') {
                if (!Object.prototype.hasOwnProperty.call(link, key2) && Object.prototype.hasOwnProperty.call(link, 'value')) {
                    link.value = valueObj.value;
                } else {
                    link[key2] = valueObj.value;
                }

                transform = link.transform;
                if (!!transform && key2 == 'alpha') link.css('opacity', valueObj.value);
            } else {
                link.copy(valueObj);
            }
        }
        if (transform) transform();
    }

    //*** Event handlers
    function linkData(data) {
        for (let key in data) {
            let dataObj = data[key];
            let realObj = _flatMap[key];

            _changedKeys[key] = true;
            completeDataLink(dataObj, realObj);
        }
    }

    async function openEditor() {
        if (!_config.sheets) await prepareConfig();

        _editor = new UILExternalTimeline(_name, 800, 1200, makeSendable(_config));
        _editor.onMessage = linkData;
        _editor.onVisualizePath = handleVisualizePath;
        _editor.onPositionChange = onPositionChange;

        _editor.onDestroy = _ => {
            _editor = null;
            handleVisualizePath({});
            _meshes?.forEach(mesh => {
                if (mesh._cameraUIL) {
                    mesh._cameraUIL.tweenUIL_groupPos = null;
                    mesh._cameraUIL.tweenUIL_scale = null;
                    mesh._cameraUIL.tweenUIL_rotation = null;
                    mesh._cameraUIL.tweenUIL_position = null;
                    mesh._cameraUIL.tweenUIL_zoom = null;
                    mesh._cameraUIL.tweenUIL_lookAt = null;
                    mesh._cameraUIL.tweenUIL_cameraRotation = null;
                    mesh._cameraUIL.tweenUIL_viewportFocus = null;
                }
                if (mesh._meshUIL) {
                    mesh._meshUIL.tweenUIL_scale = null;
                    mesh._meshUIL.tweenUIL_position = null;
                    mesh._meshUIL.tweenUIL_rotation = null;
                }
            });
        };

        _meshes?.forEach(mesh => {
            if (mesh._cameraUIL) {
                mesh._cameraUIL.tweenUIL_groupPos = value => _editor.sendUpdate(mesh._uilLayerName, value, 'position');
                mesh._cameraUIL.tweenUIL_scale = value => _editor.sendUpdate(mesh._uilLayerName, value, 'scale');
                mesh._cameraUIL.tweenUIL_rotation = value => _editor.sendUpdate(mesh._uilLayerName, value, 'rotation');
                mesh._cameraUIL.tweenUIL_position = value => _editor.sendUpdate(mesh._uilLayerName, value, 'cameraPos');
                mesh._cameraUIL.tweenUIL_zoom = value => _editor.sendUpdate(mesh._uilLayerName, value, 'zoom');
                mesh._cameraUIL.tweenUIL_lookAt = value => _editor.sendUpdate(mesh._uilLayerName, value, 'lookAt');
                mesh._cameraUIL.tweenUIL_cameraRotation = value => _editor.sendUpdate(mesh._uilLayerName, value, 'cameraRotation');
                mesh._cameraUIL.tweenUIL_viewportFocus = value => _editor.sendUpdate(mesh._uilLayerName, value, 'viewportFocus');
            } else if (mesh._meshUIL) {
                mesh._meshUIL.tweenUIL_position = value => _editor.sendUpdate(mesh._uilLayerName, value, 'position');
                mesh._meshUIL.tweenUIL_scale = value => _editor.sendUpdate(mesh._uilLayerName, value, 'scale');
                mesh._meshUIL.tweenUIL_rotation = value => _editor.sendUpdate(mesh._uilLayerName, value, 'rotation');
            }
        });
    }

    function updateKeyframeData() {
        for (let key in _sheets) {
            _this.keyframeTotalProgress = _keyframes.positionObject.position / _sheets[key].length;
        }
        _this.keyframeIndex = _keyframes.current;
        _this.keyframeLocalProgress = Math.fract(_keyframes.positionObject.position);
    }

    function updateKeyframeLoop(hz) {
        _keyframes.positionObject.position = Math.lerp(_keyframes.positionObject.target, _keyframes.positionObject.position, 0.07 * hz, false);
        for (let key in _sheets) {
            _sheets[key].sequence.position = _keyframes.positionObject.position;
        }
        updateKeyframeData();
    }

    function onPositionChange(position) {
        _editorPosition = position;
    }

    function handleVisualizePath(data) {
        if (!_pathVisualization && !data.position) return;
        if (!_pathVisualization) _pathVisualization = _this.initClass(TweenUILPathVisualization);
        let object;
        if (data.sheetId) {
            // Find the mesh in question
            let parts = data.objectKey.split(' » ');
            let prefix = parts.length > 1 ? parts[0] : data.sheetId;
            let objectKey = parts.length > 1 ? parts.last() : data.objectKey;
            let key = `${prefix}&${objectKey}`;
            object = _meshes.find(({ _uilLayerName }) => _uilLayerName === key);
            if (!object && !_layersWithWarnings[key]) {
                console.warn(`Couldn’t find mesh for object “${key}”.`);
                _layersWithWarnings[key] = true;
            }
        }
        _pathVisualization.object = object;
        _pathVisualization.update(data);
    }

    //*** Public methods
    this.play = async function(options) {
        await _this.wait('ready');
        return play(options);
    }

    this.seek = function(value) {
        if (!_this.flag('ready')) return;

        checkDuration();
        for (let key in _sheets) {
            _sheets[key].sequence.position = Math.min(_sheets[key].length, _duration * value);
        }
    }

    this.seekImmediate = function(value) {
        _this.seek(value);
        loop();
    }

    this.promise = async function() {
        await _this.wait('ready');
        return _promise;
    }

    this.setLabel = function(label) {
        if (_input) _input.setLabel(label);
    }

    this.preload = async function() {
        await _this.wait('ready');

        if (!_config.sheets) {
            await prepareConfig();
            linkLocally();
        } else if (!_this.flag('isLoaded')) {
            return _this.wait('isLoaded');
        }

        _this.seek(0);
    };

    this.loaded = async function() {
        if (!_this.flag('isLoaded')) {
            if (_config.sheets) return _this.wait('isLoaded');
        }
        await _this.preload();
    };

    this.seekToKeyframe = async function(index) {
        if (!_this.flag('isLoaded')) await _this.preload();
        if (!_keyframes) return console.warn('TweenUILConfig :: Missing keyframes! Add tween_anchor layer');
        _keyframes.current = index;
        _keyframes.positionObject = {position: _keyframes[index].position, target: _keyframes[index].position};
        _this.seek(_keyframes[index].position);
        updateKeyframeData();
        _this.startRender(updateKeyframeLoop, RenderManager.NATIVE_FRAMERATE);
    }

    this.playToKeyframe = async function(index, time, ease = 'linear', delay) {
        await _this.wait('ready');
        if (!_keyframes.positionObject) await _this.seekToKeyframe(0);
        let nextKeyframe = _keyframes[index];
        let currentKeyframe = _keyframes[_keyframes.current];
        if (!nextKeyframe) return;
        let position = nextKeyframe.position;
        if (!time) time = Math.abs(nextKeyframe.position - currentKeyframe.position) * 1000;
        if (_keyframes.tween) _keyframes.tween = clearTween(_keyframes.tween);
        _keyframes.current = index;
        _this.flag('playingToKeyframe', true, time+50);
        _keyframes.tween = tween(_keyframes.positionObject, {target: position}, time, ease, delay);
        return _keyframes.tween.promise();
    }

    this.peekInKeyframeDirection = function(dir, percent) {
        if (!_keyframes || _this.flag('playingToKeyframe')) return;
        let currentKeyframe = _keyframes[_keyframes.current];
        let nextKeyframe = _keyframes[_keyframes.current + dir];
        if (!nextKeyframe) return;

        _keyframes.positionObject.target = Math.mix(currentKeyframe.position, nextKeyframe.position, percent);
    }

    this.playToNextKeyframe = async function(time, ease, delay) {
        return this.playToKeyframe(_keyframes.current + 1, time, ease, delay);
    }

    this.playToPrevKeyframe = async function(time, ease, delay) {
        return this.playToKeyframe(_keyframes.current - 1, time, ease, delay);
    }

    this.playToDirKeyframe = async function(dir, time, ease, delay) {
        return this.playToKeyframe(_keyframes.current + dir, time, ease, delay);
    }

    this.get('position', _ => {
        let position = 0;
        for (let key in _sheets) {
            position = Math.max(position, _sheets[key]?.sequence?.position || 0);
        }

        if (_editor) {
            position = _editorPosition;
        }

        return position;
    });

    this.get('progress', _ => {
        checkDuration();
        return _this.position / _duration;
    });
    _this.get('duration', () => _duration);

    this.get('totalKeyframes', _ => _keyframes ? _keyframes.length : 0);
    this.get('currentKeyframe', _ => _keyframes ? _keyframes.current : 0);
    this.get('keyframeValue', _ => {
        // Calculate keyframeValue immediately, so it will be correct immediately after seeking.
        // Otherwise it would be wrong until the next tick.
        if (!_keyframes) return 0;
        let position = _this.position;
        for (let i = 0; i < _keyframes.length; ++i) {
            let keyframe = _keyframes[i];
            if (position >= keyframe.position) {
                let nextKeyframe = _keyframes[i + 1];
                if (!nextKeyframe) return keyframe.value;
                if (position < nextKeyframe.position) {
                    // Note: this calculates keyframeValue as if there was a linear ease on the
                    // tween anchor, which is probably not the case. But having a non-linear ease
                    // on the tween anchor keyframes doesn’t make sense anyway.
                    return Math.range(position, keyframe.position, nextKeyframe.position, keyframe.value, nextKeyframe.value, true);
                }
            }
        }
        return _keyframes[0]?.value || 0;
    });
    _this.get('keyframeSection', _ => Math.fract(_this.keyframeValue));

    _this.getPositionAtKeyframeValue = keyframeValue => {
        let index = Math.floor(keyframeValue);
        let position = _keyframes[index]?.position || 0;
        let progress = Math.fract(keyframeValue);
        if (progress) {
            let nextPosition = _keyframes[index + 1]?.position;
            if (nextPosition) {
                position = Math.mix(position, nextPosition, progress);
            }
        }
        return position;
    };

    _this.getProgressAtKeyframeValue = keyframeValue => {
        checkDuration();
        return _this.getPositionAtKeyframeValue(keyframeValue) / _duration;
    };

    _this.getTrackData = function(objectName) {
        for (let key in _savedState.sheetsById) {
            let tracks = _savedState.sheetsById[key].sequence.tracksByObject;
            if (tracks[objectName]) return tracks[objectName];
        }
    };

    this.get('manualRender', () => _manualRender);
    this.set('manualRender', value => {
        value = !!value;
        if (value === _manualRender) return;
        _manualRender = value;
        if (_manualRender) {
            _this.stopRender(loop);
        } else {
            _this.startRender(loop);
        }
    });

    _this.update = () => {
        if (!_manualRender && Hydra.LOCAL && !_this.flag('manualRenderWarned')) {
            console.warn('Set manualRender to true if using TweenUIL.update()');
            _this.flag('manualRenderWarned', true);
        }
        loop();
    };
}, () => {
    TweenUIL.BEFORE_UPDATE = 'TweenUIL.BEFORE_UPDATE';
    TweenUIL.UPDATED = 'TweenUIL.UPDATED';
});

Class(function UILFile(_offline, _path) {
    Inherit(this, Component);
    const _this = this;

    this.load = async function() {
        let path = window.UIL_STATIC_PATH || 'assets/data/uil.json';
        try {
            let data = await get(path);

            // detect merge conflicts
            // data is string when invalid json
            if (typeof data === 'string') {
                if (Hydra.LOCAL) {
                    return null;
                }

                return {};
            }

            return data;
        } catch(e) {
            return {};
        }
    }

    this.save = async function(sessionData, data) {
        Dev.writeFile(window.UIL_STATIC_PATH || 'assets/data/uil.json', data);
        if (_offline) {
            let partial = {};
            try {
                partial = await get('assets/data/uil-partial.json', data);
                for (let key in sessionData) {
                    partial[key] = sessionData[key];
                }
            } catch(e) {
                partial = sessionData;
            }
            Dev.writeFile('assets/data/uil-partial.json', partial);
            Storage.set('uil_update_partial', true);
        }
    }

});
Class(function UILStorage() {
    Inherit(this, Component);
    const _this = this;

    var _storeIds = [];
    var _data = {};
    var _dataSession = {};
    var _id = window.UIL_ID || 'default';
    var _remote = window.UIL_REMOTE || false;
    var _storage;
    window.UIL_ID = _id = _id.replaceAll(/[^a-zA-Z0-9 _-]/g, '');

    var _platform;

    var _fs, _keys;

    this.SAVE = 'uil_save';

    const OFFLINE_FIREBASE = Utils.query('offlineFB');

    Hydra.ready(async _ => {
        if (window.Platform && Platform.isDreamPlatform && Config.PLATFORM_CONFIG) initLocalCached();
        else if (!(Hydra.LOCAL && window.Platform && window.Platform.isPlatform)) init();
        if (!Utils.query('editMode') &&
            !(Hydra.LOCAL && window.Platform && window.Platform.isDreamPlatform && Utils.query('uil')) &&
            (!Hydra.LOCAL || Device.mobile || window._BUILT_ || !(Utils.query('uil') || Device.detect('hydra')))) return;
        __window.bind('keydown', e => {
            if ((e.ctrlKey || e.metaKey) && e.keyCode == 83) {
                e.preventDefault();
                write();
            }
        });
    });

    function clearOfflineData() {
        Storage.set('uil_update_partial', false);
        Dev.writeFile('assets/data/uil-partial.json', {});
    }

    async function init() {
        if (_fs) _fs.destroy();
        _fs = _this.initClass(uilFile() ? UILFile : UILRemote, OFFLINE_FIREBASE);

        let data = await _fs.load();

        // if invalid data, update from remote and reload
        if (data === null) {
            let remoteFs = _this.initClass(UILRemote);
            let remoteData = await remoteFs.load();

            if (confirm('Looks like the local uil.json has merge conflicts, do you want to sync from Firebase and resolve it?')) {
                _data[_id] = remoteData;
                await write();

                window.location.reload();
            } else {
                data = {};
            }
        }

        _data[_id] = data;
        _this.loaded = true;

        if (!OFFLINE_FIREBASE && Storage.get('uil_update_partial') && !uilFile()) {
            if (!confirm('Looks like you have UIL data captured offline, do you want to sync it to Firebase?')) return clearOfflineData();
            let data = await get('assets/data/uil-partial.json');
            for (let key in data) _this.set(key, data[key]);
            write(true, true);
            clearOfflineData();
        }
    }

    async function initLocalCached() {
        _fs = _this.initClass(UILFile);
        _data[_id] = await _fs.load();
        _this.loaded = true;
    }

    async function write(direct, silent) {
        let prevent = false;
        let e = {};
        e.prevent = _ => prevent = true;
        _this.events.fire(_this.SAVE, e);

        if (!direct) {
            if (e.wait) await e.wait();
            if (prevent) return;
        }

        _fs.save(_dataSession, _data[_id]);
        _dataSession = {};

        if (!silent) {
            __body.css({ display: 'none' });
            _this.delayedCall(() => {
                __body.css({ display: 'block' });
            }, 100);
        }
    }

    function uilFile() {
        if (Utils.query('editMode')) return false;
        if (!Hydra.LOCAL) return true;
        if (window.Config && Config.PLATFORM_CONFIG && Utils.query('uil')) return false;
        if (Device.mobile) return true;
        if (OFFLINE_FIREBASE) return true;
        if (window._BUILT_ && !Hydra.LOCAL) return true;
        if (window.AURA) return true;
        if (window._UIL_FILE_) return true;
        if (!window._FIREBASE_UIL_ && !window.UIL_ID) return true;
        if (Device.detect('hydra')) return false;
        if (!Utils.query('uil')) return true;
        return false;
    }

    this.reload = function (id, path, persist) {
        _this.loaded = false;
        if (!_platform) _platform = _id; // if reloaded, then preserve original uil id as _platform;
        if (persist) _storeIds.push(id);
        _id = id;
        window.UIL_ID = id;
        window.UIL_STATIC_PATH = path;
        init();
    };

    this.set = function (key, value) {
        if (value === null) {
            delete _data[_id][key];

            // null value to be sent to firebase to remove field
            _dataSession[key] = value;
        } else {
            _data[_id][key] = value;
            _dataSession[key] = value;
        }
    };

    this.setWrite = function (key, value) {
        this.set(key, value);
        write(true);
    };

    this.clearMatch = function (string) {
        for (let key in _data[_id]) {
            if (key.includes(string)) delete _data[_id][key];
        }

        write(true);
    };

    this.write = function (silent) {
        write(true, silent);
    };

    this.get = function (key) {
        // load from id (child), otherwise try platform uil
        let val = _data[_id] && _data[_id][key];
        if (val === undefined && _platform) val = _data[_platform][key];
        if (val === undefined && _storeIds) {
            for (let i = 0; i < _storeIds.length; i++) {
                try {
                    val = _data[_storeIds[i]][key];
                } catch (e) {
                    val = undefined;
                }
            }
        }
        return val;
    };

    this.ready = function () {
        return _this.wait(_this, 'loaded');
    };

    this.getKeys = function () {
        if (!_keys) _keys = Object.keys(_data[_id]);
        return _keys;
    }

    this.hasData = function () {
        return !!_data[_id];
    }

    _this.uploadFileToRemoteBucket = async function ({ file, progress }) {
        if (!_remote) return;

        if (!_storage) {
            await Services.ready();
            _storage = Services.app().storage();
        }

        let filename = file.name.replace(/ /g, "_");
        const ref = _storage.ref(`_tmp/${filename}`);
        const path = `https://storage.googleapis.com/${ref.bucket}/uploads/${_id}/${filename}`.toLowerCase();

        const metadata = { customMetadata: { id: _id, path, contentType: file.type } }
        const result = ref.put(file, metadata)

        if (progress) {
            result.on('state_changed', (snapshot) => {
                let _progress = (snapshot.bytesTransferred / snapshot.totalBytes) * 95;
                progress.css({ width: _progress + '%' });
            }, (error) => {
                if (err) console.log(error)
                progress.css({ width: 0 })
            }, () => {
                progress.css({ width: 0 })
            })
        }

        let exists;
        while (!exists) {
            try {
                let res = await fetch(path).then((r) => r.ok)
                if (res) exists = true
            } catch (err) {
                exists = false
            }
        }

        return metadata
    };

    this.parse = function (key, hint) {
        let data = _data[_id][key];
        if (typeof data === 'undefined') return null;

        if (Array.isArray(data)) {
            if (hint instanceof Vector2) return { value: new Vector2().fromArray(data) };
            if (hint instanceof Vector3) return { value: new Vector3().fromArray(data) };
            if (hint instanceof Vector4) return { value: new Vector4().fromArray(data) };
        } else if (typeof data === 'string') {
            if (data.charAt(0) === '#') return { value: new Color(data) };
        }

        return { value: data };
    };
}, 'static');

Class(function UILClipboard() {
    Inherit(this, Component);
    var _store = {};

    //*** Public methods
    this.copy = function(folders) {
        _store = {};
        
        for (let key in folders) {
            let folder = folders[key];
            _store[folder.label] = folder.value;
        }
    };

    this.paste = function(folders) {
        for (let key in folders) {
            let folder = folders[key];
            if (!folder) continue;
            if (_store[folder.label] == undefined) continue;
            if (key.includes('name')) continue;
            if (key.includes('shader')) continue;

            folder.force(_store[folder.label], true);
            folder.finish();
        }
    };

    this.get('store', _ => _store);
}, 'static');
/**
 * Control base class to inherit from.
 */
 Class(function UILControl() {
    Inherit(this, Element);
    const _this = this;
    let $this;
    let $label, $content, $view;
    let _value;
    let _previous;
    let _label;
    let _opts;
    let _visible = true;

    let _onChange = () => {};
    let _onFinishChange = () => {};

    //*** Constructor
    (function() {
        initHTML();
        initLabel();
        initContent();
    })();

    function initHTML() {
        $this = _this.element;
        $this.size('100%', 'auto');
        $this.css({position:'relative', display:'inline-block', borderBottom:`1px solid #161616`, padding:`2px 0`, boxSizing:`border-box`});
        $this.attr('data-type', `UILControl`);
        $this.div._this = _this;
    }

    function initLabel() {
        $label = $this.create('label');
        $label.size('100px', 'auto').fontStyle('sans-serif', 12, `#9B9C9B`);
        $label.css({paddingLeft:4, paddingTop:2, boxSizing:`border-box`, verticalAlign:`top`, float:`left`, wordBreak: 'break-all' });
        _this.$label = $label;
    }

    function initContent() {
        $content = $this.create('content');
        $content.size(`calc(100% - 100px)`, `auto`).css({float:'left'});
        _this.$content = $content;
    }
    
    function isEqual(a, b) {
        if (Array.isArray(a) || Array.isArray(b)) return a+`` === b+``;
        if (typeof a === `object` || typeof b === `object`) return JSON.stringify(a) === JSON.stringify(b);
        return a === b;
    }

    function clone(value) {
        if (Array.isArray(value)) return [...value];
        if (typeof value === `object`) return Object.assign({}, value);
        return value;
    }

    //*** Event handlers

    //*** Internal methods

    /**
     * Default init method to call from children.
     * @param {String} id Child id.
     * @param {Object} opts Child options.
     */
    this.init = function(id, opts={}) {
        _this.id = id;
        _opts = opts; 
        _value = clone(opts.value); // get from local storage here
        _previous = clone(_value);

        _this.setLabel(opts.label || id)
        $this.attr('data-id', id);
    }

    /**
     * Trigger the onFinishChange callback,
     * call this from children to tell parent that editing is done.
     * @param {Boolean} history Add action to undo/redo history.
     */
    this.finish = function(history=true) {
        _onFinishChange(_value);
        if (!isEqual(_value, _previous)) {
            if (history) UILHistory.set(_this, _previous);
            UILLocalStorage.set(_this.id, _value);
            _previous = clone(_value);
        }
    }

    /**
     * Force set value and trigger finish callback.
     * Used by Undo/Redo to programmatically set the value.
     * Overwrite if custom logic is needed.
     * @param {*} value New value
     */
    this.force = function(value) {
        _this.value = clone(value);
        _this.finish(false);
    }

    /**
     * Debounce utility function used in a few child classes.
     * @param {Function} callback called when function stops being called X ms.
     * @param {Number} [time=250] milliseconds to wait.
     */
    this.debounce = function (callback, time = 250) {
        let interval;
        return (...args) => {
            clearTimeout(interval);
            interval = setTimeout(() => {
                interval = null;
                callback(...args);
            }, time);
        };
    }

    //*** Public methods

    /**
     * Register a change callback.
     * @param {Function} cb Callback.
     * @returns {Object} this.
     */
    this.onChange = function(cb) {
        _onChange = cb;
        return _this;
    }

    /**
     * Register a complete callback.
     * @param {Function} cb Callback.
     * @returns {Object} this.
     */
    this.onFinishChange = function(cb) {
        _onFinishChange = cb;
        return _this;
    }

    /**
     * @type {*}
     */
    this.get('value', () => _value);
    this.set('value', value => {
        if (isEqual(value, _value)) return;
        _value = clone(value);
        _this.update && _this.update(_value);
        _onChange(_value);
    });

    /**
     * @type {HydraObject}
     */
    this.get('view', () => $view);
    this.set('view', view => {
        if ($view) $view.destroy();
        $view = view;
        $content.add($view);
    })
    
    /**
     * Hide control.
     * @returns {Object} this.
     */
    this.hide = function() {
        _visible = false;
        $this.css({display:'none'});
        return _this;
    }

    /**
     * Show control.
     * @returns {Object} this.
     */
    this.show = function() {
        _visible = true;
        $this.css({display:'inline-block'});
        return _this;
    }

    /**
     * Get control visibility state.
     * @returns {Boolean} visibility state.
     */
    this.isVisible = function() {
        return _visible;
    }

    /**
     * Redefine label.
     * @type {String}
     */
    this.setLabel = function(label) {
        _label = label;
        _this.label = label;
        
        let title = label;
        if (_opts.description) {
            title = title + '\n' + _opts.description;

            let $span = $('icon').css({
                verticalAlign: 'middle',
                display: 'inline-block',
                paddingTop: 1
            });
            $span.html(UILControl.infoIcon);

            $label.text(label + ' ');
            $label.add($span);
        } else {
            $label.text(label);
        }

        $label.attr('title', title);
    }

    /**
     * Redefine title.
     * @type {String}
     */
    this.setDescription = function(desc) {
        $label.attr('title', desc);
    }
}, () => {
    UILControl.infoIcon = `<span><svg xmlns="http://www.w3.org/2000/svg" width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="10"/><path d="M9 9a3 3 0 016 1c0 2-3 3-3 3M12 17h0"/></svg></span>`;
});
/**
 * Container for mutiple controls.
 * @param {String} _id unique ID.
 * @param {String} [_opts.label=id] label to display, defaults to id.
 * @param {Boolean} [_opts.closed=false] Inital open/close state.
 * @param {String} [_opts.maxHeight='none'] Max height before starting to scroll.
 * @param {Boolean} [_opts.hideTitle=false] Hide folder title and toggle functionality.
 * @param {String} [_opts.background=`#272727`] Background color.
 */
Class(function UILFolder(_id, _opts={drag:true}) {
    Inherit(this, Element);
    const _this = this;
    let $this;
    let $header, $container, $toggle, $drag, $title;
    let _children = {};
    let _open = !_opts.closed;
    let _visible = true;
    let _order = [];
    let _draggable = false;
    let _sortableChildren = false;
    let _headerDrag = false;
    var _hasClipboard = false;

    _this.id = _id;
    _this.label = `${_opts.label || _id}`;
    _this.level = -1;

    const RECURSIVE_CLOSE = true;

    //*** Constructor
    (function() {
        init();
        style();
        initHeader();
        initContainer();
        restoreFolderState();
    })();

    function init() {
        $this = _this.element;
        $this.size('100%', 'auto').bg(_opts.background || `#272727`);
        $this.css({position:'relative', border:`1px solid #161616`, boxSizing:`border-box`, maxHeight:_opts.maxHeight || 'none'});
        $this.attr('data-id', _id);
        $this.attr('data-type', `UILFolder`);
        $this.div._this = _this;
    }

    function style() {
        UIL.addCSS(UILFolder, `
            .UILFolder *:focus { outline: none; }
            .UILFolder input:focus { border-color:#37a1ef!important; }
            .UILFolder button:focus { border-color:#37a1ef!important; }
            .UILFolder .UILFolder .UILFolder .toggle {margin-left:8px; }
            .UILFolder .UILFolder .UILFolder .UILFolder .toggle {margin-left:16px; }
            .UILFolder .UILFolder .UILFolder .UILFolder .UILFolder .toggle {margin-left:24px; }
            .UILFolder .UILFolder .UILFolder .UILFolder .UILFolder .UILFolder .toggle {margin-left:32px; }
            .UILFolder .UILFolder .UILFolder .UILFolder .UILFolder .UILFolder .UILFolder .toggle {margin-left:40px; }
        `);
    }

    function initHeader() {
        if (_opts.hideTitle) return;
        $header = $this.create('title', 'a');
        $header.attr('tabindex', '0');
        $header.size('100%', 'auto').bg(`#272727`);
        $header.css({display:'block', padding:`4px 4px`, boxSizing:`border-box`, fontWeight:'bold', userSelect:'none', borderBottom:`1px solid #161616`});
        $header.fontStyle('sans-serif', 11, '#B1B1B1');
        $header.div.addEventListener('keydown', onKeydown, false);
        $header.div.addEventListener('click', onToggle, false);
        $header.div.addEventListener(`mousedown`, onMouseDown);
        $header.div.addEventListener('focus', onFocus, false);
        $header.div.addEventListener('blur', onBlur, false);
        $header.div.addEventListener('keydown', onKeyup, false);

        $toggle = $header.create('toggle');
        $toggle.text(_open ? '▼' : '▶').css({fontSize:8, display:'inline-block', verticalAlign:'middle'});

        $drag = $header.create('drag');
        $drag.text(`☰`).css({position:`absolute`, right:7, top:3, display:'inline-block', pointerEvents:`none`});
        $drag.hide();

        $title = $header.create('title');
        $title.text(_this.label).css({display:'inline-block', marginLeft:4});
    }

    function initContainer() {
        $container = $this.create('container');
        $container.size('100%', '100%').css({display:`flex`, flexDirection:`column`, position:'relative', overflowY:'auto'});
        if (!_open) $container.css({display:'none'});
        _this.container = $container.div;
    }

    function addDragHandlers() {
        $this.div.addEventListener('dragstart', dragStart, false);
        $this.div.addEventListener('dragover', dragOver, false);
        $this.div.addEventListener('drop', drop, false);
    }

    function removeDragHandlers() {
        $this.div.removeEventListener('dragstart', dragStart, false);
        $this.div.removeEventListener('dragover', dragOver, false);
        $this.div.removeEventListener('drop', drop, false);
    }

    function matchItem(str, item) {
        return UILFuzzySearch.search(str, item.id.toLowerCase()) || (UILFuzzySearch.search(str, item.label.toLowerCase()));
    }

    function filter(str, match=false) {
        str = str.toLowerCase();
        let result = [];
        let haystack = Object.values(_children);
        for (let el of haystack) {
            if (el instanceof UILFolder) {
                let matches = el.filter(str, true);
                if (matches.length) {
                    result.concat(matches);
                    el.show();
                    // el.showChildren();
                    el.open();
                } else if (matchItem(str, el)) {
                    result.push(el);
                    el.show();
                    el.showChildren();
                    el.close();
                } else {
                    !el.getVisible().length ? el.hide() : el.show();
                }
            } else {
                if (matchItem(str, el)) {
                    result.push(el);
                    el.show();
                } else {
                    el.hide();
                }
            }
        }
        return result;
    }

    function filterSingle(str) {
        str = str.toLowerCase();
        let haystack = Object.values(_children);
        for (let el of haystack) {
            if (el instanceof UILFolder) {
                el.filterSingle(str);
                if (str == el.label.toLowerCase() || str == el.id.toLowerCase()) {
                    el.show();
                    el.showChildren();
                    el.open(true);
                } else {
                    !el.getVisible().length ? el.hide() : el.show();
                }
            } else {
                if (matchItem(str, el)) {
                    el.show();
                    if (el.open) el.open(true);
                } else {
                    el.hide();
                }
            }
        }
        // saveFolderState();
        return [];
    }

    function saveSort() {
        UILStorage.set(`UIL_${UIL.sortKey}_${_this.parent.id}_order`, JSON.stringify(_order));
    }

    function getSort() {
        let sort = UILStorage.get(`UIL_${UIL.sortKey}_${_id}_order`);
        if (sort) return JSON.parse(sort);
    }

    function restoreSort() {
        _order.forEach(id => {
            if (_children[id]) $container.add(_children[id]);
        });
    }

    //*** Event handlers

    function dragStart(e) {
        if (UILFolder.DragLock) return;
        if (!_headerDrag) {
            e.preventDefault();
            e.stopPropagation();
            return;
        }
        UILFolder.DragLock = _this.id;
        e.dataTransfer.setData(`text/plain`, _this.id);
        e.dataTransfer.effectAllowed = `move`;
        $this.css({opacity:0.5});
    }

    function dragOver(e) {
        e.preventDefault();
        e.dataTransfer.dropEffect = `move`;
    }

    function drop(e) {
        if (!UILFolder.DragLock) return;

        // If dropped items is files, return
        // and don't prevent default (Needed for ImageUIL)
        if (e.dataTransfer.items) {
            for (var i = 0; i < e.dataTransfer.items.length; i++) {
                if (e.dataTransfer.items[i].kind === 'file') {
                    return;
                }
            }
        }

        e.preventDefault();
        _headerDrag = false;

        let el = e.currentTarget;
        let target = el._this;
        let dragging = _this.parent.get(UILFolder.DragLock); //_this.parent.get(e.dataTransfer.getData(`text/plain`));
        UILFolder.DragLock = null;

        // if now control or no parent on the control return
        if (!target || !target.parent || !dragging) return
        dragging.element.css({opacity:1});

        // Parent have "target" = sibling
        if (dragging.parent.get(target.id)) {
            e.stopPropagation();
            target.parent.container.insertBefore(dragging.element.div, target.element.div);
            _order = [...target.parent.container.childNodes].map(el => el._this.id);
            _this.events.fire(UIL.REORDER, {order:[..._order]});
            saveSort();
        }
    }

    function getUrlID() {
        let key = Global.PLAYGROUND || 'Global';
        return `${key}_folder_${_id}`;
    }

    function saveFolderState() {
        sessionStorage.setItem(getUrlID(), JSON.stringify({open:_open}));
    }

    function restoreFolderState() {
        let json = JSON.parse(sessionStorage.getItem(getUrlID()));
        if (json) {
            let state = json.open;
            state ? open() : close();
        }
    }

    function open(keepClosed = false) {
        _open = true;
        $container.css({ display: 'flex' });
        $toggle && $toggle.text('▼');
        if (RECURSIVE_CLOSE && keepClosed != true) forEachFolder(f => f.close());
        saveFolderState();
        _this.onOpen && _this.onOpen();
    }

    function close() {
        _open = false;
        $container.css({ display: 'none' });
        $toggle && $toggle.text('▶');
        saveFolderState();
    }

    function onToggle(e) {
        _open ? close() : open();
    }

    function onMouseDown(e) {
        _headerDrag = true;
        $header.div.addEventListener(`mouseup`, onMouseUp);
    }

    function onMouseUp(e) {
        _headerDrag = false;
        $header.div.removeEventListener(`mouseup`, onMouseUp);
    }

    function onKeydown(e) {
        if (e.which === 13) _open ? close() : open();
    }
    
    function onKeyup(e) {
        if (!_hasClipboard) return;
        if (e.key == 'c' && e.metaKey) onCopy();
        else if (e.key == 'v' && e.metaKey) onPaste();
    }

    function onFocus() {
        $this.css({border:`1px solid #37a1ef`});
        $this.div.classList.add(`active`);
        _hasClipboard = true;
    }

    function onBlur() {
        $this.css({border:`none`, border:`1px solid #161616`});
        $this.div.classList.remove(`active`);
        _hasClipboard = false;
    }

    function onCopy() {
        UILClipboard.copy(_children);
    }
    
    function onPaste() {
        UILClipboard.paste(_children);
    }

    function forEachFolder(cb) {
        Object.values(_children).forEach(el => {
            if (el instanceof UILFolder) {
                cb(el);
                el.forEachFolder(cb);
            }
        });
        return _this;
    }

    //*** Public methods

    /**
     * Register and add new child (UILControl or UILFolder).
     * @param {(UILControl|UILFolder)} child Instance to add.
     * @returns {Object} this.
     */
    this.add = function(child) {
        child.draggable && child.draggable(_sortableChildren);
        child.parent = _this;
        _children[child.id] = child;
        $container.add(child);
        return _this;
    }

    /**
     * Remove child (UILControl or UILFolder).
     * @param {String} x ID string or instance to remove.
     * @returns {Object} this.
     */
    this.remove = function(x) {
        let id = typeof x === 'string' ? x : x.id;
        let child = _children[id];
        if (!child) {
            for (let key in _children) {
                if (key.includes(x)) {
                    child = _children[key];
                    delete _children[key];
                    break;
                }
            }
        }

        if (!child) return;

        child.eliminate && child.eliminate();
        child.destroy();
        if (_order) _order = _order.filter(child => child !== id);
        delete _children[id];
        return _this;
    }

    /**
     * Get a direct child by id.
     * @param {String} id ID of child.
     * @returns {(UILControl|UILFolder)} child.
     */
    this.get = function(id) {
        return _children[id];
    }

    /**
     * Get array of all direct children.
     * @returns {Array} children.
     */
    this.getAll = function() {
        return Object.values(_children);
    }

    /**
     * Get array of all direct children,
     * but only those that are currently visible.
     * @returns {Array} children.
     */
    this.getVisible = function() {
        return Object.values(_children).filter(x => x.isVisible());
    }

    /**
     * Get a nested child by searching requrisvely.
     * @param {String} id ID of child.
     * @returns {[(UILControl|UILFolder)]} array of children matching.
     */
    this.find = function(id) {
        if (id === _id) return _this;
        return Object.values(_children).reduce((acc, item) => {
            if (item.id === id) return acc.concat(item);
            if (item instanceof UILFolder) {
                return acc.concat(item.find(id));
            } else {
                return acc;
            }
        }, []);
    }

    /**
     * Filter children requrisvely. Show and hide
     * based on filter, and return array of matches.
     * @param {String} str Filter string.
     * @returns {Array} matches.
     */
    this.filter = function(str) {
        return filter(str);
    }

    /**
     * Like filter, but is an exact search (not fuzzy).
     * @param {String} str Filter string.
     */
    this.filterSingle = filterSingle;

    /**
     * Open folder.
     * @returns {Object} this.
     */
    this.open = function (keepClosed) {
        open(keepClosed);
        return _this;
    }

    /**
     * Close folder.
     * @returns {Object} this.
     */
    this.close = function() {
        close();
        return _this;
    }

    /**
     * Redefine label.
     * @returns {Object} this.
     */
    this.setLabel = function(label) {
        _this.label = `${label}`;
        $title.text(label);
        return _this;
    }

    /**
     * Hide folder.
     * @returns {Object} this.
     */
    this.hide = function() {
        _visible = false;
        $this.css({display:'none'});
        return _this;
    }

    /**
     * Show folder.
     * @returns {Object} this.
     */
    this.show = function() {
        _visible = true;
        $this.css({display:'block'});
        return _this;
    }

    /**
     * Show all children, recursively.
     * @returns {Object} this.
     */
    this.showChildren = function() {
        Object.values(_children).forEach(el => el instanceof UILFolder ? el.showChildren() : el.show());
        _this.show();
        return _this;
    }

    /**
     * Get folder toggle state.
     * @returns {Boolean} open state.
     */
    this.isOpen = function() {
        return _open;
    }

    /**
     * Get folder visibility state.
     * @returns {Boolean} visibility state.
     */
    this.isVisible = function() {
        return _visible;
    }

    /**
     * Utility function to iterate all sub folders recursively.
     * @param {Function} cb Callback for each folder.
     * @returns {Object} this.
     */
    this.forEachFolder = function(cb) {
        return forEachFolder(cb);
    }

    /**
     * Utility function to iterate all sub controls recursively.
     * @param {Function} cb Callback for each control.
     * @returns {Object} this.
     */
    this.forEachControl = function(cb) {
        Object.values(_children).forEach(el => {
            if (el instanceof UILFolder) {
                el.forEachControl(cb);
            } else {
                cb(el);
            }
        });
        return _this;
    }

    /**
     * Make folder sortable. Make all children draggable.
     * @param {String} key Key
     * @returns {Object} this.
     */
    this.enableSorting = function(key) {
        _sortableChildren = true;
        UIL.sortKey = key;

        Object.values(_children).forEach(el => {
            if (el instanceof UILFolder) el.draggable(true);
        });

        let order = getSort();
        if (order) {
            _order = order;
            restoreSort();
        }

        return _this;
    }

    /**
     * Make element draggale for when parent is sortable.
     * @param {Boolean} enable Enable/Disable drag.
     */
    this.draggable = function(enable) {
        _draggable = enable;
        $this.attr('draggable', enable);
        if (enable) {
            addDragHandlers();
            $drag && $drag.show();
        } else {
            removeDragHandlers();
            $drag && $drag.hide();
        }
    }

    /**
     * Copy UILFolder data to UILClipboard
     */
    this.toClipboard = function() {
        UILClipboard.copy(_children);
    };

    /**
     * Set UILFolder data from UILClipboard
     */
    this.fromClipboard = function() {
        UILClipboard.paste(_children);
    };

    /**
     * Call before destroy
     */
    this.eliminate = function() {
        if (!_opts.hideTitle) {
            $header.div.removeEventListener('keydown', onToggle, false);
            $header.div.removeEventListener('click', onToggle, false);
            $header.div.removeEventListener(`mousedown`, onMouseDown);
            $header.div.removeEventListener('focus', onFocus, false);
            $header.div.removeEventListener('blur', onBlur, false);
        }
        if (_draggable) removeDragHandlers();
    }

    this.forceSort = function(index) {
        _this.parent.container.insertBefore(_this.element.div, _this.parent.container.children[index]);
        _order = [..._this.parent.container.childNodes].map(el => el._this.id);
        _this.events.fire(UIL.REORDER, {order:[..._order]});
    }

    this.openChildren = function() {
        Object.values(_children).forEach(el => el instanceof UILFolder ? el.open() : null);
    }
});
/**
 * Create panels such as sidebars,
 * with search and filter functionality.
 * @param {String} _title Title used for panel.
 * @param {String} [_opts.width='300px'] Initial Width.
 * @param {String} [_opts.height='auto'] Initial height.
 * @param {String} [_opts.maxHeight='100%'] Max height. Defaults to 100% view height.
 * @param {String} [_opts.side='right'] Initial docking ['left' or 'right'].
 * @param {Boolean} [_opts.hide=false] Change opacity on mouse over/out.
 */
Class(function UILPanel(_title, _opts={}) {
    Inherit(this, Element);
    const _this = this;
    let $this;
    let $children;
    let $toolbar;
    let _folder;
    let _toolbar;
    let _hidden = false;

    if (!('hide' in _opts)) _opts.hide = true;

    _this.id = _title;

    //*** Constructor
    (function() {
        initHTML();
        initToolbar();
        initGroup();
        addHandlers();
    })();

    function initHTML() {
        $this = _this.element;
        $this.size(_opts.width || `300px`, _opts.height || `auto`).bg(`#161616`).mouseEnabled(true);
        _opts.side === 'left' ? $this.css({left:0}) : $this.css({right:0});
        $this.css({top:0, maxHeight:_opts.maxHeight || `100%`, position:'absolute', userSelect:'none', padding:4, overflowY:'auto', borderRadius:4});
        $this.hide();

        $this.div.className += ' prevent_interaction3d';
    }

    function initToolbar() {
        _toolbar = _this.toolbar = _this.initClass(UILPanelToolbar);
    }

    function initGroup() {
        _folder = _this.initClass(UILFolder, _title, {hideTitle:true, drag:false, background:`#161616`});
        _this.folder = _folder;
    }

    function hide() {
        $this.invisible();
        _hidden = true;
    }

    function show() {
        $this.visible();
        _hidden = false;
    }

    //*** Event handlers

    function addHandlers() {
        document.addEventListener('keydown', onKeydown, false);
        if (_opts.hide) {
            dim();
            $this.div.addEventListener('mouseover', undim, false);
            $this.div.addEventListener('mouseleave', dim, false);
        }
    }

    function onKeydown(e) {
        if (!e.ctrlKey && !e.metaKey) return;
        if (e.keyCode == 72 && e.shiftKey) {
			let active = `${document.activeElement.type}`;
			if ( active.includes([ 'textarea', 'input', 'number' ])) return;
            e.preventDefault();
            _hidden ? show() : hide();
        }
        if (e.keyCode == 37 && e.shiftKey) {
            e.preventDefault();
            $this.css({left:0, right:'auto'});
        }
        if (e.keyCode == 39 && e.shiftKey) {
            e.preventDefault();
            $this.css({left:'auto', right:0});
        }
        if (e.which == 67 && e.shiftKey) {
            e.preventDefault();
            _folder.forEachFolder(f => f.close());
        }
        if (e.which == 79 && e.shiftKey) {
            e.preventDefault();
            _folder.forEachFolder(f => f.open());
        }
    }

    function undim() {
        $this.css({ opacity: 1 });
    }

    function dim() {
        $this.css({ opacity: 0.6 });
    }

    //*** Public methods

    /**
     * Register and add new child (UILControl or UILFolder).
     * @param {(UILControl|UILFolder)} child Instance to add.
     * @returns {Object} this.
     */
    this.add = function(child) {
        $this.show();
        _folder.add(child);
        return _this;
    }

    /**
     * Remove child (UILControl or UILFolder).
     * @param {String} x ID string or instance to remove.
     * @returns {Object} this.
     */
    this.remove = function(x) {
        _folder.remove(x.id);
        return _this;
    }

    /**
     * Get a direct child by id.
     * @param {String} id ID of child.
     * @returns {(UILControl|UILFolder)} child.
     */
    this.get = function(id) {
        return _folder.get(id);
    }

    /**
     * Get a nested child by searching requrisvely.
     * @param {String} id ID of child.
     * @returns {(UILControl|UILFolder)} child.
     */
    this.find = function(id) {
        return _folder.find(id);
    }

    /**
     * Filter children requrisvely. Show and hide
     * based on filter, and return array of matches.
     * @param {String} str Filter string.
     * @returns {Array} matches.
     */
    this.filter = function(str) {
        return _folder.filter(str);
    }

    /**
     * Make panel sortable.
     * @param {String} key Sort key
     * @returns {Object} this.
     */
    this.enableSorting = function(key) {
        _folder.enableSorting && _folder.enableSorting(key);
        return _this;
    }

    /**
     * Call before destroy
     */
    this.eliminate = function() {
        _toolbar.eliminate();
        $this.div.removeEventListener('mouseover', undim, false);
        $this.div.removeEventListener('mouseleave', dim, false);
        document.removeEventListener('keydown', onKeydown, false);
    }

});

/**
 * Create floating windows.
 * @param {String} _title Title used for window.
 * @param {String} [_opts.label=id] Text Label.
 * @param {String} [_opts.width='auto'] Initial Width.
 * @param {String} [_opts.minWidth=0] Minimum width.
 * @param {String} [_opts.height='auto'] Initial height.
 * @param {Boolean} [_opts.closed=false] Inital open/close state.
 * @param {Boolean} [_opts.resize=true] Allow resize.
 * @param {String} [_opts.maxHeight='100%'] Max height. Defaults to 100% view height.
 * @param {Number} [_opts.left=40] Initial X position.
 * @param {Number} [_opts.top=40] Initial Y position.
 * @param {Boolean} [_opts.hide=true] Change opacity on mouse over/out.
 */
Class(function UILWindow(_title, _opts={hide:false, drag:true, resize:true}) {
    Inherit(this, Element);
    const _this = this;
    let $this;
    let $header, $container, $toggle, $title;
    let _folder;
    let _hidden;
    let _open = !_opts.closed;

    let _x = _opts.left || 350;
    let _y = _opts.top || 50;
    let _initialX;
    let _initialY;
    let _xOffset = _x;
    let _yOffset = _y;
    let _dragging = false;

    _this.id = _title;

    //*** Constructor
    (function() {
        initHTML();
        initHeader();
        initContainer();
        initGroup();
        addHandlers();
    })();

    function initHTML() {
        $this = _this.element;
        $this.bg(`#161616`).transform({x:_x, y:_y}).mouseEnabled(true);
        $this.css({
            position:'absolute', userSelect:'none', overflowY:'auto', borderRadius:4,
            maxHeight:_opts.maxHeight || `100%`, border:`1px solid #2e2e2e`
        });
    }

    function initHeader() {
        $header = $this.create('header');
        $header.size('100%', 'auto').bg(`#272727`);
        $header.css({
            display:'block', color:'#B1B1B1', padding:`4px 4px`, boxSizing:`border-box`, 
            fontFamily:'sans-serif', fontSize:11, fontWeight:'bold', userSelect:'none', minWidth:200
        });

        $toggle = $header.create('toggle');
        $toggle.text(_open ? '▼' : '▶').css({fontSize:8, paddingLeft:4, display:'inline-block', verticalAlign:'middle'});
        $toggle.click(onToggle);

        $title = $header.create('title');
        $title.text(_opts.label || _title).css({display:'inline-block', marginLeft:4});
        $title.click(onToggle);

        let $close = $header.create('close');
        $close.text(`✕`).css({position:`absolute`, right:7, top:5, display:'inline-block'});
        $close.click(hide);

        /*
        let $drag = $header.create('drag');
        $drag.text(`☰`).css({position:`absolute`, right:7, top:3, display:'inline-block'});
        */
    }

    function initContainer() {
        $container = $this.create('container');
        $container.size(_opts.width || `auto`, _opts.height || `auto`);
        $container.css({position:'realtive', overflowY:'auto', padding:4, boxSizing:`border-box`, minWidth:_opts.minWidth || 0});
        if (_opts.resize) $container.css({resize:`both`, minWidth:200, minHeight:60});
        if (!_open) $container.css({display:'none'});
    }

    function initGroup() {
        _folder = _this.initClass(UILFolder, _title, {hideTitle:true, background:`#161616`}, null);
        _this.folder = _folder;
        $container.add(_folder);
    }

    function hide() {
        $this && $this.invisible();
        _hidden = true;
        _this.onClose && _this.onClose();
    }

    function show() {
        $this && $this.visible();
        _hidden = false;
    }

    //*** Event handlers

    function addHandlers() {
        document.addEventListener('keydown', onKeydown, false);
        if (_opts.drag) $header.div.addEventListener('mousedown', onMouseDown, false);
        if (_opts.hide) {
            $this.div.addEventListener('mouseover', undim, false);
            $this.div.addEventListener('mouseleave', dim, false);
        }
    }

    function onKeydown(e) {
        if (!e.ctrlKey && !e.metaKey) return;
        if (e.keyCode == 72 && e.shiftKey) {
			let active = `${document.activeElement.type}`;
			if ( active.includes([ 'textarea', 'input', 'number' ])) return;
            e.preventDefault();
            _hidden ? show() : hide();
        }
        if (e.which == 67 && e.shiftKey) {
            e.preventDefault();
            _folder.forEachFolder(f => f.close());
        }
        if (e.which == 79 && e.shiftKey) {
            e.preventDefault();
            _folder.forEachFolder(f => f.open());
        }
    }

    function onMouseDown(e) {
        e.preventDefault();
        $header.css({cursor:'move'});
        _initialX = e.clientX - _xOffset;
        _initialY = e.clientY - _yOffset;
        _dragging = true;
        document.addEventListener('mousemove', onMouseMove, false);
        document.addEventListener('mouseup', onMouseUp, false);
    }

    function onMouseMove(e) {
        e.preventDefault();
        _x = e.clientX - _initialX;
        _y = e.clientY - _initialY;
        _xOffset = _x;
        _yOffset = _y;
        $this.transform({x:_x, y:_y});
    }

    function onMouseUp() {
        $header.css({cursor:''});
        _initialX = _x;
        _initialY = _y;
        _dragging = false;
        document.removeEventListener('mousemove', onMouseMove, false);
		document.removeEventListener('mouseup', onMouseUp, false);
    }

    function open() {
        _open = true;
        $container.css({ display: 'block' });
        $toggle.text('▼');
    }

    function close() {
        _open = false;
        $container.css({ display: 'none' });
        $toggle.text('▶');
    }

    function onToggle(e) {
        if (e.type === 'click' || e.which === 13)  _open ? close() : open();
    }

    function undim() {
        if (_dragging) return;
        $this.css({ opacity: 1 });
    }

    function dim() {
        if (_dragging) return;
        $this.css({ opacity: 0.3 });
    }

    //*** Public methods

    /**
     * Register and add new child (UILControl or UILFolder).
     * @param {(UILControl|UILFolder)} child Instance to add.
     * @returns {Object} this.
     */
    this.add = function(child) {
        _folder.add(child);
        return _this;
    }

    /**
     * Remove child (UILControl or UILFolder).
     * @param {String} x ID string or instance to remove.
     * @returns {Object} this.
     */
    this.remove = function(x) {
        _folder.remove(id);
        return _this;
    }

    /**
     * Get a direct child by id.
     * @param {String} id ID of child.
     * @returns {(UILControl|UILFolder)} child.
     */
    this.get = function(id) {
        return _folder.get(id);
    }

    /**
     * Get a nested child by searching requrisvely.
     * @param {String} id ID of child.
     * @returns {(UILControl|UILFolder)} child.
     */
    this.find = function(id) {
        return _folder.find(id);
    }

    /**
     * Filter children requrisvely. Show and hide
     * based on filter, and return array of matches.
     * @param {String} str Filter string.
     * @returns {Array} matches.
     */ 
    this.filter = function(str) {
        return _folder.filter(str);
    }

    /**
     * Hide window.
     * @returns {Object} this.
     */
    this.show = function() {
        show();
        return _this;
    }

    /**
     * Hide window.
     * @returns {Object} this.
     */
    this.hide = function() {
        hide();
        return _this;
    }

    /**
     * Detect if the window is visible or not.
     * @returns {Boolean} true if visible.
     */
    this.isVisible = function() {
        return !_hidden;
    }

    /**
     * Make panel sortable.
     * @param {String} key Sort key
     * @returns {Object} this.
     */
    this.enableSorting = function(key) {
        _folder.enableSorting && _folder.enableSorting(key);
        return _this;
    }


    /**
     * Call before destroy
     */
    this.eliminate = function() {
        if (_opts.drag) $header.div.removeEventListener('mousedown', onMouseDown, false);
        if (_opts.hide) {
            $this.div.removeEventListener('mouseover', undim, false);
            $this.div.removeEventListener('mouseleave', dim, false);
        }
        document.removeEventListener('keydown', onKeydown, false);
    }
});

/**
 * Button input control
 * @param {Array|Object} actions Actions object[s].
 * @param {String} actions.title Action Title.
 * @param {Function} [actions.callback] Action Callback.
 * @param {String} [_opts.label=id] Text Label.
 * @param {Boolean} [_opts.hideLabel=false] Hide label.
 */
Class(function UILControlButton(_id, _opts={}) {
    Inherit(this, UILControl);
    const _this = this;
    let $view;
    let _buttons = [];

    //*** Constructor
    (function() {
        init();
        initActions();
    })();

    function init() {
        _this.init(_id, _opts);
        if (_opts.hideLabel) {
            _this.$label.css({display:`none`});
            _this.$content.css({width:`100%`});
        }
    }

    function initActions() {
        $view = $('inputs');
        let config = [].concat(_opts.actions);
        _buttons = [].concat(_opts.actions).map(({title, callback}) => {
            let btn = $view.create(`btn btn-${title}`, `button`);
            btn.text(title).bg(`#1d1d1d`);
            btn.css({ width: `calc(100% / ${config.length || 1}`, border: `1px solid #2e2e2e`, color: `#37a1ef`, position:`relative`});
            btn.interact(e => hover(btn, e));
            btn.click(e => click(e, title, callback));
            return btn;
        });
       _this.view = $view;
    }

    //*** Event handlers

    function click(e, title, callback) {
        _this.value = title;
        callback && callback(title, e);
        _this.finish();
    }

    function hover(btn, e) {
        e.action === `over` ? btn.css({border:`1px solid #9b9c9b`}) : btn.css({border:`1px solid #2e2e2e`});
    }

    //*** Public methods
    this.setTitle = function(text) {
        _buttons.forEach(btn => {
            btn.text(text)
        });
    }
});
/**
 * Checkbox input control
 * @param {Boolean} [_opts.value] Initial value.
 * @param {String} [_opts.label=id] Text Label.
 */
Class(function UILControlCheckbox(_id, _opts={}) {
    Inherit(this, UILControl);
    const _this = this;
    let $view, $label, $checkbox, $slider;
    let _buttons = [];
    let _checked;

    //*** Constructor
    (function() {
        init();
        initView();
        addHandlers();
    })();

    function init() {
        _opts.value = _opts.value || false;
        _this.init(_id, _opts);
    }

    function initView() {
        $view = $(`view`);

        $label = $view.create(`label`, `label`);
        $label.size(30, 15).css({position:`relative`, display:`inline-block`, borderRadius:15, border:`1px solid #2e2e2e`}).bg(_this.value ? `#37a1ef` : `#1d1d1d`);

        $checkbox = $label.create('checkbox', 'input');
        $checkbox.attr(`type`, `checkbox`);
        $checkbox.attr(`checked`, _this.value);
        $checkbox.css({opacity:0, width:`100%`, position:`absolute`});

        $slider = $label.create(`slider`);
        $slider.size(15, 15).css({borderRadius:15, position:`absolute`, right:_this.value ? 0 : `auto`, boxSizing:`border-box`}).bg(`#ffffff`);

       _this.view = $view;
    }

    function toggle() {
        $checkbox.attr(`checked`, _this.value);
        $slider.css({right:_this.value ? 0 : `auto`});
        $label.bg(_this.value ? `#37a1ef` : `#1d1d1d`);
    }

    //*** Event handlers

    function addHandlers() {
       $checkbox.div.addEventListener('focus', focus, false);
       $checkbox.div.addEventListener('blur', blur, false);
       $checkbox.div.addEventListener('click', click, false);
       $checkbox.div.addEventListener('keypress', click, false);
    }

    function click() {
        _this.value = !_this.value;
        toggle();
        _this.finish();
    }

    function focus() {
        $label.css({border:`1px solid #37a1ef`});
    }

    function blur() {
        $label.css({border:`1px solid #2e2e2e`});
    }

    //*** Public methods

    this.update = function() {
        toggle();
    }

    this.onDestroy = function() {
        $checkbox.div.removeEventListener('focus', focus, false);
        $checkbox.div.removeEventListener('blur', blur, false);
        $checkbox.div.removeEventListener('click', click, false);
        $checkbox.div.removeEventListener('keypress', click, false);
    }
});
/**
 * Color control
 * @param {String} [_opts.value] Initial hex value.
 * @param {String} [_opts.label=id] Text Label.
 */
 Class(function UILControlColor(_id, _opts = {}) {
    Inherit(this, UILControl);
    const _this = this;

    let $hex, $colorPicker, $hexInput, $colorInput;

    //*** Constructor
    (function() {
        init();
        initInput();
        addHandlers();
    })();

    function init() {
        _opts.value = _opts.value || `#ffffff`;
        _this.init(_id, _opts);
    }

    function initInput() {
        let $view = $('color');
        $view.css({
            position: 'relative',
            display: 'flex'
        });

        $hex = $view.create('colorHex');
        $hex.size('100%', '100%');
        $hex.css({
            boxSizing: `border-box`,
            flex: '2',
            marginRight: 4
        });

        $hexInput = $hex.create('hex', 'input');
        $hexInput.size('100%').css({
            fontSize: 12,
            fontFamily: `sans-serif`,
            padding: 1,
            color: `#37A1EF`,
            border: `1px solid #2E2E2E`
        }).bg(`#1D1D1D`);
        $hexInput.attr('value', _this.value);
        $hexInput.attr('maxlength', 7);

        $colorPicker = $view.create('colorPicker');
        $colorPicker.size('100%', 'auto').bg(_this.value);
        $colorPicker.css({
            border: `1px solid #2E2E2E`,
            position: 'relative',
            flex: '3'
        });

        $colorInput = $colorPicker.create('colorInput', 'input');
        $colorInput.attr('type', 'color');
        $colorInput.attr('value', _this.value);
        $colorInput.size(0, 0).css({
            border: 0,
            top: 6,
            zIndex: -1,
            position: 'absolute'
        });

        _this.view = $view;
    }

    //*** Event handlers
    function syncColorValue(frame, hexUpdate = false) {
        let needsUpdate = true;

        if (hexUpdate) {
            if ($hexInput.div.value !== _this.value) {
                _this.value = $hexInput.div.value;
            }
        } else if ($colorInput.div.value !== _this.value) {
            _this.value = $colorInput.div.value;
        } else {
            needsUpdate = false;
        }

        if (needsUpdate) {
            $hexInput.div.value = _this.value;
            $colorInput.div.value = _this.value;
            $colorPicker.bg(_this.value);
        }
    }

    function addHandlers() {
        $colorPicker.interact(null, onClick);
        finishChange = _this.debounce(finishChange, 250);

        $hexInput.div.addEventListener('input', onChange, false);
        $hexInput.div.addEventListener('focus', onTextFocus, false);
        $hexInput.div.addEventListener('change', finishChange, false);
        $colorInput.div.addEventListener('blur', onColorBlur, false);
    }

    function onClick() {
        $colorInput.div.click();
        $colorInput.div.focus();
        _this.startRender(syncColorValue, 24);
    }

    function onTextFocus() {
        $hexInput.div.select();
    }

    function onColorBlur() {
        _this.stopRender(syncColorValue);
        finishChange();
    }

    function onChange(v) {
        syncColorValue(null, true);

        finishChange();
    }

    function finishChange() {
        _this.finish();
    }

    //*** Public methods
    this.force = function(value) {
        $hexInput.div.value = value;
        syncColorValue(null, true);
    };

    this.update = function() {
        $hexInput.attr('value', _this.value);
        $colorPicker.bg(_this.value);
        $colorInput.attr('value', _this.value);

        finishChange();
    };

    this.onDestroy = function() {
        $hexInput.div.removeEventListener('input', onChange, false);
        $hexInput.div.removeEventListener('focus', onTextFocus, false);
        $hexInput.div.removeEventListener('change', finishChange, false);
        $colorInput.div.removeEventListener('blur', onColorBlur, false);
    };
});

/**
 * Image input control
 * @param {Object} [_opts.value] Initial value {src, relative, prefix, filename}
 * @param {String} [_opts.label=id] Text Label.
 * @param {String} [_opts.relative] Realtive path.
 * @param {String} [_opts.prefix="assets/images"] Prefix.
 */
Class(function UILControlFile(_id, _opts = { value: {} }) {
    Inherit(this, UILControl);
    const _this = this;
    let $view;
    let $picker;
    let $preview, $img, $copy, $filename, $input, $$copy, $progress;
    let _value;
    let $filepicker;

    //*** Constructor
    (function () {
        init();
        initView();
        addHandlers();
    })();

    function init() {
        _opts.value = Object.assign({
            src: ``,
            relative: _opts.relative || ``,
            prefix: _opts.prefix,
            filename: ``,
        }, _opts.value);
        _value = Object.assign({}, _opts.value);
        _this.init(_id, _opts);
    }

    function initView() {
        $view = $(`view`);
        $view.css({ position: `relative`, padding: 5 });

        $input = $view.create(`path`, `input`);
        $input.size('100%').bg(`#1D1D1D`);
        $input.css({ boxSizing: 'border-box', border: `1px solid #2E2E2E`, color: `#37A1EF`, marginBottom: 5 });
        if (_this.value.relative) $input.div.value = _this.value.relative;
        else $input.attr(`placeholder`, `Relative Path`);

        $preview = $view.create(`preview`);
        $preview.size(`100%`, 60);
        $preview.css({ boxSizing: `border-box`, position: `relative`, display: `flex`, alignItems: `center`, justifyContent: `center`, overflow: `hidden` });

        $img = $preview.create(`img`);
        $img.size(`100%`);
        $img.css({ position: `absolute`, top: 0, right: 0, bottom: 0, left: 0, backgroundSize: `cover`, backgroundRepeat: `no-repeat`, backgroundPosition: `center`, border: `1px dotted #2e2e2e`, boxSizing: `border-box` });

        $picker = $preview.create(`picker`, `input`);
        $picker.attr(`type`, `file`);
        $picker.css({ opacity: 0, position: `absolute`, top: 0, right: 0, bottom: 0, left: 0 });

        $progress = $preview.create('progress');
        $progress.css({
            "position": 'absolute',
            "bottom": 0,
            'height': 10,
            "left": 0,
            'background': '#9B9C9B'
        });

        $$copy = $preview.create(`copy`);
        $$copy.html(`Drag file here<br><small>or Click to Select</small>`);
        $$copy.fontStyle('sans-serif', 11, `#9B9C9B`).css({ textAlign: `center` });

        $filepicker = $view.create('filepicker', 'button');
        $filepicker.text('Browse').bg('#fff').css({ border: 0, width: 70, height: 15, textAlign: 'center', borderRadius: 5, position: 'relative', 'float': 'left', paddingTop: 2 }).fontStyle('sans-serif', 11, `#000`);
        $filepicker.div.onclick = () => {
            new UILExternalFilePicker(filePickerSelected, 'geometries');
        };

        _this.view = $view;

        if (_value.src) {
            $img.attr(`title`, _value.src);
            $$copy.text(_value.filename);
        }
    }

    function filePickerSelected(value) {
        if (window.UIL_REMOTE) {
            console.warn('UIL_REMOTE is not supported when using file picker!');
        }

        const src = `assets/geometry/${value}`;

        const v = {
            prefix: undefined,
            src,
            filename: value.split('/').last(),
            relative: 'assets/geometry'
        }
        
        _this.force(v);
        _this.value = v;

        _this.finish();
    }

    function getRelative() {
        if (_value.filename.includes('http')) return '';
        if (_value.relative.includes(_value.prefix))
            return _value.relative.replace(`${_value.prefix}`, ``);
        return _value.relative;
    }

    function getSrc() {
        if (_value.filename.includes('http')) return _value.filename;
        let p = _value.prefix ? _value.prefix + `/` : ``;
        let r = _value.relative ? _value.relative + `/` : ``;
        return `${p}${r}${_value.filename}`;
    }

    function fileExists(url) {
        if (url.includes('http')) return true;
        return fetch(Assets.getPath(url)).then(e => e.status != 404)
            .catch(e => console.warn(`UILControlFile image url validation failed`, e));
    }

    function makePreview(file) {
        let reader = new FileReader();
        reader.onload = e => $img.css({ backgroundImage: `url(${e.target.result})` });
        reader.readAsDataURL(file);
    }

    //*** Event handlers

    function addHandlers() {
        $picker.div.addEventListener('change', change, false);
        $picker.div.addEventListener('focus', focus, false);
        $picker.div.addEventListener('blur', blur, false);
        $input.div.addEventListener(`change`, inputChange, false);
    }

    async function change(e) {
        let file = $picker.div.files[0];
        if (!file) return;

        let name = file.name;
        if (window.UIL_REMOTE) {
            const { customMetadata } = await UILStorage.uploadFileToRemoteBucket({ file, progress: $progress });
            name = customMetadata.path;
        }

        _value.filename = name;
        _value.relative = getRelative();
        _value.src = getSrc();
        if (await fileExists(_value.src)) {
            _this.value = Object.assign({}, _value);
            $img.attr(`title`, _value.src);
            $$copy.text(_value.filename);
            _this.finish();
        } else {
            $picker.div.value = ``;
            console.warn(`UIL: Could not find file`, _value);
            alert(`"${_value.src}" not found!\nMake sure "relative path" is correct.`);
        }
    }

    function focus() {
        $img.css({ border: `1px solid #37a1ef` });
    }

    function blur() {
        $img.css({ border: `1px dotted #2e2e2e` });
    }

    function inputChange() {
        _value.relative = $input.div.value;
        if (_value.relative.includes('.')) {
            _this.value = Object.assign({}, _value);
            _this.finish();
        }
    }

    //*** Public methods

    this.force = function (value, isClipboard) {
        _value = Object.assign({}, value);
        if (isClipboard === true) _this.value = _value;

        $input.div.value = _value.relative;
        $img.attr(`title`, _value.src);
        $$copy.text(_value.filename);
    }

    this.onDestroy = function () {
        $picker.div.removeEventListener('change', change, false);
        $picker.div.removeEventListener('focus', focus, false);
        $picker.div.removeEventListener('blur', blur, false);
        $input.div.removeEventListener('change', inputChange, false);
    }
});

/**
 * Image input control
 * @param {Object} [_opts.value] Initial value {src, relative, prefix, filename}
 * @param {String} [_opts.label=id] Text Label.
 * @param {String} [_opts.relative] Realtive path.
 * @param {String} [_opts.prefix="assets/images"] Prefix.
 */
Class(function UILControlImage(_id, _opts = { value: {} }) {
    Inherit(this, UILControl);
    const _this = this;
    let $view;
    let $picker;
    let $preview, $img, $copy, $filename, $input, $check, $compress, $delete, $progress;
    let _value;
    let $filepicker;

    //*** Constructor
    (function () {
        init();
        initView();
        addHandlers();
    })();

    function init() {
        _opts.value = Object.assign({
            src: ``,
            relative: _opts.relative || ``,
            prefix: _opts.prefix || `assets/images`,
            filename: ``,
        }, _opts.value);
        _value = Object.assign({}, _opts.value);
        _this.init(_id, _opts);
    }

    function initView() {
        $view = $(`view`);
        $view.css({ position: `relative`, padding: 5 });

        $input = $view.create(`path`, `input`);
        $input.size('100%').bg(`#1D1D1D`);
        $input.css({ boxSizing: 'border-box', border: `1px solid #2E2E2E`, color: `#37A1EF`, marginBottom: 5 });
        if (_this.value.relative) $input.div.value = _this.value.relative;
        else $input.attr(`placeholder`, `Relative Path`);

        $compress = $view.create('compress');
        $compress.text('Compress').bg('#fff').css({ top: 3, width: 70, height: 15, textAlign: 'center', borderRadius: 5, position: 'relative', 'float': 'left', paddingTop: 2 }).fontStyle('sans-serif', 11, `#000`);

        $check = $view.create('#compressed', 'input');
        $check.attr('type', 'checkbox');
        $check.size(20, 20);
        $check.css({ boxSizing: `border-box`, position: `relative` });
        $check.div.checked = !!_this.value.compressed;

        let $label = $view.create('compressed-label', 'label');
        $label.attr('for', 'compressed');
        $label.text('Use Compressed').fontStyle('sans-serif', 9, `#9B9C9B`).css({ top: -6, position: 'relative' });

        $preview = $view.create(`preview`);
        $preview.size(`100%`, 60);
        $preview.css({ boxSizing: `border-box`, position: `relative`, display: `flex`, alignItems: `center`, justifyContent: `center`, overflow: `hidden` });

        $img = $preview.create(`img`);
        $img.size(`100%`);
        $img.css({ position: `absolute`, top: 0, right: 0, bottom: 0, left: 0, backgroundSize: `cover`, backgroundRepeat: `no-repeat`, backgroundPosition: `center`, border: `1px dotted #2e2e2e`, boxSizing: `border-box` });

        $picker = $preview.create(`picker`, `input`);
        $picker.attr(`type`, `file`);
        $picker.attr(`accept`, `image/*`);
        $picker.css({ opacity: 0, position: `absolute`, top: 0, right: 0, bottom: 0, left: 0 });

        $progress = $preview.create('progress');
        $progress.css({
            "position": 'absolute',
            "bottom": 0,
            'height': 10,
            "left": 0,
            'background': '#9B9C9B'
        });

        $delete = $preview.create('delete', 'button');
        $delete.size(18, 18)
            .css({
                border: 'none',
                padding: 0,
                position: 'absolute',
                top: 8,
                right: 8,
                borderRadius: '50%',
                background: '#1D1D1D',
                color: '#9B9C9B',
                textAlign: 'center'
            })
            .html(`<svg width="10" height="10" viewBox="0 0 10 10" fill="none" stroke="currentColor" xmlns="http://www.w3.org/2000/svg"><path stroke-width="2" stroke-linecap="round" d="M2 2l6 6M2 8l6-6"/></svg>`);
        $delete.hide();

        let copy = $preview.create(`copy`);
        copy.html(`Drag image here<br><small>or Click to Select</small>`);
        copy.fontStyle('sans-serif', 11, `#9B9C9B`).css({ textAlign: `center` });

        if (_this.value.src) {
            $img.css({ backgroundImage: `url('${Assets.getPath(_this.value.src)}')` });
            $picker.attr('title', _this.value.src);
            $delete.show();
        }

        $filepicker = $view.create('filepicker', 'button');
        $filepicker.text('Browse').bg('#fff').css({ border: 0, width: 70, height: 15, textAlign: 'center', borderRadius: 5, position: 'relative', 'float': 'left', paddingTop: 2 }).fontStyle('sans-serif', 11, `#000`);
        $filepicker.div.onclick = () => {
            new UILExternalFilePicker(filePickerSelected, 'textures');
        };

        _this.view = $view;
    }

    function filePickerSelected(value) {
        if (window.UIL_REMOTE) {
            console.warn('UIL_REMOTE is not supported when using file picker!');
        }

        const v = {
            compressed: false,
            filename: value.split('/').last(),
            prefix: 'assets/images',
            relative: 'assets/images',
            src: `assets/images/${value}`
        };

        _this.force(v, true);
        _this.finish();
    }

    function getRelative() {
        if (_value.filename.includes('http')) return '';
        if (_value.relative.includes(_value.prefix))
            return _value.relative.replace(`${_value.prefix}`, ``);
        return _value.relative;
    }

    function getSrc() {
        if (_value.filename.includes('http')) return _value.filename;
        let p = _value.prefix ? _value.prefix + `/` : ``;
        let r = _value.relative ? _value.relative + `/` : ``;
        return `${p}${r}${_value.filename}`;
    }

    function imageExists(url) {
        if (url.includes('http')) return true;
        url = Assets.getPath(url);
        return fetch(url).then(e => e.status != 404)
            .catch(e => console.warn(`UILControlImage image url validation failed`, e));
    }

    function makePreview(file) {
        let reader = new FileReader();
        reader.onload = e => $img.css({ backgroundImage: `url(${e.target.result})` });
        reader.readAsDataURL(file);
    }

    //*** Event handlers

    function addHandlers() {
        $picker.div.addEventListener('change', change, false);
        $picker.div.addEventListener('focus', focus, false);
        $picker.div.addEventListener('blur', blur, false);
        $input.div.addEventListener(`change`, inputChange, false);

        $delete.div.onclick = deleteImage;
        $compress.div.onclick = compressClick;
        $check.div.onchange = checkChange;
    }

    async function supportsKtx2() {
        if (typeof Dev.supportsKtx2 === 'undefined') {
            try {
                await Dev.execUILScript('compressktx2', { options: ['--help'], output: '', src: [] });
                Dev.supportsKtx2 = true;
            } catch (e) {
                console.log(
                    '%cKTX2 support not found in this project%c. 💁‍️ See https://www.notion.so/a91bbc09b19d4475bfc5bcb8d6048d70 for upgrade instructions',
                    'background-color: #ffde7b',
                    'background-color: unset'
                );
                Dev.supportsKtx2 = false;
            }
        }
        return Dev.supportsKtx2;
    }

    function parseCubePaths(path) {
        let info = Utils3D.splitCubemapPath(path);
        let src = Utils3D.getCubemapFacePaths(info);
        let output = `${info.prefix}.ktx2`;
        return [output, src];
    }

    async function compressKtx2() {
        let result;
        let path = _value.src.split('?')[0];
        if (_opts.compressOptions?.cube) {
            $compress.bg('#fdb460').html('Cubemap');
            let [output, src] = parseCubePaths(path);
            result = await Dev.execUILScript('compressktx2', {
                options: [
                    '--genmipmap',
                    '--encode',
                    'etc1s',
                    '--cubemap'
                ],
                output,
                src
            });
        } else {
            let noext = path.split('/').last().replace(/\.[^.]+$/, '');
            let folder = path.replace(/\/[^/]*$/, '');
            result = await Dev.execUILScript('compressktx2', {
                options: [
                    '--genmipmap',
                    '--encode',
                    'etc1s'
                ],
                output: `${folder}/${noext}.ktx2`,
                src: [path]
            });
        }
        return result !== 'Error';
    }

    async function compressClick() {
        if (!_value.src || _this.flag('compressPending')) return;
        _this.flag('compressPending', true);
        $compress.bg('#f4ee42').text('---');

        let success = false;
        try {
            if (await supportsKtx2()) {
                success = await compressKtx2();
            } else {
                let result = await Dev.execUILScript('compressktx', { src: _value.src.split('?')[0] });
                if (result !== 'Error') success = true;
            }
        } catch (e) {
            console.error(e);
        }
        if (success) {
            $compress.bg('#46f441').html('Success');
        } else {
            $compress.bg('#f44141').html('Failed');
        }

        _this.flag('compressPending', false);
    }

    async function checkChange() {
        let compressed = !!$check.div.checked;
        if (compressed && (await supportsKtx2())) {
            compressed = 'ktx2';
        }
        _this.value.compressed = compressed;
        _this.finish(false);
    }

    async function change(e) {
        let file = $picker.div.files[0];
        if (!file) return;

        let name = file.name;
        if (window.UIL_REMOTE) {
            const { customMetadata } = await UILStorage.uploadFileToRemoteBucket({ file, progress: $progress });
            name = customMetadata.path;
        }

        _value.filename = name;
        _value.relative = getRelative();
        _value.src = getSrc();
        _value.compressed = !!$check.div.checked;

        if (await imageExists(_value.src)) {
            _this.value = Object.assign({}, _value);

            $picker.div.value = ``;
            $picker.attr(`title`, _value.src);
            $img.css({ backgroundImage: `url(${Assets.getPath(_value.src)})` });
            $delete.show();
            _this.finish();
        } else {
            $picker.div.value = ``;
            console.warn(`UIL: Could not find image`, _value);
            alert(`"${_value.src}" not found!\nMake sure "relative path" is correct.`);
        }
    }

    function deleteImage() {
        _value = {
            src: ``,
            relative: ``,
            prefix: `assets/images`,
            filename: ``,
        };

        $input.div.value = ``;
        $picker.div.value = ``;
        $picker.attr(`title`, null);
        $img.css({ backgroundImage: `` });
        $delete.hide();

        _this.value = Object.assign({}, _value);
        _this.finish();
    }

    function focus() {
        $img.css({ border: `1px solid #37a1ef` });
    }

    function blur() {
        $img.css({ border: `1px dotted #2e2e2e` });
    }

    function inputChange() {
        _value.relative = $input.div.value;
    }

    //*** Public methods

    this.force = function (value, isClipboard) {
        _value = Object.assign({}, value);
        if (isClipboard === true) _this.value = _value;

        $input.div.value = _value.relative;
        $picker.div.value = ``;
        $picker.attr(`title`, _value.src);

        $img.css({ backgroundImage: `url('${Assets.getPath(_value.src)}')` });
        $check.div.checked = _value.compressed;
    }

    this.onDestroy = function () {
        $picker.div.removeEventListener('change', change, false);
        $picker.div.removeEventListener('focus', focus, false);
        $picker.div.removeEventListener('blur', blur, false);
        $input.div.removeEventListener('change', inputChange, false);
    }
});

/**
 * Number control
 * @param {Number} [_opts.value=0] Initial value.
 * @param {String} [_opts.label=id] Text Label.
 * @param {Number} [_opts.min=-Infinity] Minimum value.
 * @param {Number} [_opts.max=Infinity] Maximum value.
 * @param {Number} [_opts.step=1.0] Increase/decrease step amount.
 * @param {Number} [_opts.precision=3] Precision to display (does not change return value).
 */
Class(function UILControlNumber(_id, _opts={}) {
    Inherit(this, UILControl);
    const _this = this;
    let _input;

    //*** Constructor
    (function() {
        init()
        initInput();
    })();

    function init() {
        _opts.value = _opts.value || 0;
        _this.init(_id, _opts);
    }

    function initInput() {
        _input = _this.initClass(UILInputNumber, Object.assign(_opts, {value:_this.value}));
        _input.onInput(v => _this.value = v);
        _input.onFinish(v => _this.finish());
        _this.view = _input.input;
    }

    //*** Event handlers

    //*** Public methods

    this.update = function(value) {
        _input.value = _this.value || 0;
    }

    this.forceUpdate = function(value) {
        _input.forceUpdate(value);
    }
});
/**
 * Range input control
 * @param {Number} [_opts.value] Initial number value.
 * @param {String} [_opts.label=id] Text Label.
 * @param {Number} [_opts.min=0] Minimum value.
 * @param {Number} [_opts.max=100] Maximum value.
 * @param {Number} [_opts.step=1.0] Increase/decrease step amount.
 */
Class(function UILControlRange(_id, _opts={}) {
    Inherit(this, UILControl);
    const _this = this;
    let $view, $slider;
    let _max = _opts.max || 100;
    let _min = _opts.min || 0;
    let _step = _opts.step || 1;

    //*** Constructor
    (function() {
        init();
        style();
        initView();
        addHandlers();
    })();

    function init() {
        _opts.value = _opts.value || 0;
        _this.init(_id, _opts);
    }

    function style() {
        UIL.addCSS(UILControlRange, `
            .UILControlRange input { -webkit-appearance:none; appearance:none; }
            .UILControlRange input::-webkit-slider-thumb { -webkit-appearance: none; }
            .UILControlRange input::-webkit-slider-thumb { 
                -webkit-appearance:none; appearance:none;
                width:15px; height:15px;
                background:#FFF;
                border-radius:15px;
            }
            .UILControlRange input::-moz-slider-thumb { 
                -webkit-appearance:none; appearance:none;
                width:15px; height:15px;
                background:#FFF;
                border-radius:15px;
            }
        `);
    }

    function initView() {
        $view = $(`view`);
        $slider = $view.create('range', 'input');
        $slider.attr(`type`, `range`);
        $slider.attr(`max`, _max);
        $slider.attr(`min`, _min);
        $slider.attr(`step`, _step);
        $slider.div.value = _this.value;
        $slider.css({width:`100%`, margin:0, padding:0, background:`#1d1d1d`, height:4, borderRadius:15, border:`1px solid #2e2e2e`, boxSizing:`border-box`});
       _this.view = $view;
    }

    //*** Event handlers

    function addHandlers() {
       $slider.div.addEventListener('change', change, false);
       $slider.div.addEventListener('input', input, false);
       $slider.div.addEventListener('focus', focus, false);
       $slider.div.addEventListener('blur', blur, false);
    }

    function change() {
        _this.finish();
    }

    function input(e) {
        _this.value = Number($slider.div.value);
    }

    function focus() {
        $slider.css({border:`1px solid #37a1ef`});
    }

    function blur() {
        $slider.css({border:`1px solid #2e2e2e`});
    }

    //*** Public methods

    this.force = function(value) {
        _this.value = value;
        $slider.div.value = value;
        _this.finish(false);
    }

    this.onDestroy = function() {
       $slider.div.removeEventListener('change', change, false);
       $slider.div.removeEventListener('input', input, false);
       $slider.div.removeEventListener('focus', focus, false);
       $slider.div.removeEventListener('blur', blur, false);
    }
});
/**
 * Select input control
 * @param {Array} _opts.options Options [{label, value}...]. label is optional.
 * @param {String} [_opts.value] Initial value.
 * @param {String} [_opts.label=id] Text Label.
 */
Class(function UILControlSelect(_id, _opts={}) {
    Inherit(this, UILControl);
    const _this = this;
    let $view, $select;
    let _options;

    //*** Constructor
    (function() {
        init();
        style();
        initView();
        initOptions();
        addHandlers();
    })();

    function init() {
        if (!_opts.options) throw `UILControlSelect is missing select options`;
        _opts.value = _opts.value || _opts.options[0].value;
        _this.init(_id, _opts);
    }

    function style() {
        UIL.addCSS(UILControlSelect, `
            .UILControlSelect select { -webkit-appearance:none; appearance:none; }
        `);
    }

    function initView() {
        $view = $(`view`);
        $view.css({position:`relative`});

        $select = $view.create('dropdown', 'select');
        $select.css({width:`100%`, margin:0, padding:0, background:`#1d1d1d`, height:15, border:`1px solid #2e2e2e`, boxSizing:`border-box`, color:`#37a1ef`, borderRadius:0, height:17});

        let $arrow = $view.create(`arrow`);
        $arrow.text(`▼`).css({color:`#37a1ef`, fontSize:6, position:`absolute`, right:8, top:7, pointerEvents:`none`});

        _this.view = $view;
    }

    function initOptions() {
        _options = _opts.options.map(({value, label}) => {
            let el = document.createElement(`option`);
            el.setAttribute(`value`, value);
            if (_this.value === value) el.setAttribute(`selected`, true);
            el.text = label || value;
            el.value = value;
            $select.add(el);
            return el;
        });

        $select.div.value = _this.value;
    }

    //*** Event handlers

    function addHandlers() {
        $select.div.addEventListener('change', change, false);
        $select.div.addEventListener('input', input, false);
        $select.div.addEventListener('focus', focus, false);
        $select.div.addEventListener('blur', blur, false);
    }

    function change() {
        _this.finish();
    }

    function input() {
        let i = $select.div.selectedIndex;
        _this.value = _options[i].value;
    }

    function focus() {
        $select.css({border:`1px solid #37a1ef`});
    }

    function blur() {
        $select.css({border:`1px solid #2e2e2e`});
    }

    //*** Public methods

    this.force = function(value) {
        $select.div.value = value;
        _this.value = value;
    }

    this.onDestroy = function () {
        $select.div.removeEventListener('change', change, false);
        $select.div.removeEventListener('input', input, false);
        $select.div.removeEventListener('focus', focus, false);
        $select.div.removeEventListener('blur', blur, false);
    }
});

/**
 * Text input control
 * @param {String} [_opts.value] Initial value.
 * @param {String} [_opts.label=id] Text Label.
 */
Class(function UILControlText(_id, _opts={}) {
    Inherit(this, UILControl);
    const _this = this;
    let $input;
    let _timeout;

    //*** Constructor
    (function() {
        _this.init(_id, _opts); // 1) call init on parent
        initInput();
        addHandlers();
    })();

    function initInput() {
        $input = $('input', 'input');
        $input.size('100%').bg(`#1D1D1D`);
        $input.css({boxSizing:'border-box', border:`1px solid #2E2E2E`, color:`#37A1EF`});

        if (_this.value) $input.div.value = _this.value || ``;
        _this.view = $input; // 3) define control view
    }

    //*** Event handlers

    function addHandlers() {
        $input.div.addEventListener('input', onChange, false);
        $input.div.addEventListener('change', onFinishChange, false);
    }

    function onChange(v) {
        clearTimeout(_timeout);
        _timeout = setTimeout(onFinishChange, 400);
        _this.value = $input.div.value;
    }

    function onFinishChange() {
        if (_timeout === null) return;
        clearTimeout(_timeout);
        _timeout = null;
        _this.finish();
    }

    //*** Animation

    //*** Public methods

    this.update = function() {
        $input.div.value = _this.value || ``;
    }

    this.onDestroy = function() {
        $input.div.removeEventListener('input', onChange, false);
        $input.div.removeEventListener('change', onBlur, false);
    }
});
/**
 * Textarea control
 * @param {String} [_opts.value] Initial value.
 * @param {String} [_opts.label=id] Text Label.
 * @param {Boolean} [_opts.monospace=false] Use a monospace font.
 * @param {String} [_opts.minWidth=0] Minimum width.
 * @param {Number} [_opts.max=Infinity] Max length.
 * @param {Number} [_opts.min=-Infinity] Min length.
 * @param {Number} [_opts.resize='vertical'] Resize option. Valid: `none`, `both`, `horizontal` and `vertical`.
 * @param {Number} [_opts.rows=2] Height.
 * @param {Boolean} [_opts.editor=false] Behave as a tiny editor.
 * @param {Boolean} [_opts.readonly=false] Indicates that the user cannot modify the value of the control.
 */
Class(function UILControlTextarea(_id, _opts={}) {
    Inherit(this, UILControl);
    const _this = this;
    let $input;
    let _timeout;

    //*** Constructor
    (function() {
        _this.init(_id, _opts);
        initInput();
        if (_opts.editor) {
            enableTab();
            //enableHighlight();
        }
        addHandlers();
    })();

    function initInput() {
        $input = $('input', 'textarea');
        $input.attr(`maxlength`, _opts.max || Infinity);
        $input.attr(`minlength`, _opts.min || -Infinity);
        $input.attr(`rows`, _opts.rows || 2);
        $input.attr(`readonly`, _opts.readonly || false);

        $input.size('100%').bg(`#1D1D1D`);
        $input.css({boxSizing:'border-box', resize:_opts.resize || `vertical`, minWidth:_opts.minWidth || 0, border:`1px solid #2E2E2E`, color:`#37A1EF`});
        if (_opts.monospace || _opts.editor) $input.css({fontFamily:`monospace`});

        if (_this.value) $input.div.value = _this.value || ``;
        _this.view = $input;
    }

    function enableTab() {
        $input.div.onkeydown = function(e) {
            if (e.keyCode === 9) {
                // get caret position/selection
                let val = this.value;
                let start = this.selectionStart;
                let end = this.selectionEnd;
    
                // set textarea value to: text before caret + tab + text after caret
                this.value = val.substring(0, start) + '\t' + val.substring(end);
    
                // put caret at right position again
                this.selectionStart = this.selectionEnd = start + 1;
    
                // prevent the focus lose
                e.preventDefault();
            }
        };
    }

    //*** Event handlers

    function addHandlers() {
        $input.div.addEventListener('input', onChange, false);
        $input.div.addEventListener('change', onFinishChange, false);
    }

    function onChange(v) {
        clearTimeout(_timeout);
        _timeout = setTimeout(onFinishChange, 400);
        _this.value = $input.div.value;
    }

    function onFinishChange() {
        if (_timeout === null) return;
        clearTimeout(_timeout);
        _timeout = null;
        _this.finish();
    }

    //*** Animation

    //*** Public methods

    this.update = function() {
        $input.div.value = _this.value || ``;
    }

    this.onDestroy = function() {
        $input.div.removeEventListener('input', onChange, false);
        $input.div.removeEventListener('change', onBlur, false);
    }
});
/**
 * Vector control
 * @param {Array} [_opts.value] Initial value. Default to array of zeros of opts.components length.
 * @param {String} [_opts.label=id] Text Label.
 * @param {Number} [_opts.components] Type of vector. Eg. 4, 3, 2 etc. for the number of components.
 * @param {Number} [_opts.min=-Infinity] Minimum value.
 * @param {Number} [_opts.max=Infinity] Maximum value.
 * @param {Number} [_opts.step=1.0] Increase/decrease step amount.
 * @param {Number} [_opts.precision=3] Precision to display (does not change return value).
 */
Class(function UILControlVector(_id, _opts={}) {
    Inherit(this, UILControl);
    const _this = this;
    let $view;
    let _inputs = [];
    let _vector = [];
    let _length;

    //*** Constructor
    (function() {
        init();
        initInputs();
    })();

    function init() {
        if (_opts.value) {
            _length = _vector.length;
        } else if(_opts.components) {
            _opts.value = new Array(_opts.components).fill(0);
        } else {
            throw `UILControlVector: Cannot detect vector type. Define "options.components" count or init with a initial value`;
        }
        _length = _opts.value.length;
        _this.init(_id, _opts);
        _vector = [..._this.value];
    }

    function initInputs() {
        $view = $('inputs');
        for (let i = 0; i < _length; i++) {
            let { steps, ...opts } = _opts;
            if (Array.isArray(steps)) {
                let step = steps[i] || steps.last();
                if (step) opts.step = step;
            }
            let input = _this.initClass(UILInputNumber, opts);
            input.value = _this.value[i];
            input.onInput((v, m) => onInput(v, i, m));
            input.onFinish((v, m) => onFinish(v, i, m));
            input.input.css({display:`inline-block`, width:`calc(100% / ${_length})`});
            _inputs.push(input);
            $view.add(input.input);
        }
        _this.view = $view;
    }

    //*** Event handlers

    function onInput(value, index, master) {
        if (master) _vector = _vector.map(v => value);
        else _vector[index] = value;
        _this.value = [..._vector];
    }

    function onFinish(value, index, master) {
        //if (master) onInput(value, index, master);
        _this.finish();
    }

    //*** Public methods

    this.force = function(value, history = false) {
        _vector = [...value];
        _this.value = [..._vector];
        _inputs.forEach((input, index) => input.value = _this.value[index]);
        _this.finish(history);
    }

    this.update = function() {
        _inputs.forEach((input, index) => input.value = _this.value[index]);
    }
});

/**
 * Input form field with additional features.
 * @param {Number} [_opts.value=0] Initial value.
 * @param {String} [_opts.label=id] Text Label.
 * @param {Number} [_opts.min=-Infinity] Minimum value.
 * @param {Number} [_opts.max=Infinity] Maximum value.
 * @param {Number} [_opts.step=1.0] Increase/decrease step amount.
 * @param {Number} [_opts.precision=3] Precision to display (does not change return value).
 */
Class(function UILInputNumber(_opts={}) {
    Inherit(this, Component);
    const _this = this;
    let $input;
    let _timeout;
    let _editing = false;

    let _precision = _opts.precision || 3;
    let _step = _opts.step || 1.0;
    let _min = _opts.min || -Infinity;
    let _max = _opts.max || Infinity;
    let _value = _opts.value || 0;

    let _distance;
    let _onMouseDownValue;
    let _pointer = [0, 0];
    let _prevPointer = [0, 0];

    let _onInputCB = () => {};
    let _onFinishCB = () => {};

    //*** Constructor
    (function() {
        initInput();
        addHandlers();
    })();

    function initInput() {
        $input = $('input', 'input');
        $input.attr(`type`, `number`);
        $input.attr(`step`, _step);
        $input.size('100%').bg(`#1D1D1D`);
        $input.css({boxSizing:'border-box', border:`1px solid #2E2E2E`, color:`#37A1EF`, boxShadow:`none`});
        $input.div.value = parseFloat(_value).toFixed(_precision);
        _this.input = $input;
    }

    function setValue(value) {
        value = parseFloat(value) || 0;
        if (value < _min) value = _min;
        if (value > _max) value = _max;
        _value = value;
        _onInputCB(value, _this.master);
    }

    function setValueDrag(value) {
        if (value !== undefined || value !== $input.div.value) {
            setValue(value);
            $input.div.value = _value.toFixed(_precision);
        }
    }

    function addHandlers() {
        $input.div.addEventListener('mousedown', onMouseDown, false);
        $input.div.addEventListener('keyup', onKeyUp, false);
        $input.div.addEventListener('change', onFinishChange, false);
        $input.div.addEventListener('blur', onBlur, false);
        $input.div.addEventListener('input', onInput, false);
    }

    //*** Event handlers

    function onBlur() {
        onFinishChange();
        $input.div.value = parseFloat(_value).toFixed(_precision);
    }

    function onKeyUp(e) {
        if (e.keyCode === 13 && e.altKey) {
            _this.master = true;
            onInput();
        }
    }

    function onInput(e) {
        _timeout = setTimeout(onFinishChange, 400);
        _editing = true;
        setValue(parseFloat($input.div.value));
    }

    function onFinishChange() {
        if (!_editing) return;
        _editing = false;
        clearTimeout(_timeout);
        _onFinishCB(_value, _this.master);
        //$input.div.value = parseFloat(_value).toFixed(_precision);
        _this.master = false;
    }

    function onMouseDown(e) {
        if (e.button === 1 || (e.button === 0 && e.metaKey || e.ctrlKey)) {
            e.preventDefault();
            $input.css({ cursor: 'col-resize' });
            _distance = 0;
            _onMouseDownValue = _value;
            _prevPointer = [e.screenX, e.screenY];
            document.addEventListener('mousemove', onMouseMove, false);
            document.addEventListener('mouseup', onMouseUp, false);
        }
    }

    function onMouseMove(e) {
        clearTimeout(_timeout);
        _editing = true;

        let currentValue = _value;
        _pointer = [e.screenX, e.screenY];
        _distance += (_pointer[0] - _prevPointer[0]) - (_pointer[1] - _prevPointer[1]);

        let value = _onMouseDownValue + (_distance/(e.shiftKey ? 5 : 50)) * _step;
        value = Math.min(_max, Math.max(_min, value));

        _this.master = e.altKey;

        if (currentValue !== value) setValueDrag(value);

		_prevPointer = [e.screenX, e.screenY];
    }

    function onMouseUp(e) {
        onFinishChange();
        $input.css({cursor:''});
        document.removeEventListener('mousemove', onMouseMove, false);
		document.removeEventListener('mouseup', onMouseUp, false);
    }

    //*** Public methods

    this.set('value', value => {
        _value = value;
        if (!_editing) $input.div.value = parseFloat(value).toFixed(_precision);
    });
    this.get('value', () => _value);

    this.onInput = cb => _onInputCB = cb;
    this.onFinish = cb => _onFinishCB = cb;

    this.forceUpdate = function(value) {
        _value = value;
        $input.div.value = parseFloat(value).toFixed(_precision);
    }

    this.onDestroy = function() {
        $input.div.removeEventListener('mousedown', onMouseDown, false);
        $input.div.removeEventListener('change', onFinishChange, false);
        $input.div.removeEventListener('blur', onBlur, false);
        $input.div.removeEventListener('input', onInput, false);
    }
});
Class(function UILExternalColor( _title, _value ) {
    Inherit(this, Component);
    const _this = this;

    var _window;

    //*** Constructor
    (function () {
        _window = window.open(location.protocol + '//localhost/hydra/editor/color/index.html', `hydra_color_${_title}`, `width=480,height=220,left=200,top=100,location=no`);
        _window.window.onload = _ => {
            _window.window.initPicker(_title, _value, _this);
        };

        window.addEventListener( 'beforeunload', onReload );
    })();

    function onReload() {
        _this.onDestroy();
    }

    //*** Event handlers

    //*** Public methods

    this.update = function ( value ) {
        _this.events.fire( Events.UPDATE, { value });
    }

    this.onDestroy = function () {
        window.removeEventListener( 'beforeunload', onReload );
        _window && _window.window && _window.window.close();
    }

});
Class(function UILExternalEditor(_title, _height=500, _width=700) {
    Inherit(this, Component);
    const _this = this;
    var _window, _code, _language;

    //*** Constructor
    (function () {
        _window = window.open(location.protocol + '//localhost/hydra/editor/code/index.html', '_blank', `width=${_width},height=${_height},left=200,top=100`);
        _this.events.sub(Events.UNLOAD, _ => _window.close());
        _window.window.onload = _ => {
            _window.window.initEditor(_title, _code, _language, _this);
        };
    })();

    //*** Event handlers

    //*** Public methods
    this.setCode = function(code, language) {
        _code = code;
        _language = language;
    }

    this.saved = async function(code) {
        _this.onSave && _this.onSave(code);
        await defer();
        UILStorage.write();
    }
});
Class(function UILExternalFilePicker(callback, type = 'textures') {
    Inherit(this, Component);
    const _this = this;

    var _window;

    //*** Constructor
    (async function () {
        await Dev.execUILScript('assetsconfig');
        await init();
    })();

    async function init() {
        const assets = await get(Assets.getPath('assets/js/app/config/UILAssetsConfig.js'));
        eval(assets);

        let basePath, list;

        if (type === 'textures') {
            basePath = `${document.location.pathname}/assets/images`
            list = window.UIL_ASSETS_TEXTURES;
        }

        if (type === 'geometries') {
            basePath = `${document.location.pathname}/assets/geometry`
            list = window.UIL_ASSETS_GEOMETRIES;
        }

        _window = window.open(`${location.protocol}//localhost/hydra/editor/filepicker/index.html`, `pick file`, `width=800,height=700`);
        _this.events.sub(Events.UNLOAD, _ => _window.close());

        _window.window.onload = _ => {
            _window.window.initPicker(_this, basePath, list);
        };

        window.addEventListener( 'beforeunload', onReload );
    }

    //*** Event handlers
    function onReload() {
        _this.onDestroy();
    }

    //*** Public methods
    this.refresh = function() {
        _window && _window.window && _window.window.close();
        init();
    }

    this.update = function ( value ) {
        if (callback) callback(value);
    }

    this.onDestroy = function () {
        window.removeEventListener( 'beforeunload', onReload );
        _window && _window.window && _window.window.close();
    }
});

Class(function UILExternalTimeline(_title, _height=500, _width=700, _config) {
    Inherit(this, Component);
    const _this = this;
    var _window, _code, _language;

    //*** Constructor
    (function () {
        _window = window.open(location.protocol + '//localhost/hydra/editor/timeline/index.html', '_blank', `width=${_width},height=${_height},left=200,top=100`);
        _this.events.sub(Events.UNLOAD, _ => _window.close());
        _window.window.onload = _ => {
            _window.window.initEditor(_title, _config);
        };

        _window.window.addEventListener('message', e => {
            if (e.data.bundle) _this.onMessage && _this.onMessage(e.data.bundle);
            if (e.data.save) {
                _this.onSave && _this.onSave();
                let path;
                if (window.UIL_STATIC_PATH) {
                    path = window.UIL_STATIC_PATH;
                    path = path.substring(0, path.lastIndexOf('/'));
                } else {
                    path = 'assets/data';
                }
                Dev.writeFile(`${path}/timeline-${_title}.json?compress`, e.data.save);
            }
            if (e.data.visualizePath) _this.onVisualizePath?.(e.data.visualizePath);

            if (typeof e.data.position !== 'undefined') {
                _this.onPositionChange && _this.onPositionChange(e.data.position);
            }
        });

        _this.startRender(_ => {
            if (_window.closed) _this.destroy();
        }, 10);
    })();

    //*** Event handlers

    //*** Public methods
    this.saved = async function(code) {
        _this.onSave && _this.onSave(code);
        await defer();
        UILStorage.write();
    }

    this.sendUpdate = function(layerName, value, key) {
        _window.window.sendUpdate(layerName, value, key);
    }
});

Class(function UILPanelToolbar() {
    Inherit(this, Element);
    const _this = this;
    let $this;
    let $filter;
    let _state = new Map();

    //*** Constructor
    (function() {
        initHTML();
        initFilter();
    })();

    function initHTML() {
        $this = _this.element;
        $this.size('100%', 'auto').bg(`#272727`);
        $this.css({padding:4, boxSizing:'border-box', marginBottom:4});
    }

    function initFilter() {
        $filter = $this.create('filter', 'input');
        $filter.div.addEventListener('input', onInput, false);
        $filter.div.addEventListener('keydown', onKeyPressed, false);
        $filter.div.addEventListener('focus', onFocus, false);
        $filter.div.addEventListener('blur', onBlur, false);

        $filter.size('100%', 'auto').bg(`#161616`);
        $filter.css({color:`#B1B1B1`, border:`1px solid #2e2e2e`, outline:`none`, padding:2, boxSizing:`border-box`});
    }

    function saveFolderState() {
       _this.parent.folder.forEachFolder(folder => {
            _state.set(folder, folder.isOpen());
        });
    }

    function restoreFolderState() {
       _this.parent.folder.forEachFolder(folder => {
            _state.get(folder) ? folder.open() : folder.close();
        });
        _state.clear();
    }

    //*** Event handlers

    function onInput(e) {
        if (!$filter.div.value.length) {
            restoreFolderState();
            return _this.parent.folder.showChildren();
        }
        _this.parent.folder.filter($filter.div.value);
    }

    function onFocus() {
        saveFolderState();
        $filter.css({border:`1px solid #37a1ef`});
    }

    function onBlur() {
        $filter.css({border:`1px solid #2e2e2e`});
    }

    function onKeyPressed(e) {
        if (e.keyCode === 27) {
            $filter.div.value = '';
            restoreFolderState();
            return _this.parent.folder.showChildren();
        }
    }

    //*** Animation

    //*** Public methods

    this.eliminate = function() {
        $filter.div.removeEventListener('input', onInput, false);
        $filter.div.removeEventListener('keydown', onKeyPressed, false);
        $filter.div.removeEventListener('focus', onFocus, false);
        $filter.div.removeEventListener('blur', onBlur, false);
    }

    this.filter = function(text) {
        $filter.div.value = text;
        onInput();
    }

    this.filterSingle = function(text) {
        $filter.div.value = text;
        _this.parent.folder.filterSingle($filter.div.value);
    }

    this.hideAll = function() {
        if (_this.flag('init')) return;
        _this.flag('init', true);
        this.filterSingle('xxxxxx');
    }
});
Class(function AbstractUserInput() {
    Inherit(this, Component);
    const _this = this;
    var _downTime;

    this.position = new Vector3();
    this.quaternion = new Quaternion();
    this.plane2D = new Vector2();
    this.isDown = false;
    this.directionVec = new Vector3();
    this.velocity = new VelocityTracker(_this.position);
    this.velocity.start();

    //*** Constructor
    (function () {

    })();

    //*** Event handlers

    //*** Public methods
    this.down = function () {
        _this.isDown = true;
        _this.events.fire(UserInput.DOWN);
        _downTime = Render.TIME;
    };

    this.up = function () {
        _this.isDown = false;
        if (Render.TIME - _downTime < 500) _this.click();
        _this.events.fire(UserInput.UP);
    };

    this.click = function () {
        _this.events.fire(UserInput.CLICK);
    };
});

Class(function UserInput() {
    Inherit(this, Component);
    const _this = this;
    var _vr, _gazeSelector;

    this.inputs = [];

    this.DOWN = 'user_input_down';
    this.UP = 'user_input_up';
    this.CLICK = 'user_input_click';

    //*** Constructor
    (async function () {
        await Hydra.ready();
        await Hydra.ready();
        await RenderManager.initialized;
        if (RenderManager.type != RenderManager.VR) {
            _this.inputs.push(_this.initClass(UserInputMouseTouch));
            _this.flag('loaded', true);
        } else {
            _vr = true;
            VRInput.ready().then(_ => {
                VRInput.controllers.forEach(controller => {
                    _this.inputs.push(_this.initClass(UserInputVRController, controller));
                });
                _this.inputs.forEach(inp => inp.active = !inp.handedness);
                _this.flag('loaded', true);
                updateState();
            });

            VRInput.handsReady().then(_ => {
                _this.inputs.push(_this.initClass(UserInputVRController, VRInput.getHand('left')));
                _this.inputs.push(_this.initClass(UserInputVRController, VRInput.getHand('right')));
                _this.flag('loaded', true);
                updateState();

                _this.inputs.forEach(inp => inp.active = inp.handedness);

                _this.events.sub(VRInput.CHANGE, (type) => {
                    let left = VRInput.getHand('left');
                    for (let i = 0; i < _this.inputs.length; i++) {
                        if (_this.inputs[i].controller == left) return;
                    }

                    _this.inputs.push(_this.initClass(UserInputVRController, VRInput.getHand('left'), true));
                    _this.inputs.push(_this.initClass(UserInputVRController, VRInput.getHand('right'), true));
                    updateState();

                    _this.inputs.forEach(inp => inp.active = type == 'hands' ? inp.handedness : !inp.handedness);
                });
            });
        }
    })();

    function updateState() {
       for (let i = 0; i < _this.inputs.length; i++) {
           if (_this.inputs[i].updateVRState) _this.inputs[i].updateVRState(_this.inputs);
       }
    }

    //*** Event handlers

    //*** Public methods
    this.bindClick = async function (obj, hover, click) {
        await _this.ready();
        _this.inputs.forEach(inp => inp.bindClick(obj, hover, click));
    }

    this.unbindClick = async function (obj) {
        await _this.ready();
        _this.inputs.forEach(inp => inp.unbindClick(obj));
    }

    this.bindGaze = async function(obj, hover, click) {
        if (!_vr) {
            _this.bindClick(obj, hover, click);
        } else {
            if (!_gazeSelector) _gazeSelector = UserInputGazeSelector.instance();
            _gazeSelector.bind(obj, hover, click);
        }
    }

    this.unbindGaze = function(obj) {
        _gazeSelector && _gazeSelector.unbind(obj);
    }

    this.getGaze = function() {
        if (!_gazeSelector) _gazeSelector = UserInputGazeSelector.instance();
        return _gazeSelector;
    }

    this.bindProximity = async function (obj, hover, click) {
        await _this.ready();
        _this.inputs.forEach(inp => inp.bindProximity(obj, hover, click));
    }

    this.unbindProximity = async function (obj) {
        await _this.ready();
        _this.inputs.forEach(inp => inp.unbindProximity(obj));
    }

    this.alignToPlane = async function (mesh) {
        await _this.ready();
        _this.inputs.forEach(inp => inp.alignToPlane(mesh));
    }

    this.ready = function () {
        return _this.wait('loaded');
    }

    this.getGazeMesh = function() {
        if (!_gazeSelector) _gazeSelector = UserInputGazeSelector.instance();
        return _gazeSelector.mesh;
    }

    this.resetGaze = function(animateIn = false) {
        if(_gazeSelector) {
            _gazeSelector.reset();
            if (animateIn && !_gazeSelector.isVisible) {
                _gazeSelector.animateIn();
            }
        }
    }
}, 'static');

Class(function UserInputGazeSelector() {
    Inherit(this, Component);
    const _this = this;
    var _over, _mesh, _shader, _tween, _wrapper;

    var _objects = [];
    var _test = [];
    var _v3 = new Vector3();
    var _raycaster = Raycaster.find(World.CAMERA);
    var _mouse = new Vector2();
    var lastDistance = 2;

    this.prevent = false;
    this.snapToPosition = false;
    this.trackingTime = 1500;

    const renderSlot = RenderManager.type === RenderManager.NORMAL ? Camera.instance() : RenderManager.EYE_RENDER;

    //*** Constructor
    (function() {
        initMesh();
    })();

    function initMesh() {
        _wrapper = new Group();
        World.SCENE.add(_wrapper);

        _shader = _this.initClass(Shader, 'GazeSelector', {
            uColor: {value: new Color(Colors.grey[0])},
            uTime: {value: 0},
            uAlpha: {value: 0},
            uAlpha2: {value: 0.8},
            uVisible: {value: 0},
            transparent: true,
            depthWrite: false,
            depthTest: false,
            blending: Shader.ADDITIVE_BLENDING
        });

        _this.mesh = _mesh = new Mesh(World.PLANE, _shader);
        _mesh.scale.setScalar(Device.mobile.phone ? 1.25 : 0.9);

        _wrapper.add(_mesh);
        _wrapper.renderOrder = 9999;
        positionSelector();
    }

    function startTracking() {
        if (_this.tracking || _shader.uniforms.uVisible.value < 0.5) return;
        _this.tracking = true;
        _this.finishedTracking = false;
        if (_over) _over.__hasTracked = true;
        _this.events.fire(UserInputGazeSelector.TRACKING_STARTED, {object: _over});

        _this.startRender(track, renderSlot);
        _shader.tween('uAlpha', 0.9, _this.trackingTime / 3, 'easeOutSine');
        _shader.tween('uAlpha2', 0.25, _this.trackingTime / 3, 'easeOutSine');

        _shader.set('uTime', 0);
        _shader.tween('uTime', 1, _this.trackingTime, 'easeInOutSine');

        _this.timeout = _this.delayedCall(_ => {
            _this.finishedTracking = true;
            stopTracking();
            _this.animateOut();
            if (_over) {
                _over.__gazeClick && _over.__gazeClick({action: 'click', mesh: _over});
            }
        }, _this.trackingTime);
    }

    function stopTracking() {
        if (!_this.tracking) return;
        _this.tracking = false;
        _this.events.fire(UserInputGazeSelector.TRACKING_STOPPED, {object: _over, finished: _this.finishedTracking});

        _this.stopRender(track, renderSlot);
        if (_this.timeout) clearTimeout(_this.timeout);
        _shader.tween('uAlpha', 0.2, 500, 'linear');
        _shader.tween('uAlpha2', 0.8, 500, 'linear');
        if (!_this.finishedTracking) _shader.tween('uTime', 0, 1000, 'easeOutSine');
    }

    function positionSelector() {
        Utils3D.positionInFrontOfCamera(_wrapper, lastDistance);
    }

    function track() {
        if (!_over) return;
        _v3.set(0, 0, -1).applyQuaternion(World.CAMERA.quaternion);

        let [hit] = _raycaster.checkFromValues(_over, World.CAMERA.position, _v3);
        if (!hit || RenderManager.type != RenderManager.VR) return;
        if (_this.snapToPosition) {
            _wrapper.position.copy(hit.point);
            lastDistance = hit.point.distanceTo(World.CAMERA.position);
            _wrapper.lookAt(World.CAMERA.position);
        }
    }

    function loop() {
        _mouse.lerp(Mouse.tilt, 0.1);

        positionSelector();

        if (!_objects.length || _this.prevent) return;
        _test.length = 0;
        for (let i = _objects.length-1; i > -1; i--) {
            let obj = _objects[i];
            if (obj.determineVisible()) _test.push(obj);
        }

        _v3.set(0, 0, -1).applyQuaternion(World.CAMERA.quaternion);
        let [hit] = _raycaster.checkFromValues(_test, World.CAMERA.position, _v3);

        if (hit) {
            if (!_over) {
                _over = hit.object;
                _over.__hasTracked = false;
                if(_over.__preventTrack) return;
                _over.__gazeHover && _over.__gazeHover({ action: 'over', mesh: hit.object });
                startTracking();
            } else if (_over && !_over.__hasTracked && !_over.__preventTrack) {
                // The user was already gazing at an object when its __preventTrack
                // flipped from true to false.
                _over.__gazeHover && _over.__gazeHover({ action: 'over', mesh: hit.object });
                startTracking();
            }
        } else {
            if (_over) {
                _over.__gazeHover && _over.__gazeHover({ action: 'out' });
                _over.__hasTracked = false;
                _over = null;
                stopTracking(false);
            }
        }
    }

    //*** Event handlers

    //*** Public methods
    this.bind = function(obj, hover, click) {
        if (_objects.some(el => el.id === obj.id)) {
            // Already bound.
            return;
        }
        obj.__gazeHover = hover;
        obj.__gazeClick = click;
        _objects.push(obj);

        _this.animateIn();
    }

    this.unbind = function(obj) {
        if (!obj) return;
        let lengthBefore = _objects.length;
        _objects = _objects.filter(el => el.id !== obj.id);

        if (_over && _over.id === obj.id) {
            _over.__gazeHover && _over.__gazeHover({ action: 'out' });
            _over.__hasTracked = false;
            _over = null;
            stopTracking();
        }

        if (lengthBefore && _objects.length === 0 && _this.isVisible) _this.animateOut();
    }

    _this.reset = function() {
        _shader.set('uTime', 0);
        _shader.tween('uAlpha', 0.2, 2000, 'easeInOutSine');
        _shader.tween('uAlpha2', 0.8, 2000, 'easeInOutSine');
        lastDistance = 2;
    }

    _this.animateIn = function() {
        _this.isVisible = true;
        _this.startRender(loop, renderSlot);
        _this.finishedTracking = false;
        _shader.tween('uVisible', 1, 2000, 'easeInOutSine');

        _wrapper.scale.x = _wrapper.scale.y = 1.2;
        return tween(_wrapper.scale, { x: 1, y: 1 }, 2000, 'easeInOutCubic').promise();
    }

    _this.animateOut = async function() {
        _this.isVisible = false;
        _shader.tween('uTime', 0, 10, 'easeOutSine');

        await _shader.tween('uVisible', 0, 1000, 'easeOutSine').promise();
        _this.stopRender(loop, renderSlot);
        if (_over) {
            _over.__gazeHover && _over.__gazeHover({ action: 'out' });
            _over.__hasTracked = false;
            _over = null;
        }
        stopTracking();
    }

    this.getMesh = function() {
        return _mesh;
    }

    Dev.expose('gazeObjects', () => _objects);
}, 'singleton', () => {
    UserInputGazeSelector.TRACKING_STARTED = 'gaze_selector_tracking_started';
    UserInputGazeSelector.TRACKING_STOPPED = 'gaze_selector_tracking_stopped';
});
Class(function UserInputMouseTouch() {
    Inherit(this, AbstractUserInput);
    const _this = this;
    var _plane;

    var _hoverMeshes = [];
    var _activeHover = null;

    this.activeInput = true;
    this.distanceFromCamera = 0.1;

    //*** Constructor
    (function () {
        _this.startRender(loop, 24);
        addListeners();
    })();

    function loop() {
        if (!World.CAMERA) return;
        _this.position.copy(ScreenProjection.find(World.CAMERA).unproject(Mouse, _this.distanceFromCamera));

        // Check mouse hover with raycast
        if (_hoverMeshes.length) {
            performHoverCheck();
        }

        if (_plane) {
            let [hit] = Raycaster.find(World.CAMERA).checkHit(_plane, Mouse);
            if (hit) {
                _this.plane2D.x = Math.range(hit.uv.x, 0, 1, -1, 1);
                _this.plane2D.y = Math.range(hit.uv.y, 0, 1, -1, 1);
            } else {
                _this.plane2D.x = -10;
                _this.plane2D.y = -10;
            }
        }
    }

    function performHoverCheck() {
        let [newHover] = Raycaster.find(World.CAMERA).checkHit(_hoverMeshes);

        // Raycast hit
        if (newHover) {
            // New Mouseover
            if (!_activeHover) {
                newHover.object.__uiHover({ action: 'over', newHover, mesh: newHover.object });
                _activeHover = newHover;
            }

            // Mouseover swap
            else if (newHover.object !== _activeHover.object) {
                _activeHover.object.__uiHover({ action: 'out', hit: _activeHover, mesh: _activeHover.object });
                newHover.object.__uiHover({ action: 'over', newHover, mesh: newHover.object });
                _activeHover = newHover;
            }
        }
        // No hit
        else {
            if (_activeHover) {
                _activeHover.object.__uiHover({ action: 'out', hit: _activeHover, mesh: _activeHover.object });
                _activeHover = null;
            }
        }
    }

    //*** Event handlers
    function addListeners() {
        _this.events.sub(Mouse.input, Interaction.START, touchStart);
        _this.events.sub(Mouse.input, Interaction.MOVE, touchMove);
        _this.events.sub(Mouse.input, Interaction.END, touchEnd);
    }

    function touchStart(e) {
        _this.down();
    }

    function touchMove(e) {

    }

    function touchEnd(e) {
        _this.up();
    }

    //*** Public methods
    this.bindClick = function (obj, hover, click) {
        if (hover) {
            obj.__uiHover = hover;
            _hoverMeshes.push(obj);
        }

        if (click) {
            Interaction3D.find(World.CAMERA).add(obj, null, click);
        }
        obj.hitDestroy = () => this.unbindClick(obj);
    };

    this.unbindClick = function (obj) {
        _hoverMeshes.remove(obj);
        Interaction3D.find(World.CAMERA).remove(obj);
    };

    this.bindProximity = function (obj, hover, click) {
        this.bindClick(obj, hover, click);
    };

    this.unbindProximity = function (obj) {
        this.unbindClick(obj);
    };

    this.alignToPlane = function (mesh) {
        _plane = mesh;
    };
});

Class(function UserInputVRController(_controller) {
    Inherit(this, AbstractUserInput);
    const _this = this;
    var _plane;

    var _hoverMeshes = [];
    var _activeHover = null;

    var _proximity = [];
    var _v3 = new Vector3();

    const ZERO = new Vector3();

    this.controller = _controller;

    //*** Constructor
    (function () {
        addListeners();
        _this.startRender(loop, 24, World.NUKE);
        if (_controller.handedness === 'right' && !_controller.isAbstractHand) {
            Interaction3D.useInput(_controller);
            _this.activeInput = true;
        }
    })();

    function initProximitySphere(obj) {
        let box = new Box3().setFromObject(obj);
        obj.__proximitySphere = box.getBoundingSphere();
    }

    function intersects(objA, objB) {
        if (!objA.__proximitySphere) initProximitySphere(objA);
        if (!objB.__proximitySphere) initProximitySphere(objB);
        objA.__proximitySphere.center.copy(objA.getWorldPosition());
        objB.__proximitySphere.center.copy(objB.getWorldPosition());
        return objA.__proximitySphere.intersectsSphere(objB.__proximitySphere);
    }

    function loop() {
        if (!_controller.body || !_controller.body.getWorldPosition) return;
        if (!World.CAMERA || _controller.body.getWorldPosition().equals(ZERO) || !_controller.group.visible) return;

        _v3.copy(_controller.pointer);
        // _controller.group.getWorldPosition(_this.position);
        // _controller.group.getWorldQuaternion(_this.quaternion);
        _this.position.copy(_controller.group.position);
        _this.quaternion.copy(_controller.group.quaternion);

        if (_hoverMeshes.length) {
            performHoverCheck();
        }
        if (_proximity.length) {
            for (let i = _proximity.length - 1; i > -1; i--) {
                let mesh = _proximity[i];
                if (!mesh.visible) continue;

                if (_controller.isAbstractHand) {
                    _controller.tips.forEach(t => {
                        if (t.body) {
                            if (intersects(t.body, mesh)) {
                                fireProximity(mesh, t.body);
                            }
                        }
                    });
                }

                if (intersects(_controller.body, mesh)) {
                    fireProximity(mesh, _controller.body);
                }
            }
        }

        if (_plane) {
            let [hit] = Raycaster.find(World.CAMERA).checkFromValues(_plane, _controller.group.position, _v3);
            if (hit) {
                _this.plane2D.x = Math.range(hit.uv.x, 0, 1, -1, 1);
                _this.plane2D.y = Math.range(hit.uv.y, 0, 1, -1, 1);
            } else {
                _this.plane2D.x = -10;
                _this.plane2D.y = -10;
            }
        }
    }

    function fireProximity(mesh, body) {
        if (Render.TIME - mesh.__uiFireTime < 500) return;
        mesh.__uiFireTime = Render.TIME;
        if (mesh.__uiClick) {
            mesh.__uiClick({ action: 'click', mesh, handedness: _controller.handedness, controller: _controller, hitBody: body });
        }
    }

    // Uses directionVec to test hovered objects
    function performHoverCheck() {
        let [newHover] = Raycaster.checkFromValues(_hoverMeshes, World.CAMERA.position, _this.directionVec);

        // Raycast hit
        if (newHover) {
            // New Mouseover
            if (!_activeHover) {
                newHover.object.__uiHover({ action: 'over', newHover, mesh: newHover.object });
                _activeHover = newHover;
            }

            // Mouseover swap
            else if (newHover.object !== _activeHover.object) {
                _activeHover.object.__uiHover({ action: 'out', hit: _activeHover, mesh: _activeHover.object });
                newHover.object.__uiHover({ action: 'over', newHover, mesh: newHover.object });
                _activeHover = newHover;
            }
        }
        // No hit
        else {
            if (_activeHover) {
                _activeHover.object.__uiHover({ action: 'out', hit: _activeHover, mesh: _activeHover.object });
                _activeHover = null;
            }
        }
    }

    //*** Event handlers
    function addListeners() {
        _this.events.sub(_controller, VRInput.BUTTON, button);
    }

    function button(e) {
        if (!World.CAMERA || _controller.body.getWorldPosition().equals(ZERO) || !_controller.group.visible) return;
        if (e.label === 'trigger') {
            if (e.pressed) {
                _this.down();
                if (!_controller.isAbstractHand) Interaction3D.useInput(_controller);
                UserInput.inputs.forEach(inp => inp.activeInput = false);
                _this.activeInput = true;
            } else {
                _this.up();

                if (_activeHover) {
                    _activeHover.object.__uiClick({ action: 'click', mesh: _activeHover.object, hit: _activeHover.hit });
                }
            }
        }
    }

    //*** Public methods
    this.bindClick = function (obj, over, click) {
        obj.__uiHover = over;
        obj.__uiClick = click;
        _hoverMeshes.push(obj);

        obj.hitDestroy = _ => _hoverMeshes.remove(obj);
    };

    this.unbindClick = function (obj) {
        _hoverMeshes.remove(obj);
    };

    this.bindProximity = function (obj, over, click) {
        obj.__uiHover = over;
        obj.__uiClick = click;
        _proximity.push(obj);

        obj.hitDestroy = _ => _proximity.remove(obj);
    };

    this.unbindProximity = function (obj) {
        _proximity.remove(obj);
    };

    this.alignToPlane = function (plane) {
        _plane = plane;
    };

    this.setState = function(hoverMeshes, proximity) {
        _hoverMeshes = [...hoverMeshes];
        _proximity = [...proximity];
    }

    this.updateVRState = function(array) {
        array.forEach(obj => {
            if (obj.setState && obj != _this) obj.setState(_hoverMeshes, _proximity);
        });
    }

    this.getPosRelativeTo = function(head) {
        _v3.set(head.x, 0, head.z);
        _v3.add(_this.position);
        return _v3;
    }

    this.triggerHaptics = function(strength, time) {
        _controller.triggerHaptics && _controller.triggerHaptics(strength, time);
    }
});

Class(function EnvironmentCollisionThread() {
    Inherit(this, Component);
    const _this = this;
    var _geom, _mesh, _ray, _dir, _camera, _geomVR, _meshVR;

    function testHit(){

        let [hit] = _ray.intersectObject(_mesh);

        let obj = {miss:false};

        obj.success = true;

        if(_meshVR) {

            let [hitVR] = _ray.intersectObject(_meshVR);

            if(hitVR) {
                obj.miss = true;
            } else {
                if (hit) {
                    obj.normal = hit.face.normal;
                    obj.point = hit.point;
                } else {
                    obj.miss = true;
                }
            }

        } else {
            if (hit) {
                obj.normal = hit.face.normal;
                obj.point = hit.point;
            } else {
                obj.miss = true;
            }
        }

        return obj;
    }
    //*** Event handlers

    //*** Public methods
    this.mount = function({position, normal, scale}) {
        _geom = new Geometry();
        _geom.addAttribute('position', new GeometryAttribute(position, 3));
        _geom.addAttribute('normal', new GeometryAttribute(normal, 3));
        _geom.addAttribute('uv', new GeometryAttribute(new Float32Array((position.length/3) * 2), 2));
        _geom.computeBoundingSphere();
        _geom.computeBoundingBox();

        _mesh = new Mesh(_geom, {side: Shader.FRONT_SIDE});
        _ray = new RayManager();
        _dir = new Vector3(0, -1, 0);
        _camera = new PerspectiveCamera();
        _mesh.scale.fromArray(scale);
        _mesh.updateMatrixWorld(true);
    }

    this.mountVR = function({position, normal, scaleVR}) {
        _geomVR = new Geometry();
        _geomVR.addAttribute('position', new GeometryAttribute(position, 3));
        _geomVR.addAttribute('normal', new GeometryAttribute(normal, 3));
        _geomVR.addAttribute('uv', new GeometryAttribute(new Float32Array((position.length/3) * 2), 2));
        _geomVR.computeBoundingSphere();
        _geomVR.computeBoundingBox();

        _meshVR = new Mesh(_geomVR, {side: Shader.FRONT_SIDE});
        _meshVR.scale.fromArray(scaleVR);
        _meshVR.updateMatrixWorld(true);
    }


    this.test2D = function({pos}, id) {
        if (!_geom) return resolve({success: false}, id);
        _ray.setFromCamera(pos,_camera);
        let obj = testHit(true);
        resolve(obj, id);
    }

    this.updateCamera = function({fov,near,far,aspect,position,quaternion}) {
        if (_camera) {
            _camera.fov = fov;
            _camera.near = near;
            _camera.far = far;
            _camera.aspect = aspect;
            _camera.position.fromArray(position);
            _camera.quaternion.fromArray(quaternion);
            _camera.updateProjectionMatrix();
            _camera.updateMatrixWorld(true);
        }
    }

    this.test = function({pos}, id) {
        if (!_geom) return resolve({success: false}, id);
        _ray.set(pos, _dir, 0, Number.POSITIVE_INFINITY);
        let obj = testHit();
        resolve(obj, id);
    }

    this.testBox = function({pos,bounding},id){
        if (!_geom) return resolve({success: false}, id);
        _ray.set(pos, _dir, 0, Number.POSITIVE_INFINITY);
        let obj = testHit();
        let hits = [];
        if(obj.point){
            hits.push(obj)
        }
        for(let bound of bounding){
            _ray.set(bound, _dir, 0, Number.POSITIVE_INFINITY);
            let result = testHit();
            if (result.point){
                hits.push(result);
            }
        }
        if(hits.length > 0){
            let sorted = hits.sort((a,b)=>{
                return b.point.y - a.point.y
            });
            obj.point = sorted[0].point;
        }

        resolve(obj, id);
    }

    this.clear = function() {
        _geom = null;
        _geomVR = null;
    }
});
Class(function PlayerControlsVR(_group, _nullGroup, _collision) {
    Inherit(this, Object3D);
    const _this = this;
    var _time, _controller, _cyl, _preventTeleport, _wristMenu, _line;

    var _preventJoyMovement = false;
    var _canMove = true;
    var _castPos = new Vector3();
    var _hitPos = new Vector3();
    var _joyMoveDir = new Vector2();
    var _joyMoveAbsolute = new Vector3();
    var _v3 = new Vector3();
    var _qBlend = {value: 1};
    var _runningLerp = new Group();
    var _threadEvent = {};
    var _targetY = 0;

    const DOWN = new Vector3(0, -1, 0);
    const UP = new Vector3(0, 3, 0);
    const FWD = new Vector3(0, 0, -1);
    const REMOTE_LERP = 0.04;

    this.offset = new Vector3();

    //*** Constructor
    (async function () {
        [_line, _cyl] = PlayerControlsVR.getTeleportStructure();

        captureControllers();
    })();

    async function captureControllers() {
        await VRInput.ready();
        VRInput.controllers.forEach((c, i) => {
            _this.events.sub(c, VRInput.BUTTON, vrButton);
            _this.events.sub(c, VRInput.JOYSTICK, vrJoystick);
        });
    }

    function hitTestPlayer(e) {
        if (e.point) {
            _targetY = e.point.y;
        }
    }

    function hitTestCylinder(e) {
        _cyl.shader.set('uVis', 1);
        if (e.miss) {
            _canMove = false;
            _cyl.shader.set('uMiss', 1);
            _line.group.visible = false;
        } else {
            _cyl.shader.set('uMiss', 0);
            if (e.point) _cyl.position.y = e.point.y;
            _canMove = true;
            TweenManager.clearTween(_qBlend);
            _qBlend.value = REMOTE_LERP;

            if (_controller) {
                _line.group.visible = true;
                let subdivisions = 30;
                _line.clear();
                _controller.group.getWorldPosition(_line.catmull.points[0]);
                _line.catmull.points[1].copy(_line.catmull.points[0]).lerp(_cyl.position, 0.5, true);
                _line.catmull.points[1].y = Math.max(_line.catmull.points[0].y, _cyl.position.y);
                _line.catmull.points[2].copy(_cyl.position);
                for (let i = 0; i < subdivisions; i++) {
                    _line.catmull.getPoint((i+1) / subdivisions, _v3);
                    _line.draw(_v3);
                }
            } else {
                _line.group.visible = false;
            }
        }
    }

    function hitTestRunning(e) {
        if (!e.miss) {
            if (!e.success) _nullGroup.position.copy(_cyl.position);
            else _nullGroup.position.copy(e.point);
            _nullGroup.position.add(RenderManager.camera.inset);
        }
    }

    function hitTestJoystick(e) {
        if (!e.miss && !_preventJoyMovement) _group.position.add(_joyMoveAbsolute);
    }

    //*** Event handlers
    function vrButton(e) {
        Interaction3D.useInput(e.controller);
        if (e.label == 'trigger') {
            if (e.pressed) start(e);
            else end(e);
        }

        if (_wristMenu) {
            if (e.label == 'a' || e.label == 'b' || e.label == 'side_trigger' || e.label == 'touch_pad') {
                if (e.pressed) {
                    VRInput.controllers.forEach(c => {
                        if (c != e.controller) Interaction3D.useInput(c);
                    });

                    _wristMenu.object.onOpen?.();
                    _wristMenu.visible = true;
                    _wristMenu.scale.setScalar(0);
                    e.controller.group.add(_wristMenu);
                    _wristMenu.position.z = -0.05;
                    tween(_wristMenu.scale, {x: 1, y: 1, z: 1}, 300, 'easeOutCubic');
                } else {
                    if (_wristMenu.visible) {
                        VRInput.controllers.forEach(c => {
                            c.hideBeam();
                        });
                        _wristMenu.object?.onClose?.();
                        tween(_wristMenu.scale, {x: 0, y: 0, z: 0}, 300, 'easeOutCubic').onComplete(_ => {
                            _wristMenu.visible = false;
                        });
                    }
                }
            }
        }
    }

    function vrJoystick(e) {
        if (Interaction3D.find(World.CAMERA).intersecting) return;
        if (e.controller.handedness == 'right') {
            if (e.x > 0.5) {
                if (!_this.flag('blockPosX')) {
                    if (!_preventJoyMovement) RenderManager.camera.wrapper.rotation.y += Math.radians(-45);
                    _this.flag('blockPosX', true);
                }
            }

            if (e.x < -0.5) {
                if (!_this.flag('blockNegX')) {
                    if (!_preventJoyMovement) RenderManager.camera.wrapper.rotation.y += Math.radians(45);
                    _this.flag('blockNegX', true);
                }
            }

            if (e.x <= 0) _this.flag('blockPosX', false);
            if (e.x >= 0) _this.flag('blockNegX', false);
        } else {
            _joyMoveDir.set(e.x, e.y);
        }
    }

    function start(e) {
        if (_preventTeleport) return;
        if (Interaction3D.find(World.CAMERA).intersecting) return;
        if (e.controller.handedness == 'left') return;
        _time = Date.now();
        _cyl.shader.set('uVis', 0);
        _cyl.visible = true;
        _controller = e.controller;
    }

    async function end(e) {
        if (_preventTeleport) return;
        if (Interaction3D.find(World.CAMERA).intersecting || !_cyl.visible) return;
        if (e.controller.handedness == 'left') return;
        _controller = null;
        _cyl.visible = false;

        tween(_qBlend, {value: 1}, 500, 'linear');

        if (Date.now() - _time > 100 && _canMove) {
            if (_this.onTeleportCallback) await _this.onTeleportCallback();

            _group.position.x = _cyl.position.x;
            _group.position.y = _targetY = _cyl.position.y;
            _group.position.z = _cyl.position.z;

            _group.position.x -= RenderManager.camera.inset.x;
            _group.position.z -= RenderManager.camera.inset.z;
        }
    }

    //*** Public methods
    this.loop = async function() {
        if (_controller) {
            _controller.group.getWorldQuaternion(_controller.group.worldQuat);

            FWD.set(0, 0, -1);
            let angle = Utils3D.getSignedQuaternionAngleToPlane(
                _controller.group.worldQuat,
                FWD,
                UP
            );
            let ranged = Math.range(Math.degrees(angle), -45, 45, 0.1, 1, true);

            // FWD = project the controller’s direction vector onto a plane
            // parallel to the floor, then adjust its length depending on
            // `ranged`.
            FWD.applyQuaternion(_controller.group.worldQuat)
                .projectOnPlane(UP).normalize()
                .multiplyScalar(8 * PlayerControlsVR.TELEPORT_SCALAR * ranged);
            _castPos.copy(_controller.group.getWorldPosition()).add(FWD);
            _cyl.position.x = _castPos.x;
            _cyl.position.z = _castPos.z;
            if (_this.onTargetUpdate) _this.onTargetUpdate(_cyl.position);
        }

        if (_cyl.visible) {
            _hitPos.copy(_cyl.position).add(UP);
            _threadEvent.pos = _hitPos;
            _threadEvent.cylinder = true;
            _collision.test(_threadEvent, hitTestCylinder);
        }

        _runningLerp.position.lerp(_cyl.visible ? _cyl.position : _group.position, _qBlend.value);
        _runningLerp.quaternion.slerp(World.CAMERA.getWorldQuaternion(), _qBlend.value);
        _hitPos.copy(_runningLerp.position).add(UP);
        _threadEvent.pos = _hitPos;
        _threadEvent.cylinder = false;
        _collision.test(_threadEvent, hitTestRunning);

        _group.position.y = Math.lerp(_targetY, _group.position.y, 0.2);
        RenderManager.camera.offset.copy(_group.position);

        _hitPos.copy(World.CAMERA.getWorldPosition());
        _threadEvent.pos = _hitPos;
        _threadEvent.cylinder = false;
        _collision.test(_threadEvent, hitTestPlayer);

        _nullGroup.quaternion.copy(_runningLerp.quaternion);
        _nullGroup.position.y = _hitPos.y;

        if (_joyMoveDir.lengthSq() > 0 && !_preventJoyMovement) {
            _joyMoveAbsolute.set(_joyMoveDir.x, 0, _joyMoveDir.y).applyQuaternion(World.CAMERA.getWorldQuaternion()).multiplyScalar(PlayerControlsVR.JOYSTICK_SPEED * 0.02 * Render.HZ_MULTIPLIER);
            _v3.copy(_group.position).add(_joyMoveAbsolute).add(UP);
            _threadEvent.pos = _v3;
            _threadEvent.cylinder = true;
            _collision.test(_threadEvent, hitTestJoystick);
        }
    }

    this.disableTeleport = function() {
        _preventTeleport = true;
        _cyl.visible = false;
        _line.visible = false;
    }

    this.enableTeleport = function() {
        _preventTeleport = false;
    }

    this.disableJoystickMovement = function() {
        _preventJoyMovement = true;
    }

    this.enableJoystickMovement = function() {
        _preventJoyMovement = false;
    }

    this.respawn = function(pos) {
        RenderManager.camera.offset.copy(pos);
        _group.position.copy(pos);
    }

    this.initWristMenu = function(obj) {
        _wristMenu = new Group();
        _wristMenu.object = obj;
        _wristMenu.add(obj.group);
    }

    this.setOnTeleportCallback = function(value) {
        _this.onTeleportCallback = value;
    }

    this.setOnTargetUpdate = function(value) {
        _this.onTargetUpdate = value;
    }
}, _ => {
    PlayerControlsVR.TELEPORT_SCALAR = 1;
    PlayerControlsVR.JOYSTICK_SPEED = 1;

    var _line, _cyl, _lineColor, _color, _missColor;
    function initLine() {
        _line = new Line3D({
            width: 7,
            color: '#0e76c5'
        });

        let shader = new Shader('TeleportLineShader', {
            uLColor: {value: _lineColor},
            uLAlpha: {value: 0.35},
            uVis: _cyl.shader.uniforms.uVis,
            transparent: true
        });

        _line.useShader(shader);
        _line.color = new Color();
        _line.catmull = new CatmullRomCurve([new Vector3(), new Vector3(), new Vector3()]);
        World.SCENE.add(_line.group);
        _line.group.visible = false;

        _line.wait('mesh').then(_ => _line.mesh.renderOrder = 99999);
    }

    function initCylinder() {
        let geom = new CylinderGeometry(1, 1, 1, 50);
        geom.applyMatrix(new Matrix4().makeTranslation(0, 0.5, 0));
        let shader = new Shader('TeleportCylinderShader', {
            uColor: {value: _color},
            uAlpha: {value: 0.5},
            uVis: {value: 0},
            uMiss: {value: 0},
            uMissColor: {value: _missColor},
            transparent: true
        });
        _cyl = new Mesh(geom, shader);
        _cyl.depthWrite = false;
        _cyl.renderOrder = 9999;
        _cyl.scale.set(0.2, 4, 0.2);
        World.SCENE.add(_cyl);
        _cyl.shader.depthWrite = false;
        _cyl.visible = false;
    }

    PlayerControlsVR.getTeleportStructure = function() {
        if (!_line) {
            _color = new Color('#ffffff');
            _lineColor = new Color('#ffffff');
            _missColor = new Color('#D90E0E');
            initCylinder();
            initLine();
        }

        return [_line, _cyl];
    }

    PlayerControlsVR.setTeleportColor = function(color) {
        _color.set(color);
    }

    PlayerControlsVR.setLineColor = function(color) {
        _lineColor.set(color);
    }

    PlayerControlsVR.setMissColor = function(color) {
        _missColor.set(color);
    }
});

Class(function TeleportEnvironment() {
    Inherit(this, Object3D);
    const _this = this;
    var _thread, _camera;

    //*** Constructor
    (function () {
        if (!Device.system.xr.vr) return;
        initThread();
        initControls();
        _this.startRender(loop);
        _camera = {position:[],quaternion:[]};
        defer(setupBaseMesh);
    })();

    function setupBaseMesh() {
        let geom = new PlaneGeometry(100, 100).toNonIndexed();
        geom.applyMatrix(new Matrix4().makeRotationX(Math.radians(-90)));
        let mesh = new Mesh(geom, Utils3D.getTestShader());
        _this.setLevelMesh(mesh);
    }

    function initThread() {
        _thread = _this.initClass(Thread, EnvironmentCollisionThread);
        Utils3D.loadEngineOnThread(_thread);
    }

    function initControls() {
        _this.nullGroup = new Group();
        _this.nullGroup.position.copy(World.CAMERA.getWorldPosition());
        _this.controls = _this.initClass(PlayerControlsVR, _this.group, _this.nullGroup, _thread);
    }

    function loop() {
        _camera.fov = World.CAMERA.fov;
        _camera.near = World.CAMERA.near;
        _camera.far = World.CAMERA.far;
        _camera.aspect = World.CAMERA.aspect;
        World.CAMERA.getWorldPosition().toArray(_camera.position);
        World.CAMERA.getWorldQuaternion().toArray(_camera.quaternion);
        _thread.updateCamera(_camera);
        _this.controls.loop();
        RenderManager.fire(_this);
    }

    //*** Event handlers

    //*** Public methods
    this.setLevelMesh = function(mesh) {
        if (!_this.controls) return;
        if (mesh) {
            let {position, normal} = mesh.geometry.attributes;
            let pos = new Float32Array(position.array);
            let n = new Float32Array(normal.array);
            let scale = mesh.scale.toArray();
            _thread.mount({position: pos, normal: n, scale}, [pos.buffer, n.buffer]);
        } else {
            _thread.clear();
        }
    }

    this.setOcclusionMesh = function(mesh) {
        if (!_this.controls) return;
        if (mesh) {
            let {position, normal} = mesh.geometry.attributes;
            let posVR = new Float32Array(position.array);
            let nVR = new Float32Array(normal.array);
            let scaleVR = mesh.scale.toArray();
            _thread.mountVR({position: posVR, normal: nVR, scaleVR}, [posVR.buffer, nVR.buffer]);
        } else {
            _thread.clear();
        }
    }

    this.disableTeleport = function() {
        _this.controls?.disableTeleport();
    }

    this.enableTeleport = function() {
        _this.controls?.enableTeleport();
    }

    this.respawn = function(pos) {
        _this.controls?.respawn(pos);
    }

    this.initWristMenu = function(obj) {
        _this.controls?.initWristMenu(obj);
    }

    this.get('teleportTarget', _ => {
        if (!_this.controls) return;
        return PlayerControlsVR.getTeleportStructure()[1];
    })

    this.set('onTargetUpdate', value => {
        _this.controls?.setOnTargetUpdate(value);
    });

    this.set('onTeleportCallback', value => {
        _this.controls?.setOnTeleportCallback(value);
    });

    this.set('teleportColor', color => {
        if (_this.controls) PlayerControlsVR.setTeleportColor(color);
    });

    this.set('missColor', color => {
        if (_this.controls) PlayerControlsVR.setMissColor(color);
    });

    this.set('lineColor', color => {
        if (_this.controls) PlayerControlsVR.setLineColor(color);
    });

    this.set('teleportScalar', value => {
        PlayerControlsVR.TELEPORT_SCALAR = value;
    });

    this.set('joystickScalar', value => {
        PlayerControlsVR.JOYSTICK_SPEED = _config.joystickSpeed;
    });
}, 'singleton');
Class(function VelocityTracker(_vector) {
    Inherit(this, Component);
    var _this = this;

    var Vector = typeof _vector.z === 'number' ? Vector3 : Vector2;
    var _velocity = new Vector();
    var _last = new Vector();

    this.value = _velocity;

    function loop(time, delta) {
        // "Velocity" is defined as distance travelled per 16.67ms, because of
        // an assumed 60Hz refresh rate.
        _velocity.subVectors(_vector, _last).divideScalar((delta || Render.DELTA) / (1000 / 60));
        _last.copy(_vector);
    }

    //*** Event handlers

    //*** Public methods
    this.start = function() {
        _this.startRender(loop);
    }

    this.onDestroy = this.stop = function() {
        _this.stopRender(loop);
    }

    this.copy = function() {
        _last.copy(_vector);
    }

    this.update = loop;
});

Class(function XRDeviceManager() {
    Inherit(this, Component);
    const _this = this;
    var _device, _session, _promise, _activeTime;

    this.SESSION_START = 'xr_start';
    this.SESSION_END = 'xr_end';
    this.CONTROLS_START = 'controls_start';
    this.HEADSET_IDLE = 'headset_idle';

    this.FOVEATION_LEVEL_NONE = 0;
    this.FOVEATION_LEVEL_LOW = 1;
    this.FOVEATION_LEVEL_MEDIUM = 2;
    this.FOVEATION_LEVEL_HIGH = 3;
    this.FOVEATION_LEVEL_HIGH_TOP = 4;

    this.scaleFactor = 1;
    this.preallocatedScaleFactors = [];
    this.features = ['bounded-floor'];
    this.reloadWhenSessionEnds = true;
    this.mixedReality = false;

    function loop() {
        if (Render.TIME - _activeTime > 15000) _this.events.fire(_this.HEADSET_IDLE);
        _activeTime = Render.TIME;
    }

    function getFoveationFeatureName() {
        // Levels are documented at https://developer.oculus.com/documentation/native/android/mobile-ffr/
        // However in the Oculus browser, the foveation patterns are all much stronger
        // than shown on that page. Requesting "high" gives strong foveation more like
        // the documented "High Top" (4) pattern. Even "low" is strong, not considerably less
        // foveated than the documented "high" pattern.
        switch (_this.foveationLevel) {
            case _this.FOVEATION_LEVEL_LOW:
                return 'low-fixed-foveation-level';
            case _this.FOVEATION_LEVEL_MEDIUM:
                return 'medium-fixed-foveation-level';
            case _this.FOVEATION_LEVEL_HIGH:
            case _this.FOVEATION_LEVEL_HIGH_TOP:
                return 'high-fixed-foveation-level';
            default:
                return 'no-fixed-foveation';
        }
    }

    //*** Event handlers

    //*** Public methods
    this.getVRSession = async function() {
        if (_session) return _session;
        if (_this.flag('disable3D')) {
            _this.flag('needNewSession', true);
            return null;
        }
        let requiredFeatures = ['local-floor'];
        let optionalFeatures = [..._this.features, getFoveationFeatureName()];
        let sessionType = `immersive-${_this.mixedReality && Device.system.xr.ar ? 'ar' : 'vr'}`;
        if (sessionType == 'immersive-vr' && _this.mixedReality) _this.mixedReality = false;
        _session = await navigator.xr.requestSession(sessionType, {requiredFeatures, optionalFeatures});
        _session.addEventListener('end', _ => {
            _session = null;
            _this.flag('needNewSession', true);
            _this.events.fire(_this.SESSION_END);
        });

        _this.startRender(loop, 1);

        return _session;
    }

    this.getARSession = async function() {
        if (_session) return _session;
        _session = await navigator.xr.requestSession('immersive-ar');
        _session.addEventListener('end', _ => {
            _session = null;
            _this.flag('needNewSession', true);
            _this.events.fire(_this.SESSION_END);
        });
        return _session;
    }

    this.startSession = function() {
        if (_this.isDisabled()) {
            _this.enable3D();
        }
        if (_this.flag('needNewSession')) {
            _this.flag('needNewSession', false);
            RenderManager.camera.reset?.();
            RenderManager.renderer.reset?.();
            _promise = null;
        }

        if (_promise) return _promise;
        _promise = Promise.create();
        _this.events.sub(_this.SESSION_START, _promise.resolve);
        return _promise;
    }

    this.endSession = function() {
        _this.flag('needNewSession', true);
        _this.events.fire(_this.SESSION_END);
        let promise = _session?.end();
        _session = null;
        return promise;
    }

    this.waitForEnd = function() {
        let promise = Promise.create();
        _this.events.sub(_this.SESSION_END, promise.resolve);
        return promise;
    }

    this.disable3D = function() {
        _this.flag('disable3D', true);
    };

    this.enable3D = function() {
        _this.flag('disable3D', false);
    };

    this.isDisabled = function() {
        return _this.flag('disable3D');
    };

    this.set('targetFramerate', async value => {
        await _promise;
        _session?.updateTargetFrameRate?.(value);
    });
}, 'static');

Class(function ARCamera() {
    Inherit(this, Component);
    const _this = this;
    var _session, _ref;

    this.worldCamera = new PerspectiveCamera(30, Stage.width / Stage.height, 0.1, 1000);

    //*** Constructor
    (function () {

    })();

    //*** Event handlers

    //*** Public methods
    this.getFrameOfReference = async function() {
        _session = await XRDeviceManager.getARSession();
        _ref = await _session.requestReferenceSpace('local');
        return _ref;
    }

    this.getRenderCamera = function(view, pose) {
        if (!pose) return;

        _this.worldCamera.position.copy(view.transform.position);
        _this.worldCamera.quaternion.copy(view.transform.orientation);
        _this.worldCamera.updateMatrixWorld(true);
        _this.worldCamera.projectionMatrix.fromArray(view.projectionMatrix);

        return _this.worldCamera;
    }
});

Class(function ARRenderer(_renderer, _nuke) {
    Inherit(this, Component);
    const _this = this;
    var _session, _arCamera, _callback, _frame, _frameOfRef, _gl, _view;

    //*** Constructor
    (function () {
        defer(setup);
    })();

    async function setup() {
        _session = await XRDeviceManager.getARSession();
        _session.baseLayer = new XRWebGLLayer(_session, _renderer.context, {framebufferScaleFactor: RenderManager.DPR / Device.pixelRatio, stencil: _renderer.stencil});
        _session.updateRenderState({baseLayer: _session.baseLayer});

        _gl = _renderer.context;

        _arCamera = RenderManager.camera;
        _frameOfRef = await _arCamera.getFrameOfReference();

        ARUtils.frameOfReference = _frameOfRef;

        _session.requestAnimationFrame(rAF);
        Renderer.overrideViewport = true;

        _renderer.arRenderingPath = renderAR;

        Render.useRAF(rAFOverride);
        _this.events.fire(XRDeviceManager.SESSION_START);
    }

    function renderAR(render, scene, camera) {
        _gl.bindFramebuffer(_gl.FRAMEBUFFER, _session.baseLayer.framebuffer);
        let viewport = _session.baseLayer.getViewport(_view);
        _gl.viewport(viewport.x, viewport.y, viewport.width, viewport.height);
        _renderer.resolution.set(viewport.width, viewport.height);

        _renderer.autoClear = false;
        render(scene, camera);
        _gl.bindFramebuffer(_gl.FRAMEBUFFER, null);
        _renderer.autoClear = true;

        _nuke.postRender && _nuke.postRender();
    }

    function rAFOverride(callback) {
        _callback = callback;
    }

    function rAF(t, frame) {
        _session.requestAnimationFrame(rAF);
        let pose = frame.getViewerPose(_frameOfRef);
        if (!pose) return;

        ARUtils.pose = pose;
        _view = pose.views[0];
        if (window.AURA) {
            ARUtils.setFramebuffer(_session.baseLayer, _view);
            _nuke.rtt = ARUtils.getFramebuffer();
        }

        _arCamera.getRenderCamera(_view, pose);

        _frame = frame;
        if (_callback) _callback(t);
    }

    //*** Event handlers

    //*** Public methods
    this.render = function(scene, camera) {
        if (!_frame) return;
        if (_nuke.passes.length && window.AURA) _nuke.render();
        else _renderer.render(scene, camera);
    }

    this.setSize = function(width, height) {
        _renderer.setPixelRatio(RenderManager.DPR);
        _renderer.setSize(width, height);
    }

    this.getCameraTexture = function(texture) {
        texture._gl = _session.getCameraTexture();
    }
});
Class(function ARUtils() {
    Inherit(this, Component);
    const _this = this;
    var _origin, _direction, _matrix, _session, _env, _framebuffer;
    var _originArray, _directionArray, _cameraTexture;

    var _envShaders = [];
    var _tracking = false;

    this.lightIntensity = {type: 'f', value: 0};
    this.FIRST_TRANSFORM = 'arutils_first_transform';
    this.TRACKING_CHANGE = 'arutils_tracking_change';
    this.TRACKING_STARTED = 'arutils_tracking_started';
    this.CLOUD_ANCHOR = 'cloud_anchor';

    //*** Constructor
    (function () {
        _this.events.sub(XRDeviceManager.SESSION_START, async _ => {
            if (RenderManager.type != RenderManager.WEBAR) return;
            _session = await XRDeviceManager.getARSession();
            _session.onCreated = _ => _this.events.fire(_this.TRACKING_STARTED);
            _this.startRender(checkStatus, 10);
            _session.addEventListener('envTexture', handleEnvTexture);
        });
    })();

    function checkStatus() {
        if (_session.trackingStatus) {
            if (!_tracking) {
                _tracking = true;
                _this.events.fire(_this.TRACKING_CHANGE, {tracking: true});
            }
        } else {
            if (_tracking) {
                _tracking = false;
                _this.events.fire(_this.TRACKING_CHANGE, {tracking: false});
            }
        }
    }

    //*** Event handlers
    async function handleEnvTexture({texture}) {
        let t = new Texture();
        t.cube = true;
        t.needsReupload = t.needsUpdate = false;
        t._metal = t._gl = texture;

        let size = Device.system.os == 'ios' ? 256 : 16;
        let hdr = Device.system.os == 'android';

        let lastEnv = _env;
        // _env = _this.initClass(DynamicEnvGenerator, t, size, _session.environment.lightIntensity);
        _env = _this.initClass(DynamicEnvGenerator, t, size, 30, hdr);
        await _env.ready();

        _envShaders.forEach(shader => {
            shader.set('tEnvSpecular', _env.specular.texture);
            shader.set('tEnvDiffuse', _env.diffuse.texture);
        });

        if (lastEnv) lastEnv.destroy();
    }

    //*** Public methods
    this.getTrackingStatus = async function() {
        if (!_session) _session = await XRDeviceManager.getARSession();
        return _session.trackingStatus;
    }

    this.resetOrigin = function() {

    }

    this.findSurface = async function(obj = Mouse) { //https://github.com/immersive-web/webxr-samples/blob/master/proposals/phone-ar-hit-test.html
        if (!_session) _session = await XRDeviceManager.getARSession();

        if (!_this.frameOfReference) return;

        if (!_origin) {
            _origin = new Vector3();
            _direction = new Vector3();
            _matrix = new Matrix4();
            _originArray = new Float32Array(3);
            _directionArray = new Float32Array(3);
        }

        _matrix.copy(World.CAMERA.matrixWorld);

        _origin.set(0, 0, 0);
        _origin.applyMatrix4(_matrix);

        _direction.set(0, 0, -1);
        _direction.applyMatrix4(_matrix);
        _direction.sub(_origin).normalize();

        _origin.toArray(_originArray);
        _direction.toArray(_directionArray);

        let output = [];
        let results = await _session.requestHitTest(_originArray, _directionArray, _this.frameOfReference);
        results.forEach(hit => {
            let array = hit.hitMatrix;
            let group = new Group();
            group.matrixWorld.fromArray(array);
            group.matrix.fromArray(array);
            group.matrixWorld.decompose(group.position, group.rotation, group.scale);
            group.hit = hit;
            output.push(group);
        });

        return output;
    }

    this.addAnchor = async function(hit, type = 'normal') {
        if (!_session) _session = await XRDeviceManager.getARSession();
        hit = hit.hit || hit;
        if (!window.AURA) type = undefined;
        else hit.type = type;
        return _session.addAnchor(hit, type);
    }

    this.removeAnchor = async function(hit) {
        hit = hit.hit || hit;
        if (!_session) _session = await XRDeviceManager.getARSession();
        _session.removeAnchor(hit, hit.type);
    }

    this.getCameraTexture = async function() {
        if (!_session) _session = await XRDeviceManager.getARSession();
        if (!_cameraTexture) {
            _cameraTexture = new Texture();
            await RenderManager.renderer.getCameraTexture(_cameraTexture);
            _cameraTexture.needsUpdate = false;
        }

        return _cameraTexture;
    }

    this.getCameraQuad = async function(shader) {
        let texture = await _this.getCameraTexture();

        if (!shader) {
            shader = _this.initClass(Shader, 'ARCameraQuad', {
                tMap: {value: texture},
                depthWrite: false,
                depthTest: false
            });
        } else {
            shader.set('tMap', texture);
        }

        let mesh = new Mesh(World.QUAD, shader);
        mesh.renderOrder = -999;
        return mesh;
    }

    this.applyEnvLighting = async function(shader) {
        if (_env) {
            await _env.ready();
            // shader.set('tEnvSpecular', _env.specular.texture);
            shader.set('tEnvDiffuse', _env.diffuse.texture);
        }

        _envShaders.push(shader);
    }

    this.setFramebuffer = function(baseLayer, view) {
        if (!_this.framebuffer) {
            let viewport = baseLayer.getViewport(view);
            _framebuffer = new RenderTarget(viewport.width, viewport.height);
            _framebuffer._gl = baseLayer.framebuffer;
        }
    }

    this.getFramebuffer = function() {
        return _framebuffer;
    }

}, 'static');
Class(function VRInput() {
    Inherit(this, Component);
    const _this = this;
    var _controllers = [];
    var _handColors = {};
    var _hands = {};
    var _fakeHands = {};
    var _sources;
    var _session;
    var _frame;
    var _reference;
    var _pose;
    var _controller;
    var _matrix, _matrix2, _identity;

    this.SELECT_START = 'select_start';
    this.SELECT_END = 'select_end';
    this.NATIVE = 'native';
    this.BUTTON = 'vr_button';
    this.JOYSTICK = 'vr_joystick';
    this.CHANGE = 'vr_input_change';

    //*** Constructor
    (function () {
        addHandlers();
        _this.enabled = true;
    })();

    function onXRFrame( t, frame ) {
        _frame = frame;
        _session = _frame.session;
        _pose = _frame.getViewerPose( _reference );
        updateControllers();
    }

    function updateControllers() {
        _sources = _session.inputSources;
        let index = 0;
        for ( let source of _sources ) {
            if (source.hand) {
                if (!_hands[source.handedness]) _hands[source.handedness] = _this.initClass(window.AURA ? VRInputHandAura : VRInputHand, source.handedness);
                if(_handColors[source.handedness]) _hands[source.handedness].setColor(_handColors[source.handedness]);

                _hands[source.handedness].update(_frame, source.hand, _reference);

                if (!_this.flag('handsActive')) {
                    _this.flag('handsActive', true);
                    _controllers.forEach(c => c.group.visible = false);
                    for (let key in _fakeHands) _fakeHands[key].group.visible = false;
                    for (let key in _hands) _hands[key].group.visible = true;
                    _this.isSetupFakeHands = false;
                }
            } else {
                let pose = _frame.getPose(source.targetRaySpace, _reference);
                if (!pose) continue;

                _matrix.fromArray(pose.transform.matrix);
                if (_matrix.equals(_identity)) continue;

                let handedness = source.handedness;

                if (!_controllers[index]) _controllers[index] = _this.initClass(VRInputController, handedness, _controller);
                _controllers[index].inputSource = source;

                if (source.gamepad) _controllers[index].processGamepad(source.gamepad);

                let controller = _controllers[index];
                if (pose && pose.transform) {
                    controller.grip = pose.transform.matrix;
                }
                // if ( pose && pose.targetMatrix ) controller.target = pose.targetMatrix;

                if (_this.useControllerHands) {
                    if (!_fakeHands[handedness]) _fakeHands[handedness] = _this.initClass(VRInputControllerHand, handedness, _controllers[index]);

                    if(_handColors[source.handedness]) _fakeHands[handedness].setColor(_handColors[source.handedness]);

                    _fakeHands[handedness].handedness = handedness;
                    _fakeHands[handedness].update(pose.transform.matrix);
                    _controllers.forEach(c => c.group.visible = false);
                }

                if (_this.isSetupHands && _this.flag('handsActive')) {
                    _this.flag('handsActive', false);
                    if (_this.useControllerHands) for (let key in _fakeHands) _fakeHands[key].group.visible = true;
                    else _controllers.forEach(c => c.group.visible = true);
                    for (let key in _hands) _hands[key].group.visible = false;
                    _this.isSetupHands = false;
                }
                index++;
            }
        }

        if (!_this.isSetup && _controllers[0]) _this.isSetup = true;
        if (!_this.isSetupHands && _hands.left && _this.flag('handsActive')) {
            _this.isSetupHands = true;
            Promise.all([_hands.left.ready(), _hands.right.ready()]).then(_ => {
                Interaction3D.useInput([..._hands.left.tips, ..._hands.right.tips]);
            });
            _this.events.fire(_this.CHANGE, {type: 'hands'});
        }
        if (!_this.isSetupFakeHands && _fakeHands.left && !_this.flag('handsActive')) {
            _this.isSetupFakeHands = true;
            Promise.all([_fakeHands.left.ready(), _fakeHands.right.ready()]).then(_ => {
                Interaction3D.useInput([..._fakeHands.left.tips, ..._fakeHands.right.tips]);
            });
            _this.events.fire(_this.CHANGE, {type: 'controllers'});
        }
    }

    //*** Event handlers

    function addHandlers() {
        _this.events.sub( XRDeviceManager.SESSION_START, setup );
    }

    async function setup() {
        if (RenderManager.type != RenderManager.WEBVR) return;
        var session = await XRDeviceManager.getVRSession();
        if (!session) return; // indicates disable3D. Will try again later in response to next SESSION_START event.
        _matrix = new Matrix4();
        _matrix2 = new Matrix4();
        _identity = new Matrix4();
        _reference = await RenderManager.camera.getFrameOfReference();
        session.addEventListener( 'selectstart', onSelectStart );
        session.addEventListener( 'selectend', onSelectEnd );
        session.addEventListener( 'native', nativeEvent );
        await _this.wait( 100 );
        RenderManager.renderer.onFrame = onXRFrame;
        await _this.wait(_this, 'isSetup');
        _this.events.fire(XRDeviceManager.CONTROLS_START);
    }

    function nativeEvent( e ) {
        if ( !_this.enabled ) return;
        for ( let controller of _controllers ) {
            if (controller.inputSource == e.inputSource) {
                e.controller = controller;
                controller.events.fire(_this.NATIVE, e);
            }
        }
    }

    function onSelectStart( e ) {
        if ( !_this.enabled ) return;
        for ( let controller of _controllers ) {
            if (controller.inputSource == e.inputSource) {
                e.controller = controller;
                controller.events.fire(_this.SELECT_START, e);
            }
        }
    }

    function onSelectEnd( e ) {
        if ( !_this.enabled ) return;
        for ( let controller of _controllers ) {
            if (controller.inputSource == e.inputSource) {
                e.controller = controller;
                controller.events.fire(_this.SELECT_END, e);
            }
        }
    }

    //*** Public methods

    this.get( 'controllers', _ => _controllers );

    this.setControllerConfig = function ( config ) {
        _controller = config;
        for ( let controller of _controllers )
            controller.applyControllerConfig( config );
    }

    this.ready = function() {
        return _this.wait('isSetup');
    }

    this.getHandType = function() {
        return _this.isSetupHands ? 'real' : 'fake';
    }

    this.handsReady = function() {
        return Promise.race([_this.wait('isSetupHands'), _this.wait('isSetupFakeHands')]);
    }

    this.getHand = function(type) {
        return _this.isSetupHands ? _hands[type] : _fakeHands[type];
    }

    this.setHandColor = function(handedness, color) {
        _handColors[handedness] = color;
        _this.isSetupHands ? _hands[handedness].setColor(color) : _fakeHands[handedness].setColor(color);
    }

    this.setBeamColor = async function(color) {
        await _this.ready();
        for ( let controller of _controllers ) controller.setBeamColor( color );
    }

    this.setControllerObject = function(Class) {
        _this.setControllerConfig({body: Class});
    }

}, 'static' );

Class(function VRInputController(_type, _config) {
    Inherit(this, Object3D);
    const _this = this;

    var _grip = new Matrix4();
    var _target = new Matrix4();
    var _body, _beam, _point;
    var _q = new Quaternion();
    var _v3 = new Vector3();

    var _haptics = {};
    var _buttons = {};
    var _joystick = {x: 0, y: 0};

    var _hitPositionRequested;
    var _beamRequested;

    this.isVrController = true;
    this.pointer = new Vector3();

    const PHYSICAL_SYNC = !!window.PhysicalSync;

    //*** Constructor
    (function () {
        initConfig();
        initBody();
        initBeam();
        // initPoint();

        let velocity = new VelocityTracker(_this.group.position);
        velocity.start();
        _this.velocity = velocity.value;

        Interaction3D.useInput( _this );
        RenderManager.camera.wrapper.add( _this.group );

        _this.startRender( loop );
        _this.startRender(beforeRender, RenderManager.BEFORE_RENDER);
    })();

    function initConfig() {
        if ( !_config ) _config = {};
        if ( !_config.body ) _config.body = VRInputControllerBody;
        if ( !_config.beam ) _config.beam = VRInputControllerBeam;
        if ( !_config.point ) _config.point = VRInputControllerPoint;
    }

    function initBody() {
        _body = _this.initClass( _config.body, {controller: _this, type: _type} );
    }

    function initBeam() {
        _beam = _this.initClass( _config.beam );
        _beam.group.visible = false;
    }

    function initPoint() {
        _point = _this.initClass( _config.point );
        World.SCENE.add( _point.group );
    }

    function loop() {
        _grip.decompose( _this.group.position, _this.group.quaternion, _this.group.scale );
        _this.group.updateMatrixWorld(true);
        _this.group.getWorldPosition(_this.group.worldPos);
        _this.group.getWorldQuaternion(_this.group.worldQuat);
        _this.pointer.set(0, 0, -1).applyQuaternion(_this.group.worldQuat);
        if (PHYSICAL_SYNC) PhysicalSync.realignObject(_this.group);
    }

    function beforeRender() {
        if (_config.enableHitHaptics && _hitPositionRequested && !_point.group.visible) {
            _this.triggerHaptics(0.4, 30);
        }
        if (_beam) _beam.group.visible = _beamRequested;
        if (_point) _point.group.visible = _hitPositionRequested;
        _beamRequested = false;
        _hitPositionRequested = false;
    }

    function getButtonLabel(i) {
        let label;
        switch (i) {
            case 0: label = 'trigger'; break;
            case 1: label = 'side_trigger'; break;
            case 2: label = 'touch_pad'; break;
            case 3: label = 'joy_click'; break;
            case 4: label = 'a'; break;
            case 5: label = 'b'; break;
        }
        return label;
    }

    //*** Event handlers

    //*** Public methods

    this.get( 'target', _ => { return _target });
    this.set( 'target', m => _target.fromArray( m ));

    this.get( 'grip', _ => { return _grip });
    this.set( 'grip', m => _grip.fromArray( m ));

    this.get( 'color', _ => { return _beam.color });
    this.set( 'color', c => { _beam.color = c });

    this.get( 'body', _ => _body.mesh);

    this.get( 'handedness' , _ => _this.inputSource.handedness);

    this.setHitPosition = function ( hit ) {
        if ( !_point || !_point.group ) return;
        if ( hit && hit.point ) {
            _point.group.position.copy( hit.point );
            // plaster the point plane onto the hit face
            _v3.copy(hit.face.normal);
            hit.object.getWorldQuaternion(_q);
            _v3.applyQuaternion(_q);
            _v3.add(hit.point);
            _point.group.lookAt(_v3);
            _hitPositionRequested = true;
        }
    }

    this.applyControllerConfig = function ( config ) {
        _config = config;
        // if ( _beam ) {
        //     _this.group.remove( _beam );
        //     _beam.destroy();
        //     _beam = null;
        // }

        if ( _body ) {
            _this.group.remove( _body.group );
            _body.destroy();
            _body = null;
        }

        // if ( _point ) {
        //     World.SCENE.remove( _point );
        //     _point.destroy();
        //     _point = null;
        // }

        // initBeam();
        initBody();
        // initPoint();
    }

    this.processGamepad = function(gamepad) {
        gamepad.buttons.forEach((b, i) => {
            if (b.pressed) {
                if (!_buttons[i]) {
                    _buttons[i] = true;
                    _this.events.fire(VRInput.BUTTON, {pressed: true, label: getButtonLabel(i), controller: _this});
                }
            } else {
                if (_buttons[i]) {
                    _buttons[i] = false;
                    _this.events.fire(VRInput.BUTTON, {pressed: false, label: getButtonLabel(i), controller: _this});
                }
            }
        });

        let joyX = gamepad.axes[2];
        let joyY = gamepad.axes[3];
        if (joyX != _joystick.x || joyY != _joystick.y) {
            _joystick.x = joyX;
            _joystick.y = joyY;
            _joystick.controller = _this;
            _this.events.fire(VRInput.JOYSTICK, _joystick);
        }

        if (_haptics.needsUpdate == true && gamepad.hapticActuators && gamepad.hapticActuators.length) {
            _haptics.needsUpdate = false;
            gamepad.hapticActuators[0].pulse(_haptics.strength, _haptics.time);
        }
    }

    this.onDestroy = function () {
        RenderManager.camera.wrapper.remove( _this.group );
        World.SCENE.remove( _point.group );
    }

    this.setBeamColor = function(color) {
        if (!_beam) return;
        _beam.color = color;
    }

    this.showBeam = function() {
        if (!_beam) return;
        _beamRequested = true;
    }

    this.hideBeam = function() {
    }

    this.triggerHaptics = function(strength, time) {
        if (typeof strength !== 'number' || typeof time !== 'number') throw 'triggerHaptics requires (strength, time)';
        _haptics.strength = strength;
        _haptics.time = time;
        _haptics.needsUpdate = true;
    }

});

Class(function VRInputControllerBeam() {
    Inherit(this, Object3D);
    const _this = this;
    const _radius = 0.005;
    const _depth = 2;
    var _geom, _shader, _mesh;
    var _color;

    //*** Constructor
    (function () {
        initGeom();
        initShader();
        initMesh();
        position();
    })();

    function initGeom() {
        _geom = new CylinderGeometry( _radius, 0, _depth );
    }

    function initShader() {
        _color = VRInputControllerBeam.getColor();
        _shader = _this.initClass( Shader, 'VRInputControllerBeam', {
            uColor: {value: new Color( _color )},
            transparent: true,
        });
    }

    function initMesh() {
        _mesh = new Mesh( _geom, _shader );
        _mesh.renderOrder = 9999;
    }

    function position() {
        _this.group.rotation.x = Math.PI * 0.5;
        _this.group.position.z = -_depth * 0.5;
        _this.group.add( _mesh );
    }

    //*** Event handlers

    //*** Public methods

    this.set( 'color', function ( color ) {
        VRInputControllerBeam.setColor( color );
        _shader.set( 'uColor', new Color( color ));
        _color = color;
    });

    this.get( 'color', function () {
        return _color;
    });

}, _ => {
    var _color = '#ffffff';

    VRInputControllerBeam.setColor = function ( color ) {
        _color = color;
        return _color;
    }

    VRInputControllerBeam.getColor = function () {
        return _color;
    }
});
Class(function VRInputControllerBody() {
    Inherit(this, Object3D);
    const _this = this;

    //*** Constructor
    (async function () {
        let geom = await GeomThread.loadGeometry(Assets.getPath('~assets/geometry/hand_indexed.bin'));
        let shader = _this.initClass(Shader, 'VRInputControllerDefault', {
            uAlpha: {value: 0.5},
            transparent: true,
            depthWrite: false,
            side: Shader.DOUBLE_SIDE
        });
        let mesh = new Mesh( geom, shader);
        _this.group.add( mesh );
        _this.mesh = mesh;

        mesh.renderOrder = 9999;
    })();

    //*** Event handlers

    //*** Public methods

});
Class(function VRInputControllerPoint() {
    Inherit(this, Object3D);
    const _this = this;
    const _scale = 0.02;
    var _geom, _shader, _mesh;
    var _color;
    var _borderColor;

    //*** Constructor
    (function () {
        initGeom();
        initShader();
        initMesh();
    })();

    function initGeom() {
        _color = VRInputControllerPoint.getColor();
        _borderColor = VRInputControllerPoint.getBorderColor();
        _geom = World.PLANE;
    }

    function initShader() {
        _shader = _this.initClass( Shader, 'VRInputControllerPoint', {
            uColor: {value: new Color( _color )},
            uBorderColor: {value: new Color( _borderColor )},
            uAlpha: {value: 1},
            depthTest: false,
            transparent: true,
        });
    }

    function initMesh() {
        _mesh = new Mesh( _geom, _shader );
        _mesh.scale.setScalar(_scale);
        _mesh.renderOrder = 10000;
        _this.group.visible = false;
        _this.group.add( _mesh );
    }

    //*** Event handlers

    //*** Public methods

    this.set( 'color', function ( color ) {
        VRInputControllerPoint.setColor( color );
        _shader.set( 'uColor', new Color( color ));
        _color = color;
    });

    this.get( 'color', function () {
        return _color;
    });

    this.set( 'borderColor', function ( color ) {
        VRInputControllerPoint.setBorderColor( color );
        _shader.set( 'uBorderColor', new Color( color ));
        _borderColor = color;
    });

    this.get( 'borderColor', function () {
        return _borderColor;
    });

}, _ => {
    var _color = '#ffffff';
    var _borderColor = '#000000';

    VRInputControllerPoint.setColor = function ( color ) {
        _color = color;
        return _color;
    }

    VRInputControllerPoint.getColor = function () {
        return _color;
    }

    VRInputControllerPoint.setBorderColor = function ( color ) {
        _borderColor = color;
        return _borderColor;
    }

    VRInputControllerPoint.getBorderColor = function () {
        return _borderColor;
    }
});

Class(function VRAbstractHand() {
    Inherit(this, Object3D);
    const _this = this;

    this.pointer = new Vector3();
    this.isAbstractHand = true;

    var _targetColor = new Color();

    const PINCH_DISTANCE = 0.02;
    const PINCH_THRESHOLD = 0.005;
    const PHYSICAL_SYNC = !!window.PhysicalSync;

    //*** Constructor
    (function() {
        createBody();
        initShader();
        _this.startRender(loop);
    })();

    function initShader() {
        _this.shader = VRAbstractHand.shader ? VRAbstractHand.shader.clone() : _this.initClass(Shader, 'VRHand', {
            transparent: true,
            uColor: {value: new Color('#ffffff')},
            uStatic: {value: 0}
        });

        _this.shader.uniforms.uColor = {value: new Color()};
    }

    function createBody() {
        _this.body = Utils3D.createDebug(0.07);
        _this.body.shader.neverRender = true;

        let velocity = new VelocityTracker(_this.body.position);
        velocity.start();
        _this.velocity = velocity.value;
    }

    function loop() {
        if (PHYSICAL_SYNC) PhysicalSync.realignObject(_this.group);
        if (_this.thumb) {
            for (let i = _this.tips.length-1; i > -1; i--) _this.tips[i].update();
            _this.pointer.set(0, 0, -1).applyQuaternion(_this.index.quaternion);

            let distance = _this.thumb.position.distanceTo(_this.index.position);
            if (_this.flag('pinching') && distance > PINCH_DISTANCE + PINCH_THRESHOLD) {
                _this.flag('pinching', false);
                _this.events.fire(VRInputHand.PINCH, { action: 'end', hand: _this });
            } else if (!_this.flag('pinching') && distance <= PINCH_DISTANCE - PINCH_THRESHOLD) {
                _this.flag('pinching', true);
                _this.events.fire(VRInputHand.PINCH, { action: 'start', hand: _this });
            }
        }

        if (_this.index) _this.pointer.set(0, 0, -1).applyQuaternion(_this.index.quaternion);
    }

    //*** Event handlers

    //*** Public methods
    _this.setColor = function(colorHex) {
        _targetColor.set(colorHex);
        _this.shader.uniforms.uColor.value.lerp(_targetColor, 0.07);
    }

    _this.setShader = function(shader) {
        _this.shader = shader;
    }

}, _ => {
    VRAbstractHand.useShader = function(shader) {
        VRAbstractHand.shader = shader;
    }
});
Class(function VRHandFingerTip(_bone, _prev) {
    const _this = this;

    this.position = new Vector3();
    this.quaternion = new Quaternion();

    var _null = new Group();
    var _v3 = new Vector3();

    var _velocity = new VelocityTracker(this.position);

    this.velocity = _velocity.value;

    const AURA = !!window.AURA;

    //*** Event handlers

    //*** Public methods
    this.update = function() {
        _bone.getWorldPosition(_this.position);
        _prev.getWorldPosition(_null.position);
        if (!AURA) {
            _this.position.divideScalar(100);
            _null.position.divideScalar(100);
        }

        _null.isCamera = true;
        _null.lookAt(_this.position);
        _this.quaternion.copy(_null.quaternion);

        if (AURA) {
            _this.position.add(_v3.set(0, 0, -1).applyQuaternion(_null.quaternion).multiplyScalar(0.025));
        }

        _this.position.applyMatrix4(RenderManager.camera.wrapper.matrixWorld);

        _velocity.update();
    }

    this.updateStatic = function(position, quaternion) {
        _this.position.copy(position);
        _this.quaternion.copy(quaternion);
    }
});

Class(function VRInputControllerHand(_type, _controller) {
    Inherit(this, VRAbstractHand);
    const _this = this;
    var _geom, _mesh, _tip;

    var _grip = new Matrix4();

    this.tips = [];

    //*** Constructor
    (async function() {
        _geom = await GeomThread.loadGeometry('vrhands/pointy_hand_' + _type);
        _this.flag('loaded', true);
        _this.shader.uniforms.uStatic.value = 1;
        _mesh = new Mesh(_geom, _this.shader);
        _mesh.scale.multiplyScalar(0.01);
        _this.add(_mesh);
        _mesh.frustumCulled = false;
        _mesh.rotation.set(Math.radians(-90), 0, Math.radians(-90));
        _mesh.position.x = 0.03 * (_type == 'left' ? -1 : 1);

        _tip = Utils3D.createDebug(0.02);
        _tip.position.set(0.014 * (_type == 'left' ? -1 : 1), 0.02, -0.125);
        _tip.shader.neverRender = true;
        _this.add(_tip);

        _this.tips[0] = _this.initClass(VRHandFingerTip, _tip);

        RenderManager.camera.wrapper.add( _this.group );
        _this.group.add(_this.body);
    })();

    //*** Event handlers

    //*** Public methods
    this.update = function(matrix) {
        if (matrix.length != 16) return;
        _grip.fromArray(matrix);
        _grip.decompose(_this.group.position, _this.group.quaternion, _this.group.scale);
        if (_this.tips[0]) _this.tips[0].updateStatic(_tip.getWorldPosition(), _this.group.quaternion);
        if (window.PhysicalSync) PhysicalSync.realignObject(_this.group);
        _this.group.updateMatrixWorld(true);
    }

    this.ready = function() {
        return _this.wait('loaded');
    }

    this.get('index', _ => _this.tips[0]);
});

Class(function VRInputHand(_type) {
    Inherit(this, VRAbstractHand);
    const _this = this;
    var _geom, _mesh, _center;

    this.hand = this.handedness = _type;
    this.tips = [];

    var _bones = [];

    const joints = [
        'wrist',
        'thumb-metacarpal',
        'thumb-phalanx-proximal',
        'thumb-phalanx-distal',
        'thumb-tip',
        'index-finger-metacarpal',
        'index-finger-phalanx-proximal',
        'index-finger-phalanx-intermediate',
        'index-finger-phalanx-distal',
        'index-finger-tip',
        'middle-finger-metacarpal',
        'middle-finger-phalanx-proximal',
        'middle-finger-phalanx-intermediate',
        'middle-finger-phalanx-distal',
        'middle-finger-tip',
        'ring-finger-metacarpal',
        'ring-finger-phalanx-proximal',
        'ring-finger-phalanx-intermediate',
        'ring-finger-phalanx-distal',
        'ring-finger-tip',
        'pinky-finger-metacarpal',
        'pinky-finger-phalanx-proximal',
        'pinky-finger-phalanx-intermediate',
        'pinky-finger-phalanx-distal',
        'pinky-finger-tip',
    ];


    //*** Constructor
    (async function() {
        await initMesh();
        mapBones();
    })();

    async function initMesh() {
        _geom = await GeomThread.loadSkinnedGeometry('vrhands/hand_' + _type);
        _this.flag('loaded', true);
        _mesh = new Skin(_geom, _this.shader, _geom.bones);
        _mesh.root.rotation.x = Math.PI / 2;
        _mesh.scale.setScalar(0.01);
        _this.add(_mesh);
        _mesh.frustumCulled = false;
        RenderManager.camera.wrapper.add( _this.group );
    }

    function mapBones() {
        let bonesMapping = [
            'b_%_wrist', // XRHand.WRIST,

            'b_%_thumb1', // XRHand.THUMB_METACARPAL,
            'b_%_thumb2', // XRHand.THUMB_PHALANX_PROXIMAL,
            'b_%_thumb3', // XRHand.THUMB_PHALANX_DISTAL,
            'b_%_thumb_null', // XRHand.THUMB_PHALANX_TIP,

            'b_%_index0', // XRHand.INDEX_METACARPAL,
            'b_%_index1', // XRHand.INDEX_PHALANX_PROXIMAL,
            'b_%_index2', // XRHand.INDEX_PHALANX_INTERMEDIATE,
            'b_%_index3', // XRHand.INDEX_PHALANX_DISTAL,
            'b_%_index_null', // XRHand.INDEX_PHALANX_TIP,

            'b_%_middle0', // XRHand.MIDDLE_METACARPAL,
            'b_%_middle1', // XRHand.MIDDLE_PHALANX_PROXIMAL,
            'b_%_middle2', // XRHand.MIDDLE_PHALANX_INTERMEDIATE,
            'b_%_middle3', // XRHand.MIDDLE_PHALANX_DISTAL,
            'b_%_middle_null', // XRHand.MIDDLE_PHALANX_TIP,

            'b_%_ring0', // XRHand.RING_METACARPAL,
            'b_%_ring1', // XRHand.RING_PHALANX_PROXIMAL,
            'b_%_ring2', // XRHand.RING_PHALANX_INTERMEDIATE,
            'b_%_ring3', // XRHand.RING_PHALANX_DISTAL,
            'b_%_ring_null', // XRHand.RING_PHALANX_TIP,

            'b_%_pinky0', // XRHand.LITTLE_METACARPAL,
            'b_%_pinky1', // XRHand.LITTLE_PHALANX_PROXIMAL,
            'b_%_pinky2', // XRHand.LITTLE_PHALANX_INTERMEDIATE,
            'b_%_pinky3', // XRHand.LITTLE_PHALANX_DISTAL,
            'b_%_pinky_null', // XRHand.LITTLE_PHALANX_TIP
        ];

        let findBone = name => {
            for (let i = 0; i < _mesh.bones.length; i++) {
                if (_mesh.bones[i].name == name) return _mesh.bones[i];
            }
        };

        bonesMapping.forEach( boneName => {
            if ( boneName ) {
                boneName = boneName.replace( "%", _type === "right" ? "r" : "l" );
                const bone = findBone(boneName);
                if (boneName.includes('null')) {
                    _this.tips.push(_this.initClass(VRHandFingerTip, bone, findBone(boneName.replace('_null', '3'))));
                }

                if (boneName.includes('middle1')) {
                    _center = _this.initClass(VRHandFingerTip, bone, findBone(boneName.replace('_middle1', '_middle0')));
                }

                _bones.push( bone );
            } else {
                _bones.push( null );
            }
        } );

    }

    //*** Event handlers

    //*** Public methods
    this.update = function(frame, hand, ref) {
        if (!_mesh) return;
        for (let i = 0; i < joints.length; i++) {
            let jointSpace = hand.get(joints[i]);
            if (jointSpace) {
                let jointPose = frame.getJointPose(jointSpace, ref);
                if (_bones[i] && jointPose) {
                    _bones[i].position.copy(jointPose.transform.position).multiplyScalar(100);
                    _bones[i].quaternion.copy(jointPose.transform.orientation);
                }
            }
        }

        _center.update();
        _this.body.position.copy(_center.position);
        _this.body.updateMatrixWorld(true);

        _this.group.updateMatrixWorld(true);
    }

    this.useShader = function(shader) {
        _mesh.shader = shader;
    }

    this.ready = function() {
        return _this.wait('loaded');
    }

    this.get('thumb', _ => _this.tips[0]);
    this.get('index', _ => _this.tips[1]);
    this.get('middle', _ => _this.tips[2]);
    this.get('ring', _ => _this.tips[3]);
    this.get('pinky', _ => _this.tips[4]);
}, _ => {
    VRInputHand.PINCH = 'vr_hand_pinch';
});

Class(function VRInputHandAura(_type) {
    Inherit(this, VRAbstractHand);
    const _this = this;
    var _boneMapping, _mesh, _center;

    const _data = {
        rootPose: {position: [], orientation: []}
    };

    var _quaternion = new Quaternion();
    var _vector = new Vector3();

    this.hand = this.handedness = _type;
    this.tips = [];

    //*** Constructor
    (async function() {
        await initMesh();
        initBoneMapping();
        initFingerTips();
        _this.startRender(loop);
    })();

    async function initMesh() {
        _geom = await GeomThread.loadSkinnedGeometry('vrhands/aura_' + _type);
        _this.flag('loaded', true);
        _mesh = new Skin(_geom, _this.shader, _geom.bones);
        _this.add(_mesh);
        _mesh.frustumCulled = false;
        World.SCENE.add(_this.group);
    }

    function initBoneMapping() {
        _boneMapping = [
            {"name": "ovrHandBone_WristRoot", "skinIndex": 0, "skeletonIndex": 0},
            {"name": "ovrHandBone_ForearmStub", "skinIndex": 23, "skeletonIndex": 1},
            {"name": "ovrHandBone_Thumb0", "skinIndex": 1, "skeletonIndex": 2},
            {"name": "ovrHandBone_Thumb1", "skinIndex": 2, "skeletonIndex": 3},
            {"name": "ovrHandBone_Thumb2", "skinIndex": 3, "skeletonIndex": 4},
            {"name": "ovrHandBone_Thumb3", "skinIndex": 4, "skeletonIndex": 5},
            {"name": "ovrHandBone_Index1", "skinIndex": 6, "skeletonIndex": 6},
            {"name": "ovrHandBone_Index2", "skinIndex": 7, "skeletonIndex": 7},
            {"name": "ovrHandBone_Index3", "skinIndex": 8, "skeletonIndex": 8},
            {"name": "ovrHandBone_Middle1", "skinIndex": 10, "skeletonIndex": 9},
            {"name": "ovrHandBone_Middle2", "skinIndex": 11, "skeletonIndex": 10},
            {"name": "ovrHandBone_Middle3", "skinIndex": 12, "skeletonIndex": 11},
            {"name": "ovrHandBone_Ring1", "skinIndex": 14, "skeletonIndex": 12},
            {"name": "ovrHandBone_Ring2", "skinIndex": 15, "skeletonIndex": 13},
            {"name": "ovrHandBone_Ring3", "skinIndex": 16, "skeletonIndex": 14},
            {"name": "ovrHandBone_Pinky0", "skinIndex": 18, "skeletonIndex": 15},
            {"name": "ovrHandBone_Pinky1", "skinIndex": 19, "skeletonIndex": 16},
            {"name": "ovrHandBone_Pinky2", "skinIndex": 20, "skeletonIndex": 17},
            {"name": "ovrHandBone_Pinky3", "skinIndex": 21, "skeletonIndex": 18},
        ]
    }

    function loop() {
        if (typeof _data.hand != 'number') return;

        _boneMapping.forEach(entry => {
            let orientation = _data[entry.name];
            let bone = _mesh.bones[entry.skinIndex];
            _quaternion.fromArray(orientation);
            bone.quaternion.slerp(_quaternion, 0.5);
        });

        let position = _data.rootPose.position;
        let orientation = _data.rootPose.orientation;
        _vector.fromArray(position);
        _quaternion.fromArray(orientation);
        _mesh.bones[0].position.lerp(_vector, 0.5);
        _mesh.bones[0].quaternion.slerp(_quaternion, 1);
    }

    function initFingerTips() {
        const getBone = key => {
            for (let i = 0; i < _boneMapping.length; i++) {
                let entry = _boneMapping[i];
                if (entry.name == key) return _mesh.bones[entry.skinIndex];
            }
        };

        ['ovrHandBone_Thumb3', 'ovrHandBone_Index3', 'ovrHandBone_Middle3', 'ovrHandBone_Ring3', 'ovrHandBone_Pinky3'].forEach(key => {
            _this.tips.push(_this.initClass(VRHandFingerTip, getBone(key), getBone(key.replace('3', '2'))));
        });

        _center = _this.initClass(VRHandFingerTip, getBone('ovrHandBone_Middle1'), getBone('ovrHandBone_Middle3'));
    }

    //*** Event handlers

    //*** Public methods
    this.update = function(frame, data) {
        if (!_mesh) return;

        _data.hand = data.hand;

        _data.rootPose.position[0] = data.rootPose.position[0];
        _data.rootPose.position[1] = data.rootPose.position[1];
        _data.rootPose.position[2] = data.rootPose.position[2];

        _data.rootPose.orientation[0] = data.rootPose.orientation[0];
        _data.rootPose.orientation[1] = data.rootPose.orientation[1];
        _data.rootPose.orientation[2] = data.rootPose.orientation[2];
        _data.rootPose.orientation[3] = data.rootPose.orientation[3];

        _boneMapping.forEach(entry => {
            if (!_data[entry.name]) _data[entry.name] = [];
            _data[entry.name][0] = data[entry.name][0];
            _data[entry.name][1] = data[entry.name][1];
            _data[entry.name][2] = data[entry.name][2];
            _data[entry.name][3] = data[entry.name][3];
        });

        _this.group.visible = data.confidence > 3;

        _center.update();
        _this.body.position.copy(_center.position);
        _this.body.updateMatrixWorld(true);
    }

    this.ready = function() {
        return _this.wait('loaded');
    }

    this.get('thumb', _ => _this.tips[0]);
    this.get('index', _ => _this.tips[1]);
    this.get('middle', _ => _this.tips[2]);
    this.get('ring', _ => _this.tips[3]);
    this.get('pinky', _ => _this.tips[4]);
});
Class(function VRCamera(_gl, _nuke) {
    Inherit(this, Component);
    const _this = this;
    var _session, _frame, _added;
    var _map = new Map();
    var _tempCameras = new Map();

    var _wrapper0 = new Group();
    var _wrapper1 = new Group();

    this.worldCamera = new PerspectiveCamera(30, Stage.width / Stage.height, 0.1, 1000);
    this.offset = _wrapper0.position;
    this.inset = _wrapper1.position;
    this.wrapper = _wrapper0;
    this.absoluteCameraPos = new Vector3();

    //*** Constructor
    (function () {
        _wrapper0.add(_wrapper1);
    })();

    function applyDepthClipPlanes() {
        let { near: depthNear, far: depthFar } = _this.worldCamera;
        if (!(
            Math.abs(_session.renderState.depthNear - depthNear) < 0.001 &&
            Math.abs(_session.renderState.depthFar - depthFar) < 1
        )) {
            _session.updateRenderState({ depthNear, depthFar });
        }
    }

    function applyCamera(camera) {
        _this.worldCamera.projectionMatrix.copy(camera.projectionMatrix);
        applyDepthClipPlanes();
        _this.worldCamera.position.copy(camera.position);
        _this.worldCamera.quaternion.copy(camera.quaternion);
        _this.worldCamera.matrixWorld.copy(camera.matrixWorld);
        _this.worldCamera.matrix.copy(camera.matrix);
    }

    //*** Event handlers

    //*** Public methods
    this.getFrameOfReference = async function() {
        if (_frame) return _frame;
        _session = await XRDeviceManager.getVRSession();
        try {
            _frame = await _session.requestReferenceSpace('bounded-floor');
        } catch(e) {
            _frame = await _session.requestReferenceSpace('local-floor');
        }
        return _frame;
    }

    this.newFrame = function() {
        _map.clear();
    }

    this.getRenderCamera = function(view, pose) {
        if (!pose) return;
        if (_map.has(view.eye)) {
            applyCamera(_map.get(view.eye));
            return _this.worldCamera;
        }

        if (!_tempCameras.has(view.eye)) {
            _tempCameras.set(view.eye, new PerspectiveCamera(30, Stage.width / Stage.height, 0.1, 1000));
        }

        let camera = _tempCameras.get(view.eye);

        if (!_added) {
            World.SCENE.add(_wrapper0);
            _added = true;
        }

        _this.absoluteCameraPos.copy(view.transform.position);
        _wrapper1.position.copy(view.transform.position);
        _wrapper1.quaternion.copy(view.transform.orientation);
        _wrapper0.updateMatrixWorld(true);

        camera.projectionMatrix.fromArray(view.projectionMatrix);
        Utils3D.decompose(_wrapper1, camera);
        camera.updateMatrixWorld(true);

        _map.set(view.eye, camera);
        applyCamera(camera);

        return _this.worldCamera;
    }

    this.forceUpdate = function() {
        _wrapper0.updateMatrixWorld(true);
        Utils3D.decompose(_wrapper1, _this.worldCamera);
        _this.worldCamera.updateMatrixWorld(true);
    }

    this.reset = function() {
        _frame = null;
    }
});

Class(function VRRenderer(_renderer, _nuke) {
    Inherit(this, Component);
    const _this = this;
    var _session, _gl, _callback, _frame, _scaleFactor, _nativeScaleFactor, _currentUnparsedScaleFactor;
    var _frameOfRef, _vrCamera, _copyToScreen, _frameBound, _supportsRequestViewportScale;
    var _firedEyeRender;

    var _frustums = [];
    var _renderEvt = {};
    var _cameras = {};
    var _nukes = {};
    var _baseLayers;
    var _viewCameras = new WeakMap();
    var _viewNukes = new WeakMap();

    const USE_UBO = Renderer.UBO;

    this.autoClear = true;

    //*** Constructor
    (function() {
        setup();
        initCopyToScreen();
    })();

    function parseScaleFactor(value) {
        if (typeof value === 'number') return value;
        if (value === 'native') return _nativeScaleFactor;
        return 1;
    }

    function parseFixedFoveation(foveationLevel) {
        return Math.range(foveationLevel || 0, XRDeviceManager.FOVEATION_LEVEL_NONE, XRDeviceManager.FOVEATION_LEVEL_HIGH_TOP, 0, 1, true);
    }

    async function setup() {
        _session = await XRDeviceManager.getVRSession();
        if (!_session) return; // indicates disable3D. reset() can be used to setup later.
        _nativeScaleFactor = XRWebGLLayer.getNativeFramebufferScaleFactor(_session);
        _currentUnparsedScaleFactor = XRDeviceManager.scaleFactor;
        _scaleFactor = parseScaleFactor(_currentUnparsedScaleFactor);
        initBaseLayers();
        _session.updateRenderState({baseLayer: _session.baseLayer});
        Render.useRAF(rAFOverride);

        _vrCamera = RenderManager.camera;
        _frameOfRef = await _vrCamera.getFrameOfReference();

        _session.requestAnimationFrame(rAF);

        _renderer.vrRenderingPath = render;
        _gl = _renderer.context;

        _this.events.fire(XRDeviceManager.SESSION_START);
    }

    function initBaseLayers() {
        let scaleFactors = [
            _scaleFactor,
            ...XRDeviceManager.preallocatedScaleFactors.map(parseScaleFactor),
        ];
        let baseLayers = {};
        scaleFactors.forEach(scaleFactor => {
            if (baseLayers[scaleFactor]) return;
            baseLayers[scaleFactor] = new XRWebGLLayer(_session, _renderer.context, {
                stencil: _renderer.stencil,
                framebufferScaleFactor: scaleFactor
            });
        });
        _session.baseLayer = baseLayers[_scaleFactor];
        if (XRDeviceManager.preallocatedScaleFactors.length) {
            _baseLayers = baseLayers;
        }
    }

    function initCopyToScreen() {
        let shader = new Shader('ScreenQuad', {
            tMap: {value: null}
        });

        _copyToScreen = new Mesh(World.QUAD, shader);
    }

    function getCamera(eye, camera) {
        if (!_cameras[eye]) _cameras[eye] = camera.clone();
        return _cameras[eye];
    }

    function getNuke(eye) {
        if (!_nukes[eye]) {
            _nukes[eye] = new Nuke(_nuke.stage, { renderer: _nuke.renderer, camera: _nuke.camera, scene: _nuke.scene, dpr: _nuke.dpr });
            cloneDrawBuffers(_nukes[eye], _nuke);
        }
        return _nukes[eye];
    }

    function initCameraUBO(camera) {
        camera._ubo = new UBO(0, _gl);
        camera._ubo.push({value: camera.projectionMatrix});
        camera._ubo.push({value: camera.matrixWorldInverse});
        camera._ubo.push({value: camera.worldPos});
        camera._ubo.push({value: camera.worldQuat});
        camera._ubo.push({value: _renderer.resolution});
        camera._ubo.push(_renderer.time);
        camera._ubo.push(Render.timeScaleUniform);
        camera._ubo.upload();
    }

    function rAF(t, frame) {
        _vrCamera.newFrame();
        _frame = frame;
        _frameBound = false;
        _firedEyeRender = false;
        if (_callback) _callback(t);
        if (_this.onFrame) _this.onFrame(t, frame);
        _session.requestAnimationFrame(rAF);
    }

    function render(scene, camera, projScreenMatrix, frustum, attachSceneUniforms, rt) {
        if (!_frame) return;
        let doNuke = _nuke.enabled && _nuke.passes.length && !rt;

        camera.getWorldPosition(camera.worldPos);
        camera.getWorldQuaternion(camera.worldQuat);

        if (USE_UBO) {
            if (!camera._ubo) initCameraUBO(camera);
            else camera._ubo.update();
        }

        let pose;
        try {
            pose = _frame.getViewerPose(_frameOfRef);
            if (!pose) return;
        } catch(e) { return }

        if (rt) {
            let width = _session.baseLayer.framebufferWidth;
            let height = _session.baseLayer.framebufferHeight;
            if (rt.width != width || rt.height != height) rt.setSize(width, height);
            if (!rt._gl) rt.upload();
        }

        if (_supportsRequestViewportScale === undefined) _supportsRequestViewportScale = (typeof pose.views[0].requestViewportScale === 'function');
        if (XRDeviceManager.scaleFactor !== _currentUnparsedScaleFactor) {
            _currentUnparsedScaleFactor = XRDeviceManager.scaleFactor;
            _scaleFactor = parseScaleFactor(_currentUnparsedScaleFactor);
            if (_supportsRequestViewportScale) {
                for (let i = 0; i < pose.views.length; i++) {
                    let view = pose.views[i];
                    view.requestViewportScale(_scaleFactor);
                }
            } else {
                let newBaseLayer;
                if (!_baseLayers) {
                    newBaseLayer = new XRWebGLLayer(_session, _renderer.context, {stencil: _renderer.stencil, framebufferScaleFactor: _scaleFactor});
                } else {
                    newBaseLayer = _baseLayers[_scaleFactor];
                    if (!newBaseLayer) {
                        console.warn('Ignoring scaleFactor not specified in XRDeviceManager.preallocatedScaleFactors')
                    }
                }
                if (newBaseLayer) {
                    _session.updateRenderState({baseLayer: newBaseLayer});
                    _session.baseLayer = newBaseLayer;
                }
            }
        }

        let fixedFoveation = parseFixedFoveation(XRDeviceManager.foveationLevel);
        if (fixedFoveation !== _session.baseLayer.fixedFoveation) {
            _session.baseLayer.fixedFoveation = fixedFoveation;
        }

        let fireEyeRender = !_firedEyeRender;
        _firedEyeRender = true;
        for (let i = 0; i < pose.views.length; i++) {
            let view = pose.views[i];
            let renderCamera = _vrCamera.getRenderCamera(view, pose);
            if (!renderCamera) continue;

            let viewCamera = getCamera(view.eye, renderCamera);
            _viewCameras.set(view, viewCamera);
            viewCamera.projectionMatrix.copy(renderCamera.projectionMatrix);
            viewCamera.matrix.copy(renderCamera.matrix);
            viewCamera.matrixWorld.copy(renderCamera.matrixWorld);
            viewCamera.matrixWorldInverse.getInverse(viewCamera.matrixWorld);
            viewCamera.worldPos.copy(renderCamera.worldPos);
            viewCamera.worldQuat.copy(renderCamera.worldQuat);
            viewCamera.position.copy(renderCamera.position);
            viewCamera.quaternion.copy(renderCamera.quaternion);

            let viewport = _session.baseLayer.getViewport(view);

            _renderer.resolution.set(viewport.width*2, viewport.height);
            if (USE_UBO) {
                if (!viewCamera._ubo) initCameraUBO(viewCamera);
                else viewCamera._ubo.update();
            }

            if (fireEyeRender) {
                _renderEvt.stage = viewport;
                _renderEvt.camera = viewCamera;
                _renderEvt.view = i;
                _renderEvt.eye = view.eye;
                RenderManager.fire(RenderManager.EYE_RENDER, _renderEvt);
            }

            if (doNuke) {
                let nuke = getNuke(view.eye);
                _viewNukes.set(view, nuke);

                nuke.setSize(viewport.width, viewport.height);
                nuke.needsClear = true;
            }

            if (!_frustums[i]) _frustums[i] = new Frustum();
            _frustums[i].setFromCamera(viewCamera);
        }

        let forceClear = false;
        if (!doNuke && !_frameBound) {
            _frameBound = !rt;
            _gl.bindFramebuffer(_session.oculusFramebuffer ? _gl.DRAW_FRAMEBUFFER : _gl.FRAMEBUFFER, rt ? rt._gl : _session.baseLayer.framebuffer);
            if (XRDeviceManager.autoClearFrameBuffer) forceClear = true;
        }

        _gl.clearColor(Renderer.CLEAR[0], Renderer.CLEAR[1], Renderer.CLEAR[2], XRDeviceManager.mixedReality ? 0 : Renderer.CLEAR[3]);
        if (forceClear || rt || (_renderer.autoClear && _this.autoClear)) _gl.clear(_gl.COLOR_BUFFER_BIT | _gl.DEPTH_BUFFER_BIT);

        for (let l = 0; l < 2; l++) {
            for (let i = 0; i < scene.toRender[l].length; i++) {
                let object = scene.toRender[l][i];
                object.onBeforeRender && object.onBeforeRender();
                object._drawing = false;

                if (!object.determineVisible() || !object.shader.visible || object.shader.neverRender) continue;

                let inFrustum = false;
                for (let f = 0; f < pose.views.length; f++) {
                    if (!inFrustum) inFrustum = _frustums[f].intersectsObject(object);
                }

                if (!object.frustumCulled || inFrustum) {
                    object._drawing = true;
                    object.shader.draw(object, object.geometry);

                    for (let view of pose.views) {
                        let viewCamera = _viewCameras.get(view);
                        let viewport = _session.baseLayer.getViewport(view);
                        _renderer.resolution.set(viewport.width*2, viewport.height);
                        if (USE_UBO) {
                            if (!viewCamera._ubo) initCameraUBO(viewCamera);
                            else viewCamera._ubo.update();
                        }

                        object.modelViewMatrix.multiplyMatrices(viewCamera.matrixWorldInverse, object.matrixWorld);
                        object.normalMatrix.getNormalMatrix(object.modelViewMatrix);

                        if (!doNuke) {
                            _gl.viewport(viewport.x, viewport.y, viewport.width, viewport.height);
                        } else {
                            let nuke = _viewNukes.get(view);
                            if (!nuke.rttBuffer._gl) RenderTarget.renderer.upload(nuke.rttBuffer);
                            _gl.bindFramebuffer(_gl.FRAMEBUFFER, nuke.rttBuffer._gl);

                            if (nuke.needsClear) {
                                nuke.needsClear = false;
                                _gl.viewport(0, 0, nuke.rttBuffer.width, nuke.rttBuffer.height);
                                _gl.clearColor(Renderer.CLEAR[0], Renderer.CLEAR[1], Renderer.CLEAR[2], Renderer.CLEAR[3]);
                                _gl.clear(_gl.COLOR_BUFFER_BIT | _gl.DEPTH_BUFFER_BIT);
                            }
                        }

                        attachSceneUniforms(object, scene, viewCamera);

                        object.geometry.draw(object, object.shader);
                        if (USE_UBO) viewCamera._ubo.unbind();

                        if (doNuke) _gl.bindFramebuffer(_gl.FRAMEBUFFER, null);
                    }
                }
            }
        }

        Shader.renderer.resetState();

        if (doNuke) {
            for (let view of pose.views) {
                runPasses(view, camera, scene, attachSceneUniforms);
            }

            _gl.bindFramebuffer(_gl.FRAMEBUFFER, _session.baseLayer.framebuffer);
            for (let view of pose.views) {
                let viewport = _session.baseLayer.getViewport(view);
                _gl.viewport(viewport.x, viewport.y, viewport.width, viewport.height);

                let mesh = _copyToScreen;
                let nuke = _viewNukes.get(view);
                mesh.shader.uniforms.tMap.value = nuke.outputTexture;

                drawQuad(mesh, camera, scene, attachSceneUniforms); //todo: change this to a blit
            }
        }

        Shader.renderer.resetState();
    }

    function runPasses(view, camera, scene, attachSceneUniforms) {
        let nuke = _viewNukes.get(view);
        if (!nuke.ping._gl) RenderTarget.renderer.upload(nuke.ping);
        if (!nuke.pong._gl) RenderTarget.renderer.upload(nuke.pong);

        if (nuke.rttBuffer.attachments) {
            for (let i = 1; i < nuke.rttBuffer.attachments.length; i++) {
                let texture = nuke.rttBuffer.attachments[i];
                texture.fxLayer.rt.overrideTexture = texture;
            }
        }

        _renderEvt.stage = nuke.rttBuffer;
        _renderEvt.camera = _viewCameras.get(view);
        _this.events.fire(RenderManager.RENDER, _renderEvt);

        let originalShader = _copyToScreen.shader;
        let pingPong = true;
        for (let i = 0; i < _nuke.passes.length; i++) {
            pingPong = !pingPong;

            _copyToScreen.shader = _nuke.passes[i].pass;
            _copyToScreen.shader.uniforms.tDiffuse.value = i == 0 ? nuke.rttBuffer : (pingPong ? nuke.pong : nuke.ping);

            _gl.bindFramebuffer(_gl.FRAMEBUFFER, pingPong ? nuke.ping._gl : nuke.pong._gl);
            _gl.viewport(0, 0, nuke.rttBuffer.width, nuke.rttBuffer.height);
            _gl.clearColor(Renderer.CLEAR[0], Renderer.CLEAR[1], Renderer.CLEAR[2], Renderer.CLEAR[3]);
            _gl.clear(_gl.COLOR_BUFFER_BIT | _gl.DEPTH_BUFFER_BIT);
            drawQuad(_copyToScreen, camera, scene, attachSceneUniforms);
            _gl.bindFramebuffer(_gl.FRAMEBUFFER, null);
        }

        nuke.outputTexture = pingPong ? nuke.ping.texture : nuke.pong.texture;
        _copyToScreen.shader = originalShader;
    }

    function drawQuad(mesh, camera, scene, attachSceneUniforms) {
        mesh.modelViewMatrix.multiplyMatrices(camera.matrixWorldInverse, mesh.matrixWorld);
        mesh.normalMatrix.getNormalMatrix(mesh.modelViewMatrix);

        mesh.shader.draw(mesh, mesh.geometry);
        attachSceneUniforms(mesh, scene, camera);
        mesh.geometry.draw(mesh, mesh.shader);
        if (USE_UBO) camera._ubo.unbind();
    }

    function cloneDrawBuffers(to, from) {
        if (!from.rttBuffer.attachments) return;
        for (let i = 1; i < from.rttBuffer.attachments.length; i++) {
            let texture = from.rttBuffer.attachments[i];
            let clone = texture.clone();
            clone.fxLayer = texture.fxLayer;
            to.attachDrawBuffer(clone);
        }
    }

    function rAFOverride(callback) {
        _callback = callback;
    }

    //*** Event handlers

    //*** Public methods
    this.render = function(scene, camera) {
        if (!_frame) return;
        _renderer.render(scene, camera);
    }

    this.setSize = function(width, height) {
        _renderer.setSize(width, height);
    }

    this.reset = function() {
        setup();
    }

    this.getBaseLayer = function() {
        return _session.baseLayer;
    }
});

/**
 * Really simple, really fast socket with minimal abstraction.
 * @name SocketConnection
 * @constructor
 * @example
 * let ws = new SocketConnection('ws://localhost:7189', Device.mobile ? 'mobile' : 'screen');
 * setInterval(_ => ws.send('message', {arbitraryData: Math.random()}), 1000);
 * _this.events.sub(ws, 'message', e => console.log(e));
 **/
Class(function SocketConnection(_server, _channel) {
    Inherit(this, Component);
    var _this = this;
    var _socket, _pingPong;

    var _fail = 0;
    var _binary = {};
    var _time = Render.TIME;

    const PING = 'ping';
    const PONG = 'pong';
    const BINARY = 'binary:';

    this.connected = false;

    //*** Constructor
    (async function () {
        try {
            connect();
        } catch(e) {
            await defer();
            _this.events.fire(SocketConnection.ERROR, {socket: _this});
            _this.timer = _this.delayedCall(connect, 250);
            _this.delayedCall(checkIfConnected, 20000);
        }
    })();

    function connect() {
        _this.pending = false;
        _socket = new WebSocket(_server, ['permessage-deflate']);
        _socket.binaryType = 'arraybuffer';
        _socket.onopen = open;
        _socket.onmessage = message;
        _socket.onclose = close;
        _socket.onerror = close;
    }

    function sendPing() {
        if (_socket && _socket.readyState == WebSocket.OPEN) {
            _socket.send(PING);
        }
    }

    function checkIfConnected() {
        if (_this.blocked) return;
        if (!_this.connected) {
            _this.blocked = true;
            _this.events.fire(SocketConnection.BLOCKED);
        }
    }

    //*** Event handlers
    function open(e) {
        _fail = 0;
        _this.connected = true;
        _this.events.fire(SocketConnection.OPEN, {socket: _this}, true);
        if (_channel) _this.send('register', {channel: _channel});
        _pingPong = setInterval(sendPing, 5000);
    }

    function message(e)  {
        if (e.data == PONG || e.data == PING) return;
        if (typeof e.data === 'string') {
            try {
                let data = JSON.parse(e.data);
                let evt = data._evt;
                if (evt) {
                    delete data._evt;
                    _this.events.fire(evt, data, true);
                } else {
                    _binary.data = data;
                    _this.events.fire(SocketConnection.BINARY, _binary);
                }
            } catch(er) {

            }
        } else {
            _binary.data = e.data;
            _this.events.fire(SocketConnection.BINARY, _binary);
        }
    }

    function close(e) {
        if (Render.TIME - _time < 50 && !_this.blocked) {
            _this.blocked = true;
            return _this.events.fire(SocketConnection.BLOCKED);
        }
        if (_this.pending) return;
        if (_fail++ > 250) return;
        _this.connected = false;
        _this.pending = true;
        _this.events.fire(SocketConnection.CLOSE, {socket: _this}, true);
        _this.timer = _this.delayedCall(connect, 250);
        clearTimeout(_pingPong);
    }

    //*** Public methods
    this.send = function(evt, data = {}) {
        if (!_this.connected) return _this.delayedCall(_ => _this.send(evt, data), 100);
        data._evt = evt;
        if (_socket && _socket.readyState == WebSocket.OPEN) {
            _socket.send(data.length != undefined ? data : JSON.stringify(data));
        }
    }

    this.sendBinary = function(data) {
        if (_socket && _socket.readyState == WebSocket.OPEN && _socket.bufferedAmount < 1024) {
            _socket.send(BINARY + (data.length != undefined ? data : JSON.stringify(data)));
        }
    }

    this.close = function() {
        _socket.onclose = null;
        _socket.onerror = null;
        clearTimeout(_this.timer);
        _socket.close();
    }

}, _ => {
    SocketConnection.OPEN = 'socket_connection_open';
    SocketConnection.CLOSE = 'socket_connection_close';
    SocketConnection.ERROR = 'socket_connection_error';
    SocketConnection.BINARY = 'socket_connection_binary';
    SocketConnection.BLOCKED = 'socket_connection_blocked';
});
Class(function Tests() {
    const _this = this;

    this.getDPR = function() {
        //Bad GPU plugged into an external screen
        if (GPU.OVERSIZED) return 0.8;

        //Desktop
        if (GPU.lt(0)) return 1;
        if (GPU.lt(1)) return Math.min(Device.pixelRatio, 1.2);
        if (GPU.lt(2)) return Math.min(Device.pixelRatio, 1.35);
        if (GPU.lt(3)) return Math.min(Device.pixelRatio, 1.5);
        if (GPU.lt(4)) return Math.min(Device.pixelRatio, 2);
        if (GPU.lt(5)) return Math.max(Device.pixelRatio, 1.5);

        //Mobile
        if (GPU.mobileLT(0)) return 1;
        if (GPU.mobileLT(1)) return Math.min(Device.pixelRatio, 1.2);
        if (GPU.mobileLT(2)) return Math.min(Device.pixelRatio, 1.35);
        if (GPU.mobileLT(3)) return Math.min(Device.pixelRatio, 1.5);
        if (GPU.mobileLT(4)) return Math.min(Device.pixelRatio, 2);

        return 1;
    }

    this.capFPS = function() {
        if (GPU.lt(0)) return 30.001;
        if (GPU.mobileLT(2)) return 30.001;
        if (GPU.lt(3)) return Render.REFRESH_RATE > 60 ? 60.001 : null;
        if (Device.mobile) return Render.REFRESH_RATE > 100 ? 100.001 : null;
        return null;
    }

    this.renderFXAA = function() {
        if (this.msaaSamples() !== false) return false;
        if (GPU.lt(1)) return false;
        if (GPU.mobileLT(2)) return false;
        return true;
    }

    /**
     * Whether to enable MSAA on the World.NUKE when MSAA is enabled. In
     * projects that apply MSAA to FXScenes, return false here.
     * To turn MSAA on and off, and to control the number of samples, use
     * Tests.msaaSamples().
     * @returns {boolean}
     */
    this.enableWorldNukeMSAA = function() {
        return true;
    }

    /**
     * To disable MSAA, return false.
     * To enable MSAA, return the desired number of samples.
     * To enable MSAA in the World.NUKE, return the desired number of
     * samples here and return true from Tests.enableWorldNukeMSAA().
     * To enable MSAA elsewhere, use the value of Tests.msaaSamples()
     * to set the multisample and samplesAmount options.
     * @returns {boolean|number}
     */
    this.msaaSamples = function() {
        if (!(Device.graphics.webgl.webgl2 && !Utils.query('compat'))) return false;
        if (Device.system.xr.vr) return false;

        if (GPU.lt(2)) return false;
        if (GPU.mobileLT(2)) return false;

        if (GPU.lt(3)) return 2;
        if (GPU.mobileLT(3)) return 2;

        return 4;
    }

}, 'static');

Class(function Container() {
    Inherit(this, Element);
    const _this = this;
    const $this = this.element;

    const USING_XR = Device.system.xr.vr;

    var _app = _this.initClass(App);

    //*** Constructor
    (async function () {
        initHTML();
        loadView();
    })();

    function initHTML() {
        Stage.add($this);
        $this.css({position: 'static'});
    }

    async function loadView() {
        let loaderView = _this.initClass(window[_app.loaderData.fragment]);
        let loader = _this.initClass(AssetLoader, Assets.list().filter(_app.loaderData.assets.split(',').map(f => f.trim())));

        // Initializer3D.linkSceneLayout(loader);

        _this.events.sub(loader, Events.PROGRESS, loaderView.progress);
        _this.events.sub(loader, Events.COMPLETE, async () => {
            await loaderView.animateOut();
            loaderView = loaderView.destroy();
        });

        await Initializer3D.createWorld();
        loadComplete();
        // await Initializer3D.loaded();
    }

    async function loadComplete() {
        if (USING_XR) {
            waitForInteraction();
        } else {
            await World.instance().init();
            _this.initClass(window[_app.entryPointData]);
            $this.add(World.ELEMENT);
        }
    }

    async function waitForInteraction() {
        let click = async e => {
            if (e && e.isLeaveEvent) return;
            await World.instance().initXR(RenderManager.WEBVR);
            let ref = _this.initClass(window[_app.entryPointData]);
            if (ref.group) World.SCENE.add(ref.group);
            _this.events.unsub(Mouse.input, Interaction.CLICK, click);
        };

        // if (window.AURA) click();
        if (Utils.query('auto')) _this.delayedCall(click, 2000);
        else _this.events.sub(Mouse.input, Interaction.CLICK, click);
    }


    //*** Event handlers

    //*** Public methods

}, 'singleton');
Class(function Playground() {
    Inherit(this, Component);
    const _this = this;
    let _view;
    let _isRT;

    const USING_XR = Device.system.xr.vr;

    //*** Constructor
    (async function () {
        await UILStorage.ready();
        Global.PLAYGROUND = Utils.query('p');
        initXR();
    })();

    async function initXR() {
        if (USING_XR) {
            waitForInteraction();
        } else {
            await World.instance().init();
            initView();
            Stage.add(World.ELEMENT);
            initDoubleClick();
        }
    }

    async function waitForInteraction() {
        let click = async e => {
            if (e && e.isLeaveEvent) return;
            _this.events.unsub(Mouse.input, Interaction.END, click);
            await World.instance().initXR(RenderManager.WEBVR);
            initView();
        };

        if (window.AURA) click();
        else _this.events.sub(Mouse.input, Interaction.END, click);
    }

    function initDoubleClick() {
        _this.lastClick = performance.now();
        const speed = 180;

        Stage.bind('click', function() {
            const now = performance.now();
            const diff = now - _this.lastClick;

            if (diff < speed) {
                onDoubleClick();
            }

            _this.lastClick = performance.now();
        });
    }

    function onDoubleClick() {
        let camera = _isRT ? _view.nuke.camera : World.NUKE.camera;
        let scene = _isRT ? _view.scene : World.SCENE;

        let raycaster = Raycaster.find(camera);

        let objs = [];
        scene.traverse(obj => {
            objs.push(obj);
        });

        let intersects = raycaster.checkHit(objs, Mouse);
        let found = false;

        intersects.forEach(element => {
            if (found) return;
            const uilGraph = element?.object?.uilGraph;
            if (!uilGraph) return;
            found = true;
            uilGraph?.find?.(element?.object?.uilName)?.focus?.();
        });
    }

    async function addUIToWorldScene(uiGroup) {
        // Wait for the camera position to be initialized
        if (USING_XR) {
            await RenderManager.scheduleOne(RenderManager.EYE_RENDER);
        } else {
            await defer();
        }
        let group = new Group();
        let v3 = new Vector3();
        let distance = USING_XR ? 1.5 : 2;
        v3.set(0, 0, -distance).applyQuaternion(World.CAMERA.quaternion);
        group.position.copy(World.CAMERA.position).add(v3);
        group.lookAt(World.CAMERA.position);
        group.add(uiGroup);
        World.SCENE.add(group);
        return group;
    }

    async function initGLUIView(element) {
        if(USING_XR) {
            let group = await addUIToWorldScene(element.group);
            group.scale.setScalar(1/1024);
        } else {
            GLUI.Stage.add(element);
        }
    }

    async function initUI3DView(ui3d) {
        if (USING_XR) {
            await addUIToWorldScene(ui3d.$gluiObject.group);
            ui3d.$gluiObject.depthTest = false;
        } else if (Device.mobile) {
            initGLUIView(ui3d.root);
        } else {
            // retina mode
            GLUI.Scene.add(ui3d.$gluiObject);
            await addUIToWorldScene(ui3d.$gluiObject.anchor);
        }
    }

    async function initView() {
        let request = Global.PLAYGROUND.split('/')[0];
        let view = window['Playground' + request] || window[request] || null;
        if (!view) throw `No Playground class ${request} found.`;

        _view = !!view.instance ? view.instance() : _this.initClass(view);
        if (_view.element) {
            if (_view.element.mesh) {
                await initGLUIView(_view.element)
            } else {
                Stage.add(_view.element);
            }
        } else if (_view.root && _view.$gluiObject) {
            await initUI3DView(_view);
        }

        if (_view.rt && _view.scene && _view.nuke && !_view.isVrWorldMode && !_view.isVrSceneMode) {
            if (request.includes('Figma')) {
                let dimensions = _view.dimensions;
                let $obj = $gl(dimensions[0], dimensions[1], _view.rt.texture);
                $obj.x = 40;
                $obj.y = 40;
                if (Utils.query('orientation') === 'portrait') {
                    $obj.scale = .5;
                    $obj.y = -300;
                }
                GLUI.Stage.add($obj);
            } else {
                let shader = _this.initClass(Shader, 'ScreenQuad', {
                    tMap: { value: _view }
                });
                let mesh = new Mesh(World.QUAD, shader);
                mesh.frustumCulled = false;
                World.SCENE.add(mesh);
                _isRT = true;
            }
        } else {
            World.SCENE.add(_view.group || _view.mesh || _view.object3D || new Group());
        }

        initCameraHelper(_view.nuke || World.NUKE);

        Dev.expose('view', _view);
    }

    function initCameraHelper(nuke) {
        let orbitCamera = new PerspectiveCamera(30, Stage.width / Stage.height, 0.1, 1000);
        orbitCamera.position.z = 6;

        let wasdCamera = orbitCamera.clone();
        let lastCamera, timer0, timer1, timer2;

        _this.onResize(_ => {
            orbitCamera.aspect = wasdCamera.aspect = Stage.width/Stage.height;
            orbitCamera.updateProjectionMatrix();
            wasdCamera.updateProjectionMatrix();
        });

        let orbit = new DebugControls(orbitCamera, World.ELEMENT.div);
        let wasd = new WASDControls(wasdCamera, World.ELEMENT.div);
        orbit.enabled = false;
        wasd.enabled = false;
        _this.startRender(_ => {
            orbit.update();
            wasd.update();
        });

        _this.orbitControls = orbit;
        _this.wasdControls = wasd;

        const clearTimers = _ => {
            clearTimeout(timer0);
            clearTimeout(timer1);
            clearTimeout(timer2);
        };

        const goToMain = _ => {
            orbit.enabled = false;
            wasd.enabled = false;
            if (lastCamera) nuke.camera = lastCamera;
            AppState.set('playground_camera_active', false);

            clearTimers();
        };

        const goToOrbit = _ => {
            orbit.enabled = true;
            wasd.enabled = false;
            if (nuke.camera != wasdCamera && nuke.camera != orbitCamera) lastCamera = nuke.camera;
            nuke.camera = orbitCamera;
            AppState.set('playground_camera_active', nuke.camera);
            _this.activeControls = orbit;

            clearTimers();
        };

        const goToWASD = _ => {
            wasd.enabled = true;
            orbit.enabled = false;
            if (nuke.camera != wasdCamera && nuke.camera != orbitCamera) lastCamera = nuke.camera;
            nuke.camera = wasdCamera;
            AppState.set('playground_camera_active', nuke.camera);
            _this.activeControls = wasd;

            clearTimers();
        };

        if (Utils.query('orbit')) {
            goToOrbit();
            timer0 = _this.delayedCall(goToOrbit, 500);
            timer1 = _this.delayedCall(goToOrbit, 1000);
            timer2 = _this.delayedCall(goToOrbit, 3000);
        }

        _this.events.sub(Keyboard.DOWN, _ => {
            if ( document.activeElement.tagName.toLowerCase().includes([ 'textarea', 'input' ])) return;
            if (Keyboard.pressing.includes('!')) goToMain();
            if (Keyboard.pressing.includes('@')) goToOrbit();
            if (Keyboard.pressing.includes('#')) goToWASD();
        });
    }

    //*** Event handlers

    //*** Public methods
}, 'singleton');

Class(function World() {
    Inherit(this, Component);
    const _this = this;
    var _renderer, _scene, _camera, _nuke, _controls;

    World.DPR = Tests.getDPR();

    var _type = RenderManager.NORMAL;

    async function init() {
        if (World.PLANE) return;
        await initWorld();
        if (!_renderer) return;
        if (RenderManager.type == RenderManager.NORMAL) {
            Camera.instance(_camera);
            Render.capFPS = Tests.capFPS();
        }
        initControls();
        addHandlers();
        if (!Utils.query('uilOnly')) Render.onDrawFrame(loop);
    }

    async function initWorld() {
        World.PLANE = new PlaneGeometry(1, 1);
        World.QUAD = Utils3D.getQuad();
        World.BOX = new BoxGeometry(1, 1, 1);
        World.SPHERE = new SphereGeometry(1, 16, 16);

        let options = { powerPreference: 'high-performance' };
        if (Tests.enableWorldNukeMSAA()) {
            options.samplesAmount = Tests.msaaSamples() || undefined;
            options.multisample = !!options.samplesAmount;
        }
        RenderManager.initialize(_type, options);
        _renderer = RenderManager.gl;
        _scene = RenderManager.scene;
        _camera = RenderManager.camera.worldCamera;
        _nuke = RenderManager.nuke;

        World.SCENE = _scene;
        World.RENDERER = _renderer;
        World.ELEMENT = $(_renderer.domElement);
        World.CAMERA = _camera;
        World.NUKE = _nuke;

        if (RenderManager.type == RenderManager.NORMAL && Tests.renderFXAA()) _nuke.add(new FXAA());
    }

    function initControls() {
        if (!window.DebugControls) return;

        const renderTypeNormal = RenderManager.type === RenderManager.NORMAL;

        if (!Utils.query('orbit')) {
            let camera = new BaseCamera();
            camera.group.position.set(0, 0, 6);
            camera.lock();
            return;
        }

        const Controls = Utils.query('wasd') ? WASDControls : DebugControls;
        _controls = new Controls(_camera, World.ELEMENT.div);

        if (renderTypeNormal) {
            _controls.target = new Vector3(0.0, 0.0, 0.0);
        } else {
            _controls.enabled = false;
        }

        World.CONTROLS = _controls;
        World.CAMERA.position.z = 6;
    }

    //*** Event handlers
    function addHandlers() {
        _this.events.sub(Events.RESIZE, resize);
    }

    function resize() {
        _renderer.setSize(Stage.width, Stage.height);
        _camera.aspect = Stage.width / Stage.height;
        _camera.updateProjectionMatrix();
    }

    function loop(t, delta) {
        if (_controls && _controls.enabled) _controls.update();
        RenderManager.render();
    }

    //*** Public methods
    this.initXR = async function(type, startImmersive = true) {
        _type = type;
        await init();
        if (startImmersive) {
            await XRDeviceManager.startSession();
        }
    }

    this.init = function() {
        return init();
    }

}, function() {
    var _instance;

    World.instance = function() {
        if (!_instance) _instance = new World();
        return _instance;
    }

});

Class(function App() {
    const _this = this;
    Inherit(_this, Component);

    

    this.isFragment = true;

    const _promises = [];

    (async function () {
        if (_this.element) _this.element.onMountedHook = _ => _this.onMounted?.(); 

        

        _this.help = function () {
            console.groupCollapsed('Fragment App Overview');
            console.log('Your context(s) are: Component');
            console.log('You have access to the following $ methods:');
            for (let key in _this) {
                if (key.charAt(0) == '_') continue;
                if (key.includes(['flag', 'initClass', 'classes', 'events', 'parent', 'findParent', 'bindState'])) continue;
                console.log('$' + key);
            }
            console.groupEnd();
        };

        _this.set = function(key, value) {
            if (!key.includes('/')) key = "App/" + key;
            AppState.set(key, value || Utils.uuid());
        };

        _this.fire = function(key, value) {
            if (!key.includes('/')) key = "App/" + key;
            AppState.set(key, value, true);
        };

        _this.bind = _this.listen = function(key, callback, ref) {
            if (typeof ref === 'function' && typeof callback == 'string') {
                let rref = key;
                callback = ref;
                key = callback;
                ref = rref;
            }

            if (!ref) {
                if (!key.includes('/')) key = "App/" + key;
                _this.bindState(AppState, key, callback);
            } else {
                _this.events.sub(key, callback, ref);
            }
        };

        _this.get = function(key) {
            if (!key.includes('/')) key = "App/" + key;
            return AppState.get(key);
        };

        _this.createState = function() {
            if (_this.state) return;
            _this.state = AppState.createLocal();
            _this.state._bind = _this.state.bind;
            _this.state.bind = function(key, callback) {
                _this.bindState(state, key, callback);
            }

            _this.state.fire = function(key, value = Utils.uuid()) {
                _this.state.set(key, value, true);
            }

            AppState.set("App/state", _this.state);

            _this._bindOnDestroy(_ => {
                AppState.set("App/state", null); 
            });
        }

        function createStateArray(array) {
            return new StateArray(array || []);
        }

        function createState() {
            _this.createState();
            return _this.state;
        }

        
        
        
        if (_this.parent?.layers) _this.layers = _this.parent.layers;
        if (_this.layout?.getAllLayers) _this.layers = await _this.layout.getAllLayers();

        



        for (let key in _this) {
            if (_this[key]?.then) {
                let store = _this[key];
                store.then(val => _this[key] = val);
                _promises.push(store);
            }
        }

        if (_promises.length) await Promise.all(_promises);

        _this.loaderData = {"fragment":"LoaderView","assets":"shaders, uil"}; 
_this.entryPointData = 'CubeScene'; 

        _this.flag('__ready', true);
        _this.onInit?.();
    })();

});


//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIkFwcC5qcyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQ0FBQyIsImZpbGUiOiIiLCJzb3VyY2VSb290IjoiIiwic291cmNlc0NvbnRlbnQiOlsiY29udGV4dChBcHApO1xuXG5mcmFnbWVudHMoPD5cbiAgICA8TG9hZGVyIGZyYWdtZW50PVwiTG9hZGVyVmlld1wiIGFzc2V0cz1cInNoYWRlcnMsIHVpbFwiIC8+XG4gICAgPEVudHJ5UG9pbnQgZnJhZ21lbnQ9XCJDdWJlU2NlbmVcIiAvPlxuPC8+KTsiXX0=
Class(function CubeScene() {
    const _this = this;
    Inherit(_this, Frag3D, "CubeScene");

    

    this.isFragment = true;

    const _promises = [];

    (async function () {
        if (_this.element) _this.element.onMountedHook = _ => _this.onMounted?.(); 

        

        _this.help = function () {
            console.groupCollapsed('Fragment CubeScene Overview');
            console.log('Your context(s) are: Frag3D, &quot;CubeScene&quot;');
            console.log('You have access to the following $ methods:');
            for (let key in _this) {
                if (key.charAt(0) == '_') continue;
                if (key.includes(['flag', 'initClass', 'classes', 'events', 'parent', 'findParent', 'bindState'])) continue;
                console.log('$' + key);
            }
            console.groupEnd();
        };

        _this.set = function(key, value) {
            if (!key.includes('/')) key = "CubeScene/" + key;
            AppState.set(key, value || Utils.uuid());
        };

        _this.fire = function(key, value) {
            if (!key.includes('/')) key = "CubeScene/" + key;
            AppState.set(key, value, true);
        };

        _this.bind = _this.listen = function(key, callback, ref) {
            if (typeof ref === 'function' && typeof callback == 'string') {
                let rref = key;
                callback = ref;
                key = callback;
                ref = rref;
            }

            if (!ref) {
                if (!key.includes('/')) key = "CubeScene/" + key;
                _this.bindState(AppState, key, callback);
            } else {
                _this.events.sub(key, callback, ref);
            }
        };

        _this.get = function(key) {
            if (!key.includes('/')) key = "CubeScene/" + key;
            return AppState.get(key);
        };

        _this.createState = function() {
            if (_this.state) return;
            _this.state = AppState.createLocal();
            _this.state._bind = _this.state.bind;
            _this.state.bind = function(key, callback) {
                _this.bindState(state, key, callback);
            }

            _this.state.fire = function(key, value = Utils.uuid()) {
                _this.state.set(key, value, true);
            }

            AppState.set("CubeScene/state", _this.state);

            _this._bindOnDestroy(_ => {
                AppState.set("CubeScene/state", null); 
            });
        }

        function createStateArray(array) {
            return new StateArray(array || []);
        }

        function createState() {
            _this.createState();
            return _this.state;
        }

        
        
        
        if (_this.parent?.layers) _this.layers = _this.parent.layers;
        if (_this.layout?.getAllLayers) _this.layers = await _this.layout.getAllLayers();

        

let mesh = new Mesh(World.BOX, Utils3D.getTestShader());
World.SCENE.add(mesh);

_this.startRender(_ => {
    mesh.rotation.x += 0.03 * Render.HZ_MULTIPLIER;
    mesh.rotation.y += 0.01 * Render.HZ_MULTIPLIER;
    mesh.rotation.z += 0.04 * Render.HZ_MULTIPLIER;
});

        for (let key in _this) {
            if (_this[key]?.then) {
                let store = _this[key];
                store.then(val => _this[key] = val);
                _promises.push(store);
            }
        }

        if (_promises.length) await Promise.all(_promises);

        
        _this.flag('__ready', true);
        _this.onInit?.();
    })();

});


//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIkN1YmVTY2VuZS5qcyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQ0FBQzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7YUFTQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Q0FQQTtDQUNBOztDQUVBO0NBQ0E7Q0FDQTtDQUNBIiwiZmlsZSI6IiIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzQ29udGVudCI6WyJjb250ZXh0KEZyYWczRCk7XG5cbmxldCBtZXNoID0gbmV3IE1lc2goV29ybGQuQk9YLCBVdGlsczNELmdldFRlc3RTaGFkZXIoKSk7XG5Xb3JsZC5TQ0VORS5hZGQobWVzaCk7XG5cbiRzdGFydFJlbmRlcihfID0+IHtcbiAgICBtZXNoLnJvdGF0aW9uLnggKz0gMC4wMyAqIFJlbmRlci5IWl9NVUxUSVBMSUVSO1xuICAgIG1lc2gucm90YXRpb24ueSArPSAwLjAxICogUmVuZGVyLkhaX01VTFRJUExJRVI7XG4gICAgbWVzaC5yb3RhdGlvbi56ICs9IDAuMDQgKiBSZW5kZXIuSFpfTVVMVElQTElFUjtcbn0pOyJdfQ==
Class(function LoaderView(_params) {
    const _this = this;
    Inherit(_this, Element);

    _this.params = _params; 

    this.isFragment = true;

    const _promises = [];

    (async function () {
        if (_this.element) _this.element.onMountedHook = _ => _this.onMounted?.(); 

        _this.initClass(FragUIHelper, {"font":"Arial","fontSize":16,"center":1,"css":"textAlign: center, lineHeight: 1, letterSpacing: 2, opacity: 0.8","fontColor":"#ffffff","_type":"HydraObject","_innerText":"0","refName":"text","children":[]}, {"size":"100%","bg":"#000","setZ":"100"}); 


        _this.help = function () {
            console.groupCollapsed('Fragment LoaderView Overview');
            console.log('Your context(s) are: Element');
            console.log('You have access to the following $ methods:');
            for (let key in _this) {
                if (key.charAt(0) == '_') continue;
                if (key.includes(['flag', 'initClass', 'classes', 'events', 'parent', 'findParent', 'bindState'])) continue;
                console.log('$' + key);
            }
            console.groupEnd();
        };

        _this.set = function(key, value) {
            if (!key.includes('/')) key = "LoaderView/" + key;
            AppState.set(key, value || Utils.uuid());
        };

        _this.fire = function(key, value) {
            if (!key.includes('/')) key = "LoaderView/" + key;
            AppState.set(key, value, true);
        };

        _this.bind = _this.listen = function(key, callback, ref) {
            if (typeof ref === 'function' && typeof callback == 'string') {
                let rref = key;
                callback = ref;
                key = callback;
                ref = rref;
            }

            if (!ref) {
                if (!key.includes('/')) key = "LoaderView/" + key;
                _this.bindState(AppState, key, callback);
            } else {
                _this.events.sub(key, callback, ref);
            }
        };

        _this.get = function(key) {
            if (!key.includes('/')) key = "LoaderView/" + key;
            return AppState.get(key);
        };

        _this.createState = function() {
            if (_this.state) return;
            _this.state = AppState.createLocal();
            _this.state._bind = _this.state.bind;
            _this.state.bind = function(key, callback) {
                _this.bindState(state, key, callback);
            }

            _this.state.fire = function(key, value = Utils.uuid()) {
                _this.state.set(key, value, true);
            }

            AppState.set("LoaderView/state", _this.state);

            _this._bindOnDestroy(_ => {
                AppState.set("LoaderView/state", null); 
            });
        }

        function createStateArray(array) {
            return new StateArray(array || []);
        }

        function createState() {
            _this.createState();
            return _this.state;
        }

        _this.params = _params; 
        
        
        if (_this.parent?.layers) _this.layers = _this.parent.layers;
        if (_this.layout?.getAllLayers) _this.layers = await _this.layout.getAllLayers();

        



_this.text.percent = 0;

_this.startRender(_ => {
    let percent = Math.round(_this.text.percent * 100);
    _this.text.text(`${percent}`);
});

_this.progress = ({percent}) => {
    tween(_this.text, {percent: percent}, 500, 'easeOutSine');
};

_this.animateOut = async _ => {
    tween(_this.text, {percent: 1}, 300, 'easeOutSine');
    _this.text.tween({opacity: 0}, 500, 'easeInOutSine', 300);
    await _this.element.tween({opacity: 0}, 500, 'easeInOutSine', 300).promise();
};

        for (let key in _this) {
            if (_this[key]?.then) {
                let store = _this[key];
                store.then(val => _this[key] = val);
                _promises.push(store);
            }
        }

        if (_promises.length) await Promise.all(_promises);

        
        _this.flag('__ready', true);
        _this.onInit?.();
    })();

});


//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIkxvYWRlclZpZXcuanMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkNBQUM7Ozs7Ozs7Ozs7Ozs7OFJBa0JBOzs7Ozs7Ozs7Ozs7O1NBSUE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0NBVEE7O0NBRUE7Q0FDQTtDQUNBOzs7Q0FHQTtDQUNBOzs7Q0FHQTtDQUNBO0NBQ0E7Q0FDQSIsImZpbGUiOiIiLCJzb3VyY2VSb290IjoiIiwic291cmNlc0NvbnRlbnQiOlsiY29udGV4dChFbGVtZW50KTtcblxudWkoPD5cbiAgICA8Um9vdCBzaXplPVwiMTAwJVwiIGJnPVwiIzAwMFwiIHNldFo9XCIxMDBcIiAvPlxuICAgIFxuICAgIDxIeWRyYU9iamVjdCAkdGV4dCBcbiAgICAgICAgZm9udD1cIkFyaWFsXCIgXG4gICAgICAgIGZvbnRTaXplPVwiMTZcIlxuICAgICAgICBjZW50ZXJcbiAgICAgICAgY3NzPVwidGV4dEFsaWduOiBjZW50ZXIsIGxpbmVIZWlnaHQ6IDEsIGxldHRlclNwYWNpbmc6IDIsIG9wYWNpdHk6IDAuOFwiIFxuICAgICAgICBmb250Q29sb3I9XCIjZmZmZmZmXCI+MDwvSHlkcmFPYmplY3Q+XG48Lz4pO1xuXG4kdGV4dC5wZXJjZW50ID0gMDtcblxuJHN0YXJ0UmVuZGVyKF8gPT4ge1xuICAgIGxldCBwZXJjZW50ID0gTWF0aC5yb3VuZCgkdGV4dC5wZXJjZW50ICogMTAwKTtcbiAgICAkdGV4dC50ZXh0KGAke3BlcmNlbnR9YCk7XG59KTtcblxuJHByb2dyZXNzID0gKHtwZXJjZW50fSkgPT4ge1xuICAgIHR3ZWVuKCR0ZXh0LCB7cGVyY2VudDogcGVyY2VudH0sIDUwMCwgJ2Vhc2VPdXRTaW5lJyk7XG59O1xuXG4kYW5pbWF0ZU91dCA9IGFzeW5jIF8gPT4ge1xuICAgIHR3ZWVuKCR0ZXh0LCB7cGVyY2VudDogMX0sIDMwMCwgJ2Vhc2VPdXRTaW5lJyk7XG4gICAgJHRleHQudHdlZW4oe29wYWNpdHk6IDB9LCA1MDAsICdlYXNlSW5PdXRTaW5lJywgMzAwKTtcbiAgICBhd2FpdCAkZWxlbWVudC50d2Vlbih7b3BhY2l0eTogMH0sIDUwMCwgJ2Vhc2VJbk91dFNpbmUnLCAzMDApLnByb21pc2UoKTtcbn07Il19
Class(function Main() {

    //*** Constructor
    (async function() {
        await Device.system.detectXR();
        if (Utils.query('performance')) return Performance.displayResults();
        init();
    })();

    function init() {
        GLUI.init();
        if (window.location.search.includes('p=')) return AssetLoader.loadAssets(Assets.list().filter(['uil', 'shaders'])).then(Playground.instance);
        Container.instance();
    }

    //*** Event Handlers

    //*** Public methods
});

window._BUILT_=true;